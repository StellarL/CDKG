<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637132348244561250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJK201910006%26RESULT%3d1%26SIGN%3dud1KrUCLPjV3bRngzWOpkhyzbx8%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJK201910006&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJK201910006&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJK201910006&amp;v=MTkyMjBESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSbUZ5L2dWYjdOTHo3QlpiRzRIOWpOcjQ5RllvUUs=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#19" data-title="&lt;b&gt;1 引言&lt;/b&gt; "><b>1 引言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#23" data-title="&lt;b&gt;2 基于冗余修复方案的一种存储器结构&lt;/b&gt; "><b>2 基于冗余修复方案的一种存储器结构</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#24" data-title="&lt;b&gt;2.1 存储器冗余单元结构&lt;/b&gt;"><b>2.1 存储器冗余单元结构</b></a></li>
                                                <li><a href="#30" data-title="&lt;b&gt;2.2 冗余修复对存储器良率的影响&lt;/b&gt;"><b>2.2 冗余修复对存储器良率的影响</b></a></li>
                                                <li><a href="#45" data-title="&lt;b&gt;2.3 设计实例&lt;/b&gt;"><b>2.3 设计实例</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#62" data-title="&lt;b&gt;3 实验结果与分析&lt;/b&gt; "><b>3 实验结果与分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#64" data-title="&lt;b&gt;3.1 存储器内建自测试仿真&lt;/b&gt;"><b>3.1 存储器内建自测试仿真</b></a></li>
                                                <li><a href="#68" data-title="&lt;b&gt;3.2 存储器修复电路的仿真及测试方案&lt;/b&gt;"><b>3.2 存储器修复电路的仿真及测试方案</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#79" data-title="&lt;b&gt;4 结束语&lt;/b&gt; "><b>4 结束语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#27" data-title="图1 TSMC 28 nm SPRAM中控制冗余行修复的24位移位寄存器结构">图1 TSMC 28 nm SPRAM中控制冗余行修复的24位移位寄存器结构</a></li>
                                                <li><a href="#29" data-title="图2 带有冗余列的嵌入式存储器结构">图2 带有冗余列的嵌入式存储器结构</a></li>
                                                <li><a href="#39" data-title="图3 含有不同冗余单元的存储器良率对比情况">图3 含有不同冗余单元的存储器良率对比情况</a></li>
                                                <li><a href="#43" data-title="&lt;b&gt;表1 TSMC 1088&#215;144 SPRAM良率&lt;/b&gt;"><b>表1 TSMC 1088×144 SPRAM良率</b></a></li>
                                                <li><a href="#53" data-title="&lt;b&gt;表2 平均良率和平均缺陷率&lt;/b&gt;"><b>表2 平均良率和平均缺陷率</b></a></li>
                                                <li><a href="#54" data-title="&lt;b&gt;表3 同时出现&lt;/b&gt;&lt;i&gt;&lt;b&gt;r&lt;/b&gt;&lt;/i&gt;&lt;b&gt;个缺陷的概率&lt;/b&gt;&lt;i&gt;&lt;b&gt;p&lt;/b&gt;&lt;/i&gt;&lt;b&gt;(&lt;/b&gt;&lt;i&gt;&lt;b&gt;r&lt;/b&gt;&lt;/i&gt;)"><b>表3 同时出现</b><i><b>r</b></i><b>个缺陷的概率</b><i><b>p</b></i><b>(</b><i><b>r</b></i>)</a></li>
                                                <li><a href="#56" data-title="图4 基于冗余单元的存储器测试修复结构">图4 基于冗余单元的存储器测试修复结构</a></li>
                                                <li><a href="#59" data-title="图5 存储器修复与芯片功能交互时序图">图5 存储器修复与芯片功能交互时序图</a></li>
                                                <li><a href="#66" data-title="图6 MBSIT 仿真图">图6 MBSIT 仿真图</a></li>
                                                <li><a href="#67" data-title="图8 存储器修复仿真图">图8 存储器修复仿真图</a></li>
                                                <li><a href="#77" data-title="图7 存储器修复仿真及测试流程图">图7 存储器修复仿真及测试流程图</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" Rajsuman R.Design and test of large embedded memories:An overview[J].IEEE Design and Test of Computers,2001,18(3):16-27." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Design and test large embedded memories: An overview">
                                        <b>[1]</b>
                                         Rajsuman R.Design and test of large embedded memories:An overview[J].IEEE Design and Test of Computers,2001,18(3):16-27.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" >
                                        <b>[2]</b>
                                     Yu Yang,Li Jia-ming,Qiao Li-yan.Memory built-in self-repair method based on address partitioning strategy[J].Acta Electronica Sinica,2010,38(2A):169-173.(in Chinese)</a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" Qin Pan,Wang Jian,Wu Hui.A method and improvement of self-repair of embedded memories[J].Jichengdianlu Tongxun,2015,33(3):34-38.(in Chinese)" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A method and improvement of self-repair of embedded memories">
                                        <b>[3]</b>
                                         Qin Pan,Wang Jian,Wu Hui.A method and improvement of self-repair of embedded memories[J].Jichengdianlu Tongxun,2015,33(3):34-38.(in Chinese)
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title=" Lu Shyue-Kung,Yang Chun-lin,Lin Han-wen.Efficient BISR techniques for word-oriented embedded memories with hierarchical redundancy[C]//Proc of the 5th IEEE/ACIS International Conference on Computer and Information Science and 1st IEEE/ACIS International Workshop on Component-Based Software Engineering,2006:355-360." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient BISR techniques for word-oriented embedded memories with hierarchical redundancy">
                                        <b>[4]</b>
                                         Lu Shyue-Kung,Yang Chun-lin,Lin Han-wen.Efficient BISR techniques for word-oriented embedded memories with hierarchical redundancy[C]//Proc of the 5th IEEE/ACIS International Conference on Computer and Information Science and 1st IEEE/ACIS International Workshop on Component-Based Software Engineering,2006:355-360.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" Mentor Graphics.Memory repair primer[M].Drego:Mentor Graphics,2008." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Memory repair primer">
                                        <b>[5]</b>
                                         Mentor Graphics.Memory repair primer[M].Drego:Mentor Graphics,2008.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" Mentor Graphics.Tessent memory bist usage guide and reference software[M].Drego:Mentor Graphics,2011." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Tessent memory bist usage guide and reference software">
                                        <b>[6]</b>
                                         Mentor Graphics.Tessent memory bist usage guide and reference software[M].Drego:Mentor Graphics,2011.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_2" title=" 俞洋,李嘉铭,乔立岩.基于地址分割的嵌入式存储器内建自修复的方法[J].电子学报,2010,38(2A):169-173." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU2010S1030&amp;v=MDgyNTMzenFxQnRHRnJDVVJMT2VaZVJtRnkvZ1ZiN05JVGZUZTdHNEg5R3ZybzlHWklRS0RIODR2UjRUNmo1NE8=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         俞洋,李嘉铭,乔立岩.基于地址分割的嵌入式存储器内建自修复的方法[J].电子学报,2010,38(2A):169-173.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_3" >
                                        <b>[3]</b>
                                     秦盼,王健,吴慧.一种嵌入式存储器的测试与修复方法[J].集成电路通讯,2015,33(3):34-38.</a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJK" target="_blank">计算机工程与科学</a>
                2019,41(10),1749-1754 DOI:10.3969/j.issn.1007-130X.2019.10.005            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>SoC嵌入式存储器内建自修复方法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%A7%A6%E7%9B%BC&amp;code=35964815&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">秦盼</a>
                                <a href="javascript:;">王健</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9C%B1%E8%8A%B3&amp;code=43026333&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">朱芳</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%84%A6%E8%B4%B5%E5%BF%A0&amp;code=43026334&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">焦贵忠</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%8C%97%E6%96%B9%E9%80%9A%E7%94%A8%E7%94%B5%E5%AD%90%E9%9B%86%E5%9B%A2%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8&amp;code=1700269&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">北方通用电子集团有限公司</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%AD%E5%9B%BD%E4%BA%BA%E6%B0%91%E8%A7%A3%E6%94%BE%E5%86%9B%E9%A9%BB9373%E5%8E%82%E5%86%9B%E4%BA%8B%E4%BB%A3%E8%A1%A8%E5%AE%A4&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">中国人民解放军驻9373厂军事代表室</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>嵌入式存储器的内建自测试及修复是提高SoC芯片成品率的有效办法。详细描述了存储器良率的评估方法,提出了一种基于Mentor公司Tessent工具的存储器修复结构。该结构采用了冗余修复及电可编程熔丝eFuse硬修复的方法,具有很好的通用性及可行性,已多次应用在实际项目中。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=SoC&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">SoC;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">嵌入式存储器;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%86%85%E5%BB%BA%E8%87%AA%E6%B5%8B%E8%AF%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">内建自测试;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%86%85%E5%BB%BA%E8%87%AA%E4%BF%AE%E5%A4%8D&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">内建自修复;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    秦盼（1987-），女，山东兖州人，硕士，工程师，研究方向为SoC可测性设计。E-mail:qinpan111@126.com，通信地址：233030安徽省蚌埠市经开区汤和路2016号北方通用电子集团有限公司&lt;image id="88" type="formula" href="images/JSJK201910006_08800.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    王健（1988-），男，安徽淮南人，硕士，工程师，研究方向为集成电路测试与检验。E-mail:563032021@qq.com&lt;image id="90" type="formula" href="images/JSJK201910006_09000.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    朱芳（1972-），女，安徽蚌埠人，高级工程师，研究方向为集成电路测试。E-mail:598192732@qq.com，通信地址：233030安徽省蚌埠市经开区汤和路2016号北方通用电子集团有限公司&lt;image id="92" type="formula" href="images/JSJK201910006_09200.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    焦贵忠（1981-），男，黑龙江勃利人，高级工程师，研究方向为集成电路测试。E-mail:jiaoguizhong@163.com，通信地址：233030安徽省蚌埠市经开区汤和路2016号北方通用电子集团有限公司&lt;image id="94" type="formula" href="images/JSJK201910006_09400.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-11-14</p>

            </div>
                    <h1><b>A memory built-in self-repair method for SoC design</b></h1>
                    <h2>
                    <span>QIN Pan</span>
                    <span>WANG Jian</span>
                    <span>ZHU Fang</span>
                    <span>JIAO Gui-zhong</span>
            </h2>
                    <h2>
                    <span>North General Electronics Group Co. Ltd.</span>
                    <span>PLA Representative Office in 9373 Factory</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Built-in self-test and self-repair of embbeded memory is an effective method to improve the System-on-Chip(SoC) yield. The memory yield evaluation method is described in detail. A memory repair structure based on Tessent tool of Mentor corporation is proposed. This structure uses the redundant repair method and the efuse-based hard repair method. It has been applied to practical projects many times.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=SoC&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">SoC;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=embedded%20memory&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">embedded memory;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Built-In%20Self-Test(BIST)&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Built-In Self-Test(BIST);</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Built-In%20Self-Repair(BISR)&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Built-In Self-Repair(BISR);</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    QIN Pan,born in 1987,MS,engineer, her research interest includes SoC design for test.Address:North General Electronics Group Co.Ltd.,2016 Tanghe Road,Economic Development Zone,Bengbu 233030,Anhui,P.R. China;
                                </span>
                                <span>
                                    WANG Jian,born in 1988,MS,engineer,his research interest includes integrated circuit test and verification.;
                                </span>
                                <span>
                                    ZHU Fang,born in 1972,senior engineer,her research interest includes integrated circuit test.Address:North General Electronics Group Co.Ltd.,2016 Tanghe Road,Economic Development Zone,Bengbu 233030,Anhui,P.R. China;
                                </span>
                                <span>
                                    JIAO Gui-zhong,born in 1981,senior engineer,his research interest includes integrated circuit test.Address:North General Electronics Group Co.Ltd.,2016 Tanghe Road,Economic Development Zone,Bengbu 233030,Anhui,P.R. China;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2018-11-14</p>
                            </div>


        <!--brief start-->
                        <h3 id="19" name="19" class="anchor-tag"><b>1 引言</b></h3>
                <div class="p1">
                    <p id="20">随着SoC(System on Chip)向纳米级工艺发展,嵌入式存储器的数量和密度都有很大程度的增加。在大多数SoC设计中,嵌入式存储器占用的芯片空间已超过50%,数量已到几百甚至上千个,因此嵌入式存储器已成为决定SoC良率的最重要因素。在提高存储器良率方面,完备的存储器内建自测试及修复是很好的解决方案。对于SoC设计者来说,一个好的存储器策略应该包含有存储器修复方案,从而可以达到更好的良率。嵌入式存储器修复技术可以使存储器芯片成品率提高5%～20%,相应的系统成品率提高1%～10%<citation id="81" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="21">所谓存储器修复就是采用预置的冗余存储单元替代已检测到的故障存储单元,从而完成修复的目的<citation id="82" type="reference"><link href="5" rel="bibliography" /><link href="15" rel="bibliography" /><sup>[<a class="sup">2</a>,<a class="sup">2</a>]</sup></citation>。制定一个完善的存储器修复方法需要综合嵌入式存储器IP供应商、代工厂提供的数据及DFT(Design For Test)设计工具等。</p>
                </div>
                <div class="p1">
                    <p id="22">文献<citation id="83" type="reference">[<a class="sup">3</a>,<a class="sup">3</a>]</citation>中提出了一种存储器结构,该结构无法实现自动化测试,需要测试人员人为判断是否可修复和提取修复数据,这样使得测试时间大大增加。本文提出了一种非常实用和高效的嵌入式存储器修复方案,该方案通过对Mentor公司Tessent工具产生的存储器测试和修复电路进行改进和优化,最终实现了一个完善、通用的嵌入式存储器测试、修复结构,并通过仿真和实际应用验证了该结构的可行性。</p>
                </div>
                <h3 id="23" name="23" class="anchor-tag"><b>2 基于冗余修复方案的一种存储器结构</b></h3>
                <h4 class="anchor-tag" id="24" name="24"><b>2.1 存储器冗余单元结构</b></h4>
                <div class="p1">
                    <p id="25">可修复存储器中通常都设计了能够用来克服制程缺陷的冗余单元,如果在测试过程中发现存储器有缺陷,可以用冗余单元替换有缺陷的单元。根据冗余单元的形式不同,嵌入式存储器的修复策略分为3类:基于冗余行的修复策略、基于冗余列的修复策略和基于冗余字的修复策略<citation id="84" type="reference"><link href="9" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>。目前,在实际应用中最常用的存储器修复方法为行修复和列修复,行修复即用冗余行修复存储器存在缺陷的行,列修复即采用冗余列修复存在缺陷的列。修复方法的选择需要根据SoC设计的实际需求情况进行,需要对面积、速度、功耗及良率等进行综合考虑。目前TSMC SPSRAM(Single Port SRAM)嵌入式存储器中已经包含行冗余单元,可以进行行修复,其他存储器比如1PRF(1 Port Register File)、2PRF(2 Port Register File)以及DPSRAM(Dual Port SRAM)等存储器中一般不包含行冗余单元,但可以采用增加冗余列的方式实现。</p>
                </div>
                <div class="p1">
                    <p id="26">行修复是最便宜的修复方式,该类存储器IP核一般可以由代工厂提供,以TSMC 28 nm 工艺为例,TSMC Memory Compiler产生的存储器可包含2行冗余行,最多可以1次修复2行有缺陷的行。图1为TSMC 28 nm SPRAM中控制2行冗余行修复的24位移位寄存器结构,其中<i>D</i>0和<i>D</i>12为使能位,当其为1时表示相应的冗余行被使能,用来修复有缺陷的行,<i>D</i>23～<i>D</i>13及<i>D</i>11～<i>D</i>1分别对应需要修复的行地址。</p>
                </div>
                <div class="area_img" id="27">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_027.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 TSMC 28 nm SPRAM中控制冗余行修复的24位移位寄存器结构" src="Detail/GetImg?filename=images/JSJK201910006_027.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 TSMC 28 nm SPRAM中控制冗余行修复的24位移位寄存器结构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_027.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 1 24 bits shift register for row redundancy repair in TSMC 28 nm SPRAM</p>

                </div>
                <div class="p1">
                    <p id="28">对于不含冗余行的存储器可采用列修复方法,带有列修复冗余单元的存储器通常采用比实际所需存储器多1个端口IO的存储器替换,并通过外部电路互连实现,采用列修复方式会明显增加芯片的面积。图2为1个典型的带有冗余列的存储器结构,其中,阴影部分为冗余列,通过<i>S</i>0～<i>S</i>3控制存储器的修复。例如,若<i>D</i>0列在制造过程中出现了缺陷,令<i>S</i>[3:0]等于‘4’b1111’,即可实现存储器的修复。</p>
                </div>
                <div class="area_img" id="29">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_029.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 带有冗余列的嵌入式存储器结构" src="Detail/GetImg?filename=images/JSJK201910006_029.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 带有冗余列的嵌入式存储器结构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_029.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 2 Embedded memory architecture 
 with redundant columns</p>

                </div>
                <h4 class="anchor-tag" id="30" name="30"><b>2.2 冗余修复对存储器良率的影响</b></h4>
                <div class="p1">
                    <p id="31">存储器修复策略中一个最基本的问题是需要增加多少冗余单元。冗余单元用来提高存储器良率从而提高芯片的良率,所以需要有一种计算良率的方法来分析对冗余单元的需求。文献<citation id="85" type="reference">[<a class="sup">5</a>]</citation>提出一种通用的存储器良率计算模型—Negative Binomial Model。存储器的良率<i>Y</i><sub>MEM</sub>为:</p>
                </div>
                <div class="p1">
                    <p id="32" class="code-formula">
                        <mathml id="32"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>D</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext></mrow></msub><mi>A</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext></mrow></msub><mo stretchy="false">)</mo><msup><mrow></mrow><mrow><mo>-</mo><mi>C</mi></mrow></msup><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="33">其中,<i>D</i><sub>MEM</sub>为存储器缺陷密度(defects/mm<sup>2</sup>);<i>A</i><sub>MEM</sub>为存储器的尺寸(mm<sup>2</sup>);<i>C</i>为复杂性因子,该参数是由基础工艺复杂度推导出来的,通常取值为5～15。</p>
                </div>
                <div class="p1">
                    <p id="34">为了计算冗余单元对存储器良率的影响,首先考虑在存储器中添加1行或1列冗余单元的情况,在这种情况下,存储器可以被看成是分成<i>N</i>个与冗余单元大小相等的部分。例如,带有1行冗余单元的存储器,<i>N</i>等于行的数目,该存储器可看作分为<i>N</i>+1个具有相同良率的部分,每部分的良率为<i>Y</i><sub>MEM/</sub><sub><i>N</i></sub>,可以通过式(1)计算得到。而存储器的良率可以由<i>N</i>+1个部分全部合格的概率与<i>N</i>+1个部分出现一个不合格的概率之和近似计算。所以,带有1个冗余单元的存储器的良率计算公式为:</p>
                </div>
                <div class="p1">
                    <p id="35" class="code-formula">
                        <mathml id="35"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>Y</mi><msub><mrow></mrow><mrow><mn>1</mn><mtext>S</mtext><mtext>Ρ</mtext></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><msup><mrow></mrow><mrow><mi>Ν</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>+</mo></mtd></mtr><mtr><mtd><mo stretchy="false">(</mo><mi>Ν</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><msup><mrow></mrow><mi>Ν</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo>-</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="36">随着额外的冗余单元数量的增加,良率的计算变得更复杂,对于带有2个冗余单元的存储器,良率计算变为:</p>
                </div>
                <div class="p1">
                    <p id="37" class="code-formula">
                        <mathml id="37"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>Y</mi><msub><mrow></mrow><mrow><mn>2</mn><mtext>S</mtext><mtext>Ρ</mtext></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><msup><mrow></mrow><mrow><mi>Ν</mi><mo>+</mo><mn>2</mn></mrow></msup><mo>+</mo></mtd></mtr><mtr><mtd><mo stretchy="false">(</mo><mi>Ν</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><msup><mrow></mrow><mrow><mi>Ν</mi><mo>+</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mn>1</mn><mo>-</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><mo>+</mo></mtd></mtr><mtr><mtd><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mi>Ν</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>Ν</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><msup><mrow></mrow><mi>Ν</mi></msup><mo stretchy="false">(</mo><mn>1</mn><mo>-</mo><mi>Y</mi><msub><mrow></mrow><mrow><mtext>Μ</mtext><mtext>E</mtext><mtext>Μ</mtext><mo>/</mo><mi>Ν</mi></mrow></msub><mo stretchy="false">)</mo><msup><mrow></mrow><mn>2</mn></msup><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="38">图3为含有不同冗余单元的存储器良率对比情况。从图3中可以看到,对于面积较小的存储器,含有1个冗余单元(<i>Y</i><sub>1SP</sub>)和2个冗余单元(<i>Y</i><sub>2SP</sub>)的良率几乎一样,对于面积较大的存储器(对于1个含有很多存储器的SoC芯片,位置较近的存储器可以作为1个整体进行评估),含有2行冗余单元的存储器良率会有一定的提升。可见冗余单元数量的选择需要对存储器良率、面积进行综合考虑。</p>
                </div>
                <div class="area_img" id="39">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_039.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 含有不同冗余单元的存储器良率对比情况" src="Detail/GetImg?filename=images/JSJK201910006_039.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 含有不同冗余单元的存储器良率对比情况  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_039.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 3 Comparison of memory yield 
 with different redundant units</p>

                </div>
                <div class="p1">
                    <p id="40">以1个实际芯片为例,该芯片采用TSMC 28 nm工艺,包含930个存储器,考虑到面积、良率等情况,对面积较大的SPRAM存储器采用了2行冗余单元修复策略,可修复存储器共为211个,具体的良率评估方法如下所示:</p>
                </div>
                <div class="p1">
                    <p id="41">(1)首先针对每1个存储器进行良率计算。以TSMC 1088×144 SPRAM为例,通过式(1)和式(2)进行良率计算,其中存储器缺陷密度<i>D</i><sub>MEM</sub>=6.510e<sup>-10 </sup>(defect/μm<sup>2</sup>),复杂性因子<i>C</i>=18,均由TSMC工艺厂家提供。计算结果见表1,可见带有行或列冗余单元的存储器良率会有一定的提升。</p>
                </div>
                <div class="p1">
                    <p id="42">(2)将所有不带冗余单元的存储器良率相乘,得到存储器总良率约为91.347%;根据该芯片的修复策略,将面积较大的SPRAM存储器转换为带有冗余单元的存储器,重新计算总良率为97.009%。可见该SoC中存储器总良率大约提升了5.7%。</p>
                </div>
                <div class="area_img" id="43">
                    <p class="img_tit"><b>表1 TSMC 1088×144 SPRAM良率</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 1 Yield of TSMC 1088×144 SPRAM</b></p>
                    <p class="img_note"></p>
                    <table id="43" border="1"><tr><td><br />冗余单元</td><td>面积/μm<sup>2</sup></td><td>良率/%</td></tr><tr><td><br />不带冗余单元</td><td>19 897.34</td><td>99.976 687 114 6</td></tr><tr><td><br />2行冗余单元</td><td>20 043.65</td><td>99.999 999 999 8</td></tr><tr><td><br />1列冗余单元</td><td>20 035.52</td><td>99.999 997 263 4</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="45" name="45"><b>2.3 设计实例</b></h4>
                <div class="p1">
                    <p id="46">Tessent工具提供的存储器修复电路主要包含3种基本结构:内建自测试BIST(Built-In Self-Test)、内建冗余分析BIRA(Built-In Redundancy Analysis)、内建自修复BISR(Built-In Self-Repair)<citation id="86" type="reference"><link href="13" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>。BIST电路根据所选用的测试算法测试存储器;BIRA电路分析存储器缺陷是否能被修复;BISR 用于传送存储器修复信息,并控制修复信息的存储及读写操作。图4提出一种基于冗余单元的存储器测试及修复结构,其中BIST、存储器接口、BISR控制器、BISR链等模块由Tessent 工具配置后产生。</p>
                </div>
                <div class="p1">
                    <p id="47">该结构采用硬修复方式对存储器进行修复,硬修复即将存储器的修复信息下载到可编程存储器Fuse中,掉电不易丢失。目前常用的Fuse有激光Fuse与eFuse,由于eFuse的面积比激光Fuse的面积小2～3倍,并且不需要特殊的设备和测试,所以目前通常采用eFuse的方式进行硬修复。本结构中采用eFuse进行存储器修复信息的存储。eFuse数量及大小可以由式(4)确定:</p>
                </div>
                <div class="p1">
                    <p id="48" class="code-formula">
                        <mathml id="48"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>F</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>=</mo><mo stretchy="false">(</mo><mi>R</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo>*</mo><mi>B</mi><mi>Ι</mi><mi>S</mi><mi>R</mi><mi>R</mi><mi>e</mi><mi>g</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">)</mo><mo>+</mo></mtd></mtr><mtr><mtd><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>R</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>i</mi><mi>r</mi><mi>s</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>*</mo><mi>Ζ</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>B</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="49">其中,<i>Repairs</i> 为1个芯片中可同时修复的缺陷数目;<i>BISRRegSize</i>为解码1个冗余单元所需要修复的数据最大长度;<i>BISRChainLength</i>=<i>BISRRegSize</i> * 冗余单元的数量;<i>ZeroCountBits</i>=log(<i>BISRChainLength</i>)。</p>
                </div>
                <div class="p1">
                    <p id="50">要确定eFuse的大小,首先应该确定1个芯片上最多可修复的缺陷数(<i>Repairs</i>)。以2.2节中所述芯片为例,首先计算平均良率和平均缺陷率,如表2所示,然后由式(5)计算出现<i>r</i>个缺陷的概率<i>p</i>(<i>r</i>)(如表3所示)。</p>
                </div>
                <div class="p1">
                    <p id="51" class="code-formula">
                        <mathml id="51"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><msubsup><mrow></mrow><mi>n</mi><mi>r</mi></msubsup><mo>*</mo><mi>A</mi><mi>D</mi><msup><mrow></mrow><mi>r</mi></msup><mi>A</mi><mi>Y</mi><msup><mrow></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>-</mo><mi>r</mi><mo stretchy="false">)</mo></mrow></msup><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="52">其中,<i>n</i>为可修复存储器数量;<i>AA</i>为平均面积,<i>AY</i>为平均良率,且<i>AY</i>=(1-<i>AA</i>+<i>D</i>)<sup>-</sup><sup><i>C</i></sup>;<i>AD</i>为平均缺陷率,且<i>AD</i>=1-<i>AY</i>。</p>
                </div>
                <div class="area_img" id="53">
                    <p class="img_tit"><b>表2 平均良率和平均缺陷率</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 2 Average yield and defect rate</b></p>
                    <p class="img_note"></p>
                    <table id="53" border="1"><tr><td><br />存储器<br />数量</td><td>可修复存储<br />器数量</td><td>平均面积<br />(μm<sup>2</sup>)</td><td>平均<br />良率/%</td><td>平均<br />缺陷率/%</td></tr><tr><td><br />930</td><td>211</td><td>26 889.118 94</td><td>99.968</td><td>0.032</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="54">
                    <p class="img_tit"><b>表3 同时出现</b><i><b>r</b></i><b>个缺陷的概率</b><i><b>p</b></i><b>(</b><i><b>r</b></i>) <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 3 Probability of </b><i><b>r</b></i><b> defects </b><i><b>p</b></i><b>(</b><i><b>r</b></i><b>) at the same time</b></p>
                    <p class="img_note"></p>
                    <table id="54" border="1"><tr><td><br />最多可修复缺陷数<i>r</i></td><td>出现<i>r</i>个缺陷的概率<i>p</i>(<i>r</i>)/%</td></tr><tr><td><br />1</td><td>6.221 639 997 2</td></tr><tr><td><br />2</td><td>0.205 868 420 2</td></tr><tr><td><br />3</td><td>0.004 519 707 4</td></tr><tr><td><br />4</td><td>0.000 074 064 4</td></tr><tr><td><br />5</td><td>0.000 000 966 3</td></tr><tr><td><br />6</td><td>0.000 000 010 5</td></tr><tr><td><br />7</td><td>0.000 000 000 1</td></tr><tr><td><br />8</td><td>0.000 000 000 0</td></tr><tr><td><br />9</td><td>0.000 000 000 0</td></tr><tr><td><br />10</td><td>0.000 000 000 0</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="55">由表3可知,该芯片最大可修复缺陷数大于7个即可。本芯片选取10个可修复缺陷数,即式(5)中<i>Repairs</i>为10,本芯片采用的冗余单元为TSMC标准的行冗余单元,所以<i>BISRRegSize</i>为12,经计算所需<i>FuseCount</i>为274。</p>
                </div>
                <div class="area_img" id="56">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_056.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 基于冗余单元的存储器测试修复结构" src="Detail/GetImg?filename=images/JSJK201910006_056.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 基于冗余单元的存储器测试修复结构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_056.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 4 Memory test and repair structure based on redundant units</p>

                </div>
                <div class="p1">
                    <p id="57">eFuse控制及接口电路主要用于eFuse与BISR 控制器的接口互连,从而使得BISR控制器可以读写eFuse。如果芯片功能模式下也需要操作eFuse,比如存储CHIP-ID等,则eFuse前应加入选择电路进行不同模式的选择。</p>
                </div>
                <div class="p1">
                    <p id="58">功能模式下的修复控制器主要用于芯片正常工作时存储器修复过程的控制。该模块产生“Repair_clk” 和“Repair_en”信号用于BISR控制器的时钟和使能信号,如图5所示。修复完成后,BISR控制器会产生Repair_done信号给该模块,表示修复过程完成,芯片可以进入正常工作模式。</p>
                </div>
                <div class="area_img" id="59">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 存储器修复与芯片功能交互时序图" src="Detail/GetImg?filename=images/JSJK201910006_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 存储器修复与芯片功能交互时序图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 5 Interaction sequence diagram 
 of memory repair and chip function</p>

                </div>
                <div class="p1">
                    <p id="60">BISR控制器的“bisr_done”信号是由组合逻辑产生的,为了消除“X”及毛刺的影响,需要加入Repair_done处理电路使 “bisr_done” 信号开始的时候置为0。</p>
                </div>
                <div class="p1">
                    <p id="61">下面针对该结构具体描述一下该存储器测试修复结构的修复过程,该结构有2种工作模式:测试/修复模式和正常工作模式。在测试/修复模式下,首先由BIST电路测试芯片中所有的存储器,当测试出存储器有缺陷时,BIST电路给BIRA发送故障信号,并将故障地址送入BIRA寄存器中,由BIRA电路分析该类存储器缺陷是否能被修复,如能修复便给出修复信息,该修复信息由BISR链传送给BISR 控制器,并由该控制器将修复信息写入到eFuse中。在正常工作模式下,当芯片正常上电时,BISR 控制器首先应从eFuse中读出存储器修复信息配置好待修复存储器,再进入正常工作。</p>
                </div>
                <h3 id="62" name="62" class="anchor-tag"><b>3 实验结果与分析</b></h3>
                <div class="p1">
                    <p id="63">上述修复电路已应用到多个电路中,以上文中提到的芯片为例,加入MBIST及修复电路后芯片门的数量由47 583 982增至50 555 225,面积增加5.96%,良率提升4.6%。</p>
                </div>
                <h4 class="anchor-tag" id="64" name="64"><b>3.1 存储器内建自测试仿真</b></h4>
                <div class="p1">
                    <p id="65">该芯片采用的存储器测试算法为SMarchCHKBvcd,存储器内建自测试仿真如图6所示,当MBISTPG_GO为1后,MBISTPG_DONE为1时表示存储器测试成功。</p>
                </div>
                <div class="area_img" id="66">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_066.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 MBSIT 仿真图" src="Detail/GetImg?filename=images/JSJK201910006_066.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 MBSIT 仿真图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_066.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 6 MBIST simulation diagram</p>

                </div>
                <div class="area_img" id="67">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_067.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 存储器修复仿真图" src="Detail/GetImg?filename=images/JSJK201910006_067.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图8 存储器修复仿真图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_067.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 8 Simulation diagram of memory repair</p>

                </div>
                <h4 class="anchor-tag" id="68" name="68"><b>3.2 存储器修复电路的仿真及测试方案</b></h4>
                <div class="p1">
                    <p id="69">该存储器修复结构的仿真及测试方案如图7所示,在仿真过程中,可以给特定的存储器加入一定的缺陷。通常存储器IP的仿真库中一般会包含插入缺陷的方法。</p>
                </div>
                <div class="p1">
                    <p id="70">具体描述如下:</p>
                </div>
                <div class="p1">
                    <p id="71">(1)TP0:初始化,复位所有的BISR寄存器、计算BISR长度、验证BISR链的完整性。</p>
                </div>
                <div class="p1">
                    <p id="72">(2)TP1:修复前内建自测试,测试芯片上所有的存储器。</p>
                </div>
                <div class="p1">
                    <p id="73">(3)TP2.1:分析判断是否需要修复,并将BIRA分析的值写入BISR链中。</p>
                </div>
                <div class="p1">
                    <p id="74">(4)TP2.2:获取BISR链中的值,压缩后写入eFuse中。</p>
                </div>
                <div class="p1">
                    <p id="75">(5)TP2.3:读取eFuse中的值,解压后移入BISR中,对其进行验证。</p>
                </div>
                <div class="p1">
                    <p id="76">(6)TP3:修复后内建自测试,重新读取eFuse中的修复信息,再次测试存储器。</p>
                </div>
                <div class="area_img" id="77">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJK201910006_077.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 存储器修复仿真及测试流程图" src="Detail/GetImg?filename=images/JSJK201910006_077.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 存储器修复仿真及测试流程图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJK201910006_077.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Figure 7 Simulation and test flow of memory repair</p>

                </div>
                <div class="p1">
                    <p id="78">仿真结果如图8所示。</p>
                </div>
                <h3 id="79" name="79" class="anchor-tag"><b>4 结束语</b></h3>
                <div class="p1">
                    <p id="80">目前,嵌入式存储器的良率决定着芯片的良率,进入纳米工艺后,嵌入式存储器的修复已经变得非常重要,本文详细描述了存储器良率评估的方法,提出了一种嵌入式存储器自修复结构。该结构采用eFuse硬修复及冗余修复方法,包括测试/修复模式下的存储器的内建自测试、分析、修复及功能模式下的修复,并通过实际案例、仿真,证明了它是一种行之有效的方法,可以应用到目前各类SoC芯片的DFT设计中。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Design and test large embedded memories: An overview">

                                <b>[1]</b> Rajsuman R.Design and test of large embedded memories:An overview[J].IEEE Design and Test of Computers,2001,18(3):16-27.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" >
                                    <b>[2]</b>
                                 Yu Yang,Li Jia-ming,Qiao Li-yan.Memory built-in self-repair method based on address partitioning strategy[J].Acta Electronica Sinica,2010,38(2A):169-173.(in Chinese)
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A method and improvement of self-repair of embedded memories">

                                <b>[3]</b> Qin Pan,Wang Jian,Wu Hui.A method and improvement of self-repair of embedded memories[J].Jichengdianlu Tongxun,2015,33(3):34-38.(in Chinese)
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient BISR techniques for word-oriented embedded memories with hierarchical redundancy">

                                <b>[4]</b> Lu Shyue-Kung,Yang Chun-lin,Lin Han-wen.Efficient BISR techniques for word-oriented embedded memories with hierarchical redundancy[C]//Proc of the 5th IEEE/ACIS International Conference on Computer and Information Science and 1st IEEE/ACIS International Workshop on Component-Based Software Engineering,2006:355-360.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Memory repair primer">

                                <b>[5]</b> Mentor Graphics.Memory repair primer[M].Drego:Mentor Graphics,2008.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Tessent memory bist usage guide and reference software">

                                <b>[6]</b> Mentor Graphics.Tessent memory bist usage guide and reference software[M].Drego:Mentor Graphics,2011.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU2010S1030&amp;v=MTY1NjhIOUd2cm85R1pJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSbUZ5L2dWYjdOSVRmVGU3RzQ=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 俞洋,李嘉铭,乔立岩.基于地址分割的嵌入式存储器内建自修复的方法[J].电子学报,2010,38(2A):169-173.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_3" >
                                    <b>[3]</b>
                                 秦盼,王健,吴慧.一种嵌入式存储器的测试与修复方法[J].集成电路通讯,2015,33(3):34-38.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJK201910006" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJK201910006&amp;v=MTkyMjBESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSbUZ5L2dWYjdOTHo3QlpiRzRIOWpOcjQ5RllvUUs=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQ3cmEvcXIxT0wrTHhvaVdCNFNyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
