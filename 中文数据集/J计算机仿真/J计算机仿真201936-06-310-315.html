<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=NOOK-mvTMnxl11s6oPYV0boPXN3iP4N7Rc-A56nk4KI1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2fKXReader%2fDetail%3fTIMESTAMP%3d637141007053541250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJZ201906064%26RESULT%3d1%26SIGN%3dCUPQ91Bvzd5pE0%252b36rjZ5GMEh14%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJZ201906064&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJZ201906064&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJZ201906064&amp;v=MDQwNTVxcUJ0R0ZyQ1VSN3FmWnVabkZ5N2xXcnpCTHo3QmRMRzRIOWpNcVk5RFlJUUtESDg0dlI0VDZqNTRPM3o=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#31" data-title="&lt;b&gt;1 引言&lt;/b&gt; "><b>1 引言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#35" data-title="&lt;b&gt;2 MDL基本理论&lt;/b&gt; "><b>2 MDL基本理论</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#36" data-title="&lt;b&gt;2.1 Brockett的基本理论&lt;/b&gt;"><b>2.1 Brockett的基本理论</b></a></li>
                                                <li><a href="#44" data-title="&lt;b&gt;2.2 机械臂轨迹生成&lt;/b&gt;"><b>2.2 机械臂轨迹生成</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#49" data-title="&lt;b&gt;3 MDLg模型&lt;/b&gt; "><b>3 MDLg模型</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#90" data-title="&lt;b&gt;4 算法实现&lt;/b&gt; "><b>4 算法实现</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#93" data-title="&lt;b&gt;4.1 时域分割与时间扩张&lt;/b&gt;"><b>4.1 时域分割与时间扩张</b></a></li>
                                                <li><a href="#109" data-title="&lt;b&gt;4.2 空间分解&lt;/b&gt;"><b>4.2 空间分解</b></a></li>
                                                <li><a href="#135" data-title="&lt;b&gt;4.3 信号重构&lt;/b&gt;"><b>4.3 信号重构</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#139" data-title="&lt;b&gt;5 仿真研究&lt;/b&gt; "><b>5 仿真研究</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#148" data-title="&lt;b&gt;6 结论&lt;/b&gt; "><b>6 结论</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#61" data-title="&lt;b&gt;图1 基于MDLg模型的控制系统架构&lt;/b&gt;"><b>图1 基于MDLg模型的控制系统架构</b></a></li>
                                                <li><a href="#92" data-title="&lt;b&gt;图2 MDLg算法信号流图&lt;/b&gt;"><b>图2 MDLg算法信号流图</b></a></li>
                                                <li><a href="#143" data-title="&lt;b&gt;图3 IRB4600机械臂模型&lt;/b&gt;"><b>图3 IRB4600机械臂模型</b></a></li>
                                                <li><a href="#145" data-title="&lt;b&gt;图4 机械臂末端的圆形轨迹&lt;/b&gt;"><b>图4 机械臂末端的圆形轨迹</b></a></li>
                                                <li><a href="#147" data-title="&lt;b&gt;表1 MDLg与传统方法的数据传输量&lt;/b&gt;"><b>表1 MDLg与传统方法的数据传输量</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>
                                    <dd class="subnode">
                                        <h6>
                                            <a href="#a_footnote">注释</a>

                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="166">


                                    <a id="bibliography_1" title=" R Brockett.Formal languages for motion description and map making[J].Robotics, 1990, 41:181-191." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Formal languages for motion description and map making,&amp;quot;">
                                        <b>[1]</b>
                                         R Brockett.Formal languages for motion description and map making[J].Robotics, 1990, 41:181-191.
                                    </a>
                                </li>
                                <li id="168">


                                    <a id="bibliography_2" title=" R W Brockett.On the computer control of movement[C].Robotics and Automation, 1988.Proceedings, 1988 IEEE International Conference on, 1988:534-540." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On the computer control of movement">
                                        <b>[2]</b>
                                         R W Brockett.On the computer control of movement[C].Robotics and Automation, 1988.Proceedings, 1988 IEEE International Conference on, 1988:534-540.
                                    </a>
                                </li>
                                <li id="170">


                                    <a id="bibliography_3" >
                                        <b>[3]</b>
                                     Brockett R W.Hybrid models for motion control systems[M].Springer, 1993.</a>
                                </li>
                                <li id="172">


                                    <a id="bibliography_4" title=" V Manikonda, P S Krishnaprasad, J Hendler.A motion description language and a hybrid architecture for motion planning with nonholonomic robots[J].Proceedings of 1995 Ieee International Conference on Robotics and Automation, Vols 1-3, 1995 2021-2028." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A motion description language and a hybrid architecture for motion planning with nonholonomic robots">
                                        <b>[4]</b>
                                         V Manikonda, P S Krishnaprasad, J Hendler.A motion description language and a hybrid architecture for motion planning with nonholonomic robots[J].Proceedings of 1995 Ieee International Conference on Robotics and Automation, Vols 1-3, 1995 2021-2028.
                                    </a>
                                </li>
                                <li id="174">


                                    <a id="bibliography_5" title=" H Li.Choreographing Dynamical Systems[D].Harvard University, 2004." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Choreographing Dynamical Systems">
                                        <b>[5]</b>
                                         H Li.Choreographing Dynamical Systems[D].Harvard University, 2004.
                                    </a>
                                </li>
                                <li id="176">


                                    <a id="bibliography_6" >
                                        <b>[6]</b>
                                     化建宁.基于网络的机器人遥操作系统:运动描述语言方法[D].中国科学院沈阳自动化研究所, 2007.</a>
                                </li>
                                <li id="178">


                                    <a id="bibliography_7" title=" 化建宁, 等.基于MDL的机器人网络遥操作系统控制方法[J].机器人, 2013, 35 (5) :615-622." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JQRR201305015&amp;v=MDg2NzMzenFxQnRHRnJDVVI3cWZadVpuRnk3bFdyekJMenpaZkxHNEg5TE1xbzlFWVlRS0RIODR2UjRUNmo1NE8=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                         化建宁, 等.基于MDL的机器人网络遥操作系统控制方法[J].机器人, 2013, 35 (5) :615-622.
                                    </a>
                                </li>
                                <li id="180">


                                    <a id="bibliography_8" title=" 化建宁, 等.基于运动描述语言的轮式移动机器人控制[J].机器人, 2006, 28 (3) :316-320." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JQRR200603014&amp;v=MDM2ODY0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVabkZ5N2xXcnpCTHp6WmZMRzRIdGZNckk5RVlJUUtESDg0dlI=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[8]</b>
                                         化建宁, 等.基于运动描述语言的轮式移动机器人控制[J].机器人, 2006, 28 (3) :316-320.
                                    </a>
                                </li>
                                <li id="182">


                                    <a id="bibliography_9" title=" P J Martin.Motion description languages:from specification to execution[D].Georgia Institute of Technology, 2010." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Motion description languages:from specification to execution">
                                        <b>[9]</b>
                                         P J Martin.Motion description languages:from specification to execution[D].Georgia Institute of Technology, 2010.
                                    </a>
                                </li>
                                <li id="184">


                                    <a id="bibliography_10" title=" Gargas Iii E F.Generation and use of a discrete robotic controls alphabet for high-level tasks[D].Georgia Institute of Technology, 2012." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Generation and use of a discrete robotic controls alphabet for high-level tasks">
                                        <b>[10]</b>
                                         Gargas Iii E F.Generation and use of a discrete robotic controls alphabet for high-level tasks[D].Georgia Institute of Technology, 2012.
                                    </a>
                                </li>
                                <li id="186">


                                    <a id="bibliography_11" title=" 刘维惠, 陈殿生, 张立志.人机协作下的机械臂轨迹生成与修正方法[J].机器人, 2016, 38 (4) :504-512." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JQRR201604015&amp;v=MjYyMDZxZlp1Wm5GeTdsV3J6Qkx6elpmTEc0SDlmTXE0OUVZWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjc=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                         刘维惠, 陈殿生, 张立志.人机协作下的机械臂轨迹生成与修正方法[J].机器人, 2016, 38 (4) :504-512.
                                    </a>
                                </li>
                                <li id="188">


                                    <a id="bibliography_12" title=" Craig J J, 贠超.机器人学导论[M].北京:机械工业出版社, 2006." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=0007111186818999&amp;v=MTM3MTFFYk9JR0JSTTh6eFVTbURkOVNIN24zeEU5ZmJ2bktyaWZaZVp2Rnluc1U3bklLVjBkVlYyN0diSzVIOURFcVlk&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[12]</b>
                                         Craig J J, 贠超.机器人学导论[M].北京:机械工业出版社, 2006.
                                    </a>
                                </li>
                                <li id="190">


                                    <a id="bibliography_13" title=" Biagiotti L, Melchiorri C.Trajectory Planning for Automatic Machines and Robots[M].Springer Science &amp;amp; Business Media, 2008." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Trajectory planning for automatic machines and robots">
                                        <b>[13]</b>
                                         Biagiotti L, Melchiorri C.Trajectory Planning for Automatic Machines and Robots[M].Springer Science &amp;amp; Business Media, 2008.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJZ" target="_blank">计算机仿真</a>
                2019,36(06),310-315             </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于运动描述语言的机械臂轨迹生成及仿真</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%88%98%E9%92%8A%E9%93%AD&amp;code=32967191&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">刘钊铭</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%88%98%E4%B9%83%E9%BE%99&amp;code=41185049&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">刘乃龙</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%AD%8F%E9%9D%92&amp;code=37222465&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">魏青</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%B4%94%E9%BE%99&amp;code=30440331&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">崔龙</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%AD%E5%9B%BD%E7%A7%91%E5%AD%A6%E9%99%A2%E6%B2%88%E9%98%B3%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A0%94%E7%A9%B6%E6%89%80&amp;code=0183762&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">中国科学院沈阳自动化研究所</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%AD%E5%9B%BD%E7%A7%91%E5%AD%A6%E9%99%A2%E5%A4%A7%E5%AD%A6&amp;code=1698842&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">中国科学院大学</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>传统的机械臂轨迹生成与控制方法本质上是一种离散采样方法, 主控制器以固定的时间间隔采样关节的轨迹参考函数, 并将采样点的位置、速度等信息作为参考控制信号发送给关节控制器。在这种方法中, 轨迹精度依赖于采样点的数量, 提高精度就要增加采样点, 但是这将增加数据传输量, 总线系统的速率和带宽也需要相应提高。针对传统方法的特点, 提出基于运动描述语言 (MDL) 的机械臂轨迹生成与控制方法。上述方法把连续的轨迹函数映射到运动基元, 用运动基元的组合来描述轨迹函数, 总线系统只需实时传输少量参数化的运动基元, 就可以在关节端重构参考轨迹。上述方法摆脱了离散采样的方式, 可以在不提高总线速率的前提下提高机械臂的轨迹精度, 还通过仿真软件验证了上述方法的有效性。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%9C%BA%E5%99%A8%E4%BA%BA&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">机器人;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%BF%90%E5%8A%A8%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">运动描述语言;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%BD%A8%E8%BF%B9%E7%94%9F%E6%88%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">轨迹生成;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BB%BF%E7%9C%9F&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">机器人仿真;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    刘钊铭 (1989-) , 男 (汉族) , 辽宁沈阳人, 博士研究生, 主要研究领域为机器人动力学建模与控制, 机器人关节驱动器, 实时以太网通信。;
                                </span>
                                <span>
                                    刘乃龙 (1989-) , 男 (汉族) , 山东临沂人, 博士研究生, 主要研究领域为机器人操作, 人工智能, 深度强化学习。;
                                </span>
                                <span>
                                    魏青 (1988-) , 男 (汉族) , 河南夏邑人, 博士研究生, 主要研究领域为遥操作机器人技术, 虚拟现实技术。;
                                </span>
                                <span>
                                    崔龙 (1980-) , 男 (汉族) , 辽宁沈阳人, 博士, 副研究员, 硕士研究生导师, 主要研究领域为机器人及遥操作技术, 智能机构与振动技术, 先进工业机器人及其控制。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-03-02</p>

            </div>
                    <h1><b>A Research of MDL Method for Manipulator Trajectory Generation and Simulation</b></h1>
                    <h2>
                    <span>LIU Zhao-ming</span>
                    <span>LIU Nai-long</span>
                    <span>WEI Qing</span>
                    <span>CUI Long</span>
            </h2>
                    <h2>
                    <span>Shenyang Institute of Automation, Chinese Academy of Sciences</span>
                    <span>University of Chinese Academy of Sciences</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Traditional trajectory generation and control method is essentially a discrete sampling method. The joint's trajectory function is sampled at a fixed time interval in the core controller, then the position, velocity and so on are transformed to the joint controller. In this method, the accuracy of trajectory depends on the number of samples, which means the more samples the more accuracy. However the bandwidth and rate of communication bus are limited, the number of samples cannot be increased arbitrarily. In view of the feature of the traditional method, this paper proposes a method of manipulator trajectory generation and control based on motion description language (MDL) . We mapped continuous trajectory functions to some atoms, and described these functions by the combination of atoms. A few of parameterized atoms were transmitted by the communication bus, and the reference function can be reconstructed in the joint controller. This method gets rid of the sampling way. The accuracy of trajectory can be improved on the premise of the same communication rate. This article also verifies the validity of the method via simulation software.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Robot&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Robot;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=MDL&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">MDL;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Trajectory%20generation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Trajectory generation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Robotic%20simulation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Robotic simulation;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-03-02</p>
                            </div>


        <!--brief start-->
                        <h3 id="31" name="31" class="anchor-tag"><b>1 引言</b></h3>
                <div class="p1">
                    <p id="32">运动描述语言 (Motion Description Language) , 简写MDL, 是由哈佛大学的Roger Brockett教授提出的用于机器人控制的理论。Brockett教授指出, 机器人系统具有混杂系统 (Hybrid System) 的特征, 可以用一种具有语言的形式依靠字符串驱动的方法进行控制, 这就是MDL方法<citation id="196" type="reference"><link href="166" rel="bibliography" /><link href="168" rel="bibliography" /><link href="170" rel="bibliography" /><sup>[<a class="sup">1</a>,<a class="sup">2</a>,<a class="sup">3</a>]</sup></citation>。Brockett教授提出MDL理论后, 又有许多学者对该理论进行了探索。1995年, 马里兰大学的Manikonda提出MDLe模型, 这是一种加入了中断函数的扩展MDL模型, 他把这种方法用于非完整性移动机器人的运动规划与控制<citation id="192" type="reference"><link href="172" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>。2005年, 哈佛大学的李洪谊提出了DMDL模型, 这种模型应用于包含了惯性的动力系统的控制。他以倒立摆系统为研究对象, 运用DMDL模型得到了很好的控制效果<citation id="193" type="reference"><link href="174" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>。2008年, 中科院沈阳自动化所的化建宁在机器人遥操作系统中应用了MDL方法, 基于该方法设计了新的遥操作控制系统架构, 成功解决了遥操作系统中存在的通信带宽不足和计算能力较弱的问题<citation id="197" type="reference"><link href="176" rel="bibliography" /><link href="178" rel="bibliography" /><link href="180" rel="bibliography" /><sup>[<a class="sup">6</a>,<a class="sup">7</a>,<a class="sup">8</a>]</sup></citation>。2010年, 佐治亚理工的Patrick J. Martin再次完善了MDL理论的基础框架, 丰富了MDL理论的许多细节, 并设计了MDL控制系统的软件结构, 使它更适用于具有能源、驱动、感知和通信约束的控制系统<citation id="194" type="reference"><link href="182" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>。2012年, 佐治亚理工的Gargas 以MDLe模型为基础, 建立了一套移动机器人运动控制与规划的方法。这种方法运用希尔伯特空间理论, 把移动机器人的轨迹控制信号分解到运动描述基元, 在减少系统通信数据量的基础上保持了原有运动轨迹的精确性<citation id="195" type="reference"><link href="184" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="33">MDL理论的核心思想就是把底层的具体运动细节交给执行机构, 控制系统高层只负责整体运动规划。在传统的机械臂控制系统中, 每个关节的参考轨迹在机器人核心控制器中生成, 然后对参考轨迹采样, 最后将采样点处的参考控制信号通过总线发送到关节驱动器。这种系统架构意味着, 关节运动的所有细节都由核心控制器产生, 提高轨迹精度只能通过增加采样点的方式。但是由于总线带宽有限, 采样点的增加是有上限的。基于MDL的控制系统架构则与之不同, 在该系统的框架下, 不再传输离散的轨迹采样点, 而是直接传输参数化的轨迹函数。所谓参数化的轨迹函数, 是指利用类似傅立叶变换的技术, 把轨迹映射到一些预先给定的运动基元上, 通过对基元的线性组合就可以还原参考轨迹。通信系统只需要传输几个用于线性组合的参数, 就可以在关节端重构出连续的关节参考轨迹。在这种架构下, 数据传输量将大幅下降而轨迹精度却几乎不会损失。</p>
                </div>
                <div class="p1">
                    <p id="34">在这篇论文中, 我们将首先介绍MDL的基本理论, 然后基于MDL理论建立专用于机械臂轨迹生成与控制的MDLg模型并给出它的算法实现。最后, 通过V-REP机器人仿真平台进行仿真。</p>
                </div>
                <h3 id="35" name="35" class="anchor-tag"><b>2 MDL基本理论</b></h3>
                <h4 class="anchor-tag" id="36" name="36"><b>2.1 Brockett的基本理论</b></h4>
                <div class="p1">
                    <p id="37">考虑一个具有如下形式的系统</p>
                </div>
                <div class="p1">
                    <p id="38" class="code-formula">
                        <mathml id="38"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign="left"><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>u</mi><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>+</mo><mi>k</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>y</mi><mo>=</mo><mi>h</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="39">其中<i>u</i>、<i>x</i>、<i>y</i>都是时间的函数;<i>u</i>是输入的控制率, 它是一个<i>m</i>维的连续函数;<i>x</i>是<i>n</i>维的系统状态;<i>y</i>是一个<i>p</i>维的系统输出;<i>k</i>是状态反馈。在<i>MDL</i>理论中, 这个系统可以被分割成许多小段, 每一段用一个三元组 (<i>u</i>, <i>k</i>, <i>t</i>) 来表示, 这个三元组被称为运动基元 (<i>atom</i>) , 其中<i>u</i>是控制率, <i>k</i>是反馈状态, <i>t</i>表示时间。从初始时刻开始, <i>MDL</i>编译器接收到一个运动基元的序列, 随后编译器将这个序列翻译成如下的分段仿射系统</p>
                </div>
                <div class="p1">
                    <p id="40" class="code-formula">
                        <mathml id="40"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign="left"><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>+</mo><mi>k</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>, </mo><mi>y</mi><mo>=</mo><mi>h</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>;</mo><mi>τ</mi><msub><mrow></mrow><mn>0</mn></msub><mo>≤</mo><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mn>1</mn></msub></mtd></mtr><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>+</mo><mi>k</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>, </mo><mi>y</mi><mo>=</mo><mi>h</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>;</mo><mi>τ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>≤</mo><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mn>2</mn></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>+</mo><mi>k</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>, </mo><mi>y</mi><mo>=</mo><mi>h</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>;</mo><mi>τ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>≤</mo><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mi>i</mi></msub></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="41">关于这个分段仿射系统与原系统的关系, Brockett教授给出了下面的定理</p>
                </div>
                <div class="p1">
                    <p id="42">定理2.1:如果关于<i>x</i>的连续函数<i>G</i> (<i>x</i>) 满足利普希茨连续性条件, 那么形如方程组 (2) 的分段仿射系统可以对系统 (1) 生成一个足够好的逼近<citation id="198" type="reference"><link href="168" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="43">这个定理构成了整个运动描述语言理论的基础, 它使一个仿射系统可以被分段表示。因此只要将一个连续系统分段表示, 然后将每一个小段用参数化的运动基元 (<i>u</i>, <i>k</i>, <i>t</i>) 表示, 就可以用一串离散的符号序列来驱动一个连续系统。</p>
                </div>
                <h4 class="anchor-tag" id="44" name="44"><b>2.2 机械臂轨迹生成</b></h4>
                <div class="p1">
                    <p id="45">机械臂的运动控制分为路径规划 (Path Planning) 和轨迹生成 (Trajectory Generation) 两个层次。路径规划是控制的高层次内容, 它的任务是在末端笛卡尔空间生成一条满足要求并且规避碰撞的合理路径, 常用方法有人工势场、动态运动基元等<citation id="199" type="reference"><link href="186" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>;轨迹生成任务在路径规划完成后执行, 它负责在机械臂的关节空间根据已经产生的末端路径和速度、加速度等约束条件生成足够平滑的关节运动轨迹。一般用样条曲线插补的方法实现轨迹的平滑, 用优化理论使轨迹满足约束条件<citation id="200" type="reference"><link href="188" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>。本文关注的就是机械臂的轨迹生成, 基于运动描述语言理论建立一种用于机械臂轨迹生成的MDLg模型。</p>
                </div>
                <div class="p1">
                    <p id="46">事实上, 传统方法在关节空间产生的轨迹都是使用点到点运动方式实现的。所谓点到点运动, 就是对关节的运动轨迹以Δ<i>t</i>为采用时间进行离散采样, 然后在两个离散的采样点之间使用样条曲线进行轨迹插补, 只要采样时间足够小, 实际的运动轨迹的就会达到期望精度。关于样条曲线, 一般根据轨迹的连续性要求进行选取, 已经形成了成熟的理论<citation id="201" type="reference"><link href="190" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>。常用的样条曲线有二次、三次、五次样条曲线等:</p>
                </div>
                <div class="p1">
                    <p id="47" class="code-formula">
                        <mathml id="47"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign="left"><mtr><mtd><mtext>q</mtext><mo stretchy="false"> (</mo><mtext>t</mtext><mo stretchy="false">) </mo><mo>=</mo><mtext>q</mtext><msub><mrow></mrow><mn>2</mn></msub><mi>t</mi><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>1</mn></msub><mi>t</mi><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>0</mn></msub></mtd></mtr><mtr><mtd><mi>q</mi><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>=</mo><mi>a</mi><msub><mrow></mrow><mn>3</mn></msub><mi>t</mi><msup><mrow></mrow><mn>3</mn></msup><mo>+</mo><mtext>q</mtext><msub><mrow></mrow><mn>2</mn></msub><mi>t</mi><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>1</mn></msub><mi>t</mi><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>0</mn></msub></mtd></mtr><mtr><mtd><mi>q</mi><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>=</mo><mi>a</mi><msub><mrow></mrow><mn>5</mn></msub><mi>t</mi><msup><mrow></mrow><mn>5</mn></msup><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>4</mn></msub><mi>t</mi><msup><mrow></mrow><mn>4</mn></msup><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>3</mn></msub><mi>t</mi><msup><mrow></mrow><mn>3</mn></msup><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>2</mn></msub><mi>t</mi><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>1</mn></msub><mi>t</mi><mo>+</mo><mi>a</mi><msub><mrow></mrow><mn>0</mn></msub></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="48">这些样条曲线也是构建机械臂轨迹生成MDLg模型的运动基元的基础。</p>
                </div>
                <h3 id="49" name="49" class="anchor-tag"><b>3 MDLg模型</b></h3>
                <div class="p1">
                    <p id="50">本节将介绍用于机械臂轨迹生成的MDLg模型。MDLg模型以MDL理论和加入了中断描述的MDLe模型为基础, 结合机械臂轨迹生成与控制的特点建立。基于MDLg模型的机器人控制系统架构如图1所示, 是一种主从结构。MDLg生成器位于机器人的主端核心控制器中, 它将关节的运动轨迹映射成一系列基于运动基元的字符串序列。MDLg解析器位于机器人的关节控制器, 将主端发送来的字符串序列解析为轨迹参考函数, 并基于关节的模型对关节运动进行控制。</p>
                </div>
                <div class="p1">
                    <p id="51">下面给出MDLg模型的定义。考虑一个具有如下形式的系统:</p>
                </div>
                <div class="p1">
                    <p id="52" class="code-formula">
                        <mathml id="52"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mtext>i</mtext><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mi>g</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mi>u</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>;</mo><mi>y</mi><mo>=</mo><mi>h</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>∈</mo><mi>ℝ</mi><msup><mrow></mrow><mi>p</mi></msup></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="53">其中</p>
                </div>
                <div class="area_img" id="54">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJZ201906064_05400.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="55">对于这个系统, 首先定义<i>MDLg</i>模型的运动基元。</p>
                </div>
                <div class="p1">
                    <p id="56">定义3.1 (运动基元) :在<i>MDLg</i>模型中, 运动基元 (<i>atom</i>) 是一个三元组符号, 用<i>σ</i><sub><i>i</i></sub>来表示, 其中</p>
                </div>
                <div class="p1">
                    <p id="57" class="code-formula">
                        <mathml id="57"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign="left"><mtr><mtd><mi>σ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>U</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>, </mo><mi>ξ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>, </mo><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo>, </mo><mi>t</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>τ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>, </mo><mi>τ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">]</mo></mtd></mtr><mtr><mtd><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mi>τ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>τ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub></mtd></mtr><mtr><mtd><mi>U</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mi>Τ</mi></msup></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="58">其中<i>U</i><sub><i>i</i></sub>是输入控制率, <i>ξ</i><sub><i>i</i></sub>是一个触发中断的布尔函数</p>
                </div>
                <div class="area_img" id="59">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJZ201906064_05900.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="60">t是表示时间的正整数, 而<i>s</i> (·) :[0, <i>T</i>]→ℝ<sup><i>k</i></sup>表示一个来自关节传感器的信号反馈。在发生紧急情况的时候, 这个函数会触发中断, 停止机械臂的运动。</p>
                </div>
                <div class="area_img" id="61">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJZ201906064_061.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 基于MDLg模型的控制系统架构" src="Detail/GetImg?filename=images/JSJZ201906064_061.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 基于MDLg模型的控制系统架构</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJZ201906064_061.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="62">当这一串运动基元被传输到<i>MDLg</i>从端解析器的时候, 就可以构成一个运动序列</p>
                </div>
                <div class="p1">
                    <p id="63" class="code-formula">
                        <mathml id="63"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>⋯</mo><mi>σ</mi><msub><mrow></mrow><mi>n</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>U</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>ξ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>Τ</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">) </mo><mo>⋯</mo><mo stretchy="false"> (</mo><mi>U</mi><msub><mrow></mrow><mi>n</mi></msub><mo>, </mo><mi>ξ</mi><msub><mrow></mrow><mi>n</mi></msub><mo>, </mo><mi>Τ</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="64">解析器将这个运动序列重构以后就可以得到分段系统的状态方程</p>
                </div>
                <div class="p1">
                    <p id="65" class="code-formula">
                        <mathml id="65"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign="left"><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mi>U</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mtext> </mtext><mi>τ</mi><msub><mrow></mrow><mn>0</mn></msub><mo>≤</mo><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mn>1</mn></msub></mtd></mtr><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mi>U</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mspace width="0.25em" /><mi>τ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>≤</mo><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mn>2</mn></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mi>U</mi><msub><mrow></mrow><mi>n</mi></msub><mo>, </mo><mspace width="0.25em" /><mi>τ</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>≤</mo><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mi>n</mi></msub></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>5</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="66">定义3.2 (缩放基元) :缩放基元是一个进行了数乘的运动基元, 它对控制信号进行了放大或缩小, 对执行时间进行了压缩或扩张</p>
                </div>
                <div class="p1">
                    <p id="67" class="code-formula">
                        <mathml id="67"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mo stretchy="false"> (</mo><mi>α</mi><mo>, </mo><mi>β</mi><mo stretchy="false">) </mo><mi>σ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>α</mi><mi>U</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>β</mi><mi>t</mi><mo stretchy="false">) </mo><mo>, </mo><mi>ξ</mi><mo>, </mo><mfrac><mrow><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>β</mi></mfrac><mo stretchy="false">) </mo><mo>, </mo></mtd><mtd><mi>t</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo>, </mo><mi>Τ</mi><mo stretchy="false">]</mo></mtd></mtr><mtr><mtd><mi>s</mi><mi>t</mi></mtd><mtd><mi>β</mi><mo>=</mo><mfrac><mrow><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>Τ</mi></mfrac></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>6</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="68">等式左边就是一个缩放基元 (<i>α</i>, <i>β</i>) <i>σ</i><sub><i>i</i></sub>, (<i>α</i>, <i>β</i>) 被称为缩放系数。</p>
                </div>
                <div class="p1">
                    <p id="69">缩放基元对执行时间不同的运动基元进行时间扩张, 使它们的执行时间一致, 有利于基元的存储和传输。</p>
                </div>
                <div class="p1">
                    <p id="70">定义3.3 (字母表) :字母表用符号<i>Σ</i>表示, 是一个系统全体运动基元的集合</p>
                </div>
                <div class="p1">
                    <p id="71" class="code-formula">
                        <mathml id="71"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>σ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>σ</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>σ</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">}</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="72">其中对∀<i>σ</i><sub><i>i</i></sub>, <i>σ</i><sub><i>j</i></sub>∈<i>Σ</i>都满足<i>σ</i><sub><i>i</i></sub>≠ (<i>α</i>, <i>β</i>) <i>σ</i><sub><i>j</i></sub>, <i>α</i>∈ℝ<sup><i>m</i></sup>, <i>β</i>∈ℝ。</p>
                </div>
                <div class="p1">
                    <p id="73">字母表是系统中有限个运动基元的全集。它的定义表明, 字母表中的每一个运动基元都是独立的, 它不能用缩放操作被字母表中的另一个基元表示。接下来将要定义基元的合并方法, 首先需要引入运动基元的合并运算:</p>
                </div>
                <div class="p1">
                    <p id="74" class="code-formula">
                        <mathml id="74"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>β</mi><mo stretchy="false">) </mo><mi>σ</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">∥</mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mi>β</mi><mo stretchy="false">) </mo><mi>σ</mi><msub><mrow></mrow><mn>2</mn></msub></mtd></mtr><mtr><mtd><mo>=</mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mn>1</mn></msub><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false"> (</mo><mi>β</mi><mi>t</mi><mo stretchy="false">) </mo><mo>+</mo><mi>α</mi><msub><mrow></mrow><mn>2</mn></msub><mi>u</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false"> (</mo><mi>β</mi><mi>t</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>, </mo><mi>min</mi><mrow><mo>{</mo><mrow><mi>ξ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>ξ</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mo>}</mo></mrow></mtd></mtr><mtr><mtd><mi>s</mi><mi>t</mi><mtext> </mtext><mi>Τ</mi><mo>=</mo><mfrac><mrow><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>β</mi></mfrac></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="75">在合并运算的基础上, 我们可以定义合并基元:</p>
                </div>
                <div class="p1">
                    <p id="76">定义3.4 (合并基元) :合并基元是对字母表<i>Σ</i>中的所有运动基元进行缩放与合并操作后得到的新的运动基元</p>
                </div>
                <div class="p1">
                    <p id="77" class="code-formula">
                        <mathml id="77"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi>σ</mi><mo>˜</mo></mover><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>, </mo><mi>β</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mi>σ</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">∥</mo><mo>⋯</mo><mo stretchy="false">∥</mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>, </mo><mi>β</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mi>σ</mi><msub><mrow></mrow><mi>n</mi></msub><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>7</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="78">其中<i>n</i>是字母表<i>Σ</i>中基元的个数。另外用符号<mathml id="79"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi>ρ</mi><mo>˜</mo></mover><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>, </mo><mi>β</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mi>i</mi><mn>2</mn></mrow></msub><mo>, </mo><mi>β</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo>⋯</mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo>, </mo><mi>β</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></math></mathml>表示合并基元中所有缩放系数的组合, 称为合并基元系数。</p>
                </div>
                <div class="p1">
                    <p id="80">MDLg模型对MDL模型最大的改进就是引入了合并基元。在MDL模型中, 仿射系统的每一个分割段都用一个单独的运动基元表示。而在MDLg模型中, 每一个分割段用一个合并基元<mathml id="81"><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>σ</mi><mo>˜</mo></mover></math></mathml><sub><i>i</i></sub>表示, 一串合并基元序列就可以重构原系统的状态。由于合并基元由其系数决定, 不同的系数组合可以产生不同的合并基元, 所以合并基元拓展了运动基元的表达能力, 无需定义太多的基元, 就可以还原初始系统。</p>
                </div>
                <div class="p1">
                    <p id="82">定义3.5 (MDLg字符串) :MDLg字符串是一系列合并基元系数的组合, 用符号MDLg表示</p>
                </div>
                <div class="p1">
                    <p id="83" class="code-formula">
                        <mathml id="83"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Μ</mi><mi>D</mi><mi>L</mi><mi>g</mi><mo>=</mo><mo stretchy="false">{</mo><mover accent="true"><mi>ρ</mi><mo>˜</mo></mover><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mover accent="true"><mi>ρ</mi><mo>˜</mo></mover><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mover accent="true"><mi>ρ</mi><mo>˜</mo></mover><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false">}</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="84">如果将一个MDLg字符串传输到MDLg从端解析器, 解析器就得到了一个合并基元序列<mathml id="85"><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>σ</mi><mo>˜</mo></mover></math></mathml><sub>1</sub><mathml id="86"><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>σ</mi><mo>˜</mo></mover></math></mathml><sub>2</sub>…<mathml id="87"><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>σ</mi><mo>˜</mo></mover></math></mathml><sub><i>m</i></sub>。解析器将这个合并基元序列重构以后, 就可以得到一个满足如下状态方程组的系统</p>
                </div>
                <div class="p1">
                    <p id="88" class="code-formula">
                        <mathml id="88"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mn>1</mn><mn>1</mn></mrow></msub><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>α</mi><msub><mrow></mrow><mrow><mn>1</mn><mi>n</mi></mrow></msub><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo><mo>, </mo><mi>τ</mi><msub><mrow></mrow><mn>0</mn></msub><mo>≤</mo><mi>β</mi><msub><mrow></mrow><mn>1</mn></msub><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mn>1</mn></msub></mtd><mtd></mtd></mtr><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mn>2</mn><mn>1</mn></mrow></msub><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>α</mi><msub><mrow></mrow><mrow><mn>2</mn><mi>n</mi></mrow></msub><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo><mo>, </mo><mi>τ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>≤</mo><mi>β</mi><msub><mrow></mrow><mn>2</mn></msub><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mn>2</mn></msub></mtd><mtd></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd><mtd></mtd></mtr><mtr><mtd><mover accent="true"><mi>x</mi><mo>˙</mo></mover><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mi>G</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>α</mi><msub><mrow></mrow><mrow><mi>m</mi><mn>1</mn></mrow></msub><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>α</mi><msub><mrow></mrow><mrow><mi>m</mi><mi>n</mi></mrow></msub><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo><mo>, </mo><mi>τ</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>≤</mo><mi>β</mi><msub><mrow></mrow><mi>m</mi></msub><mi>t</mi><mo>&lt;</mo><mi>τ</mi><msub><mrow></mrow><mi>m</mi></msub></mtd><mtd></mtd></mtr></mtable></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="89">在完成了MDLg模型的基本定义之后, 就可以运用这个模型构建MDLg轨迹生成算法, 这将在下一节中展开论述。</p>
                </div>
                <h3 id="90" name="90" class="anchor-tag"><b>4 算法实现</b></h3>
                <div class="p1">
                    <p id="91">本节将介绍<i>MDLg</i>算法的具体实现, 图<b>2</b>展示了整个算法的信号流图。<i>MDLg</i>算法包含两个主要部分:参考信号的分解与重构。整个算法流程大致分为四个步骤:第一步是对参考信号的分割, 根据某种规则将参考信号在时间域上分割成不同时间长度的小段, 这称为时域分割;第二步是时间扩张, 本步骤对分割完成但是执行时间不同的分割段进行时间扩张, 把所有分割段的执行时间拉齐;第三步是将已经分段的每一个信号分解映射到合并基元上, 所有的合并基元系数组合在一起, 就构成了<i>MDLg</i>字符串, 这一步称为空间分解;第四步是信号重构, 就是通过<i>MDLg</i>字符串和字母表<i>Σ</i>在机器人关节端的<i>MDLg</i>解析器中重构出参信号的过程。</p>
                </div>
                <div class="area_img" id="92">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJZ201906064_092.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 MDLg算法信号流图" src="Detail/GetImg?filename=images/JSJZ201906064_092.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 MDLg算法信号流图</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJZ201906064_092.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="93" name="93"><b>4.1 时域分割与时间扩张</b></h4>
                <div class="p1">
                    <p id="94">时域分割是对参考信号<b><i>u</i></b><sub><b><i>r</i></b></sub> (<b><i>t</i></b>) 的预处理过程, 把输入信号根据某种规则分割成许多不同时间长度的小段。这一过程有两个输入, 分别是参考信号<b><i>u</i></b><sub><b><i>r</i></b></sub> (<b><i>t</i></b>) 和初始字母表<i>Σ</i><sub><b><i>init</i></b></sub>。给定的参考输入信号是一个在时间域上连续的函数。然而, 事实上计算机并不能处理连续信号, 要以采样时间<i>Δ</i><b><i>t</i></b>对参考信号进行离散化处理, 可以得到参考信号的离散形式为向量<b><i>u</i></b><sub><b><i>r</i></b></sub> (<b><i>k</i></b>) ∈ℝ<sup><b>1×<i>d</i></b></sup>。接下来需要在采样信号中找到变化率比较大的点, 以完成时域分割。首先计算输入信号的二阶导数</p>
                </div>
                <div class="p1">
                    <p id="95" class="code-formula">
                        <mathml id="95"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mover accent="true"><mi>u</mi><mo>˙</mo></mover><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>u</mi><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mo>-</mo><mi>u</mi><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo></mrow><mrow><mi>Δ</mi><mi>t</mi></mrow></mfrac><mo>, </mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo>, </mo><mi>d</mi><mo>-</mo><mn>1</mn><mo stretchy="false">]</mo></mtd></mtr><mtr><mtd><mover accent="true"><mi>u</mi><mo>¨</mo></mover><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mover accent="true"><mi>u</mi><mo>˙</mo></mover><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mo>-</mo><mover accent="true"><mi>u</mi><mo>˙</mo></mover><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo></mrow><mrow><mi>Δ</mi><mi>t</mi></mrow></mfrac><mo>, </mo><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo>, </mo><mi>d</mi><mo>-</mo><mn>2</mn><mo stretchy="false">]</mo></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>8</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="96">根据二阶导数值就可以找到用于分段的过渡点。所谓过渡点就是满足下面条件的点:</p>
                </div>
                <div class="p1">
                    <p id="97" class="code-formula">
                        <mathml id="97"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mo stretchy="false">∥</mo><mover accent="true"><mi>u</mi><mo>¨</mo></mover><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo stretchy="false">∥</mo><mo>&gt;</mo><mi>ε</mi><mo>, </mo><mspace width="0.25em" /><mo stretchy="false">∥</mo><mover accent="true"><mi>u</mi><mo>¨</mo></mover><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo><mo stretchy="false">∥</mo><mo>&lt;</mo><mi>ε</mi></mtd></mtr><mtr><mtd><mi>o</mi><mi>r</mi><mo stretchy="false">∥</mo><mover accent="true"><mi>u</mi><mo>¨</mo></mover><msub><mrow></mrow><mi>r</mi></msub><mo stretchy="false"> (</mo><mi>k</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo stretchy="false">∥</mo><mo>&lt;</mo><mi>ε</mi><mo>, </mo><mo stretchy="false">∥</mo><mover accent="true"><mi>u</mi><mo>¨</mo></mover><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo><mo stretchy="false">∥</mo><mo>&gt;</mo><mi>ε</mi></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>9</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="98">其中<i>ε</i>是用户给定的控制变量。这一过程将会输出一个矩阵<b><i>u</i></b><sub><b><i>i</i></b></sub>∈ℝ<sup><b><i>n</i>×<i>m</i></b></sup>, 它的行数<b><i>n</i></b>表示分割出的总段数, 列数<b><i>m</i></b>是采样点最多的那一个分割段的采样点个数, 其它不足<b><i>m</i></b>个采样点的分割段则用<b>0</b>填充。</p>
                </div>
                <div class="p1">
                    <p id="99">完成分割过程之后, 就要对分割段进行时间尺度扩张, 使每一个分割段的执行时间一致。因此, 这一过程有两个输入, 分别是前面经过分割得到参考信号矩阵<b><i>u</i></b><sub><b><i>i</i></b></sub>∈ℝ<sup><b><i>n</i>×<i>m</i></b></sup>和初始字母表<i>Σ</i><sub><b><i>init</i></b></sub>∈ℝ<sup><b><i>j</i>×<i>k</i></b></sup>。输出则是完成了时间扩张的分割段矩阵<b><i>u</i></b><sub><b><i>s</i></b></sub>∈ℝ<sup><b><i>n</i>×<i>max</i> (<i>s</i>, <i>k</i></b>) </sup>和字母表矩阵<i>Σ</i><sub><b><i>s</i></b></sub>∈ℝ<sup><b><i>j</i>×<i>max</i> (<i>s</i>, <i>k</i></b>) </sup>, 以及扩张尺度系数向量<i>β</i>∈ℝ<sup><b><i>n</i></b></sup>。扩张以后每一段的时间尺度都统一为<b><i>T</i></b><sub><b><i>s</i></b></sub>=<i>Δ</i><b><i>t</i>× (<i>max</i> (<i>m</i>, <i>k</i>) -1</b>) 。</p>
                </div>
                <div class="p1">
                    <p id="100">首先用下面的方程计算时间扩张系数</p>
                </div>
                <div class="area_img" id="101">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJZ201906064_10100.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="102">其中</p>
                </div>
                <div class="p1">
                    <p id="103" class="code-formula">
                        <mathml id="103"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>s</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo>⋅</mo><mi>Δ</mi><mi>t</mi></mtd></mtr><mtr><mtd><mi>Τ</mi><msub><mrow></mrow><mi>s</mi></msub><mo>=</mo><mo stretchy="false"> (</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false"> (</mo><mi>m</mi><mo>.</mo><mi>k</mi><mo stretchy="false">) </mo><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo>⋅</mo><mi>Δ</mi><mi>t</mi></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="104">可以得到</p>
                </div>
                <div class="p1">
                    <p id="105" class="code-formula">
                        <mathml id="105"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mi>β</mi><msub><mrow></mrow><mrow><mi>s</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msub><mo>=</mo><mfrac><mrow><mo stretchy="false"> (</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false"> (</mo><mi>m</mi><mo>, </mo><mi>k</mi><mo stretchy="false">) </mo><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo>⋅</mo><mi>Δ</mi><mi>t</mi></mrow><mrow><mo stretchy="false"> (</mo><mi>s</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo>⋅</mo><mi>Δ</mi><mo>⋅</mo><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false"> (</mo><mi>m</mi><mo>, </mo><mi>k</mi><mo stretchy="false">) </mo><mo>-</mo><mn>1</mn></mrow><mrow><mi>s</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="106">当计算出所有的时间扩张系数以后, 把它们总结成一个向量</p>
                </div>
                <div class="p1">
                    <p id="107" class="code-formula">
                        <mathml id="107"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>β</mi><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mi>β</mi><msub><mrow></mrow><mn>1</mn></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>β</mi><msub><mrow></mrow><mi>n</mi></msub></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mo>∈</mo><mi>ℝ</mi><msup><mrow></mrow><mi>n</mi></msup><mspace width="0.25em" /><mi>s</mi><mi>t</mi><mspace width="0.25em" /><mi>β</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>β</mi><msub><mrow></mrow><mrow><mi>s</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msub></mrow></mfrac><mo>, </mo><mi>i</mi><mo>∈</mo><mrow><mo>[</mo><mrow><mn>1</mn><mo>, </mo><mi>n</mi></mrow><mo>]</mo></mrow><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="108">输出的这个向量<i>β</i>用于对扩张后的向量<b><i>u</i></b><sub><b><i>s</i></b></sub>进行压缩, 得到分割段的原始执行时间。</p>
                </div>
                <h4 class="anchor-tag" id="109" name="109"><b>4.2 空间分解</b></h4>
                <div class="p1">
                    <p id="110">时域分割和扩张完成之后, 就要对扩张后的分割段进行空间分解, 把它们映射到合并基元上。空间分解过程的输入信号为扩张后的分段参考信号矩阵<i>u</i><sub><i>s</i></sub>∈ℝ<sup><i>j</i>×<i>max</i> (<i>m</i>.<i>k</i>) </sup>和字母表<i>Σ</i><sub><i>s</i></sub>∈ℝ<sup><i>j</i>×<i>max</i> (<i>m</i>, <i>k</i>) </sup>。输出则是新的字母表<i>Σ</i>和表示运动序列的<i>MDLg</i>字符串。</p>
                </div>
                <div class="p1">
                    <p id="111">根据泛函分析理论, 参考信号<i>u</i><sub><i>r</i></sub> (<i>t</i>) 是<i>L</i><sup><b>2</b></sup>空间中的函数。因此可以对这个函数进行正交分解, 正交分解的基就是已经得到的字母表<i>Σ</i><sub><i>s</i></sub>。根据希尔伯特空间正交分解理论, 对每一个分割段<i>u</i><sub><i>s</i></sub> (<i>t</i>) 进行正交分解后, 这个函数就可以表示成如下形式:</p>
                </div>
                <div class="p1">
                    <p id="112" class="code-formula">
                        <mathml id="112"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>u</mi><msub><mrow></mrow><mi>s</mi></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>=</mo><mi>α</mi><msub><mrow></mrow><mn>1</mn></msub><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>α</mi><msub><mrow></mrow><mi>n</mi></msub><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="113">即参考信号<i>u</i><sub><i>s</i></sub>可以表示成一些基函数的线性组合, 这些基函数就是运动基元<i>σ</i><sub><i>i</i></sub>= (<i>u</i><sub><i>i</i></sub>, <i>ξ</i><sub><i>i</i></sub>, <i>T</i><sub><i>i</i></sub>) 。下一步就是计算出线性组合的参数<i>α</i>, 根据希尔伯特空间函数内积的性质, 可以得到</p>
                </div>
                <div class="p1">
                    <p id="114">&lt;<i>u</i><sub><i>s</i></sub>, <i>u</i><sub><i>i</i></sub>&gt;=&lt;<i>α</i><sub><b>1</b></sub><i>u</i><sub><b>1</b></sub>+<i>α</i><sub><b>2</b></sub><i>u</i><sub><b>2</b></sub>+…+<i>α</i><sub><i>n</i></sub><i>u</i><sub><i>n</i></sub>, <i>u</i><sub><i>i</i></sub>&gt;</p>
                </div>
                <div class="p1">
                    <p id="115">=&lt;<i>α</i><sub><b>1</b></sub><i>u</i><sub><b>1</b></sub>, <i>u</i><sub><i>i</i></sub>&gt;+…+&lt;<i>α</i><sub><i>n</i></sub><i>u</i><sub><i>n</i></sub>, <i>u</i><sub><i>i</i></sub>&gt;</p>
                </div>
                <div class="p1">
                    <p id="116">=&lt;<i>α</i><sub><b>1</b></sub><i>u</i><sub><b>1</b></sub>, <i>u</i><sub><i>i</i></sub>&gt;+…+&lt;<i>α</i><sub><i>n</i></sub><i>u</i><sub><i>n</i></sub>, <i>u</i><sub><i>i</i></sub>&gt;</p>
                </div>
                <div class="p1">
                    <p id="117">从<i>u</i><sub><b>1</b></sub>到<i>u</i><sub><i>n</i></sub>排列成矩阵, 可以得到下面的矩阵方程</p>
                </div>
                <div class="p1">
                    <p id="118" class="code-formula">
                        <mathml id="118"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>s</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>&gt;</mo></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>s</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>&gt;</mo></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>&gt;</mo></mtd><mtd><mo>⋯</mo></mtd><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>&gt;</mo></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd><mtd><mo>⋱</mo></mtd><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>&gt;</mo></mtd><mtd><mo>⋯</mo></mtd><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>&gt;</mo></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mspace width="0.25em" /><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mi>α</mi><msub><mrow></mrow><mn>1</mn></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>α</mi><msub><mrow></mrow><mi>n</mi></msub></mtd></mtr></mtable></mrow><mo>]</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="119">用简化符号表示上面的矩阵方程, 令</p>
                </div>
                <div class="p1">
                    <p id="120" class="code-formula">
                        <mathml id="120"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mi>v</mi><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>s</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>&gt;</mo></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>s</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>&gt;</mo></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mo>, </mo><mtext> </mtext><mi>α</mi><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mi>α</mi><msub><mrow></mrow><mn>1</mn></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>α</mi><msub><mrow></mrow><mi>n</mi></msub></mtd></mtr></mtable></mrow><mo>]</mo></mrow></mtd></mtr><mtr><mtd columnalign="left"><mi>G</mi><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>&gt;</mo></mtd><mtd><mo>⋯</mo></mtd><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>&gt;</mo></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd><mtd><mo>⋱</mo></mtd><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>&gt;</mo></mtd><mtd><mo>⋯</mo></mtd><mtd><mo>&lt;</mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub><mo>&gt;</mo></mtd></mtr></mtable></mrow><mo>]</mo></mrow></mtd></mtr></mtable><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="121">则方程可以表示为<i>v</i>=<i>Gα</i>, 因此参数向量可以表示为</p>
                </div>
                <div class="p1">
                    <p id="122" class="code-formula">
                        <mathml id="122"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>α</mi><mo>=</mo><mi>G</mi><msup><mrow></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup><mi>v</mi><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="123">如此操作把所有的分割段都进行分解, 就得到系数矩阵<i>A</i></p>
                </div>
                <div class="p1">
                    <p id="124" class="code-formula">
                        <mathml id="124"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mi>α</mi><msubsup><mrow></mrow><mn>1</mn><mi>Τ</mi></msubsup></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>α</mi><msubsup><mrow></mrow><mi>n</mi><mi>Τ</mi></msubsup></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="125">但是, 这里存在两个问题。一是如何选择初始的运动基元;二是初始的运动基元可能不足, 无法满足正交分解的精度要求。对初始运动基元的选择基于轨迹插补理论, 可以选择一些典型的样条曲线作为运动基元, 本文使用了二次、三次、五次、正弦曲线以及傅立叶级数组合曲线作为初始运动基元。第二个问题则需要构建一种扩展运动基元的方法, 使对参考信号<i>u</i><sub><i>r</i></sub>的分解满足给定的精度要求。</p>
                </div>
                <div class="p1">
                    <p id="126">如果参考信号<i>u</i><sub><i>r</i></sub>经过初始运动基元分解后, 误差不满足给定要求, 那么可以令</p>
                </div>
                <div class="p1">
                    <p id="127" class="code-formula">
                        <mathml id="127"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>u</mi><msup><mrow></mrow><mo>*</mo></msup><mo>=</mo><mi>α</mi><msub><mrow></mrow><mn>1</mn></msub><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mi>α</mi><msub><mrow></mrow><mn>2</mn></msub><mi>u</mi><msub><mrow></mrow><mn>2</mn></msub><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>α</mi><msub><mrow></mrow><mi>n</mi></msub><mi>u</mi><msub><mrow></mrow><mi>n</mi></msub></mtd></mtr><mtr><mtd><mi>s</mi><mi>t</mi><mtext> </mtext><mi>u</mi><msub><mrow></mrow><mi>i</mi></msub><mo>∈</mo><mi>Σ</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msub><mo>, </mo><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo>, </mo><mi>n</mi><mo stretchy="false">]</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="128">则有</p>
                </div>
                <div class="p1">
                    <p id="129" class="code-formula">
                        <mathml id="129"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>u</mi><msup><mrow></mrow><mo>⊥</mo></msup><mo>=</mo><mi>u</mi><msub><mrow></mrow><mi>r</mi></msub><mo>-</mo><mi>u</mi><msup><mrow></mrow><mo>*</mo></msup><mtext> </mtext><mi>s</mi><mi>t</mi><mtext> </mtext><mi>u</mi><msup><mrow></mrow><mo>⊥</mo></msup><mo>∉</mo><mi>Σ</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow></msub><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>6</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="130">这样就得到了新的运动基元<i>σ</i><sub><i>n</i>+<b>1</b></sub>, 其中的控制率为<i>u</i><sub><i>n</i>+<b>1</b></sub>=<i>u</i><sub><i>r</i></sub>-<i>u</i><sup>*</sup>=<i>u</i><sup>⊥</sup>。扩展后的新字母表是<i>Σ</i>=<i>Σ</i><sub><i>init</i></sub>♁<i>σ</i><sub><i>n</i>+<b>1</b></sub>。这一过程将会被反复执行, 直到分解满足给定误差要求为止。</p>
                </div>
                <div class="p1">
                    <p id="131">连续函数上的内积一般由如下公式定义:</p>
                </div>
                <div class="p1">
                    <p id="132" class="code-formula">
                        <mathml id="132"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&lt;</mo><mi>u</mi><mo>, </mo><mi>v</mi><mo>&gt;</mo><mo>=</mo><mstyle displaystyle="true"><mrow><munderover><mo>∫</mo><mn>0</mn><mi>Τ</mi></munderover><mi>u</mi></mrow></mstyle><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mi>v</mi><mo stretchy="false"> (</mo><mi>t</mi><mo stretchy="false">) </mo><mi>d</mi><mi>t</mi><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>7</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="133">但是在实践中, 处理的是离散点的内积, 需要使用数值内积算法:</p>
                </div>
                <div class="p1">
                    <p id="134" class="code-formula">
                        <mathml id="134"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd><mi>h</mi><mo stretchy="false"> (</mo><mi>s</mi><mo stretchy="false">) </mo><mo>=</mo><mi>u</mi><mo stretchy="false"> (</mo><mi>s</mi><mo stretchy="false">) </mo><mi>v</mi><mo stretchy="false"> (</mo><mi>s</mi><mo stretchy="false">) </mo><mo>, </mo><mspace width="0.25em" /><mi>s</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo>, </mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false"> (</mo><mi>m</mi><mo>, </mo><mi>k</mi><mo stretchy="false">) </mo><mo stretchy="false">]</mo></mtd></mtr><mtr><mtd><mi>u</mi><mo>, </mo><mi>v</mi><mo>≈</mo><mfrac><mrow><mi>d</mi><mi>t</mi></mrow><mn>2</mn></mfrac><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false"> (</mo><mi>m</mi><mo>, </mo><mi>k</mi><mo stretchy="false">) </mo><mo>-</mo><mn>1</mn></mrow></munderover><mo stretchy="false"> (</mo></mstyle><mi>h</mi><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mo>+</mo><mi>h</mi><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mtd></mtr></mtable></mrow></mrow><mspace width="0.25em" /></mrow></math></mathml>
                    </p>
                </div>
                <h4 class="anchor-tag" id="135" name="135"><b>4.3 信号重构</b></h4>
                <div class="p1">
                    <p id="136">本过程将在MDLg从端解析器中重构参考信号, 完成对机器人关节的控制。通过前面的几个过程, 可以获得扩展后的字母表Σ以及包含了系数矩阵A和扩张系数向量β的MDLg字符串。字母表被预先存储在MDLg从端关节中, 我们只需要把MDLg字符串实时传输到机器人关节控制器的MDLg解析器中, 就可以完成对机器人轨迹的控制。</p>
                </div>
                <div class="p1">
                    <p id="137">信号重构分为两个步骤。首先是重构参考信号, 在这个过程中, 可以得到每一个分割段。但此时每个分割段的执行时间并不是原始时间。因此, 第二步就是应用扩张系数β使所有分割段回归原始的执行时间。然后把所有分割段拼接在一起就得到了初始的参考信号。</p>
                </div>
                <div class="p1">
                    <p id="138">所有的合并基元被顺序执行, 关节就可以按照参考轨迹运动。同时, 每一个运动基元都可以接收到来自关节传感器的反馈信息, 只要出现异常情况, 就会控制关节和机器人停止运动, 保证系统安全。</p>
                </div>
                <h3 id="139" name="139" class="anchor-tag"><b>5 仿真研究</b></h3>
                <div class="p1">
                    <p id="140">为了验证MDLg模型的效果, 用V-REP和Matlab进行了联合仿真实验。V-REP (Virtual Robot Experimentation Platform) 是Coppelia Robotics公司开发的一款跨平台机器人仿真软件, 它是一个集成开发环境, 采用分布式控制架构, 可以进行机器人模型创建、动力学仿真、控制器开发, 支持C/C++、Python、Java、Lua和Matlab等编程语言。使用V-REP平台可以快速实现机器人控制算法的开发与验证。</p>
                </div>
                <div class="p1">
                    <p id="141">本文仿真使用V-REP <b>3.4.0</b>和Matlab <b>2016</b>b。机器人模型在V-REP中建立, 利用V-REP自带的物理引擎进行实物仿真。MDLg轨迹生成算法在Matlab中开发实现, 通过V-REP提供的Remote API接口与Matlab连接, 将运动数据发送给V-REP中的机器人模型, 控制机器人运动。</p>
                </div>
                <div class="p1">
                    <p id="142">本次选择ABB的IRB<b>4600</b>机器人模型进行仿真。IRB<b>4600</b>是一款传统的<b>6</b>轴机械臂, 我们让这个机械臂的末端走一个圆形轨迹以验证MDLg算法的有效性。</p>
                </div>
                <div class="area_img" id="143">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJZ201906064_143.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 IRB4600机械臂模型" src="Detail/GetImg?filename=images/JSJZ201906064_143.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 IRB4600机械臂模型</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJZ201906064_143.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="144">本次仿真开启了V-REP的实时仿真模式 (real-time mode) , 应用MDLg轨迹生成算法, 机械臂实现了末端的圆形轨迹运动。完整的仿真代码和视频录像已经被上传到网络空间, 读者可以下载参考<citation id="165" type="note"><link href="163" rel="footnote" /><sup> (1) </sup></citation>。</p>
                </div>
                <div class="area_img" id="145">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJZ201906064_145.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 机械臂末端的圆形轨迹" src="Detail/GetImg?filename=images/JSJZ201906064_145.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 机械臂末端的圆形轨迹</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJZ201906064_145.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="146">使用MDLg算法, 主端控制器只需要向关节控制器实时传输MDLg字符串。这种构型的六轴机器人, 末端画出如图<b>4</b>所示的圆形轨迹, 需要转动<b>1、2、3、5</b>轴, <b>4</b>轴不需要运动也不考虑<b>6</b>轴的转动。通过下面表格的对比可以看到, 末端画圆的情况下, MDLg算法需要实时传输的数据量不到<b>100</b>个, 与传统方式相比数量大幅减少。</p>
                </div>
                <div class="area_img" id="147">
                    <p class="img_tit"><b>表1 MDLg与传统方法的数据传输量</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="147" border="1"><tr><td><br /></td><td colspan="2">方法</td></tr><tr><td><br /></td><td>MDLg</td><td>传统方法</td></tr><tr><td><br />数据传输量</td><td>54</td><td>519</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h3 id="148" name="148" class="anchor-tag"><b>6 结论</b></h3>
                <div class="p1">
                    <p id="149">运动描述语言 (MDL) 是一种分布式的控制体系结构, 适用于连续和离散信号相混杂的系统的控制, 机器人控制系统恰好具有这种特征。使用本文提出的MDLg模型和轨迹生成算法, 可以在不损失或者损失极少轨迹精度的条件下, 大幅减少机器人运动过程中的实时数据传输量, 降低总线负载, 从而实现机器人控制系统的优化和简化。</p>
                </div>
                <div class="p1">
                    <p id="150">但是必须指出, 本文只是基于运动描述语言的机械臂控制系统的初步理论, 目前只进行了算法的仿真验证, 要想真正实现这种优化的控制系统, 还需要在真实的机械臂上进行实验研究。这就要进一步考虑机器人的动力学模型、关节控制器设计以及总线时钟同步方法等内容。因此, 下一步任务就是设计一款具有MDLg算法解析能力的机器人关节控制器, 进行多关节联动实验。</p>
                </div>
                <div class="area_img" id="162">
                                <img alt="" src="Detail/GetImg?filename=images/JSJZ201906064_16200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="166">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Formal languages for motion description and map making,&amp;quot;">

                                <b>[1]</b> R Brockett.Formal languages for motion description and map making[J].Robotics, 1990, 41:181-191.
                            </a>
                        </p>
                        <p id="168">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On the computer control of movement">

                                <b>[2]</b> R W Brockett.On the computer control of movement[C].Robotics and Automation, 1988.Proceedings, 1988 IEEE International Conference on, 1988:534-540.
                            </a>
                        </p>
                        <p id="170">
                            <a id="bibliography_3" >
                                    <b>[3]</b>
                                 Brockett R W.Hybrid models for motion control systems[M].Springer, 1993.
                            </a>
                        </p>
                        <p id="172">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A motion description language and a hybrid architecture for motion planning with nonholonomic robots">

                                <b>[4]</b> V Manikonda, P S Krishnaprasad, J Hendler.A motion description language and a hybrid architecture for motion planning with nonholonomic robots[J].Proceedings of 1995 Ieee International Conference on Robotics and Automation, Vols 1-3, 1995 2021-2028.
                            </a>
                        </p>
                        <p id="174">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Choreographing Dynamical Systems">

                                <b>[5]</b> H Li.Choreographing Dynamical Systems[D].Harvard University, 2004.
                            </a>
                        </p>
                        <p id="176">
                            <a id="bibliography_6" >
                                    <b>[6]</b>
                                 化建宁.基于网络的机器人遥操作系统:运动描述语言方法[D].中国科学院沈阳自动化研究所, 2007.
                            </a>
                        </p>
                        <p id="178">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JQRR201305015&amp;v=Mjk2MDVSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1Wm5GeTdsV3J6Qkx6elpmTEc0SDlMTXFvOUVZWVFLREg4NHY=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b> 化建宁, 等.基于MDL的机器人网络遥操作系统控制方法[J].机器人, 2013, 35 (5) :615-622.
                            </a>
                        </p>
                        <p id="180">
                            <a id="bibliography_8" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JQRR200603014&amp;v=MjU0OTJGeTdsV3J6Qkx6elpmTEc0SHRmTXJJOUVZSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1Wm4=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[8]</b> 化建宁, 等.基于运动描述语言的轮式移动机器人控制[J].机器人, 2006, 28 (3) :316-320.
                            </a>
                        </p>
                        <p id="182">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Motion description languages:from specification to execution">

                                <b>[9]</b> P J Martin.Motion description languages:from specification to execution[D].Georgia Institute of Technology, 2010.
                            </a>
                        </p>
                        <p id="184">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Generation and use of a discrete robotic controls alphabet for high-level tasks">

                                <b>[10]</b> Gargas Iii E F.Generation and use of a discrete robotic controls alphabet for high-level tasks[D].Georgia Institute of Technology, 2012.
                            </a>
                        </p>
                        <p id="186">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JQRR201604015&amp;v=MTk4NzBmTXE0OUVZWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1Wm5GeTdsV3J6Qkx6elpmTEc0SDk=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b> 刘维惠, 陈殿生, 张立志.人机协作下的机械臂轨迹生成与修正方法[J].机器人, 2016, 38 (4) :504-512.
                            </a>
                        </p>
                        <p id="188">
                            <a id="bibliography_12" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=0007111186818999&amp;v=MzA4OTVmWmVadkZ5bnNVN25JS1YwZFZWMjdHYks1SDlERXFZZEViT0lHQlJNOHp4VVNtRGQ5U0g3bjN4RTlmYnZuS3Jp&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[12]</b> Craig J J, 贠超.机器人学导论[M].北京:机械工业出版社, 2006.
                            </a>
                        </p>
                        <p id="190">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Trajectory planning for automatic machines and robots">

                                <b>[13]</b> Biagiotti L, Melchiorri C.Trajectory Planning for Automatic Machines and Robots[M].Springer Science &amp; Business Media, 2008.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
            <div class="reference anchor-tag" id="a_footnote">
 <h3>注释</h3>
                    <p>
                        <span id="163" href="javascript:void(0)">
                            <b>1</b> 仿真代码及录像https://github.com/liuzhaoming5954/MDL_paper
                        </span>
                    </p>
            </div>
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJZ201906064" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJZ201906064&amp;v=MDQwNTVxcUJ0R0ZyQ1VSN3FmWnVabkZ5N2xXcnpCTHo3QmRMRzRIOWpNcVk5RFlJUUtESDg0dlI0VDZqNTRPM3o=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDM1V09TVFE2TFgybGV6bTlmY29MQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=842_VlRz_g1CMCLi-M0twVw-4EOFG_noWyi_OsMnrAg1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
