<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637135754014190000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJYRJ201904033%26RESULT%3d1%26SIGN%3dRnIjGzkV9M1HU4ddWX7B8m0V2ac%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201904033&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201904033&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201904033&amp;v=MDQ5OTZaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeXptVWJ6TEx6VFpaTEc0SDlqTXE0OUc=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#43" data-title="&lt;b&gt;0 引 言&lt;/b&gt; "><b>0 引 言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#48" data-title="&lt;b&gt;1 系统模型&lt;/b&gt; "><b>1 系统模型</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#49" data-title="&lt;b&gt;1.1 有向无环图 (DAG) 任务&lt;/b&gt;"><b>1.1 有向无环图 (DAG) 任务</b></a></li>
                                                <li><a href="#54" data-title="&lt;b&gt;1.2 任务分解&lt;/b&gt;"><b>1.2 任务分解</b></a></li>
                                                <li><a href="#68" data-title="&lt;b&gt;1.3 CPU平台与调度算法&lt;/b&gt;"><b>1.3 CPU平台与调度算法</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#70" data-title="&lt;b&gt;2 可调度性分析&lt;/b&gt; "><b>2 可调度性分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#72" data-title="&lt;b&gt;2.1 基于干扰的可调度性分析&lt;/b&gt;"><b>2.1 基于干扰的可调度性分析</b></a></li>
                                                <li><a href="#89" data-title="&lt;b&gt;2.2 基于工作负载的可调度性分析&lt;/b&gt;"><b>2.2 基于工作负载的可调度性分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#144" data-title="&lt;b&gt;3 线程级最优优先级分配算法&lt;/b&gt; "><b>3 线程级最优优先级分配算法</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#181" data-title="&lt;b&gt;4 动态截止期的线程级调度算法&lt;/b&gt; "><b>4 动态截止期的线程级调度算法</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#182" data-title="&lt;b&gt;4.1 算法设计&lt;/b&gt;"><b>4.1 算法设计</b></a></li>
                                                <li><a href="#235" data-title="&lt;b&gt;4.2 计算复杂度分析&lt;/b&gt;"><b>4.2 计算复杂度分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#239" data-title="&lt;b&gt;5 仿真实验与结果分析&lt;/b&gt; "><b>5 仿真实验与结果分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#240" data-title="&lt;b&gt;5.1 仿真环境&lt;/b&gt;"><b>5.1 仿真环境</b></a></li>
                                                <li><a href="#268" data-title="&lt;b&gt;5.2 实验结果与分析&lt;/b&gt;"><b>5.2 实验结果与分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#273" data-title="&lt;b&gt;6 结 语&lt;/b&gt; "><b>6 结 语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#53" data-title="图1 任务示意图">图1 任务示意图</a></li>
                                                <li><a href="#53" data-title="图1 任务示意图">图1 任务示意图</a></li>
                                                <li><a href="#98" data-title="图2 &lt;i&gt;τ&lt;/i&gt;&lt;sub&gt;&lt;i&gt;i&lt;/i&gt;&lt;/sub&gt;中所有线程的最大工作负载">图2 <i>τ</i><sub><i>i</i></sub>中所有线程的最大工作负载</a></li>
                                                <li><a href="#244" data-title="图3 不同&lt;i&gt;U&lt;/i&gt;&lt;sub&gt;sys&lt;/sub&gt;的调度性能变化情况">图3 不同<i>U</i><sub>sys</sub>的调度性能变化情况</a></li>
                                                <li><a href="#245" data-title="图4 不同任务内并行度的调度性能变化情况">图4 不同任务内并行度的调度性能变化情况</a></li>
                                                <li><a href="#246" data-title="图5 对&lt;i&gt;τ&lt;/i&gt;中节点总数量的调度性能变化情况">图5 对<i>τ</i>中节点总数量的调度性能变化情况</a></li>
                                                <li><a href="#247" data-title="图6 本调度算法的计算时间与任务内节点总数量的关系">图6 本调度算法的计算时间与任务内节点总数量的关系</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="294">


                                    <a id="bibliography_1" title=" 姜浩, 杜琦, 郭敏, 等. 面向ARMv8 64位多核处理器的QGEMM设计与实现[J]. 计算机学报, 2017, 40 (9) :2018-2029." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201709004&amp;v=MTcwODU3cWZadVp0Rnl6bVViekxMejdCZHJHNEg5Yk1wbzlGWUlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         姜浩, 杜琦, 郭敏, 等. 面向ARMv8 64位多核处理器的QGEMM设计与实现[J]. 计算机学报, 2017, 40 (9) :2018-2029.
                                    </a>
                                </li>
                                <li id="296">


                                    <a id="bibliography_2" title=" 焦文喆, 翟正军, 王国庆. 时间触发AFDX调度设计及实时性分析[J]. 计算机工程, 2016, 42 (7) :42-48." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201607008&amp;v=Mjk3NjNCYmJHNEg5Zk1xSTlGYklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnl6bVViekxMejc=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         焦文喆, 翟正军, 王国庆. 时间触发AFDX调度设计及实时性分析[J]. 计算机工程, 2016, 42 (7) :42-48.
                                    </a>
                                </li>
                                <li id="298">


                                    <a id="bibliography_3" title=" 徐俊, 汤庸, 刘道余. 基于混合差分粒子群算法的MapReduce任务调度算法研究[J]. 小型微型计算机系统, 2016, 37 (7) :1479-1481." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXWX201607022&amp;v=MzA0NzlMUFRYY2RyRzRIOWZNcUk5SFpvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5em1VYno=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         徐俊, 汤庸, 刘道余. 基于混合差分粒子群算法的MapReduce任务调度算法研究[J]. 小型微型计算机系统, 2016, 37 (7) :1479-1481.
                                    </a>
                                </li>
                                <li id="300">


                                    <a id="bibliography_4" title=" 杨辉华, 张晓凤, 谢谱模, 等. 基于布谷鸟搜索的多处理器任务调度算法[J].计算机科学, 2015, 42 (1) :86-89." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201501021&amp;v=MjcwNzJybzlIWllRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnl6bVViekxMejdCYjdHNEg5VE0=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                         杨辉华, 张晓凤, 谢谱模, 等. 基于布谷鸟搜索的多处理器任务调度算法[J].计算机科学, 2015, 42 (1) :86-89.
                                    </a>
                                </li>
                                <li id="302">


                                    <a id="bibliography_5" title=" Melani A, Bertogna M, Bonifaci V, et al. Response-Time Analysis of Conditional DAG Tasks in Multiprocessor Systems[J]. Molecular Immunology, 2015, 25 (4) :329-335." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Response-Time Analysis of Conditional DAG Tasks in Multiprocessor Systems">
                                        <b>[5]</b>
                                         Melani A, Bertogna M, Bonifaci V, et al. Response-Time Analysis of Conditional DAG Tasks in Multiprocessor Systems[J]. Molecular Immunology, 2015, 25 (4) :329-335.
                                    </a>
                                </li>
                                <li id="304">


                                    <a id="bibliography_6" title=" 梁浩, 晏立, 沈项军. 全局固定优先级实时调度算法分析[J]. 计算机工程, 2017, 43 (12) :65-68." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201712012&amp;v=MDczOTFOclk5RVpvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5em1VYnpMTHo3QmJiRzRIOWI=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         梁浩, 晏立, 沈项军. 全局固定优先级实时调度算法分析[J]. 计算机工程, 2017, 43 (12) :65-68.
                                    </a>
                                </li>
                                <li id="306">


                                    <a id="bibliography_7" title=" Guan N, Han M, Gu C, et al. Bounding Carry-in Interference to Improve Fixed-Priority Global Multiprocessor Scheduling Analysis[C]//IEEE International Conference on Embedded and Real-Time Computing Systems and Applications. IEEE, 2015:11-20." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Bounding Carry-in Interference to Improve Fixed-Priority Global Multiprocessor Scheduling Analysis">
                                        <b>[7]</b>
                                         Guan N, Han M, Gu C, et al. Bounding Carry-in Interference to Improve Fixed-Priority Global Multiprocessor Scheduling Analysis[C]//IEEE International Conference on Embedded and Real-Time Computing Systems and Applications. IEEE, 2015:11-20.
                                    </a>
                                </li>
                                <li id="308">


                                    <a id="bibliography_8" title=" Qi Wang, Parmer, G. FJOS: Practical, predictable, and efficient system support for fork/join parallelism[C]//2014 IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS) .IEEE Computer Society, 2014:25-36." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=FJOS: Practical predictable and efficient system support for fork/join parallelism">
                                        <b>[8]</b>
                                         Qi Wang, Parmer, G. FJOS: Practical, predictable, and efficient system support for fork/join parallelism[C]//2014 IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS) .IEEE Computer Society, 2014:25-36.
                                    </a>
                                </li>
                                <li id="310">


                                    <a id="bibliography_9" title=" Li J, Luo Z, Ferry D, et al. Global EDF scheduling for parallel real-time tasks[J]. Real-Time Systems, 2015, 51 (4) :395-439." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Global EDF scheduling for parallel real-time tasks">
                                        <b>[9]</b>
                                         Li J, Luo Z, Ferry D, et al. Global EDF scheduling for parallel real-time tasks[J]. Real-Time Systems, 2015, 51 (4) :395-439.
                                    </a>
                                </li>
                                <li id="312">


                                    <a id="bibliography_10" title=" Axer P, Quinton S, Neukirchner M, et al. Response-Time Analysis of Parallel Fork-Join Workloads with Real-Time Constraints[C]//Euromicro Conference on Real-Time Systems. IEEE Computer Society, 2013:215-224." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Response-time analysis of parallel fork-join w orkloads w ith real-time constraints">
                                        <b>[10]</b>
                                         Axer P, Quinton S, Neukirchner M, et al. Response-Time Analysis of Parallel Fork-Join Workloads with Real-Time Constraints[C]//Euromicro Conference on Real-Time Systems. IEEE Computer Society, 2013:215-224.
                                    </a>
                                </li>
                                <li id="314">


                                    <a id="bibliography_11" title=" Davis R I, Burns A. A survey of hard real-time scheduling for multiprocessor systems[J]. Acm Computing Surveys, 2011, 43 (4) ." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000008598&amp;v=MTE0MTlXYVJFPU5pZklZN0s3SHRqTnI0OUZaT3NIQ1hVeG9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXJ6SUpGMA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                         Davis R I, Burns A. A survey of hard real-time scheduling for multiprocessor systems[J]. Acm Computing Surveys, 2011, 43 (4) .
                                    </a>
                                </li>
                                <li id="316">


                                    <a id="bibliography_12" title=" Davis R I, Burns A. Improved priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems[J].Real-Time Systems, 2011, 47 (1) :1-40." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Improved priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems">
                                        <b>[12]</b>
                                         Davis R I, Burns A. Improved priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems[J].Real-Time Systems, 2011, 47 (1) :1-40.
                                    </a>
                                </li>
                                <li id="318">


                                    <a id="bibliography_13" title=" Ferry D, Li J, Mahadevan M, et al. A real-time scheduling service for parallel tasks[C]//Real-Time and Embedded Technology and Applications Symposium (RTAS) , 2013 IEEE 19th. IEEE, 2013: 261-272." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A real-time scheduling service for parallel tasks">
                                        <b>[13]</b>
                                         Ferry D, Li J, Mahadevan M, et al. A real-time scheduling service for parallel tasks[C]//Real-Time and Embedded Technology and Applications Symposium (RTAS) , 2013 IEEE 19th. IEEE, 2013: 261-272.
                                    </a>
                                </li>
                                <li id="320">


                                    <a id="bibliography_14" title=" 林英, 孟正, 康雁, 等. 多核下一种线程调度算法的研究与实现[J]. 计算机技术与发展, 2013 (10) :19-22." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WJFZ201310005&amp;v=MjUxMDY0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5em1VYnpMTWlmTmRMRzRIOUxOcjQ5RllZUUtESDg0dlI=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[14]</b>
                                         林英, 孟正, 康雁, 等. 多核下一种线程调度算法的研究与实现[J]. 计算机技术与发展, 2013 (10) :19-22.
                                    </a>
                                </li>
                                <li id="322">


                                    <a id="bibliography_15" title=" Davis R I, Burns A. Priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems[C]//Real-Time Systems Symposium, 2009, RTSS 2009. 30th IEEE. IEEE, 2009: 398-409." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Priority Assignment for Global Fixed Priority Pre-Emptive Scheduling in Multiprocessor Real-Time Systems">
                                        <b>[15]</b>
                                         Davis R I, Burns A. Priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems[C]//Real-Time Systems Symposium, 2009, RTSS 2009. 30th IEEE. IEEE, 2009: 398-409.
                                    </a>
                                </li>
                                <li id="324">


                                    <a id="bibliography_16" title=" Bertogna M, Cirinei M, Lipari G. Improved schedulability analysis of EDF on multiprocessor platforms[C]//Real-Time Systems, 2005. (ECRTS 2005) . Proceedings. 17th Euromicro Conference on. IEEE, 2005: 209-218." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Improved Schedulability Analysis of EDF on Multiprocessor PlatfoDMs">
                                        <b>[16]</b>
                                         Bertogna M, Cirinei M, Lipari G. Improved schedulability analysis of EDF on multiprocessor platforms[C]//Real-Time Systems, 2005. (ECRTS 2005) . Proceedings. 17th Euromicro Conference on. IEEE, 2005: 209-218.
                                    </a>
                                </li>
                                <li id="326">


                                    <a id="bibliography_17" title=" Saifullah A, Li J, Agrawal K, et al. Multi-core real-time scheduling for generalized parallel task models[J]. Real-Time Systems, 2013, 49 (4) : 404-435." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD13062800009746&amp;v=MTMyNzdPc0dDM2cvb0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcnpJSkYwV2FSRT1OajdCYXJLN0h0Zk9wNDlGWg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                         Saifullah A, Li J, Agrawal K, et al. Multi-core real-time scheduling for generalized parallel task models[J]. Real-Time Systems, 2013, 49 (4) : 404-435.
                                    </a>
                                </li>
                                <li id="328">


                                    <a id="bibliography_18" title=" Cordeiro D, Mouni&#233; G, Perarnau S, et al. Random graph generation for scheduling simulations[C]//Proceedings of the 3rd International ICST Conference on Simulation Tools and Techniques. 2010." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Random graph generation for scheduling simulations">
                                        <b>[18]</b>
                                         Cordeiro D, Mouni&#233; G, Perarnau S, et al. Random graph generation for scheduling simulations[C]//Proceedings of the 3rd International ICST Conference on Simulation Tools and Techniques. 2010.
                                    </a>
                                </li>
                                <li id="330">


                                    <a id="bibliography_19" title=" Baruah S. Improved Multiprocessor Global Schedulability Analysis of Sporadic DAG Task Systems[C]//Proceedings of the 2014 26th Euromicro Conference on Real-Time Systems. IEEE, 2014:97-105." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Improved Multiprocessor Global Schedulability Analysis of Sporadic DAG Task Systems">
                                        <b>[19]</b>
                                         Baruah S. Improved Multiprocessor Global Schedulability Analysis of Sporadic DAG Task Systems[C]//Proceedings of the 2014 26th Euromicro Conference on Real-Time Systems. IEEE, 2014:97-105.
                                    </a>
                                </li>
                                <li id="332">


                                    <a id="bibliography_20" title=" Chwa H S, Lee J, Phan K M, et al. Global edf schedulability analysis for synchronous parallel tasks on multicore platforms[C]//Proceedings of the 2013 25th Euromicro Conference on Real-Time Systems. IEEE, 2013: 25-34." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Global EDF schedulability analysis for synchronous parallel tasks on multicore platforms">
                                        <b>[20]</b>
                                         Chwa H S, Lee J, Phan K M, et al. Global edf schedulability analysis for synchronous parallel tasks on multicore platforms[C]//Proceedings of the 2013 25th Euromicro Conference on Real-Time Systems. IEEE, 2013: 25-34.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JYRJ" target="_blank">计算机应用与软件</a>
                2019,36(04),202-209 DOI:10.3969/j.issn.1000-386x.2019.04.032            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>嵌入式系统的细粒度多处理器实时抢占式调度算法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9D%8E%E6%89%AC&amp;code=35201980&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">李扬</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%8B%E6%98%A5%E6%98%8E&amp;code=10989730&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">王春明</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B1%9F%E8%8B%8F%E5%95%86%E8%B4%B8%E8%81%8C%E4%B8%9A%E5%AD%A6%E9%99%A2%E7%94%B5%E5%AD%90%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%99%A2&amp;code=1699402&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">江苏商贸职业学院电子与信息学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%8D%97%E9%80%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2&amp;code=0180964&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">南通大学计算机科学与技术学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>现有的嵌入式实时系统调度算法一般以任务级为调度单位, 对此提出一种细粒度的线程级多处理器实时调度算法。采用DAG图描述实时系统的任务, 并采用任务分解法将其分解为线程形式;为任务级调度采用基于干扰的可调度性分析, 为线程级调度采用基于工作负载的可调度性分析;将线程的偏移、截止期与优先级作为三个调度目标, 设计混合线程级调度算法。仿真实验结果表明, 算法对于多线程任务的实时系统具有较好的性能。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">多核处理器;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B9%B6%E8%A1%8C%E4%BB%BB%E5%8A%A1&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">并行任务;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BA%91%E8%AE%A1%E7%AE%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">云计算;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">多线程任务;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">调度算法;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">嵌入式系统;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    李扬, 副教授, 主研领域:嵌入式系统, 物联网。;
                                </span>
                                <span>
                                    王春明, 副教授。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-10-17</p>

                    <p>

                            <b>基金：</b>
                                                        <span>江苏省“333工程”科研项目 (BRA2018220);</span>
                                <span>南通市港闸区科技项目 (GZKJ2018JHK008);</span>
                                <span>江苏高校‘青蓝工程’资助项目 (201706-202006);</span>
                                <span>南通市科技计划项目 (GY12015037);</span>
                                <span>中华供销合作总社职业教育专项研究课题 (NGX1425);</span>
                    </p>
            </div>
                    <h1><b>REAL-TIME PREEMPTIVE SCHEDULING ALGORITHM FOR FINE-GRAINED MULTIPROCESSOR IN EMBEDDED SYSTEM</b></h1>
                    <h2>
                    <span>Li Yang</span>
                    <span>Wang Chunming</span>
            </h2>
                    <h2>
                    <span>School of Electronics and Information, Jiangsu Vocational College of Business</span>
                    <span>School of Computer Science and Technology, Nantong University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>The existing scheduling algorithms of embedded real-time system treat task level as scheduling unit generally. We proposed real-time scheduling algorithm for fine-grained thread-level multiprocessor. DAG graph was used to describe the tasks in real-time system, and the task decomposition method was adopted to decompose the tasks into threads. The interference-based schedulability analysis was introduced for task-level scheduling, and the workload-based schedulability analysis was introduced for thread-level scheduling. We treated offset, deadline and priority as three scheduling targets and designed hybrid thread-level scheduling algorithm. Simulation experimental results show that the proposed algorithm has better performance in real-time system with multi-threaded tasks.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Multi-core%20CPU&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Multi-core CPU;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Parallel%20tasks&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Parallel tasks;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Cloud%20computing&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Cloud computing;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Multi-threaded%20tasks&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Multi-threaded tasks;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Scheduling%20algorithm&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Scheduling algorithm;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Embedded%20system&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Embedded system;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-10-17</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="43" name="43" class="anchor-tag"><b>0 引 言</b></h3>
                <div class="p1">
                    <p id="44">如今AMD与Intel等处理器厂商已经发布8个核心以上的CPU, 未来CPU的核心数量更可能达到百级, 由此增加了多处理器、多任务调度问题的难度<citation id="334" type="reference"><link href="294" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。传统的研究大多集中于单处理器, 而针对单处理器的诸多研究成功无法扩展至多处理器系统<citation id="335" type="reference"><link href="296" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>。为了充分利用多核心处理器的计算能力, 任务调度算法需要支持任务之间的并行化<citation id="337" type="reference"><link href="298" rel="bibliography" /><link href="300" rel="bibliography" /><sup>[<a class="sup">3</a>,<a class="sup">4</a>]</sup></citation>, 此外, 对于多线程的任务, 更可能发生同一任务的不同线程在多个处理器核心上并发执行的情况, 因此, 细粒度的任务调度算法成为一个亟待解决的问题<citation id="336" type="reference"><link href="302" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="45">实时调度研究中有两个基本问题: (1) 调度算法需为任务或线程分配合适的优先级, 且满足系统的截止期约束; (2) 为调度算法提供可调度性分析, 证明算法满足系统的截止期约束<citation id="338" type="reference"><link href="304" rel="bibliography" /><link href="306" rel="bibliography" /><sup>[<a class="sup">6</a>,<a class="sup">7</a>]</sup></citation>。以往的研究大多从单线程多任务、多处理器的实时调度方面解决上述两个问题。近期, 出现多个考虑多线程多任务的多处理器调度研究, 其中可调度性分析的研究为主要目标, 但针对此场景的调度算法优化研究相对较少<citation id="339" type="reference"><link href="308" rel="bibliography" /><link href="310" rel="bibliography" /><link href="312" rel="bibliography" /><sup>[<a class="sup">8</a>,<a class="sup">9</a>,<a class="sup">10</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="46">单线程任务中, 作业是基本的调度单位, 该场景的实时调度算法根据优先级变化的时间点主要分为三类<citation id="340" type="reference"><link href="314" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>: (1) 任务级固定优先级算法; (2) 作业级固定优先级算法; (3) 动态优先级算法。如果将线程作为调度单位, 则为调度问题增加了一个维度, 从而提升了问题的复杂度。</p>
                </div>
                <div class="p1">
                    <p id="47">文献<citation id="341" type="reference">[<a class="sup">12</a>]</citation>提出了最优优先级分配算法 (OPA) , 该研究证明了OPA是任务级固定优先级分配问题的最优算法, 本文期望将OPA算法扩展至线程级调度场景, 但由此带来两个问题:线程级依赖关系与线程级调度算法的可调度性分析。本文首先采用任务分解方法<citation id="342" type="reference"><link href="318" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>为各线程分配偏移时间与截止期;然后, 基于干扰的线程级分析证明本文扩展调度算法与OPA算法兼容, 从而证明本文线程级调度算法也是最优调度算法;最终, 设计了完整的线程级调度算法。</p>
                </div>
                <h3 id="48" name="48" class="anchor-tag"><b>1 系统模型</b></h3>
                <h4 class="anchor-tag" id="49" name="49"><b>1.1 有向无环图 (DAG) 任务</b></h4>
                <div class="p1">
                    <p id="50">本文采用DAG (有向无环图) 表示并行任务<citation id="343" type="reference"><link href="320" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>, 假设任务集合为<i>τ</i>, 一个任务<i>τ</i><sub><i>i</i></sub>∈<i>τ</i>表示为一个有向无环图, 如图1 (a) 所示。<i>τ</i><sub><i>i</i></sub>的顶点<i>v</i><sub><i>i</i>, <i>p</i></sub>代表一个线程<i>θ</i><sub><i>i</i>, <i>p</i></sub>, 一条有向边 (<i>v</i><sub><i>i</i>, <i>p</i></sub>到<i>v</i><sub><i>i</i>, <i>q</i></sub>) 代表线程之间的依赖关系。一个DAG任务包含若干个作业, 作业之间最小间隔为<i>T</i><sub><i>i</i></sub>, 各作业的截止期应当在<i>D</i><sub><i>i</i></sub>以内, 设<i>J</i><mathml id="51"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>h</mi></msubsup></mrow></math></mathml>表示<i>τ</i><sub><i>i</i></sub>的第<i>h</i>个作业, 任务分解的结果如图1 (b) 所示。</p>
                </div>
                <div class="area_img" id="53">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904033_05300.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 任务示意图" src="Detail/GetImg?filename=images/JYRJ201904033_05300.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 任务示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904033_05300.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="53">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904033_05301.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 任务示意图" src="Detail/GetImg?filename=images/JYRJ201904033_05301.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 任务示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904033_05301.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="54" name="54"><b>1.2 任务分解</b></h4>
                <div class="p1">
                    <p id="55">可将一个DAG任务分解为独立、有序的子任务集合, 线程之间具有依赖关系与执行出口, 为DAG任务的各线程分配对应的偏移与截止期。</p>
                </div>
                <div class="p1">
                    <p id="56">将任务<i>τ</i>分解产生的线程集合设为<i>τ</i><sup>decom</sup>, <i>τ</i><sup>decom</sup>中线程的数量设为<i>n</i>。对于任务<i>τ</i><sub><i>i</i></sub>, 定义任务的主线程为<i>θ</i><sub><i>i</i>, 1</sub>, <i>τ</i><sub><i>i</i></sub>中其他各线程<i>θ</i><sub><i>i</i>, <i>p</i></sub>表示为 (<i>T</i><sub><i>i</i>, <i>p</i></sub>, <i>C</i><sub><i>i</i>, <i>p</i></sub>, <i>D</i><sub><i>i</i>, <i>p</i></sub>, <i>O</i><sub><i>i</i>, <i>p</i></sub>) , 其中<i>T</i><sub><i>i</i>, <i>p</i></sub>是最小间隔 (等于<i>T</i><sub><i>i</i></sub>) , <i>C</i><sub><i>i</i>, <i>p</i></sub>与<i>D</i><sub><i>i</i>, <i>p</i></sub>分别表示最坏情况的运行时间及其截止期, <i>O</i><sub><i>i</i>, <i>p</i></sub>为对应的偏移 (从<i>O</i><sub><i>i</i>, 1</sub>=0开始) 。</p>
                </div>
                <div class="p1">
                    <p id="57">假设主线程<i>θ</i><sub><i>i</i>, 1</sub>在<i>r</i><mathml id="58"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mn>1</mn></mrow><mi>h</mi></msubsup></mrow></math></mathml>点运行, 则作业<i>j</i><mathml id="59"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>h</mi></msubsup></mrow></math></mathml>具有绝对的截止期<i>d</i><mathml id="60"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mn>1</mn></mrow><mi>h</mi></msubsup></mrow></math></mathml>=<i>r</i><mathml id="61"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mn>1</mn></mrow><mi>h</mi></msubsup></mrow></math></mathml>+<i>D</i><sub><i>i</i>, 1</sub>。那么, 依赖于<i>θ</i><sub><i>i</i>, 1</sub>的下一个线程<i>θ</i><sub><i>i</i>, <i>p</i></sub>将在<i>r</i><mathml id="62"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mi>h</mi></msubsup></mrow></math></mathml>=<i>r</i><mathml id="63"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mn>1</mn></mrow><mi>h</mi></msubsup></mrow></math></mathml>+<i>O</i><sub><i>i</i>, <i>p</i></sub>点运行, 其截止期为<i>d</i><mathml id="64"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mi>h</mi></msubsup></mrow></math></mathml>=<i>r</i><mathml id="65"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mi>h</mi></msubsup></mrow></math></mathml>+<i>D</i><sub><i>i</i>, <i>p</i></sub>。将<i>θ</i><sub><i>i</i>, <i>p</i></sub>的执行窗口定义为时间段 (<i>r</i><mathml id="66"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mi>h</mi></msubsup></mrow></math></mathml>, <i>d</i><mathml id="67"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mi>h</mi></msubsup></mrow></math></mathml>]。</p>
                </div>
                <h4 class="anchor-tag" id="68" name="68"><b>1.3 CPU平台与调度算法</b></h4>
                <div class="p1">
                    <p id="69">假设多核CPU由<i>m</i>个相同的处理器组成, 调度策略为全局任务-线程级固定优先级调度, 每个线程<i>θ</i><sub><i>i</i>, <i>p</i></sub>可以动态地在处理器之间迁移, 且为所有线程分配静态的优先级<i>P</i><sub><i>i</i>, <i>p</i></sub>。将优先级高于<i>P</i><sub><i>i</i>, <i>p</i></sub>的线程集合设为<i>hp</i> (<i>θ</i><sub><i>i</i>, <i>p</i></sub>) 。</p>
                </div>
                <h3 id="70" name="70" class="anchor-tag"><b>2 可调度性分析</b></h3>
                <div class="p1">
                    <p id="71">DAG任务分解为线程级之后, 各线程即设置了偏移与截止期, 无需考虑线程间的依赖关系。基于干扰的可调度性分析兼容OPA, 所以本文采用该方案<citation id="344" type="reference"><link href="322" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>。</p>
                </div>
                <h4 class="anchor-tag" id="72" name="72"><b>2.1 基于干扰的可调度性分析</b></h4>
                <div class="p1">
                    <p id="73">线程级干扰可如下定义:</p>
                </div>
                <div class="p1">
                    <p id="74">干扰<i>I</i><sub><i>k</i>, <i>q</i></sub> (<i>a</i>, <i>b</i>) :如果<i>θ</i><sub><i>k</i>, <i>q</i></sub>为ready状态, 但[<i>a</i>, <i>b</i>) 中更高优先级的线程正在运行, 此时的时隙总和定义为干扰<i>I</i><sub><i>k</i>, <i>q</i></sub> (<i>a</i>, <i>b</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="75">干扰<i>I</i><sub> (<i>k</i>, <i>q</i>) → (<i>k</i>, <i>q</i>) </sub> (<i>a</i>, <i>b</i>) :[<i>a</i>, <i>b</i>) 中<i>θ</i><sub><i>i</i>, <i>p</i></sub>正在运行, 且<i>θ</i><sub><i>k</i>, <i>q</i></sub>为ready状态, 此时的时隙总和定义为干扰<i>I</i><sub> (<i>k</i>, <i>q</i>) → (<i>k</i>, <i>q</i>) </sub> (<i>a</i>, <i>b</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="76"><i>I</i><sub><i>k</i>, <i>q</i></sub> (<i>a</i>, <i>b</i>) 与<i>I</i><sub> (<i>k</i>, <i>q</i>) → (<i>k</i>, <i>q</i>) </sub> (<i>a</i>, <i>b</i>) 之间的关系是可调度性分析的重要基础, <i>I</i><sub><i>k</i>, <i>q</i></sub> (<i>a</i>, <i>b</i>) 与<i>I</i><sub> (<i>k</i>, <i>q</i>) → (<i>k</i>, <i>q</i>) </sub> (<i>a</i>, <i>b</i>) 之间的关系可推导为<citation id="345" type="reference"><link href="324" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>:</p>
                </div>
                <div class="p1">
                    <p id="77"><mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ι</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false"> (</mo><mi>a</mi><mo>, </mo><mi>b</mi><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>p</mi><mo stretchy="false">) </mo><mo>≠</mo><mo stretchy="false"> (</mo><mi>k</mi><mo>, </mo><mi>q</mi><mo stretchy="false">) </mo></mrow></munder><mi>Ι</mi></mstyle><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>p</mi><mo stretchy="false">) </mo><mo>→</mo><mo stretchy="false"> (</mo><mi>k</mi><mo>, </mo><mi>q</mi><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false"> (</mo><mi>a</mi><mo>, </mo><mi>b</mi><mo stretchy="false">) </mo></mrow><mi>m</mi></mfrac></mrow></math></mathml>      (1) </p>
                </div>
                <div class="p1">
                    <p id="79">假设<i>J</i><mathml id="80"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>表示<i>θ</i><sub><i>k</i>, <i>q</i></sub>中总干扰最大的作业, 该作业的总干扰可表示为:</p>
                </div>
                <div class="p1">
                    <p id="81"><mathml id="82"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ι</mi><msubsup><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow><mo>*</mo></msubsup><mo>≜</mo><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mi>max</mi></mrow></mstyle><mi>h</mi></munder><mo stretchy="false"> (</mo><mi>Ι</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false"> (</mo><mi>r</mi><msubsup><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow><mi>h</mi></msubsup><mo>, </mo><mi>d</mi><msubsup><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow><mi>h</mi></msubsup><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>=</mo><mi>Ι</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false"> (</mo><mi>r</mi><msubsup><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow><mo>*</mo></msubsup><mo>, </mo><mi>d</mi><msubsup><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow><mo>*</mo></msubsup><mo stretchy="false">) </mo></mrow></math></mathml>      (2) </p>
                </div>
                <div class="p1">
                    <p id="83">文献<citation id="346" type="reference">[<a class="sup">15</a>,<a class="sup">16</a>]</citation>定义了以下可调度性判定条件:</p>
                </div>
                <div class="p1">
                    <p id="84"><b>引理</b>1 当且仅当所有线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>满足以下条件, 则<i>m</i>个相同处理器组成的多处理器平台中集合<i>τ</i><sup>decom</sup>是可调度的:</p>
                </div>
                <div class="p1">
                    <p id="85" class="code-formula">
                        <mathml id="85"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>θ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub><mo>∈</mo><mi>τ</mi><msup><mrow></mrow><mrow><mtext>d</mtext><mtext>e</mtext><mtext>c</mtext><mtext>o</mtext><mtext>m</mtext></mrow></msup><mrow><mi>θ</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">}</mo></mrow><mrow><mi>min</mi></mrow><mo stretchy="false"> (</mo><mi>Ι</mi><msubsup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>p</mi><mo stretchy="false">) </mo><mo>→</mo><mo stretchy="false"> (</mo><mi>k</mi><mo>, </mo><mi>q</mi><mo stretchy="false">) </mo></mrow><mo>*</mo></msubsup><mo>, </mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>-</mo><mi>C</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></munder><mrow></mrow></mstyle></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="86">&lt;<i>m</i>: (<i>D</i><sub><i>k</i>, <i>q</i></sub>-<i>C</i><sub><i>k</i>, <i>q</i></sub>+1)      (3) </p>
                </div>
                <div class="p1">
                    <p id="87">文献<citation id="347" type="reference">[<a class="sup">17</a>]</citation>对引理1扩展, 获得了以下线程级判定条件:</p>
                </div>
                <div class="p1">
                    <p id="88"><b>引理2</b> 如果<i>τ</i><sup>decom</sup>是可调度的, 则<i>τ</i>也是可调度的。</p>
                </div>
                <h4 class="anchor-tag" id="89" name="89"><b>2.2 基于工作负载的可调度性分析</b></h4>
                <div class="p1">
                    <p id="90">首先需要确保各线程的截止期早于任务的截止期 (引理1) , 然后需要计算其他线程对目标线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>的干扰 (式 (3) ) 。</p>
                </div>
                <div class="p1">
                    <p id="91">本文推导进程对线程干扰的上界, 即任务<i>τ</i><sub><i>i</i></sub>对<i>θ</i><sub><i>k</i>, <i>q</i></sub>的干扰, 表示为<mathml id="92"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mo>∀</mo><mi>θ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub><mo>∈</mo><mi>τ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></munder><mrow></mrow></mstyle></mrow></math></mathml>min (<i>I</i><mathml id="93"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>p</mi><mo stretchy="false">) </mo><mo>→</mo><mo stretchy="false"> (</mo><mi>k</mi><mo>, </mo><mi>q</mi><mo stretchy="false">) </mo></mrow><mo>*</mo></msubsup></mrow></math></mathml>, <i>D</i><sub><i>k</i>, <i>q</i></sub>-<i>C</i><sub><i>k</i>, <i>q</i></sub>+1) 。首先根据<i>τ</i><sub><i>i</i></sub>释放作业的偏移点, 计算<i>τ</i><sub><i>i</i></sub>在<i>θ</i><sub><i>k</i>, <i>q</i></sub>运行窗口中的执行长度;然后, 选择<i>τ</i><sub><i>i</i></sub>最大运行长度对应的偏移。</p>
                </div>
                <div class="p1">
                    <p id="94">考虑两个场景计算最大工作负载:<i>i</i>≠<i>k</i>与<i>i</i>=<i>k</i>, 原因在于<i>i</i>=<i>k</i>表示两个干扰线程属于同一个任务, 说明<i>τ</i><sub><i>i</i></sub>中作业释放的偏移已经自动给定。</p>
                </div>
                <h4 class="anchor-tag" id="95" name="95"><b>2.2.1 <i>i</i>≠<i>k</i></b>情况的负载最大化</h4>
                <div class="p1">
                    <p id="96">为了简化描述, 对于时间段 (<i>x</i>, <i>y</i>], 如果作业的启动时间在<i>x</i>之前, 截止期在 (<i>x</i>, <i>y</i>]内, 则简称为前置作业;如果作业的启动时间与截止期均在 (<i>x</i>, <i>y</i>]内, 则简称为期内作业;如果作业的启动时间在 (<i>x</i>, <i>y</i>]内, 截止期在<i>y</i>之后, 则简称为后置作业。</p>
                </div>
                <div class="p1">
                    <p id="97">假设<i>τ</i><sub><i>i</i></sub>的作业为周期地启动, 定义<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) 为 (<i>x</i>, <i>y</i>] 中前置任务启动时间点与<i>x</i>的差值, 如图2所示。</p>
                </div>
                <div class="area_img" id="98">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904033_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 τi中所有线程的最大工作负载" src="Detail/GetImg?filename=images/JYRJ201904033_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 <i>τ</i><sub><i>i</i></sub>中所有线程的最大工作负载  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904033_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="99">对于一个给定的<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) , 如果 (<i>x</i>, <i>y</i>]时长为<i>l</i>, 可将 (<i>x</i>, <i>y</i>]时间段分为前置时段<i>CI</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) , 期内时段<i>BD</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) 以及后置时段<i>CO</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) , 三种时段可表示为:</p>
                </div>
                <div class="p1">
                    <p id="100"><i>CI</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) =min (<i>T</i><sub><i>i</i></sub>-<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) , <i>l</i>)      (4) </p>
                </div>
                <div class="p1">
                    <p id="101"><i>BD</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) =<mathml id="102"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>l</mi><mo>-</mo><mi>C</mi><mi>Ι</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>l</mi><mo>, </mo><mi>Δ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo>, </mo><mi>y</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mrow><mrow><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></mfrac></mrow></math></mathml>·<i>T</i><sub><i>i</i></sub>      (5) </p>
                </div>
                <div class="p1">
                    <p id="103"><i>CO</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) =<i>l</i>-<i>CI</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) -<i>BD</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) )      (6) </p>
                </div>
                <div class="p1">
                    <p id="104">对于给定的<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) , (<i>x</i>, <i>y</i>]中每个线程的负载贡献度 (如图2所示) 可计算为:</p>
                </div>
                <div class="p1">
                    <p id="105"><i>W</i><sub><i>i</i>, <i>p</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) =<i>W</i><mathml id="106"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ι</mi></mrow></msubsup></mrow></math></mathml>+<i>W</i><mathml id="107"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>B</mi><mi>D</mi></mrow></msubsup></mrow></math></mathml>+<i>W</i><mathml id="108"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ο</mi></mrow></msubsup></mrow></math></mathml>      (7) </p>
                </div>
                <div class="p1">
                    <p id="109">式中:</p>
                </div>
                <div class="p1">
                    <p id="110"><i>W</i><mathml id="111"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ι</mi></mrow></msubsup></mrow></math></mathml>=[min (<i>O</i><sub><i>i</i>, <i>p</i></sub>+<i>D</i><sub><i>i</i>, <i>p</i></sub>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) +<i>l</i>) -</p>
                </div>
                <div class="p1">
                    <p id="112">max (<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) , <i>O</i><sub><i>i</i>, <i>p</i></sub>) ]<mathml id="113"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>C</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub></mrow></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="114"><i>W</i><mathml id="115"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>B</mi><mi>D</mi></mrow></msubsup></mrow></math></mathml>=<mathml id="116"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>l</mi><mo>-</mo><mi>C</mi><mi>Ι</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>l</mi><mo>, </mo><mi>Δ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo>, </mo><mi>y</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mrow><mrow><mi>Τ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub></mrow></mfrac></mrow></math></mathml>·<i>C</i><sub><i>i</i>, <i>p</i></sub></p>
                </div>
                <div class="p1">
                    <p id="117"><i>W</i><mathml id="118"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ο</mi></mrow></msubsup></mrow></math></mathml>=[<i>CO</i><sub><i>i</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) -<i>O</i><sub><i>i</i>, <i>p</i></sub>]<mathml id="119"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>C</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub></mrow></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="120">[<i>X</i>]<mathml id="121"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>a</mi><mi>b</mi></msubsup></mrow></math></mathml>表示min (max (<i>X</i>, <i>a</i>) , <i>b</i>) 。此时论证目标变为:对于<i>W</i><mathml id="122"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ι</mi></mrow></msubsup></mrow></math></mathml>, 首先寻找<i>θ</i><sub><i>i</i>, <i>p</i></sub>中前置作业的运行窗口与 (<i>x</i>, <i>y</i>]重叠的部分, 将其表示为 (<i>a</i>, <i>b</i>]。不失一般性, 将<i>r</i><mathml id="123"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mn>0</mn></mrow><mrow><mi>C</mi><mi>Ι</mi></mrow></msubsup></mrow></math></mathml>设为0, 则前置作业在<i>O</i><sub><i>i</i>, <i>p</i></sub>启动。如果<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) &lt;<i>O</i><sub><i>i</i>, <i>p</i></sub>, 则<i>a</i>等于<i>O</i><sub><i>i</i>, <i>p</i></sub>;否则, <i>a</i>等于<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) , 如图2所示。此时<i>θ</i><sub><i>i</i>, <i>p</i></sub>中前置作业的截止期为<i>O</i><sub><i>i</i>, <i>p</i></sub>+<i>D</i><sub><i>i</i>, <i>p</i></sub>。如果<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) +<i>l</i>&gt;<i>O</i><sub><i>i</i>, <i>p</i></sub>+<i>D</i><sub><i>i</i>, <i>p</i></sub>, 则<i>b</i>等于<i>O</i><sub><i>i</i>, <i>p</i></sub>+<i>D</i><sub><i>i</i>, <i>p</i></sub>;否则<i>b</i>等于<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) +<i>l</i>, 说明进前置作业与 (<i>x</i>, <i>y</i>]产生重叠。由此可总结为:<i>a</i>等于max (<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) , <i>O</i><sub><i>i</i>, <i>p</i></sub>) , <i>b</i>等于min (<i>O</i><sub><i>i</i>, <i>p</i></sub>+<i>D</i><sub><i>i</i>, <i>p</i></sub>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) +<i>l</i>) 。在 (<i>a</i>, <i>b</i>]中, 前期作业的运行时间在0与<i>C</i><sub><i>i</i>, <i>p</i></sub>之间。因此获得了式 (7) 的<i>W</i><mathml id="124"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ι</mi></mrow></msubsup></mrow></math></mathml>。</p>
                </div>
                <div class="p1">
                    <p id="125"><i>θ</i><sub><i>i</i>, <i>p</i></sub>期内作业的数量可计算为<mathml id="126"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>l</mi><mo>-</mo><mi>C</mi><mi>Ι</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>l</mi><mo>, </mo><mi>Δ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo>, </mo><mi>y</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mrow><mrow><mi>Τ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub></mrow></mfrac></mrow></math></mathml>, 所以<i>W</i><mathml id="127"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>B</mi><mi>D</mi></mrow></msubsup></mrow></math></mathml>等于作业数量乘以运行时间<i>C</i><sub><i>i</i>, <i>p</i></sub>。<i>W</i><mathml id="128"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ο</mi></mrow></msubsup></mrow></math></mathml>的推导过程与<i>W</i><mathml id="129"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ι</mi></mrow></msubsup></mrow></math></mathml>相似。</p>
                </div>
                <div class="p1">
                    <p id="130">对于偶发任务:此时可简单地检查 (<i>x</i>, <i>y</i>]中<i>θ</i><sub><i>i</i>, <i>p</i></sub>的运行量, 则<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) 上界为<i>W</i><sub><i>i</i>, <i>p</i></sub> (<i>l</i>, <i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) ) 。</p>
                </div>
                <div class="p1">
                    <p id="131">考虑任务<i>τ</i><sub><i>i</i></sub>中<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) 的所有可能值, 优先级高于<i>θ</i><sub><i>k</i>, <i>q</i></sub>的所有线程工作负载之和即为<i>τ</i><sub><i>i</i></sub>对线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>的最大干扰的上界, 表示为:</p>
                </div>
                <div class="p1">
                    <p id="132" class="code-formula">
                        <mathml id="132"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign="left"><mtr><mtd><mi>W</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo><mo>=</mo><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mi>max</mi></mrow></mstyle><mrow><mn>0</mn><mo>≤</mo><mi>Δ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo>, </mo><mi>y</mi><mo stretchy="false">) </mo><mo>&lt;</mo><mi>Τ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></munder><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mo>∀</mo><mi>θ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub><mo>∈</mo><mi>h</mi><mi>p</mi><mo stretchy="false"> (</mo><mi>θ</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo></mrow></munder><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mi>min</mi><mo stretchy="false"> (</mo><mi>W</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>, </mo><mi>Δ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo>, </mo><mi>y</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>, </mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>-</mo><mi>C</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo></mtd></mtr></mtable><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>8</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="133">在时段 (<i>x</i>, <i>y</i>]中, 对于给定的<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) , 证明<i>W</i><mathml id="134"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ι</mi></mrow></msubsup></mrow></math></mathml>、<i>W</i><mathml id="135"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>B</mi><mi>D</mi></mrow></msubsup></mrow></math></mathml>与<i>W</i><mathml id="136"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>p</mi></mrow><mrow><mi>C</mi><mi>Ο</mi></mrow></msubsup></mrow></math></mathml>分别是<i>θ</i><sub><i>i</i>, <i>p</i></sub>中前置作业、期内作业与后置作业运行量 (执行时长) 的上界。</p>
                </div>
                <h4 class="anchor-tag" id="137" name="137"><b>2.2.2 <i>i</i>=<i>k</i></b>情况的负载最大化</h4>
                <div class="p1">
                    <p id="138">该情况下<i>τ</i><sub><i>k</i></sub>的作业被同一个任务干扰, 因此可自动地决定<i>τ</i><sub><i>k</i></sub>中作业启动的偏移时间。为了计算<i>i</i>=<i>k</i>情况的最大工作负载, 本文仅需要考虑与线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>重叠的部分执行窗口, 使用式 (7) 可计算这些线程的负载贡献量。因此, <i>τ</i><sub><i>k</i></sub>中优先级高于线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>的其他所有线程最大负载计算为:</p>
                </div>
                <div class="p1">
                    <p id="139" class="code-formula">
                        <mathml id="139"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>W</mi><msub><mrow></mrow><mi>k</mi></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mo>∀</mo><mi>θ</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>p</mi></mrow></msub><mo>∈</mo><mi>h</mi><mi>p</mi><mo stretchy="false"> (</mo><mi>θ</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo></mrow></munder><mrow><mi>min</mi></mrow></mstyle><mo stretchy="false"> (</mo><mi>W</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>p</mi></mrow></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>, </mo><mi>Ο</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo><mo>, </mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>-</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>C</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>9</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="140">基于式 (8) 和式 (9) 计算的干扰上界, 为本文线程级调度算法设计了以下可调度性判定:</p>
                </div>
                <div class="p1">
                    <p id="141"><b>理论1</b> 对于<i>m</i>个相同的处理器平台的线程级调度算法, 如果每个线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>满足以下的不等式, 则集合<i>τ</i><sup>decom</sup>为可调度。</p>
                </div>
                <div class="p1">
                    <p id="142" class="code-formula">
                        <mathml id="142"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mo>∀</mo><mi>τ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>≠</mo><mi>τ</mi><msub><mrow></mrow><mi>k</mi></msub></mrow></munder><mrow></mrow></mstyle></mrow><mi>W</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo><mo>+</mo><mi>W</mi><msub><mrow></mrow><mi>k</mi></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo><mo>&lt;</mo><mi>m</mi><mo>⋅</mo><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>-</mo><mi>C</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="143"><b>证明</b> 上文所述<i>W</i><sub><i>k</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>) 是<i>θ</i><sub><i>k</i>, <i>q</i></sub>运行窗口中优先级高于<i>p</i><sub><i>k</i>, <i>q</i></sub>的最大运行量。当且仅当A优先级高于B时, A才对B产生干扰, 式 (3) 左式的上界为式 (10) 的左式。根据引理1, 可证明该理论。</p>
                </div>
                <h3 id="144" name="144" class="anchor-tag"><b>3 线程级最优优先级分配算法</b></h3>
                <div class="p1">
                    <p id="145">问题描述为:给定一个分解线程的集合<i>τ</i><sup>decom</sup>, 为每个线程<i>θ</i><sub><i>i</i>, <i>q</i></sub>∈<i>τ</i><sup>decom</sup>分配优先级<i>P</i><sub><i>i</i>, <i>p</i></sub>, 因此根据基于工作负载的可调度性判定 (理论1) 认为分解集合为可调度的。</p>
                </div>
                <div class="p1">
                    <p id="146">OPA算法通过优先级分配为各任务分配一个优先级, 如果所有任务<i>τ</i><sub><i>i</i></sub>满足以下两个条件, 则该可调度性判定为OPA兼容:</p>
                </div>
                <div class="p1">
                    <p id="147"><b>条件1</b>:任务<i>τ</i><sub><i>i</i></sub>的可调度性对其他优先级的任务顺序不敏感。</p>
                </div>
                <div class="p1">
                    <p id="148"><b>条件2</b>:如果交换<i>τ</i><sub><i>k</i></sub>与<i>τ</i><sub><i>i</i></sub>之间的优先级使得<i>τ</i><sub><i>k</i></sub>的优先级提高, 交换前后<i>τ</i><sub><i>k</i></sub>的可调度性不变。</p>
                </div>
                <div class="p1">
                    <p id="149">算法1为本文改进的OPA调度算法, 该算法从优先级最低的线程开始迭代地为所有线程分配优先级, 其中<i>τ</i><sup>decom</sup>为操作系统中待分配优先级的线程集。第<i>k</i>次迭代中, <i>τ</i><sup>decom</sup>分为两个不相交的子集:<i>A</i> (<i>k</i>) 与<i>R</i> (<i>k</i>) , 其中:</p>
                </div>
                <div class="p1">
                    <p id="150">1) <i>A</i> (<i>k</i>) 表示第<i>k</i>步之前已分配优先级的线程子集;</p>
                </div>
                <div class="p1">
                    <p id="151">2) <i>R</i> (<i>k</i>) 表示剩余线程的子集。</p>
                </div>
                <div class="p1">
                    <p id="152">理论1的可调度性判定是OPA兼容的, 说明该判定满足线程级可调度性的条件1与条件2, 因此算法1的优先级分配过程正确, 证明方法如下:</p>
                </div>
                <div class="p1">
                    <p id="153"><b>理论2</b> 理论1的可调度性判定兼容算法1。</p>
                </div>
                <div class="p1">
                    <p id="154"><b>证明</b> 根据本文的可调度性判定证明线程级调度算法满足条件1与条件2:</p>
                </div>
                <div class="p1">
                    <p id="155"> (1) 满足条件1证明:式 (10) 的左式计算了每个任务对线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>干扰的上界, 任务的干扰上界计算为优先级高于<i>θ</i><sub><i>k</i>, <i>q</i></sub>的其他线程工作负载之和。而该计算过程不依赖相应的优先级顺序。因此, 满足条件1。</p>
                </div>
                <div class="p1">
                    <p id="156"> (2) 满足条件2证明:交换<i>θ</i><sub><i>k</i>, <i>q</i></sub>与<i>θ</i><sub><i>i</i>, <i>p</i></sub>优先级, <i>θ</i><sub><i>k</i>, <i>q</i></sub>的优先级提高。因为<i>θ</i><sub><i>k</i>, <i>q</i></sub>的优先级提高, 所以<i>hp</i> (<i>θ</i><sub><i>k</i>, <i>q</i></sub>) 交换后变得更小。因此, 式 (8) 、式 (9) 的<i>W</i><sub><i>i</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>) 与<i>W</i><sub><i>k</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>) 交换之后变得更小, 满足条件2。</p>
                </div>
                <div class="p1">
                    <p id="157">计算复杂度分析:分解任务集合<i>τ</i><sup>decom</sup>的线程数量设为<i>n</i>, 根据可调度性判定, 如果存在所有线程可调度的情况, 则算法可成功找到该优先级分配策略, 所以对于<i>n</i>个线程的场景, 最多需<mathml id="158"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi>n</mi><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo></mrow><mn>2</mn></mfrac></mrow></math></mathml>次可调度性判定。</p>
                </div>
                <div class="area_img" id="353">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904033_35300.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="354">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904033_35400.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="354">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904033_35401.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <h3 id="181" name="181" class="anchor-tag"><b>4 动态截止期的线程级调度算法</b></h3>
                <h4 class="anchor-tag" id="182" name="182"><b>4.1 算法设计</b></h4>
                <div class="p1">
                    <p id="183">上文考虑了线程静态偏移与截止期的情况, 本算法的决策目标为各线程的偏移、截止期与优先级三个目标, 所以根据理论1的可调度性分析, 并行任务系统是可调度的。本文动态截止期的线程级优先级分配策略的主要思想为:首先通过算法1分配优先级, 如果算法1分配失败, 则调节一些线程的偏移与截止期, 使得调节后某个线程可成功地分配优先级, 如果找到该调节方法, 则继续使用算法1分配优先级;否则, 认为调度失败, 如算法3所示。算法3中输入为操作系统中待分配优先级的线程集, 输出为调度的状态。</p>
                </div>
                <div class="p1">
                    <p id="184">将线程结束时间与截止期之间的最小距离定义为线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>的富余时间, 表示为<i>S</i><sub><i>k</i>, <i>q</i></sub>。根据理论1的可调度性判定, <i>S</i><sub><i>k</i>, <i>q</i></sub>可近似为:</p>
                </div>
                <div class="p1">
                    <p id="185"><i>S</i><sub><i>k</i>, <i>q</i></sub>=<i>D</i><sub><i>k</i>, <i>q</i></sub>-<i>C</i><sub><i>k</i>, <i>q</i></sub>-<mathml id="186"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mo>∀</mo><mi>τ</mi><msub><mrow></mrow><mi>i</mi></msub><mo>≠</mo><mi>τ</mi><msub><mrow></mrow><mi>k</mi></msub></mrow></munder><mi>W</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo><mo>+</mo><mi>W</mi><msub><mrow></mrow><mi>k</mi></msub><mo stretchy="false"> (</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo stretchy="false">) </mo></mrow><mi>m</mi></mfrac></mrow></math></mathml>      (11) </p>
                </div>
                <div class="p1">
                    <p id="187">定义线程的归一化富余时间<mathml id="188"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi>S</mi><mo stretchy="true">¯</mo></mover><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>=</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub><mo>/</mo><mi>D</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>, </mo><mi>q</mi></mrow></msub></mrow></math></mathml>。可将线程的截止期调节变换为线程的富余时间调节, 即富余时间多的线程将部分富余时间赠予时间紧缺的线程, 将赠予方简称为赠予线程, 被赠予方成为受赠线程。最终, 截止期调节问题可分为三个子问题:赠予线程、受赠线程的决策策略, 以及赠予时间量的分配。</p>
                </div>
                <div class="p1">
                    <p id="189">线程间赠予富余时间的目标是为受赠线程分配一个优先级, 使得受赠线程变为可调度, 然而由此可能对其他可调度的线程产生边际效应。考虑该问题, 本文设计了以下三个子问题解决策略:</p>
                </div>
                <div class="p1">
                    <p id="190"> (1) 受赠线程的决策策略:应当保证已分配优先级线程具有足够的富余时间, 所以决策策略为最小化总赠予时间的量。据此将所需赠予时间最少的线程作为受赠线程, 时期变为可调度状态, 见算法4的第3行。</p>
                </div>
                <div class="p1">
                    <p id="191"> (2) 赠予线程的决策策略:确定受赠线程后, 建立一个赠予线程候选集合 (算法4第4行) , 属同一个任务的候选线程已经分配了优先级, 应当能够赠予富余时间, 且不影响所有线程的可调度性。为了避免破坏已分配优先级线程的可调度状态, 本文选择候选集合中归一化富余时间量最大的线程作为赠予线程 (算法4第6行) 。</p>
                </div>
                <div class="p1">
                    <p id="192"> (3) 赠予时间量的分配:</p>
                </div>
                <div class="p1">
                    <p id="193"><b>引理3</b> 如果线程<i>θ</i><sub><i>k</i>, <i>q</i></sub>的截止期<i>D</i><sub><i>k</i>, <i>q</i></sub>减小, 则对<i>θ</i><sub><i>k</i>, <i>q</i></sub>最坏情况的干扰随之单调减小。</p>
                </div>
                <div class="p1">
                    <p id="194"><b>证明</b> 式 (8) 、式 (9) 中, 分别计算了<i>τ</i><sub><i>i</i></sub>与<i>τ</i><sub><i>k</i></sub>的最大执行量。式 (7) 中给定<i>t</i>, <i>W</i><sub><i>i</i>, <i>p</i></sub> (<i>D</i><sub><i>i</i>, <i>p</i></sub>, <i>t</i>) 与<i>W</i><sub><i>k</i>, <i>q</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>, <i>t</i>) 随<i>D</i><sub><i>k</i>, <i>q</i></sub>下降而单调下降。式 (8) 中, 因为需要调节<i>Δ</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) 使得<i>W</i><sub><i>i</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>) 最大化, 所以<i>W</i><sub><i>k</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>) 不会随<i>D</i><sub><i>k</i>, <i>q</i></sub>下降而提高, 因此, 可看出<i>W</i><sub><i>i</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>) 与<i>W</i><sub><i>k</i></sub> (<i>D</i><sub><i>k</i>, <i>q</i></sub>) 随<i>D</i><sub><i>k</i>, <i>q</i></sub>下降呈单调下降。由此证明引理3。</p>
                </div>
                <div class="p1">
                    <p id="195">引理3说明如果赠予线程减小其截止期 (将富余时间赠予受赠线程) , 赠予线程可能获得其他的富余时间。因此, 每个赠予步骤中将赠予时间设置较小, 从而增加找到其他富余时间的概率 (算法第7行) , 赠予完成后, 每个赠予线程保持更新其富余时间量, 以期找到其他的富余时间 (算法11行) 。</p>
                </div>
                <div class="area_img" id="355">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904033_35500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="356">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904033_35600.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="356">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904033_35601.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="235" name="235"><b>4.2 计算复杂度分析</b></h4>
                <div class="p1">
                    <p id="236">本文线程级调度算法迭代地为各线程分配优先级。如果算法2分配失败, 则启动算法4, 算法4中建立基于候选线程的集合, 并为<i>n</i>个线程进行可调度性判定, 复杂度为<i>O</i> (<i>n</i><sup>2</sup>) 。算法中循环体 (6～12行) 最多重复<i>S</i><mathml id="237"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>s</mi><mo>, </mo><mi>e</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>/<i>Ω</i>次, 其中<i>S</i><mathml id="238"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>s</mi><mo>, </mo><mi>e</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>&lt;<i>T</i><sub><i>s</i></sub>。因为最外层循环 (2～14行) 最多重复<i>n</i>次, 所以算法4的可调度性判定次数为max{<i>O</i> (<i>n</i><sup>3</sup>) , <i>O</i> (<i>nT</i><sub>max</sub>) }, 其中<i>T</i><sub>max</sub>代表所有任务中的最大<i>T</i><sub><i>i</i></sub>。因为本算法中截止期的调节最多发生<i>n</i>次, 所以可调度判定的次数为max{<i>O</i> (<i>n</i><sup>4</sup>) , <i>O</i> (<i>nT</i><sub>max</sub>) }。</p>
                </div>
                <h3 id="239" name="239" class="anchor-tag"><b>5 仿真实验与结果分析</b></h3>
                <h4 class="anchor-tag" id="240" name="240"><b>5.1 仿真环境</b></h4>
                <div class="p1">
                    <p id="241">为了简化表达, 定义以下术语:<i>C</i><sub><i>i</i></sub>表示<i>τ</i><sub><i>i</i></sub> (∑<sub><i>q</i></sub><i>C</i><sub><i>i</i>, <i>q</i></sub>) 内所有线程最差情况的运行时间总和, <i>U</i><sub>sys</sub>表示系统利用率, <i>L</i><sub><i>i</i></sub>是<i>τ</i><sub><i>i</i></sub>最坏情况的执行时间, <i>LU</i><sub>sys</sub>定义为任务<i>τ</i><sub><i>i</i></sub>∈<i>τ</i>中最大的<i>L</i><sub><i>i</i></sub>/<i>D</i><sub><i>i</i></sub>值。</p>
                </div>
                <div class="p1">
                    <p id="242">采用文献<citation id="348" type="reference">[<a class="sup">18</a>]</citation>的方法生成DAG任务, 对于任务<i>τ</i><sub><i>i</i></sub>, 其参数如下设置:节点数量<i>n</i><sub><i>i</i></sub>均匀选择于区间[1, <i>N</i><sub>max</sub>]内, 其中<i>N</i><sub>max</sub>为单个任务的线程数量上限。每对节点之间边随机地生成, 概率为<i>p</i>。根据<i>C</i><sub><i>i</i>, <i>p</i></sub>值所属的三个范围[1, 5]、 (6, 10]、 (11, 40], 分别为任务<i>τ</i><sub><i>i</i></sub>与每个线程分配一个类型 (轻型、中等、重型) , 同时确定<i>T</i><sub><i>i</i></sub> (=<i>D</i><sub><i>i</i></sub>) 参数, 因此<i>C</i><sub><i>i</i></sub>/<i>T</i><sub><i>i</i></sub>值分别在[0.1, 0.3], (0.3, 0.6]或 (0.6, 1.0]随机地选择。</p>
                </div>
                <div class="p1">
                    <p id="243">为了全面地测试本算法对并行DAG任务的性能, 共设计了三种测试统计量: (1) 系统利用率; (2) 并行度; (3) 节点总数量。第一组实验评估了系统对<i>U</i><sub>sys</sub>的调度性能变化情况, 结果如图3所示。第二组实验评估了算法对不同任务内并行度的调度性能变化情况, 结果如图4所示。第三组实验评估了算法对<i>τ</i>中节点总数量的调度性能变化情况, 结果如图5、图6所示。将本文算法与基本OPA算法<citation id="350" type="reference"><link href="316" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>、B_task_EDF<citation id="351" type="reference"><link href="330" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>以及C_task_EDF<citation id="352" type="reference"><link href="332" rel="bibliography" /><sup>[<a class="sup">20</a>]</sup></citation>三种算法进行横向比较, 评估本算法的性能。</p>
                </div>
                <div class="area_img" id="244">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904033_244.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 不同Usys的调度性能变化情况" src="Detail/GetImg?filename=images/JYRJ201904033_244.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 不同<i>U</i><sub>sys</sub>的调度性能变化情况  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904033_244.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="245">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904033_245.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 不同任务内并行度的调度性能变化情况" src="Detail/GetImg?filename=images/JYRJ201904033_245.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 不同任务内并行度的调度性能变化情况  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904033_245.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="246">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904033_246.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 对τ中节点总数量的调度性能变化情况" src="Detail/GetImg?filename=images/JYRJ201904033_246.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 对<i>τ</i>中节点总数量的调度性能变化情况  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904033_246.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="247">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904033_247.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 本调度算法的计算时间与任务内节点总数量的关系" src="Detail/GetImg?filename=images/JYRJ201904033_247.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 本调度算法的计算时间与任务内节点总数量的关系  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904033_247.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="248" name="248"><b>5.1.1</b> 第一组实验的任务集生成方法</h4>
                <div class="p1">
                    <p id="249">设置<i>p</i>=0.5、<i>N</i><sub>max</sub>=10、<i>m</i>=8的情况, 生成1 000个任务集。生成准确的<i>U</i><sub>sys</sub>难度较大, 所以本文生成任务所采用的<i>U</i><sup>*</sup>上下界分别为<i>U</i><mathml id="250"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>max</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>=<i>U</i><sup>*</sup>+0.005与<i>U</i><mathml id="251"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>min</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>=<i>U</i><sup>*</sup>-0.005。生成任务集的步骤为:</p>
                </div>
                <div class="p1">
                    <p id="252">步骤1:随机地将任务逐个加入任务集中;</p>
                </div>
                <div class="p1">
                    <p id="253">步骤2:如果某个任务加入之后导致<i>U</i><sup>*</sup>&gt;<i>U</i><mathml id="254"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>max</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>, 则忽略该集合并返回步骤1;</p>
                </div>
                <div class="p1">
                    <p id="255">步骤3:如果一个任务加入后导致<i>U</i><mathml id="256"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>min</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>≤<i>U</i><sup>*</sup>≤<i>U</i><mathml id="257"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>max</mi></mrow><mo>*</mo></msubsup></mrow></math></mathml>, 则采用该任务集进行实验。</p>
                </div>
                <div class="p1">
                    <p id="258">将<i>U</i><sup>*</sup>从1增加至8, 步长设为0.4, 因此实验的任务集数量为18 000。</p>
                </div>
                <h4 class="anchor-tag" id="259" name="259"><b>5.1.2</b> 第二组实验的任务集生成方法</h4>
                <div class="p1">
                    <p id="260">设置<i>m</i>=8、<i>N</i><sub>max</sub>=10、<i>p</i>为变量因子, 生成1 000个任务集, 步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="261">步骤1:使用上述参数生成<i>m</i>个任务的任务集;</p>
                </div>
                <div class="p1">
                    <p id="262">步骤2:如果任务集的<i>U</i><sub>sys</sub>大于<i>m</i>, 则忽略该任务集并返回步骤1;</p>
                </div>
                <div class="p1">
                    <p id="263">步骤3:采用此时的任务集进行实验, 然后向该任务集添加一个任务, 并返回步骤2直至生成1 000个任务集。</p>
                </div>
                <div class="p1">
                    <p id="264">对于节点间的边, 如果<i>p</i>=0, 则没有边 (不存在父线程) , 此时任务内的并行度为最大;如果<i>p</i>=1, 每个节点均与其他节点连接, 说明一个任务内同时仅一个线程运行;随着<i>p</i>值增加, 每个DAG任务<i>τ</i><sub><i>i</i></sub>内边的数量增加, 由此导致关键的执行路径<i>L</i><sub><i>i</i></sub>变长, 然后<i>LU</i><sub>sys</sub>增加。</p>
                </div>
                <div class="p1">
                    <p id="265">为了针对不同的任务内并行度进行仿真, 在10个不同的<i>p</i>值下, 进行仿真实验, <i>p</i>值从0.1增加至1, 步长为0.1, 共有10 000个仿真。</p>
                </div>
                <h4 class="anchor-tag" id="266" name="266"><b>5.1.3</b> 第三组实验的任务集生成方法</h4>
                <div class="p1">
                    <p id="267">第三组实验采用第一组实验的参数设置, 将任务逐个加入任务集直至<i>τ</i>中节点数量达到给定的节点总数量, 任务的节点数量范围为[1, 给定的总节点数量-<i>τ</i>中节点数量]。将节点总数量从10增加至100, <i>p</i>=0.5, <i>U</i><sup>*</sup>=<i>m</i>/2。每个数据点包含1 000个仿真, 共有10 000个仿真。</p>
                </div>
                <h4 class="anchor-tag" id="268" name="268"><b>5.2 实验结果与分析</b></h4>
                <div class="p1">
                    <p id="269">从图3中可看出, <i>U</i><sup>*</sup>从1到5.8, 本算法的检测率远超过其他三个算法。将本算法与OPA基本算法相比, 可看出本文细粒度的调度算法 (线程为调度单位) 明显提高了调度算法的性能, 同时本算法优于两个EDF的增强算法, 可看出本算法中采用线程级调度、动态线程截止期等设计具有显著的效果。</p>
                </div>
                <div class="p1">
                    <p id="270">图4所示为检测率与<i>p</i>值的关系, <i>p</i>值增加引起每个DAG任务的边数量增加, 从而使得节点间依赖的关系度升高。从图中可看出, 线程级优先级分配算法在<i>p</i>值较小时具有较好的性能, 而当<i>p</i>值为1时, 本算法与基本OPA算法、C_task_EDF性能接近, 此时一个DAG任务中所有节点均被连接, 任务均为单线程任务。B_task_EDF的检测率随着<i>p</i>值的增加而降低, 主要原因是该方法的调度性判定<i>LU</i><sub>sys</sub>是否小于阈值<i>m</i>/ (2<i>m</i>-1) , 随着<i>p</i>值的增加, <i>LU</i><sub>sys</sub>值升高, 导致可调度性下降。</p>
                </div>
                <div class="p1">
                    <p id="271">为了测试本算法对不同数量线程的性能, 将线程数量设为因变量, 统计系统检测率的变化情况。图5中可看出, 节点数量较多时, 本算法优于其他三个算法。节点数量越多, 本算法调节线程截止期的机会越多, 因此可调度性越高。</p>
                </div>
                <div class="p1">
                    <p id="272">图6是本算法计算时间与任务内节点数量的关系, 可看出节点数量越高, 算法的计算时间越高。虽然对于100个线程的任务, 本算法的计算时间约为2.2 s, 但是本算法将实时系统的检测率提高到约60%。</p>
                </div>
                <h3 id="273" name="273" class="anchor-tag"><b>6 结 语</b></h3>
                <div class="p1">
                    <p id="274">现有实时系统调度算法将任务作为调度单位, 严重限制了多线程任务的调度性能, 并且已有的算法大多对一些经典的调度算法进行可调度性分析, 以期通过优化可调度性判定条件提高算法的可调度性。然而受限于原调度算法的性能限制, 通过收紧可调度性判定条件所获得的性能提升往往较为有限。本文提出了一种细粒度的线程级多处理器实时调度算法, 并给出了详细的可调度性分析, 仿真实验结果表明, 本算法对于多线程任务的实时系统具有较好的性能, 对高线程数量的任务具有明显地优势。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="294">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201709004&amp;v=MTgyNjR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnl6bVViekxMejdCZHJHNEg5Yk1wbzlGWUlRS0RIODQ=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 姜浩, 杜琦, 郭敏, 等. 面向ARMv8 64位多核处理器的QGEMM设计与实现[J]. 计算机学报, 2017, 40 (9) :2018-2029.
                            </a>
                        </p>
                        <p id="296">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201607008&amp;v=MDUxMjI4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeXptVWJ6TEx6N0JiYkc0SDlmTXFJOUZiSVFLREg=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 焦文喆, 翟正军, 王国庆. 时间触发AFDX调度设计及实时性分析[J]. 计算机工程, 2016, 42 (7) :42-48.
                            </a>
                        </p>
                        <p id="298">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXWX201607022&amp;v=Mjk2MDY0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5em1VYnpMUFRYY2RyRzRIOWZNcUk5SFpvUUtESDg0dlI=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> 徐俊, 汤庸, 刘道余. 基于混合差分粒子群算法的MapReduce任务调度算法研究[J]. 小型微型计算机系统, 2016, 37 (7) :1479-1481.
                            </a>
                        </p>
                        <p id="300">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201501021&amp;v=MTMwNjBGckNVUjdxZlp1WnRGeXptVWJ6TEx6N0JiN0c0SDlUTXJvOUhaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEc=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b> 杨辉华, 张晓凤, 谢谱模, 等. 基于布谷鸟搜索的多处理器任务调度算法[J].计算机科学, 2015, 42 (1) :86-89.
                            </a>
                        </p>
                        <p id="302">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Response-Time Analysis of Conditional DAG Tasks in Multiprocessor Systems">

                                <b>[5]</b> Melani A, Bertogna M, Bonifaci V, et al. Response-Time Analysis of Conditional DAG Tasks in Multiprocessor Systems[J]. Molecular Immunology, 2015, 25 (4) :329-335.
                            </a>
                        </p>
                        <p id="304">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201712012&amp;v=MDMxOTZab1FLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeXptVWJ6TEx6N0JiYkc0SDliTnJZOUU=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> 梁浩, 晏立, 沈项军. 全局固定优先级实时调度算法分析[J]. 计算机工程, 2017, 43 (12) :65-68.
                            </a>
                        </p>
                        <p id="306">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Bounding Carry-in Interference to Improve Fixed-Priority Global Multiprocessor Scheduling Analysis">

                                <b>[7]</b> Guan N, Han M, Gu C, et al. Bounding Carry-in Interference to Improve Fixed-Priority Global Multiprocessor Scheduling Analysis[C]//IEEE International Conference on Embedded and Real-Time Computing Systems and Applications. IEEE, 2015:11-20.
                            </a>
                        </p>
                        <p id="308">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=FJOS: Practical predictable and efficient system support for fork/join parallelism">

                                <b>[8]</b> Qi Wang, Parmer, G. FJOS: Practical, predictable, and efficient system support for fork/join parallelism[C]//2014 IEEE Real-Time and Embedded Technology and Applications Symposium (RTAS) .IEEE Computer Society, 2014:25-36.
                            </a>
                        </p>
                        <p id="310">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Global EDF scheduling for parallel real-time tasks">

                                <b>[9]</b> Li J, Luo Z, Ferry D, et al. Global EDF scheduling for parallel real-time tasks[J]. Real-Time Systems, 2015, 51 (4) :395-439.
                            </a>
                        </p>
                        <p id="312">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Response-time analysis of parallel fork-join w orkloads w ith real-time constraints">

                                <b>[10]</b> Axer P, Quinton S, Neukirchner M, et al. Response-Time Analysis of Parallel Fork-Join Workloads with Real-Time Constraints[C]//Euromicro Conference on Real-Time Systems. IEEE Computer Society, 2013:215-224.
                            </a>
                        </p>
                        <p id="314">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000008598&amp;v=MjUxMDBIdGpOcjQ5RlpPc0hDWFV4b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcnpJSkYwV2FSRT1OaWZJWTdLNw==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b> Davis R I, Burns A. A survey of hard real-time scheduling for multiprocessor systems[J]. Acm Computing Surveys, 2011, 43 (4) .
                            </a>
                        </p>
                        <p id="316">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Improved priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems">

                                <b>[12]</b> Davis R I, Burns A. Improved priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems[J].Real-Time Systems, 2011, 47 (1) :1-40.
                            </a>
                        </p>
                        <p id="318">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A real-time scheduling service for parallel tasks">

                                <b>[13]</b> Ferry D, Li J, Mahadevan M, et al. A real-time scheduling service for parallel tasks[C]//Real-Time and Embedded Technology and Applications Symposium (RTAS) , 2013 IEEE 19th. IEEE, 2013: 261-272.
                            </a>
                        </p>
                        <p id="320">
                            <a id="bibliography_14" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WJFZ201310005&amp;v=MDAzNTR6bVViekxNaWZOZExHNEg5TE5yNDlGWVlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnk=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[14]</b> 林英, 孟正, 康雁, 等. 多核下一种线程调度算法的研究与实现[J]. 计算机技术与发展, 2013 (10) :19-22.
                            </a>
                        </p>
                        <p id="322">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Priority Assignment for Global Fixed Priority Pre-Emptive Scheduling in Multiprocessor Real-Time Systems">

                                <b>[15]</b> Davis R I, Burns A. Priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems[C]//Real-Time Systems Symposium, 2009, RTSS 2009. 30th IEEE. IEEE, 2009: 398-409.
                            </a>
                        </p>
                        <p id="324">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Improved Schedulability Analysis of EDF on Multiprocessor PlatfoDMs">

                                <b>[16]</b> Bertogna M, Cirinei M, Lipari G. Improved schedulability analysis of EDF on multiprocessor platforms[C]//Real-Time Systems, 2005. (ECRTS 2005) . Proceedings. 17th Euromicro Conference on. IEEE, 2005: 209-218.
                            </a>
                        </p>
                        <p id="326">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD13062800009746&amp;v=MTI2NzBnL29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXJ6SUpGMFdhUkU9Tmo3QmFySzdIdGZPcDQ5RlpPc0dDMw==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b> Saifullah A, Li J, Agrawal K, et al. Multi-core real-time scheduling for generalized parallel task models[J]. Real-Time Systems, 2013, 49 (4) : 404-435.
                            </a>
                        </p>
                        <p id="328">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Random graph generation for scheduling simulations">

                                <b>[18]</b> Cordeiro D, Mounié G, Perarnau S, et al. Random graph generation for scheduling simulations[C]//Proceedings of the 3rd International ICST Conference on Simulation Tools and Techniques. 2010.
                            </a>
                        </p>
                        <p id="330">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Improved Multiprocessor Global Schedulability Analysis of Sporadic DAG Task Systems">

                                <b>[19]</b> Baruah S. Improved Multiprocessor Global Schedulability Analysis of Sporadic DAG Task Systems[C]//Proceedings of the 2014 26th Euromicro Conference on Real-Time Systems. IEEE, 2014:97-105.
                            </a>
                        </p>
                        <p id="332">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Global EDF schedulability analysis for synchronous parallel tasks on multicore platforms">

                                <b>[20]</b> Chwa H S, Lee J, Phan K M, et al. Global edf schedulability analysis for synchronous parallel tasks on multicore platforms[C]//Proceedings of the 2013 25th Euromicro Conference on Real-Time Systems. IEEE, 2013: 25-34.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JYRJ201904033" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201904033&amp;v=MDQ5OTZaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeXptVWJ6TEx6VFpaTEc0SDlqTXE0OUc=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="1" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
