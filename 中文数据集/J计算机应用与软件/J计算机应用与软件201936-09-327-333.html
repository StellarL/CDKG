<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637135598340315000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJYRJ201909057%26RESULT%3d1%26SIGN%3dHjhr0dtR43jwSLr%252bNM0hAGjIuCQ%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201909057&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201909057&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201909057&amp;v=MjYwNTc0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5amtVYnZOTHpUWlpMRzRIOWpNcG85QVk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#41" data-title="&lt;b&gt;0 引 言&lt;/b&gt; "><b>0 引 言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#46" data-title="&lt;b&gt;1 相关工作&lt;/b&gt; "><b>1 相关工作</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#51" data-title="&lt;b&gt;2 缓冲区溢出漏洞自动化利用&lt;/b&gt; "><b>2 缓冲区溢出漏洞自动化利用</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#56" data-title="&lt;b&gt;2.1 基于符号执行的漏洞检测&lt;/b&gt;"><b>2.1 基于符号执行的漏洞检测</b></a></li>
                                                <li><a href="#107" data-title="&lt;b&gt;2.2 基于约束求解的利用生成&lt;/b&gt;"><b>2.2 基于约束求解的利用生成</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#165" data-title="&lt;b&gt;3 实验与分析&lt;/b&gt; "><b>3 实验与分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#167" data-title="&lt;b&gt;3.1 漏洞检测&lt;/b&gt;"><b>3.1 漏洞检测</b></a></li>
                                                <li><a href="#172" data-title="&lt;b&gt;3.2 漏洞利用&lt;/b&gt;"><b>3.2 漏洞利用</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#183" data-title="&lt;b&gt;4 结 语&lt;/b&gt; "><b>4 结 语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#55" data-title="图1 漏洞自动利用系统设计">图1 漏洞自动利用系统设计</a></li>
                                                <li><a href="#61" data-title="&lt;b&gt;表1 危险函数列表&lt;/b&gt;"><b>表1 危险函数列表</b></a></li>
                                                <li><a href="#127" data-title="图2 shellcode分段存放">图2 shellcode分段存放</a></li>
                                                <li><a href="#169" data-title="&lt;b&gt;表2 漏洞检测结果&lt;/b&gt;"><b>表2 漏洞检测结果</b></a></li>
                                                <li><a href="#171" data-title="图3 漏洞检测时间对比">图3 漏洞检测时间对比</a></li>
                                                <li><a href="#177" data-title="&lt;b&gt;表3 漏洞自动利用结果对比&lt;/b&gt;"><b>表3 漏洞自动利用结果对比</b></a></li>
                                                <li><a href="#179" data-title="图5 shellcode连续存放">图5 shellcode连续存放</a></li>
                                                <li><a href="#181" data-title="图6 shellcode分段存放">图6 shellcode分段存放</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" 中国信息安全测评中心.2017年国内外信息安全漏洞情况[J].中国信息安全,2018(1):117-121." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=CINS201801046&amp;v=MDk2OTJPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5amtVYnZOSmlURmZiRzRIOW5Ncm85QllvUUtESDg0dlI0VDZqNTQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         中国信息安全测评中心.2017年国内外信息安全漏洞情况[J].中国信息安全,2018(1):117-121.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title=" CNNVD[OL].http://www.cnnvd.org.cn." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=CNNVD[OL]">
                                        <b>[2]</b>
                                         CNNVD[OL].http://www.cnnvd.org.cn.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" Brumley D,Poosankam P,Song D,et al.Automatic patch-based exploit generation is possible:Techniques and implications[C]//Proceedings of the 2008 IEEE Symposium on Security and Privacy.IEEE,2008:143-157." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Automatic Patch- Based Exploit Generation is Possible: Techniques and Implications,&amp;quot;">
                                        <b>[3]</b>
                                         Brumley D,Poosankam P,Song D,et al.Automatic patch-based exploit generation is possible:Techniques and implications[C]//Proceedings of the 2008 IEEE Symposium on Security and Privacy.IEEE,2008:143-157.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title=" Avgerinos T,Cha S K,Rebert A,et al.Automatic exploit generation[J].Communications of the ACM,2014,57(2):74-84." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM14021300000074&amp;v=MDkyNTd0UE5ySTlGWk9zUERIczlvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyeklJRjhXYmhjPU5pZklZN0s4SA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                         Avgerinos T,Cha S K,Rebert A,et al.Automatic exploit generation[J].Communications of the ACM,2014,57(2):74-84.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" Heelan S,Kroening D.Automatic generation of control flow hijacking exploits for software vulnerabilities[D].University of Oxford,2009." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Automatic generation of control flow hijacking exploits for software vulnerabilities">
                                        <b>[5]</b>
                                         Heelan S,Kroening D.Automatic generation of control flow hijacking exploits for software vulnerabilities[D].University of Oxford,2009.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" Cha S S K,Avgerinos T T,Rebert A A,et al.Unleashing Mayhem on Binary Code[C]//Proceedings of the 2012 IEEE Symposium on Security and Privacy.IEEE,2012:380-394." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Unleashing Mayhem on Binary Code">
                                        <b>[6]</b>
                                         Cha S S K,Avgerinos T T,Rebert A A,et al.Unleashing Mayhem on Binary Code[C]//Proceedings of the 2012 IEEE Symposium on Security and Privacy.IEEE,2012:380-394.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title=" Wang M,Su P,Li Q,et al.Automatic Polymorphic Exploit Generation for Software Vulnerabilities[M]//Security and Privacy in Communication Networks.Springer International Publishing,2013:216-233." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Automatic polymorphic exploit generation for software vulnerabilities">
                                        <b>[7]</b>
                                         Wang M,Su P,Li Q,et al.Automatic Polymorphic Exploit Generation for Software Vulnerabilities[M]//Security and Privacy in Communication Networks.Springer International Publishing,2013:216-233.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title=" Huang S K,Huang M H,Huang P Y,et al.Software Crash Analysis for Automatic Exploit Generation on Binary Programs[J].IEEE Transactions on Reliability,2014,63(1):270-289." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Software crash analysis for automatic exploit generation on binary programs">
                                        <b>[8]</b>
                                         Huang S K,Huang M H,Huang P Y,et al.Software Crash Analysis for Automatic Exploit Generation on Binary Programs[J].IEEE Transactions on Reliability,2014,63(1):270-289.
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title=" Hu H,Chua Z L,Adrian S,et al.Automatic Generation of Data-Oriented Exploits[C]//24th USENIX Security Symposium.Washington:USENIX Association,2015:177-179." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Automatic generation of data-oriented exploits">
                                        <b>[9]</b>
                                         Hu H,Chua Z L,Adrian S,et al.Automatic Generation of Data-Oriented Exploits[C]//24th USENIX Security Symposium.Washington:USENIX Association,2015:177-179.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title=" Wang Y,Zhang C,Xiang X,et al.Revery:From Proof-of-Concept to Exploitable[C]//Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security.New York,USA:ACM,2018:1914-1927." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Revery From Proof-of-Concept to Exploitable">
                                        <b>[10]</b>
                                         Wang Y,Zhang C,Xiang X,et al.Revery:From Proof-of-Concept to Exploitable[C]//Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security.New York,USA:ACM,2018:1914-1927.
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title=" Alhuzali A,Gjomemo R,Eshete B,et al.NAVEX:Precise and scalable exploit generation for dynamic web applications[C]//27th USENIX Security Symposium,Washington:USENIX Association,2018:377-392." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=NAVEX Precise and scalable exploit generation for dynamic web applications">
                                        <b>[11]</b>
                                         Alhuzali A,Gjomemo R,Eshete B,et al.NAVEX:Precise and scalable exploit generation for dynamic web applications[C]//27th USENIX Security Symposium,Washington:USENIX Association,2018:377-392.
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" title=" Roemer R,Buchanan E,Shacham H,et al.Return-Oriented Programming:Systems,Languages,and Applications[J].Acm Transactions on Information &amp;amp; System Security,2012,15(1):1-34." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000014032&amp;v=MjYyMDg2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXJ6SUlGOFdiaGM9TmlmSVk3SzdIdGpOcjQ5RlpPb0xESDg3b0JNVA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[12]</b>
                                         Roemer R,Buchanan E,Shacham H,et al.Return-Oriented Programming:Systems,Languages,and Applications[J].Acm Transactions on Information &amp;amp; System Security,2012,15(1):1-34.
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title=" Shoshitaishvili Y,Kruegel C,Vigna G,et al.SOK:(State of) The Art of War:Offensive Techniques in Binary Analysis[C]//2016 IEEE Symposium on Security and Privacy.IEEE Computer Society,2016:138-157." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=&amp;quot;SOK: (State of)The Art of War:Offensive Techniques in Binary Analysis,&amp;quot;">
                                        <b>[13]</b>
                                         Shoshitaishvili Y,Kruegel C,Vigna G,et al.SOK:(State of) The Art of War:Offensive Techniques in Binary Analysis[C]//2016 IEEE Symposium on Security and Privacy.IEEE Computer Society,2016:138-157.
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_14" title=" King J C.Symbolic execution and program testing[J].Communications of the ACM,1976,19(7):385-394." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000024473&amp;v=MTU5NThud1plWnRGaW5sVXJ6SUlGOFdiaGM9TmlmSVk3SzdIdGpOcjQ5RlpPa0xDSHM2b0JNVDZUNFBRSC9pclJkR2VycVFUTQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[14]</b>
                                         King J C.Symbolic execution and program testing[J].Communications of the ACM,1976,19(7):385-394.
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_15" title=" 苏璞睿,应凌云,杨轶.软件安全分析与应用[M].北京:清华大学出版社,2017." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787302472070000&amp;v=MDYzNTdCTTh6eFVTbURkOVNIN24zeEU5ZmJ2bktyaWZaZVp2RnlubVU3L0pJbG9SWEZxekdiQzRITlhMclk5Q1pPc1BE&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                         苏璞睿,应凌云,杨轶.软件安全分析与应用[M].北京:清华大学出版社,2017.
                                    </a>
                                </li>
                                <li id="33">


                                    <a id="bibliography_16" title=" Kiss K,Jsz J,Lehotai G,et al.Interprocedural Static Slicing of Binary Executables[C]//Proceedings Third IEEE International Workshop on Source Code Analysis and Manipulation.IEEE,2003:118-127." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Interprocedural Static Slicing of Binary Executables">
                                        <b>[16]</b>
                                         Kiss K,Jsz J,Lehotai G,et al.Interprocedural Static Slicing of Binary Executables[C]//Proceedings Third IEEE International Workshop on Source Code Analysis and Manipulation.IEEE,2003:118-127.
                                    </a>
                                </li>
                                <li id="35">


                                    <a id="bibliography_17" title=" Schwartz E J,Avgerinos T,Brumley D.All you ever wanted to know about dynamic taint analysis and forward symbolic execution[C]//IEEE Symposium on Security and Privacy.Piscataway,2010:317-331." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask)">
                                        <b>[17]</b>
                                         Schwartz E J,Avgerinos T,Brumley D.All you ever wanted to know about dynamic taint analysis and forward symbolic execution[C]//IEEE Symposium on Security and Privacy.Piscataway,2010:317-331.
                                    </a>
                                </li>
                                <li id="37">


                                    <a id="bibliography_18" title=" Moura L D,Bj∅rner N.Z3:an efficient SMT solver[C]//Proceedings of the Theory and practice of software,14th international conference on Tools and algorithms for the construction and analysis of systems.Springer-Verlag,2008:337-340." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Z3:An efficient smt solver">
                                        <b>[18]</b>
                                         Moura L D,Bj∅rner N.Z3:an efficient SMT solver[C]//Proceedings of the Theory and practice of software,14th international conference on Tools and algorithms for the construction and analysis of systems.Springer-Verlag,2008:337-340.
                                    </a>
                                </li>
                                <li id="39">


                                    <a id="bibliography_19" title=" Shacham H,Page M,Pfaff B,et al.On the effectiveness of address-space randomization[C]//Proceedings of the 11th ACM Conference on Computer and Communications Security,CCS 2004,Washington,DC,USA,October 25-29,2004.ACM,2004:298-307." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On the effectiveness of address-space random-ization">
                                        <b>[19]</b>
                                         Shacham H,Page M,Pfaff B,et al.On the effectiveness of address-space randomization[C]//Proceedings of the 11th ACM Conference on Computer and Communications Security,CCS 2004,Washington,DC,USA,October 25-29,2004.ACM,2004:298-307.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JYRJ" target="_blank">计算机应用与软件</a>
                2019,36(09),327-333 DOI:10.3969/j.issn.1000-386x.2019.09.056            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于符号执行的缓冲区溢出漏洞自动化利用</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9D%8E%E8%B6%85&amp;code=10168992&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">李超</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%83%A1%E5%BB%BA%E4%BC%9F&amp;code=09091878&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">胡建伟</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%B4%94%E8%89%B3%E9%B9%8F&amp;code=10168511&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">崔艳鹏</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AD%A6%E9%99%A2&amp;code=0008505&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">西安电子科技大学网络与信息安全学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>软件规模与数量的快速增长给软件安全研究带来了严峻的挑战,以人工方式分析漏洞已难以完成漏洞危害性的评估。分析缓冲区溢出漏洞的形成原理,提出一种缓冲区溢出漏洞自动化利用方法。该方法采用符号执行检测漏洞,为缓解符号执行中状态爆炸问题,使用危险函数切片减少状态数量。对于检测到的漏洞,通过构建约束表达式和约束求解自动生成exploit。针对进程中不存在空间足够的可控内存块的情况,以shellcode分段存放的方式利用漏洞。实验结果表明,该方法可有效缓解符号执行路径爆炸问题,自动检测漏洞并生成适用性较好的exploit。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">缓冲区溢出;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">符号执行;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A8%8B%E5%BA%8F%E5%88%87%E7%89%87&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">程序切片;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%A9%E7%94%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">自动化利用;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    李超,硕士生,主研领域:软件安全。;
                                </span>
                                <span>
                                    胡建伟,副教授。;
                                </span>
                                <span>
                                    崔艳鹏,副教授。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2019-01-20</p>

            </div>
                    <h1><b>AUTOMATIC EXPLOIT GENERATION FOR BUFFER OVERFLOW BASED ON SYMBOLIC EXECUTION</b></h1>
                    <h2>
                    <span>Li Chao</span>
                    <span>Hu Jianwei</span>
                    <span>Cui Yanpeng</span>
            </h2>
                    <h2>
                    <span>School of Cyber Engineering, Xidian University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>The rapid growth of the software scale and quantity has brought severe challenges to software security research. It is difficult to perform vulnerability assessment by analyzing the vulnerability manually. This paper analyzed the principle of buffer overflow and proposed an automatic exploit generation method. The method used symbolic execution to detect vulnerabilities. To alleviate the state explosion of symbolic execution, we pruned the states according to the slice of unsafe function calls. For detected vulnerabilities, exploit was automatically generated by constructing constraint expressions and constraint solving. In the case that there was no enough controllable memory block in the process, we segmented shellcode to construct the exploit. The experimental results show that the method can detect vulnerabilities and generate exploit with good applicability automatically.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Buffer%20overflow&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Buffer overflow;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Symbolic%20execution&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Symbolic execution;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Program%20slicing&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Program slicing;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Automatic%20exploit%20generation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Automatic exploit generation;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2019-01-20</p>
                            </div>


        <!--brief start-->
                        <h3 id="41" name="41" class="anchor-tag"><b>0 引 言</b></h3>
                <div class="p1">
                    <p id="42">信息技术的快速发展使得计算机软件在社会活动与工业生产中起着越来越重要的作用。同时,软件规模与数量的快速增长给信息安全带来了严峻的挑战。信息系统中存在软件漏洞是导致信息安全问题的重要原因。软件漏洞通常指软件系统在设计、实现、配置、运行等过程中,由操作实体有意或无意产生的缺陷、瑕疵或错误,它们以不同形式存在于信息系统的各个层次与环节中。为确保信息系统的安全,众多研究人员对漏洞分析与防护问题进行了大量的研究工作。然而,由于冯·诺依曼计算机体系自身的缺陷,以及当前软件系统的代码规模和技术复杂度的急剧提升,并且在软件生命周期的每个阶段都需要人工参与,难免会引入一些错误,导致无法彻底清除软件中存在的漏洞。</p>
                </div>
                <div class="p1">
                    <p id="43">在不能完全杜绝漏洞存在的情况下,需对其进行分析与研究,以最小化漏洞所带来的损失。由于大多数商业软件都不公开源码,并且二进制代码是软件的最终表现形式,分析二进制代码可以更加全面和直接地找到软件中存在的漏洞,因此,二进制漏洞分析技术更具有实用性。文献<citation id="185" type="reference">[<a class="sup">1</a>]</citation>的数据显示,2017年新增漏洞中,缓冲区溢出漏洞为数量最多的漏洞类型,占新增漏洞总量的18.06%,远远高于其他漏洞类型。因此,研究缓冲区溢出漏洞具有重要意义。</p>
                </div>
                <div class="p1">
                    <p id="44">面对各类信息系统中存在的大量漏洞,CNNVD<citation id="186" type="reference"><link href="5" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>等组织对漏洞进行统一的分类管理,评估漏洞的危害性并将其标记为不同危害等级,指导软件厂商采取相应的修复措施,从而减少漏洞带来的威胁和损失。通常可利用的软件漏洞具有很高的危害性,攻击者往往通过这些漏洞控制目标系统。因此,在漏洞响应过程中,需要快速甄别大量软件错误中的可利用漏洞。虽然使用模糊测试技术发现软件错误具有很好的效果,但由于漏洞类型的多样性和漏洞形成机理的复杂性,漏洞可利用性的评估和利用数据的构造通常需进行动态调试分析漏洞形成的细节,这个过程由分析人员以手工方式完成,并且要求分析人员熟悉汇编语言等计算机底层原理。随着软硬件产品和应用的快速增长,漏洞数量急剧攀升,2017年共发布漏洞信息13 417条,漏洞数量达到2016年的近2倍<citation id="187" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。因此,传统漏洞分析方式已难以应对上述挑战。</p>
                </div>
                <div class="p1">
                    <p id="45">为提高软件漏洞风险评估的效率,本文研究缓冲区溢出漏洞,提出一种面向二进制程序的自动化漏洞利用方法,通过构建exploit证明漏洞的危害性。该方法首先使用符号执行检测漏洞,然后构建路径约束表达式和利用约束表达式,最后通过约束求解器求解得到exploit。</p>
                </div>
                <h3 id="46" name="46" class="anchor-tag"><b>1 相关工作</b></h3>
                <div class="p1">
                    <p id="47">目前已有学者对自动化漏洞利用进行了研究,并取得了一定的进展。由Brumley等<citation id="188" type="reference"><link href="7" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>提出的APEG基于补丁比对的方法定位程序中已修补的漏洞,通过分析补丁中添加的过滤条件,构造不满足过滤条件的输入触发漏洞。该方法无法适用于补丁中没有添加过滤条件的情况,并且构造的输入只能进行拒绝服务攻击。相对于APEG对补丁的分析,Avgerinos等<citation id="189" type="reference"><link href="9" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>提出了基于源码的漏洞自动挖掘和利用方法AEG,AEG使用预置条件的符号执行找到程序漏洞,利用动态二进制插桩获取程序运行时信息,构建约束表达式,并求解得到可实现控制流劫持攻击的利用数据。</p>
                </div>
                <div class="p1">
                    <p id="48">为了能够在无法获取程序源码的情况下自动构造利用数据,Heelan<citation id="190" type="reference"><link href="11" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>提出了基于二进制程序的漏洞自动利用方法。该方法以可触发漏洞的样例作为输入,通过代码插桩定位到漏洞,并使用污点分析找到可用于存放攻击代码的可控内存,构建生成利用数据所需的约束表达式,最后求解得到控制流劫持攻击利用数据。Cha等<citation id="191" type="reference"><link href="13" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>提出的漏洞自动利用生成方法Mayhem使用混合符号执行技术,分析过程中符号执行引擎在离线符号执行与在线符号执行间不断切换,以减少内存消耗,缓解状态爆炸问题。此外,该方法使用基于索引的内存模型优化符号化内存的加载提高系统效率。Wang等<citation id="192" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>提出自动化生成多样性漏洞利用的方法PolyAEG,该方法以崩溃样例为输入,通过动态污点分析获得程序执行的相关信息,构建污点传播流图和全局污点状态记录获取程序中所有可能被控制的劫持点、跳板指令和内存区域,最后利用不同的跳转指令和可控制内存区域构造多样性的利用样本。Huang等<citation id="193" type="reference"><link href="17" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>提出的CRAX同样以崩溃样例为输入对程序进行全系统模拟的符号执行分析,分析过程中对漏洞利用不相关的库函数或内核函数进行具体执行,以优化符号执行,提高处理速度。该方法可适用于Microsoft office word等规模较大的应用程序。</p>
                </div>
                <div class="p1">
                    <p id="49">相对于上述面向控制流的利用方法,Hu等<citation id="194" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>提出了面向数据流的自动利用方法FlowStitch,利用内存错误修改程序数据流中的关键变量,可达到敏感信息泄露或提权的攻击效果。该方法可实现敏感信息泄露,因此实用性较强。其缺点是需要能触发内存错误的输入。由于堆管理机制的复杂性,导致堆漏洞利用的难度相对较大,Revery<citation id="195" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>对堆漏洞自动化利用问题进行了探索,在19个测试程序中可成功对9个程序生成利用。此外,NAVEX<citation id="196" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>对Web应用漏洞自动构造利用数据,可成功利用SQL注入和XSS漏洞,该方法与二进制漏洞利用有较大的差别。</p>
                </div>
                <div class="p1">
                    <p id="50">综上所述,APEG和AEG分别依赖于补丁和源码检测漏洞;Mayhem使用符号执行检测漏洞,采用具体化部分符号变量的方法减少搜索空间,但可能导致漏洞不可利用;文献<citation id="197" type="reference">[<a class="sup">5</a>]</citation>和文献<citation id="198" type="reference">[<a class="sup">7</a>,<a class="sup">8</a>,<a class="sup">9</a>]</citation>均依赖于已知的崩溃输入,无法自动检测程序中存在的漏洞。此外,上述方法未考虑进程中不存在空间足以容纳shellcode的可控内存块的情况,构造利用的适用性较差。本文所提方法使用符号执行检测漏洞,通过切片减少状态数量,并改进漏洞利用时shellcode存放方式,可提高系统适用性。</p>
                </div>
                <h3 id="51" name="51" class="anchor-tag"><b>2 缓冲区溢出漏洞自动化利用</b></h3>
                <div class="p1">
                    <p id="52">缓冲区溢出漏洞产生的原因是程序未正确检查用户输入数据的长度是否超过目标缓冲区的大小,向缓冲区写入过多数据覆盖了内存中其他数据,可能导致控制流劫持。通过缓冲区溢出劫持控制流的常见方法包括覆盖栈中函数返回地址和覆盖函数指针。利用代码注入或代码复用<citation id="199" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>可实现执行任意代码。代码注入将一段攻击代码写入进程空间,之后劫持控制流到攻击代码执行;代码复用将内存中已有的代码片段拼接成可实现特定功能的攻击链进行攻击。本文主要研究代码注入攻击的自动化。</p>
                </div>
                <div class="p1">
                    <p id="53">本文基于二进制分析框架angr<citation id="200" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>设计并实现缓冲区溢出漏洞自动利用原型系统AutoExp(Automatic Exploitation),该系统以漏洞程序为输入,使用符号执行<citation id="201" type="reference"><link href="29" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>检测漏洞,通过构建约束表达式和约束求解生成exploit。以exploit作为程序输入可触发漏洞,并利用漏洞达到获取系统控制权、运行任意代码或窃取数据等目的。</p>
                </div>
                <div class="p1">
                    <p id="54">如图1所示,自动化生成exploit包括4个步骤:1) 预处理。为了减小漏洞检测过程中符号执行的状态空间,首先扫描目标程序中危险函数调用位置,然后通过程序切片技术获取危险函数调用位置到程序入口点的代码切片。2) 漏洞检测。针对上一步得到的切片进行符号执行,记录每个状态的路径约束、寄存器和符号内存信息。同时,每运行一步均检测是否存在包含漏洞的状态。3) 构建利用约束。找到漏洞后,判断漏洞的可利用性,通过构建shellcode约束将可控内存区域的值约束为shellcode以实现攻击代码注入,构建EIP约束将EIP寄存器的值约束为shellcode存放地址以实现控制流劫持。4) 约束求解。使用约束求解器求解路径约束和利用约束,若有解则成功生成exploit。</p>
                </div>
                <div class="area_img" id="55">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909057_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 漏洞自动利用系统设计" src="Detail/GetImg?filename=images/JYRJ201909057_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 漏洞自动利用系统设计  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909057_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="56" name="56"><b>2.1 基于符号执行的漏洞检测</b></h4>
                <div class="p1">
                    <p id="57">漏洞自动化利用的前提条件为找到程序中存在的漏洞,本文采用符号执行检测漏洞。符号执行以符号变量代替具体值作为程序输入,并动态模拟执行程序中的指令,在执行过程中记录寄存器和内存状态。当遇到分支语句时,复制程序状态以便继续分析所有分支,并构建路径约束表达式记录到达不同分支的路径信息。符号执行过程中,根据不同漏洞模型设置违例断言可检测程序中存在的漏洞。</p>
                </div>
                <div class="p1">
                    <p id="58">由于符号执行分析过程中每一个分支语句都可能导致新增一条路径,所以路径数量可能按指数级别增长,即存在状态爆炸问题。为了缓解状态爆炸问题,并且使分析过程更具有针对性,本文提出基于危险函数切片的方法获取包含危险函数调用的程序切片,符号执行时根据切片剔除无关路径。</p>
                </div>
                <h4 class="anchor-tag" id="59" name="59"><b>2.1.1 预处理</b></h4>
                <div class="p1">
                    <p id="60">控制流劫持漏洞的利用主要关注漏洞脆弱点和控制流劫持点<citation id="202" type="reference"><link href="31" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>,漏洞脆弱点指导致漏洞产生的函数或指令,而控制流劫持点指程序控制流被输入数据控制的指令。缓冲区溢出漏洞多是由于程序中使用了危险函数,并且未对用户输入数据进行严格的检查所导致的。因此,缓冲区溢出漏洞的脆弱点往往为危险函数调用位置。常见危险函数如表1所示。</p>
                </div>
                <div class="area_img" id="61">
                    <p class="img_tit"><b>表1 危险函数列表</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="61" border="1"><tr><td><br />函数功能</td><td>函数名称</td></tr><tr><td><br />获取输入</td><td>gets、scanf、fscanf、vscanf、vfscanf、<br />vfwscanf、vwscanf</td></tr><tr><td><br />内存拷贝</td><td>strcpy、stpcpy、wcscpy、memcpy、wmemcpy</td></tr><tr><td><br />其他</td><td>sprintf、getwd、realpath、strcat、wcscat、wcxscat</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="62">预处理过程如算法1所示,首先通过静态分析获取程序中的脆弱点位置。具体方法为,根据预先定义的危险函数名列表unsafe_func_name查找程序链接表PLT(Procedure Linkage Table)得到危险函数地址unsafe_func_addr;根据地址查找控制流图CFG(Control Flow Graph)得到所有危险函数节点unsafe_nodes,获取危险函数节点的前驱节点即可得到危险函数调用点地址列表unsafe_callsites。接着对危险函数调用点进行程序切片<citation id="203" type="reference"><link href="33" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>,得到从程序入口点到危险函数调用点的切片。具体方法为,分析程序数据依赖关系和控制依赖关系构建数据依赖图ddg(Data Dependence Graph,DDG)和控制依赖图cdg(Control Dependence Graph,CDG),根据ddg和cdg使用轻量级污点分析<citation id="204" type="reference"><link href="35" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>从危险函数调用点target进行后向切片得到切片bk_slice。</p>
                </div>
                <div class="p1">
                    <p id="63"><b>算法1</b> 预处理</p>
                </div>
                <div class="p1">
                    <p id="64">输入:目标程序program, 危险函数名列表unsafe_func_name</p>
                </div>
                <div class="p1">
                    <p id="65">输出:程序切片bk_slice</p>
                </div>
                <div class="p1">
                    <p id="66">1 plt = get_plt(program)  // 获取程序 plt 信息</p>
                </div>
                <div class="p1">
                    <p id="67">2 cfg = create_cfg(program)  // 构建程序CFG</p>
                </div>
                <div class="p1">
                    <p id="68">/* 获取每个危险函数的调用点 */</p>
                </div>
                <div class="p1">
                    <p id="69">3 for fname in unsafe_func_name:</p>
                </div>
                <div class="p1">
                    <p id="70">4  unsafe_func_addr = plt[fname]</p>
                </div>
                <div class="p1">
                    <p id="71">// 根据CFG得到程序中所有危险函数节点</p>
                </div>
                <div class="p1">
                    <p id="72">5  unsafe_nodes = cfg.get_all_nodes(unsafe_func_addr)</p>
                </div>
                <div class="p1">
                    <p id="73">// 获取危险函数节点的前驱节点得到危险函数调用点</p>
                </div>
                <div class="p1">
                    <p id="74">6  for node in unsafe_nodes:</p>
                </div>
                <div class="p1">
                    <p id="75">7  unsafe_callsites.append(node.predecessors.addr)</p>
                </div>
                <div class="p1">
                    <p id="76">/* 根据危险函数调用点进行切片 */</p>
                </div>
                <div class="p1">
                    <p id="77">8 ddg = create_ddg(cfg)  // 构建DDG</p>
                </div>
                <div class="p1">
                    <p id="78">9 cdg = create_cdg(cfg)  // 构建CDG</p>
                </div>
                <div class="p1">
                    <p id="79">10 for target in unsafe_callsites:</p>
                </div>
                <div class="p1">
                    <p id="80">11 bs=create_backward_slice(cfg, ddg, cdg, target)  //切片</p>
                </div>
                <div class="p1">
                    <p id="81">12  bk_slice.append({‘target’: addr, ‘slice’: bs})</p>
                </div>
                <div class="p1">
                    <p id="82">13 return bk_slice</p>
                </div>
                <h4 class="anchor-tag" id="83" name="83"><b>2.1.2 漏洞检测</b></h4>
                <div class="p1">
                    <p id="84">符号执行引擎<citation id="205" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>在模拟运行程序时,以状态(state)表示程序的执行过程,其中记录了程序的执行路径和内存、寄存器等运行时信息;使用模拟管理器(SimulationManager)控制符号执行过程,可管理不同类型的状态和使用搜索策略探索程序状态空间。SimulationManager通过stash管理active、found、unconstrained等不同类型的状态,active state为当前正执行的状态,found state为通过设定探索目标所找到的状态unconstrained state为不受约束的状态。</p>
                </div>
                <div class="p1">
                    <p id="85">符号执行以符号值替换用户输入,如果程序中存在缓冲区溢出漏洞,当程序运行到漏洞劫持点时EIP寄存器将被符号化,由于符号化变量不是具体值,符号执行引擎不能确定下一步需执行的指令,导致无法继续运行,此时状态类型为unconstrained。因此,通过判断符号执行过程中是否存在unconstrained状态即可检测缓冲区溢出漏洞。</p>
                </div>
                <div class="p1">
                    <p id="86">算法2描述了漏洞检测方法。符号执行过程中,在程序入口点与脆弱点间运行时根据预处理得到的切片进行状态修剪,剔除切片之外的路径,以减少状态数量。具体方法为,符号化用户输入并创建模拟管理器simgr,接着获取切片bk_slice中脆弱点地址(即危险函数调用点)target作为符号执行的探索目标。同时设定状态修剪策略函数drop_states_not_in_slice,该函数判断active stash中的状态是否在切片范围内,若是则返回False,即保留该状态;否则返回True,丢弃该状态。当找到脆弱点状态后,丢弃active中所有状态,并把脆弱点状态从found stash移动到active stash以便从脆弱点继续运行;找到脆弱点之后继续执行,当unconstrained stash非空时则表明存在控制流劫持点,即找到漏洞状态vul_state。</p>
                </div>
                <div class="p1">
                    <p id="87"><b>算法2</b> 漏洞检测</p>
                </div>
                <div class="p1">
                    <p id="88">输入:目标程序program, 切片bk_slice</p>
                </div>
                <div class="p1">
                    <p id="89">输出:漏洞状态vul_state</p>
                </div>
                <div class="p1">
                    <p id="90">1  for slice in bk_slice:</p>
                </div>
                <div class="p1">
                    <p id="91">/*程序入口点到脆弱点间运行时根据切片进行状态修剪*/</p>
                </div>
                <div class="p1">
                    <p id="92">2 sym_input = symbolic(input)  // 符号化用户输入</p>
                </div>
                <div class="p1">
                    <p id="93">3 init_state = entry_state(program, sym_input)  //创建初始状态</p>
                </div>
                <div class="p1">
                    <p id="94">4 simgr = simulation_manager(init_state)  // 创建模拟管理器</p>
                </div>
                <div class="p1">
                    <p id="95">5 target = slice[‘target’]  // 获取脆弱点地址</p>
                </div>
                <div class="p1">
                    <p id="96">// 以脆弱点为目标进行符号执行,并设定状态修剪策略</p>
                </div>
                <div class="p1">
                    <p id="97">6 simgr.explore(find=target, filter=drop_states_not_in_slice)</p>
                </div>
                <div class="p1">
                    <p id="98">// 若找到脆弱点状态,则使active stash中只包含该状态</p>
                </div>
                <div class="p1">
                    <p id="99">7 if simgr.found not NULL:</p>
                </div>
                <div class="p1">
                    <p id="100">8  simgr.drop(stash=′active′)</p>
                </div>
                <div class="p1">
                    <p id="101">9  simgr.move(from_stash=″found″, to_stash=″active″)</p>
                </div>
                <div class="p1">
                    <p id="102">/* 从脆弱点继续探索,直到找到unconstrained状态 */</p>
                </div>
                <div class="p1">
                    <p id="103">10 while simgr.unconstrained is NULL:</p>
                </div>
                <div class="p1">
                    <p id="104">11  simgr.step()  // 向前执行一步</p>
                </div>
                <div class="p1">
                    <p id="105">12 vul_state = simgr.unconstrained</p>
                </div>
                <div class="p1">
                    <p id="106">13 return vul_state</p>
                </div>
                <h4 class="anchor-tag" id="107" name="107"><b>2.2 基于约束求解的利用生成</b></h4>
                <h4 class="anchor-tag" id="108" name="108"><b>2.2.1 利用约束构建</b></h4>
                <div class="p1">
                    <p id="109">进程空间中存在可控内存块是进行代码注入攻击的必要条件。进程中可控内存区域并非都是连续的,为了找到能存放shellcode的可控内存块,需获取可控内存块信息,包括内存块的起始地址和大小。获取可控内存块信息的方法如算法3所示,首先获取漏洞状态vul_state中符号化内存地址列表sym_addrs;然后根据地址是否连续来统计内存块的大小size,并记录内存起始地址buf_start;最后将内存块按空间从大到小的顺序排序。</p>
                </div>
                <div class="p1">
                    <p id="110"><b>算法3</b> 获取可控内存块信息</p>
                </div>
                <div class="p1">
                    <p id="111">输入:漏洞状态vul_state</p>
                </div>
                <div class="p1">
                    <p id="112">输出:符号化内存块sym_bufs  // 获取符号化内存地址列表</p>
                </div>
                <div class="p1">
                    <p id="113">1 sym_addrs = find_symbolic_addr(vul_state)</p>
                </div>
                <div class="p1">
                    <p id="114">2 while sym_addrs not NULL:</p>
                </div>
                <div class="p1">
                    <p id="115">3  size = 0  // 设定内存块初始大小</p>
                </div>
                <div class="p1">
                    <p id="116">4  buf_start = sym_addrs[0]  // 记录内存块起始地址</p>
                </div>
                <div class="p1">
                    <p id="117">/* 统计连续内存地址组成的内存块大小 */</p>
                </div>
                <div class="p1">
                    <p id="118">5  while True:</p>
                </div>
                <div class="p1">
                    <p id="119">6  if not buf_start + size in sym_addrs:</p>
                </div>
                <div class="p1">
                    <p id="120">7  break</p>
                </div>
                <div class="p1">
                    <p id="121">8  sym_addrs.remove(buf_start + size)  //删除已处理地址</p>
                </div>
                <div class="p1">
                    <p id="122">9  size += 1</p>
                </div>
                <div class="p1">
                    <p id="123">10 sym_bufs.append({‘addr’: buf_start, ‘size’: size})</p>
                </div>
                <div class="p1">
                    <p id="124">11 sorted_by_size(sym_bufs)  // 根据内存块大小排序</p>
                </div>
                <div class="p1">
                    <p id="125">12 return sym_bufs</p>
                </div>
                <div class="p1">
                    <p id="126">当进程空间中不存在足以容纳shellcode的可控内存块时,现有方法将无法成功构建exploit。如图2所示,为提高漏洞自动利用系统的适用性,AutoExp把shellcode分段存放在多个可控内存块,并使用跳转指令连接不同内存块中的攻击代码,从而完成攻击过程。</p>
                </div>
                <div class="area_img" id="127">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909057_127.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 shellcode分段存放" src="Detail/GetImg?filename=images/JYRJ201909057_127.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 shellcode分段存放  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909057_127.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="128">对shellcode分段时应确保指令的完整性,本文将机器码形式的shellcode反汇编为汇编指令,分段时以指令为基本单位。算法4具体描述了分段的方法,首先反汇编shellcode为汇编指令asm,根据可控内存块信息与shellcode大小确定分段数量和每个片段的长度segs_len;接着根据片段长度对shellcode进行分段;最后在除末尾片段外的所有片段后添加跳转指令jmp_ins。</p>
                </div>
                <div class="p1">
                    <p id="129"><b>算法4</b> shellcode分段</p>
                </div>
                <div class="p1">
                    <p id="130">输入:符号化内存块sym_bufs, 攻击代码shellcode</p>
                </div>
                <div class="p1">
                    <p id="131">输出:shellcode片段sc_segments</p>
                </div>
                <div class="p1">
                    <p id="132">1 asm = disassemble(shellcode)  // 反汇编shellcode</p>
                </div>
                <div class="p1">
                    <p id="133">/* 确定每个片段的长度 */</p>
                </div>
                <div class="p1">
                    <p id="134">2 length = 0, n = 0  // 初始化片段长度length和内存块序号n</p>
                </div>
                <div class="p1">
                    <p id="135">3 for ins in asm:</p>
                </div>
                <div class="p1">
                    <p id="136">// 若当前内存块还能容纳指令ins,则划分在该内存块</p>
                </div>
                <div class="p1">
                    <p id="137">4  if length + ins.size &lt;= sym_bufs[n].size-len(jmp_ins):</p>
                </div>
                <div class="p1">
                    <p id="138">5  length += ins.size</p>
                </div>
                <div class="p1">
                    <p id="139">6 else:  // 否则,当前内存块已存满,考虑下一个内存块</p>
                </div>
                <div class="p1">
                    <p id="140">7  segs_len.append(length)</p>
                </div>
                <div class="p1">
                    <p id="141">8  length = 0, n += 1</p>
                </div>
                <div class="p1">
                    <p id="142">/* 在除末尾片段外的所有片段后添加跳转指令 */</p>
                </div>
                <div class="p1">
                    <p id="143">9 for len in segs_len not last:</p>
                </div>
                <div class="p1">
                    <p id="144">10  sc_segments.append(shellcode[:len] + jmp_ins)</p>
                </div>
                <div class="p1">
                    <p id="145">11  shellcode = shellcode[len:]  // 删除已处理的数据</p>
                </div>
                <div class="p1">
                    <p id="146">12 sc_segments.append(shellcode)</p>
                </div>
                <div class="p1">
                    <p id="147">13 return sc_segments</p>
                </div>
                <div class="p1">
                    <p id="148">利用缓冲区溢出漏洞进行代码注入攻击需要两个步骤,分别是把攻击代码写入进程空间和劫持程序控制流到攻击代码处,该过程可通过构建shellcode约束表达式和EIP约束表达式的方法实现自动化。如算法5所示,首先需把shellcode片段写入进程中对应的可控内存块,实现方法为依次加载可控内存块sym_bufs[n],并构建约束表达式将内存块中数据约束为对应的shellcode片段sc_segments[n];接着构建约束表达式将漏洞状态的EIP寄存器值约束为shellcode存放内存的起始地址sym_bufs[0].addr。</p>
                </div>
                <div class="p1">
                    <p id="149"><b>算法5</b> 构建利用约束</p>
                </div>
                <div class="p1">
                    <p id="150">输入:漏洞状态vul_state, 符号化内存块sym_bufs, shellcode片段sc_segments</p>
                </div>
                <div class="p1">
                    <p id="151">输出:约束表达式constraints</p>
                </div>
                <div class="p1">
                    <p id="152">/* 依次约束可控内存块中数据为对应shellcode片段的值 */</p>
                </div>
                <div class="p1">
                    <p id="153">1 for n in range(len(sc_segments)):</p>
                </div>
                <div class="p1">
                    <p id="154">// 加载可控内存块</p>
                </div>
                <div class="p1">
                    <p id="155">2  memory = vul_state.load_mem(sym_bufs[n].addr)</p>
                </div>
                <div class="p1">
                    <p id="156">// 将可控内存块中数据约束为shellcode</p>
                </div>
                <div class="p1">
                    <p id="157">3  vul_state.add_constraints(memory == sc_segments[n])</p>
                </div>
                <div class="p1">
                    <p id="158">4  constraints.append(memory == sc_segments[n])</p>
                </div>
                <div class="p1">
                    <p id="159">/* 约束EIP寄存器的值为shellcode起始地址 */</p>
                </div>
                <div class="p1">
                    <p id="160">5 vul_state.add_constraints(vul_state.eip == sym_bufs[0].addr)</p>
                </div>
                <div class="p1">
                    <p id="161">6 constraints.append(vul_state.eip == sym_bufs[0].addr)</p>
                </div>
                <div class="p1">
                    <p id="162">7 return constraints</p>
                </div>
                <h4 class="anchor-tag" id="163" name="163"><b>2.2.2 约束求解</b></h4>
                <div class="p1">
                    <p id="164">对于上述构建的路径约束表达式和利用约束表达式,使用支持SMT求解理论的Z3求解器<citation id="206" type="reference"><link href="37" rel="bibliography" /><sup>[<a class="sup">18</a>]</sup></citation>进行求解。若有解,则得到一个可触发漏洞并进行代码注入攻击的exploit;若无解,则表明检测到的漏洞无法利用。</p>
                </div>
                <h3 id="165" name="165" class="anchor-tag"><b>3 实验与分析</b></h3>
                <div class="p1">
                    <p id="166">实验运行环境为Intel Core i7-7700HQ CPU,主频2.8 GHz,4 GB内存, Ubuntu 16.04 64 bits系统,测试程序使用gcc 5.4.0 编译。本文不考虑漏洞缓解机制的绕过,编译时不启用NX和Stack Canary保护,同时关闭系统ASLR保护<citation id="207" type="reference"><link href="39" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>。为验证系统的有效性,本文设置两组实验,分别用于验证漏洞检测效果和测试自动生成利用数据的有效性。</p>
                </div>
                <h4 class="anchor-tag" id="167" name="167"><b>3.1 漏洞检测</b></h4>
                <div class="p1">
                    <p id="168">实验选取以下3个已披露漏洞作为测试样本,分别使用angr和本文实现的AutoExp检测目标程序中存在的漏洞,并记录两种方法检测漏洞所需时间。实验结果如表2所示,表中第三列和第四列分别为目标程序的基本块数量和使用AutoExp进行预处理所得切片的基本块数量。从实验数据可知,使用切片技术对程序进行预处理可减少待分析程序的基本块数量,从而有效减小符号执行分析的复杂度。</p>
                </div>
                <div class="area_img" id="169">
                    <p class="img_tit"><b>表2 漏洞检测结果</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="169" border="1"><tr><td rowspan="2"><br />程序</td><td rowspan="2">漏洞编号</td><td colspan="2"><br />基本块数量</td><td colspan="2">时间/s</td></tr><tr><td><br />total</td><td>slice</td><td>angr</td><td>AutoExp</td></tr><tr><td>Squirrel Mail</td><td>CVE-2004-0524</td><td>384</td><td>30</td><td>10.61</td><td>20.87</td></tr><tr><td><br />iwconfig</td><td>CVE-2003-0947</td><td>1 989</td><td>54</td><td>19.68</td><td>37.73</td></tr><tr><td><br />PSUtils</td><td>EDB-ID-890</td><td>11 026</td><td>95</td><td>1 920.76</td><td>127.05</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="170">表2使用两种方法检测漏洞所需时间。实验数据表明,当程序结构较简单且基本块数量较少时,直接使用angr进行符号执行分析能更快地检测到漏洞;而随着程序基本块数量的增大,angr检测漏洞所需时间远远多于AutoExp。具体原因如图3所示,AutoExp在预处理阶段构建CFG需花费较多的时间,但是预处理可避免分析与漏洞无关的路径,从而在符号执行阶段花费的时间相对angr要少,且消耗的内存也随之减少。测试结果中,AutoExp检测PSUtils中漏洞所需时间为127.05 s,而angr所需时间是AutoExp的15倍,分析代码发现程序中switch语句会导致状态爆炸问题,该语句与漏洞路径无关,进行代码切片能避免分析该语句,使得符号执行效率得以提高。由此可见,对于结构较复杂的程序而言,本文所提方法可极大提高漏洞检测的效率。</p>
                </div>
                <div class="area_img" id="171">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909057_171.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 漏洞检测时间对比" src="Detail/GetImg?filename=images/JYRJ201909057_171.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 漏洞检测时间对比  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909057_171.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="172" name="172"><b>3.2 漏洞利用</b></h4>
                <div class="p1">
                    <p id="173">为验证系统自动生成exploit的适用性,以图4中漏洞程序memo和上述3个漏洞程序进行测试,测试时选取长度为25 bytes的shellcode利用漏洞。memo程序第14行调用read函数获取用户输入到缓冲区buf中,由于第15行strcpy函数往数组title中写入过多的数据而导致缓冲区溢出漏洞,从而覆盖相邻内存中函数指针func_ptr,利用该漏洞可劫持控制流进行代码注入攻击。</p>
                </div>
                <div class="area_img" id="174">
                    <p class="img_tit"> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="174" border="1"><tr><td><br />1 typedef struct memo{<br />2 char content[22];<br />3 time_t time;<br />4 char title[15];<br />5 int (*func_ptr)();<br />6 }memorandum;<br />7 memorandum memo;<br />8 int message(){<br />9 printf(″%s″, memo.title);<br />10}</td><td>11int main(){<br />12 char buf[22];<br />13 memo.func_ptr=message;<br />14 read(0, buf, sizeof(buf));<br />15 strcpy(memo.title, buf);<br />16 read(0, buf, sizeof(buf));<br />17 strcpy(memo.content,buf);<br />18 time(&amp;memo.time);<br />19 memo.func_ptr();<br />20}</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="175">图4 缓冲区溢出漏洞程序memo</p>
                </div>
                <div class="p1">
                    <p id="176">实验结果如表3所示,AutoExp可成功利用4个漏洞,而Mayhem<citation id="208" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation> 由于未考虑可控内存块不足以容纳shellcode的情况,因此无法成功利用memo中漏洞。实验结果表明,本文所提方法相对Mayhem具有更好的适用性。</p>
                </div>
                <div class="area_img" id="177">
                    <p class="img_tit"><b>表3 漏洞自动利用结果对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="177" border="1"><tr><td rowspan="2">程序</td><td rowspan="2">漏洞编号</td><td rowspan="2">脆弱点</td><td colspan="2"><br />生成利用</td></tr><tr><td><br />Mayhem</td><td>AutoExp</td></tr><tr><td>memo</td><td>N/A</td><td>strcpy</td><td>N</td><td>Y</td></tr><tr><td><br />Squirrel Mail</td><td>CVE-2004-0524</td><td>sprintf</td><td>Y</td><td>Y</td></tr><tr><td><br />iwconfig</td><td>CVE-2003-0947</td><td>strcpy</td><td>Y</td><td>Y</td></tr><tr><td><br />PSUtils</td><td>EDB-ID-890</td><td>sprintf</td><td>Y</td><td>Y</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="178">下面具体分析AutoExp自动生成exploit的效果。程序memo中存在content[22] 和title[15] 两块连续可控内存,利用过程中选取不同长度的shellcode,AutoExp可根据内存块能否容纳shellcode采取不同的exploit构造方法。如图5所示,当选取长度为21 bytes的shellcode利用漏洞时,由于存在能容纳shellcode的可控内存块,故选择可控内存块content[22]注入shellcode构造利用。</p>
                </div>
                <div class="area_img" id="179">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909057_179.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 shellcode连续存放" src="Detail/GetImg?filename=images/JYRJ201909057_179.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 shellcode连续存放  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909057_179.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="180">如图6所示,当选取长度为25 bytes的shellcode利用漏洞时,由于不存在可容纳shellcode的内存块,故将shellcode分段存放在content[22]和title[15]中,并用指令“eb 07”实现不同分段间的跳转。</p>
                </div>
                <div class="area_img" id="181">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909057_181.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 shellcode分段存放" src="Detail/GetImg?filename=images/JYRJ201909057_181.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 shellcode分段存放  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909057_181.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="182">上述结果表明,本文所提方法可根据漏洞程序中可控内存块的大小和所选取的shellcode调整exploit构造方法,具有更好的适用性。</p>
                </div>
                <h3 id="183" name="183" class="anchor-tag"><b>4 结 语</b></h3>
                <div class="p1">
                    <p id="184">本文对漏洞自动化利用方法进行了总结,提出一种基于符号执行的缓冲区溢出漏洞自动化利用方法。该方法采用危险函数切片减少漏洞检测中符号执行的状态数量,可有效缓解状态爆炸问题,提高符号执行的效率。在漏洞利用阶段,当进程中不存在空间足够的可控内存块时,将shellcode进行分段存放,具有更好的适用性。本文实现了缓冲区溢出漏洞利用的自动化,后续工作可进一步研究其他类型漏洞的自动化利用,以及自动绕过程序和系统中部署的漏洞缓解机制。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=CINS201801046&amp;v=MjY1Mjk5bk1ybzlCWW9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnlqa1Vidk5KaVRGZmJHNEg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 中国信息安全测评中心.2017年国内外信息安全漏洞情况[J].中国信息安全,2018(1):117-121.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=CNNVD[OL]">

                                <b>[2]</b> CNNVD[OL].http://www.cnnvd.org.cn.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Automatic Patch- Based Exploit Generation is Possible: Techniques and Implications,&amp;quot;">

                                <b>[3]</b> Brumley D,Poosankam P,Song D,et al.Automatic patch-based exploit generation is possible:Techniques and implications[C]//Proceedings of the 2008 IEEE Symposium on Security and Privacy.IEEE,2008:143-157.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM14021300000074&amp;v=MDQxMTdSZEdlcnFRVE1ud1plWnRGaW5sVXJ6SUlGOFdiaGM9TmlmSVk3SzhIdFBOckk5RlpPc1BESHM5b0JNVDZUNFBRSC9pcg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b> Avgerinos T,Cha S K,Rebert A,et al.Automatic exploit generation[J].Communications of the ACM,2014,57(2):74-84.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Automatic generation of control flow hijacking exploits for software vulnerabilities">

                                <b>[5]</b> Heelan S,Kroening D.Automatic generation of control flow hijacking exploits for software vulnerabilities[D].University of Oxford,2009.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Unleashing Mayhem on Binary Code">

                                <b>[6]</b> Cha S S K,Avgerinos T T,Rebert A A,et al.Unleashing Mayhem on Binary Code[C]//Proceedings of the 2012 IEEE Symposium on Security and Privacy.IEEE,2012:380-394.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Automatic polymorphic exploit generation for software vulnerabilities">

                                <b>[7]</b> Wang M,Su P,Li Q,et al.Automatic Polymorphic Exploit Generation for Software Vulnerabilities[M]//Security and Privacy in Communication Networks.Springer International Publishing,2013:216-233.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Software crash analysis for automatic exploit generation on binary programs">

                                <b>[8]</b> Huang S K,Huang M H,Huang P Y,et al.Software Crash Analysis for Automatic Exploit Generation on Binary Programs[J].IEEE Transactions on Reliability,2014,63(1):270-289.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Automatic generation of data-oriented exploits">

                                <b>[9]</b> Hu H,Chua Z L,Adrian S,et al.Automatic Generation of Data-Oriented Exploits[C]//24th USENIX Security Symposium.Washington:USENIX Association,2015:177-179.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Revery From Proof-of-Concept to Exploitable">

                                <b>[10]</b> Wang Y,Zhang C,Xiang X,et al.Revery:From Proof-of-Concept to Exploitable[C]//Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security.New York,USA:ACM,2018:1914-1927.
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=NAVEX Precise and scalable exploit generation for dynamic web applications">

                                <b>[11]</b> Alhuzali A,Gjomemo R,Eshete B,et al.NAVEX:Precise and scalable exploit generation for dynamic web applications[C]//27th USENIX Security Symposium,Washington:USENIX Association,2018:377-392.
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000014032&amp;v=MDIzMzlUNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyeklJRjhXYmhjPU5pZklZN0s3SHRqTnI0OUZaT29MREg4N29CTQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[12]</b> Roemer R,Buchanan E,Shacham H,et al.Return-Oriented Programming:Systems,Languages,and Applications[J].Acm Transactions on Information &amp; System Security,2012,15(1):1-34.
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=&amp;quot;SOK: (State of)The Art of War:Offensive Techniques in Binary Analysis,&amp;quot;">

                                <b>[13]</b> Shoshitaishvili Y,Kruegel C,Vigna G,et al.SOK:(State of) The Art of War:Offensive Techniques in Binary Analysis[C]//2016 IEEE Symposium on Security and Privacy.IEEE Computer Society,2016:138-157.
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_14" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000024473&amp;v=Mjk2NzRNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcnpJSUY4V2JoYz1OaWZJWTdLN0h0ak5yNDlGWk9rTENIczZvQg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[14]</b> King J C.Symbolic execution and program testing[J].Communications of the ACM,1976,19(7):385-394.
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787302472070000&amp;v=MjcxNzluS3JpZlplWnZGeW5tVTcvSklsb1JYRnF6R2JDNEhOWExyWTlDWk9zUERCTTh6eFVTbURkOVNIN24zeEU5ZmJ2&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b> 苏璞睿,应凌云,杨轶.软件安全分析与应用[M].北京:清华大学出版社,2017.
                            </a>
                        </p>
                        <p id="33">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Interprocedural Static Slicing of Binary Executables">

                                <b>[16]</b> Kiss K,Jsz J,Lehotai G,et al.Interprocedural Static Slicing of Binary Executables[C]//Proceedings Third IEEE International Workshop on Source Code Analysis and Manipulation.IEEE,2003:118-127.
                            </a>
                        </p>
                        <p id="35">
                            <a id="bibliography_17" target="_blank" href="http://scholar.cnki.net/result.aspx?q=All you ever wanted to know about dynamic taint analysis and forward symbolic execution (but might have been afraid to ask)">

                                <b>[17]</b> Schwartz E J,Avgerinos T,Brumley D.All you ever wanted to know about dynamic taint analysis and forward symbolic execution[C]//IEEE Symposium on Security and Privacy.Piscataway,2010:317-331.
                            </a>
                        </p>
                        <p id="37">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Z3:An efficient smt solver">

                                <b>[18]</b> Moura L D,Bj∅rner N.Z3:an efficient SMT solver[C]//Proceedings of the Theory and practice of software,14th international conference on Tools and algorithms for the construction and analysis of systems.Springer-Verlag,2008:337-340.
                            </a>
                        </p>
                        <p id="39">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On the effectiveness of address-space random-ization">

                                <b>[19]</b> Shacham H,Page M,Pfaff B,et al.On the effectiveness of address-space randomization[C]//Proceedings of the 11th ACM Conference on Computer and Communications Security,CCS 2004,Washington,DC,USA,October 25-29,2004.ACM,2004:298-307.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JYRJ201909057" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201909057&amp;v=MjYwNTc0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5amtVYnZOTHpUWlpMRzRIOWpNcG85QVk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
