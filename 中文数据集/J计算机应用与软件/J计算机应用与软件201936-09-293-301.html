<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637135598213596250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJYRJ201909052%26RESULT%3d1%26SIGN%3ddUAEaOUIWsoIzPeL%252fzHrlrExwvU%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201909052&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201909052&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201909052&amp;v=MTQ1MzBqTXBvOUFab1FLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeWprVWJySUx6VFpaTEc0SDk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#23" data-title="&lt;b&gt;0 引 言&lt;/b&gt; "><b>0 引 言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#29" data-title="&lt;b&gt;1 ROP技术&lt;/b&gt; "><b>1 ROP技术</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#35" data-title="&lt;b&gt;2 方法描述&lt;/b&gt; "><b>2 方法描述</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#133" data-title="&lt;b&gt;3 gadget指令序列获取&lt;/b&gt; "><b>3 gadget指令序列获取</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#135" data-title="&lt;b&gt;3.1 搜索gadget&lt;/b&gt;"><b>3.1 搜索gadget</b></a></li>
                                                <li><a href="#157" data-title="&lt;b&gt;3.2 构造gadget&lt;/b&gt;"><b>3.2 构造gadget</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#198" data-title="&lt;b&gt;4 方法分析&lt;/b&gt; "><b>4 方法分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#200" data-title="&lt;b&gt;4.1 有效性&lt;/b&gt;"><b>4.1 有效性</b></a></li>
                                                <li><a href="#214" data-title="&lt;b&gt;4.2 空间和时间开销&lt;/b&gt;"><b>4.2 空间和时间开销</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#220" data-title="&lt;b&gt;5 实验分析&lt;/b&gt; "><b>5 实验分析</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#239" data-title="&lt;b&gt;6 结 语&lt;/b&gt; "><b>6 结 语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#31" data-title="图1 函数栈帧结构的内存布局">图1 函数栈帧结构的内存布局</a></li>
                                                <li><a href="#33" data-title="图2 ROP技术示例">图2 ROP技术示例</a></li>
                                                <li><a href="#37" data-title="图3 基于ROP技术的代码混淆方法流程框架">图3 基于ROP技术的代码混淆方法流程框架</a></li>
                                                <li><a href="#87" data-title="图4 程序执行路径">图4 程序执行路径</a></li>
                                                <li><a href="#130" data-title="图5 混淆后程序执行路径">图5 混淆后程序执行路径</a></li>
                                                <li><a href="#132" data-title="图6 随机多样化混淆效果">图6 随机多样化混淆效果</a></li>
                                                <li><a href="#156" data-title="图7 指令序列树&lt;i&gt;T&lt;/i&gt;">图7 指令序列树<i>T</i></a></li>
                                                <li><a href="#160" data-title="&lt;b&gt;表1 目标指令的等价指令序列&lt;/b&gt;"><b>表1 目标指令的等价指令序列</b></a></li>
                                                <li><a href="#162" data-title="&lt;b&gt;表2 等价指令变换方法示例&lt;/b&gt;"><b>表2 等价指令变换方法示例</b></a></li>
                                                <li><a href="#197" data-title="图8 隐蔽嵌入gadget效果">图8 隐蔽嵌入gadget效果</a></li>
                                                <li><a href="#222" data-title="&lt;b&gt;表3 gadget指令序列搜索结果&lt;/b&gt;"><b>表3 gadget指令序列搜索结果</b></a></li>
                                                <li><a href="#224" data-title="图9 冒泡排序程序混淆示例">图9 冒泡排序程序混淆示例</a></li>
                                                <li><a href="#226" data-title="&lt;b&gt;表4 混淆前后程序的执行和开销情况&lt;/b&gt;"><b>表4 混淆前后程序的执行和开销情况</b></a></li>
                                                <li><a href="#235" data-title="&lt;b&gt;表5 混淆前后程序相关数据&lt;/b&gt;"><b>表5 混淆前后程序相关数据</b></a></li>
                                                <li><a href="#237" data-title="图10 混淆前后代码块数量和指令数量对比">图10 混淆前后代码块数量和指令数量对比</a></li>
                                                <li><a href="#237" data-title="图10 混淆前后代码块数量和指令数量对比">图10 混淆前后代码块数量和指令数量对比</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" Collberg C,Thomborson C,Low D.A taxonomy of obfuscating transformations[R].Department of Computer Science,The University of Auckland,New Zealand,1997." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A taxonomy of obfuscating transformations">
                                        <b>[1]</b>
                                         Collberg C,Thomborson C,Low D.A taxonomy of obfuscating transformations[R].Department of Computer Science,The University of Auckland,New Zealand,1997.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title=" Kulkarni A,Metta R.A new code obfuscation scheme for software protection[C]//Proceedings of the 2014 IEEE 8th International Symposium on Service Oriented System Engineering.IEEE,2014:409-414." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A New Code Obfuscation Scheme for Software Protection">
                                        <b>[2]</b>
                                         Kulkarni A,Metta R.A new code obfuscation scheme for software protection[C]//Proceedings of the 2014 IEEE 8th International Symposium on Service Oriented System Engineering.IEEE,2014:409-414.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" Xie X,Liu F,Lu B,et al.Mixed obfuscation of overlapping instruction and self-modify code based on hyper-chaotic opaque predicates[C]//2014 Tenth International Conference on Computational Intelligence and Security.IEEE,2014:524-528." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Mixed Obfuscation of Overlapping Instruction and Self-Modify Code Based on Hyper-Chaotic Opaque Predicates">
                                        <b>[3]</b>
                                         Xie X,Liu F,Lu B,et al.Mixed obfuscation of overlapping instruction and self-modify code based on hyper-chaotic opaque predicates[C]//2014 Tenth International Conference on Computational Intelligence and Security.IEEE,2014:524-528.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title=" Behera C K,Bhaskari D L.Self-Modifying Code:A Provable Technique for Enhancing Program Obfuscation[J].International Journal of Secure Software Engineering (IJSSE),2017,8(3):24-41." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJIG&amp;filename=SJIG88C1A86B6DF99029839B5DD9B09B0F01&amp;v=MzE5MTR0aHhMbTl4YWc9TmlmQ2FidXdiZEM5cDRrM1lwOTVCWFU1elI4YjZUWVBUUXVXcFdBMWNNQ1VNN3FlQ09OdkZTaVdXcjdKSUZwbWFCdUhZZk9HUWxmQnJMVTA1dA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                         Behera C K,Bhaskari D L.Self-Modifying Code:A Provable Technique for Enhancing Program Obfuscation[J].International Journal of Secure Software Engineering (IJSSE),2017,8(3):24-41.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" 陈喆,贾春福,宗楠,等.随机森林在程序分支混淆中的应用[J].电子学报,2018,46(10):2458-2466." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU201810020&amp;v=MzIzMTZxQnRHRnJDVVI3cWZadVp0Rnlqa1VicklJVGZUZTdHNEg5bk5yNDlIWklRS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         陈喆,贾春福,宗楠,等.随机森林在程序分支混淆中的应用[J].电子学报,2018,46(10):2458-2466.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" 苏庆,孙金田.基于混沌不透明表达式的不透明谓词混淆技术研究[J].计算机科学,2017,44 (12):114-119." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201712023&amp;v=MjE0NjJDVVI3cWZadVp0Rnlqa1VicklMejdCYjdHNEg5Yk5yWTlIWjRRS0RIODR2UjRUNmo1NE8zenFxQnRHRnI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         苏庆,孙金田.基于混沌不透明表达式的不透明谓词混淆技术研究[J].计算机科学,2017,44 (12):114-119.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title=" Falcarin P,Di Carlo S,Cabutto A,et al.Exploiting code mobility for dynamic binary obfuscation[C]//2011 World Congress on Internet Security(WorldCIS-2011).IEEE,2011:114-120." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Exploiting code mobility for dynamic binary obfuscation">
                                        <b>[7]</b>
                                         Falcarin P,Di Carlo S,Cabutto A,et al.Exploiting code mobility for dynamic binary obfuscation[C]//2011 World Congress on Internet Security(WorldCIS-2011).IEEE,2011:114-120.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title=" Ma H,Lu K,Ma X,et al.Software Watermarking using Return-Oriented Programming[C]//Proceedings of the 10th ACM Symposium on Information,Computer and Communications Security.ACM,2015:369-380." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Software Watermarking Using Return-Oriented Programming,&amp;quot;">
                                        <b>[8]</b>
                                         Ma H,Lu K,Ma X,et al.Software Watermarking using Return-Oriented Programming[C]//Proceedings of the 10th ACM Symposium on Information,Computer and Communications Security.ACM,2015:369-380.
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title=" Mu D,Guo J,Ding W,et al.ROPOB:Obfuscating Binary Code via Return Oriented Programming[C]//International Conference on Security and Privacy in Communication Systems.Springer,Cham,2017:721-737." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=ROPOB:Obfuscating Binary Code via Return Oriented Programming">
                                        <b>[9]</b>
                                         Mu D,Guo J,Ding W,et al.ROPOB:Obfuscating Binary Code via Return Oriented Programming[C]//International Conference on Security and Privacy in Communication Systems.Springer,Cham,2017:721-737.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title=" Lu K,Xiong S,Gao D.Ropsteg:program steganography with return oriented programming[C]//Proceedings of the 4th ACM conference on Data and application security and privacy.ACM,2014:265-272." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=RopSteg:program steganography with return oriented programming">
                                        <b>[10]</b>
                                         Lu K,Xiong S,Gao D.Ropsteg:program steganography with return oriented programming[C]//Proceedings of the 4th ACM conference on Data and application security and privacy.ACM,2014:265-272.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JYRJ" target="_blank">计算机应用与软件</a>
                2019,36(09),293-301 DOI:10.3969/j.issn.1000-386x.2019.09.051            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>一种基于ROP技术的代码混淆方法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="javascript:;">向飞</a>
                                <a href="javascript:;">巩道福</a>
                                <a href="javascript:;">刘粉林</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E5%A4%A7%E5%AD%A6&amp;code=0199248&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">信息工程大学</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%95%B0%E5%AD%A6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%85%88%E8%BF%9B%E8%AE%A1%E7%AE%97%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">数学工程与先进计算国家重点实验室</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>针对静动态逆向分析容易获取程序内部核心代码的问题,提出一种基于ROP技术的代码混淆方法。借鉴ROP攻击技术的代码组织和调用方式,利用内存空间随机分布的gadget指令序列执行目标代码的等价功能,实现隐藏目标代码和抵抗逆向分析的目的。从有效性、时间开销和空间开销三个方面评价方法的性能,分析和实验表明,该方法能够有效增加攻击者静动态获取和分析目标代码的难度,具有较好的时间和空间开销性能。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">软件安全;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">代码混淆;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=ROP%E6%8A%80%E6%9C%AF&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">ROP技术;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=gadget%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">gadget指令序列;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    向飞,博士生,主研领域:网络信息安全,软件安全与保护。;
                                </span>
                                <span>
                                    巩道福,讲师。;
                                </span>
                                <span>
                                    刘粉林,教授。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2019-01-15</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目(61302159,61379151,61272489,61602508,61772549);</span>
                                <span>河南省重点技术研发项目(162102210032);</span>
                                <span>河南省科学技术研究重点项目(152102210005);</span>
                    </p>
            </div>
                    <h1><b>A ROP-BASED CODE OBFUSCATION</b></h1>
                    <h2>
                    <span>Xiang Fei</span>
                    <span>Gong Daofu</span>
                    <span>Liu Fenlin</span>
            </h2>
                                    <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>In terms of the problem that the core code of programs can be easily obtained through static and dynamic reverse analysis, this paper proposed a code obfuscation method based on ROP. We refered to the code organization and calling way of the attack technique ROP, and utilized the gadget instruction sequences randomly distributed in memory space to realize the equivalent functionality of the target code, achieve the purpose of hiding the target code and resisting reverse analysis. This paper evaluated the performance of the method from three aspects: effectiveness, time overhead and space overhead. Analysis and experiments show that the method can effectively increase the difficulty for the attackers to statically and dynamically acquire and analyze of the target code, and it has better time and space overhead performance.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Software%20security&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Software security;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Code%20obfuscation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Code obfuscation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=ROP&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">ROP;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Gadget%20instruction%20sequence&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Gadget instruction sequence;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2019-01-15</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="23" name="23" class="anchor-tag"><b>0 引 言</b></h3>
                <div class="p1">
                    <p id="24">随着软件产业的迅猛发展,软件在发挥巨大社会和经济效益的同时,安全问题也随之产生。通过对商业软件进行逆向分析和破解,进而盗用软件或剽窃核心算法,将对软件的知识产权造成严重侵害,破坏市场的公平正义。因此,软件安全已经成为软件产业界的研究热点。Collberg等<citation id="241" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>最早提出代码混淆的软件保护技术,通过对程序代码实施混淆变换,在保持程序语义功能等价的基础上,使其形式变得更加复杂和难以理解,能够抵抗静动态逆向分析,提高软件破解的时间成本,进而增强软件安全性能<citation id="242" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="25">攻击者对目标程序进行逆向分析时,通常重点关注实现特定功能的核心代码。通过静态反汇编或动态跟踪执行,能够获取和分析核心代码,进而理解程序功能或实施篡改破解。因此,研究保护程序核心代码抵抗攻击者逆向分析,对于保护程序安全具有重要意义。Kulkarni等<citation id="243" type="reference"><link href="5" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>提出将程序重要代码进行切片,针对每个代码片段克隆多个等价片段且生成多条随机执行路径,增加代码执行路径的随机多样性,使得攻击者难以恢复和分析原始代码。Xie等<citation id="244" type="reference"><link href="7" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>提出针对程序代码设计重叠指令和嵌入跳转指令,函数执行过程跳转到重叠指令中间执行,能够降低代码反汇编的准确程度。Behera等<citation id="245" type="reference"><link href="9" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>提出针对函数代码进行篡改并嵌入自修改指令,程序执行时动态恢复执行原始代码,能有效扰乱静态反汇编。陈喆等<citation id="246" type="reference"><link href="11" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>利用随机森林分类的思想混淆程序重要代码的路径信息,将分析路径分支的难度转化为提取随机森林规则的难度。苏庆等<citation id="247" type="reference"><link href="13" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>提出基于混沌映射和二次映射的混沌不透明表达式构造方法,进而构造不透明谓词插入到重要代码的混淆,能够明显提升软件代码的复杂度。Falcarin等<citation id="248" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>提出将程序重要代码放置于攻击者不可控的远程可信实体,利用网络数据的流动性使程序执行过程动态获取代码,减少攻击者对程序代码的可见度。上述方法实现了不同角度的程序代码保护,然而保护后代码依然存在于目标程序,容易被逆向分析获取,或是通过网络传输执行代码严重依赖于网络环境,可用性大打折扣。</p>
                </div>
                <div class="p1">
                    <p id="26">针对传统的直接在进程栈空间注入可执行代码的缓冲区溢出漏洞攻击方式,操作系统实现诸多防御机制,如:通过修改可执行文件的内存布局使得堆栈不可执行;通过硬件支持使得进程映像的内存空间不能同时可写入和可执行;通过设置不可执行页限制程序生成可执行代码;通过进程地址空间布局随机化技术(ASLR)使堆栈首地址随机化等。因此攻击者又提出新型的代码复用攻击方式,不再直接向进程栈空间注入可执行代码,而是充分利用内存空间已有的代码进行执行,主要有RIL(Return-into-libc)技术和ROP(Return-oriented-programming)技术等。RIL技术直接复用内存空间的库函数,通过连续调用特定的库函数可以实现复杂的攻击。ROP技术是RIL技术的提升,其以内存空间更细粒度的指令片段为复用对象,能够实现任意图灵完备的攻击。具体来说,ROP技术通过在栈空间预设返回地址。使得目标指令片段结尾处的返回指令(RET指令)直接返回到指定内存地址继续执行下一个指令片段,进而实现指令片段的动态连续执行。两种代码复用攻击技术执行的都是进程内存空间正常的代码,因此不会被系统检测出异常,能够突破现有的安全防御机制。</p>
                </div>
                <div class="p1">
                    <p id="27">由于ROP技术的代码组织方式和调用过程跟传统的代码顺序执行有很大的不同,能够以较为隐蔽的方式驱动代码执行,使得ROP技术在代码保护方面能够发挥一定的作用。已有相关研究将ROP技术应用于代码保护,实现较好的保护效果。Ma等<citation id="249" type="reference"><link href="17" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>实现了基于ROP的动态软件水印技术,通过秘密输入触发执行精心设计的ROP指令片段,实现目标水印功能。Mu等<citation id="250" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>实现了混淆工具ROPOB,将函数基本块转化为ROP指令片段,通过ROP返回指令将直接控制转移转化为间接控制转移,能够抵抗攻击者静态分析函数控制流。ROPOB主要针对基本块间的控制转移指令进行混淆,没有考虑基本块内部的普通指令。Lu等<citation id="251" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>实现了混淆系统RopSteg,将目标指令代码转化为隐蔽的ROP指令片段,然后构造ROP生成器实现动态计算ROP指令片段地址和返回地址。同时构造ROP跳板实现将ROP返回地址压栈再转到ROP指令片段执行,能够有效隐藏目标指令代码,抵抗静态逆向分析。RopSteg主要使用单个等价的ROP指令片段进行混淆,没有充分结合ROP技术在攻击场景的应用特性,实现多个ROP指令片段组合执行。</p>
                </div>
                <div class="p1">
                    <p id="28">本文提出一种新的基于ROP技术的代码混淆方法,用以保护程序内部核心代码避免暴露给逆向攻击过程。利用程序内存空间随机分布的若干gadget指令片段的动态组合执行,实现目标代码的等价功能,进而实现隐藏目标代码的目的,抵抗攻击者通过静动态手段获取和分析目标代码功能。</p>
                </div>
                <h3 id="29" name="29" class="anchor-tag"><b>1 ROP技术</b></h3>
                <div class="p1">
                    <p id="30">程序执行过程中,每个函数调用具有独立的栈帧结构,其内存空间布局如图1所示。缓冲区溢出漏洞的产生是因为在函数内部针对拷贝给局部变量的输入字符串缺少安全检查,使得攻击者能够通过外部输入注入二进制可执行代码到栈空间而且把函数返回地址覆盖为可执行代码地址,导致函数执行完毕返回到攻击者注入的代码进行执行,进而实现恶意攻击目的。</p>
                </div>
                <div class="area_img" id="31">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_031.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 函数栈帧结构的内存布局" src="Detail/GetImg?filename=images/JYRJ201909052_031.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 函数栈帧结构的内存布局  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_031.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="32">ROP攻击技术不直接向函数栈空间注入可执行代码,而是另辟蹊径,充分利用内存空间共享库代码中以ret指令结尾的指令片段(称为gadget)。ret指令的功能是弹出栈顶的4字节数据并赋给指令指针寄存器EIP作为下一条执行指令的地址。ROP技术将若干gadget的地址和数据按照固定顺序注入到函数栈空间,通过执行前一个gadget结尾的ret指令可跳转至栈中设定的后一个gadget继续执行,进而实现gadget的动态连续调用,不动声色地达到攻击目的。下面举例说明ROP技术的实现过程,图2为实现0x10与0x20的加法操作。</p>
                </div>
                <div class="area_img" id="33">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_033.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 ROP技术示例" src="Detail/GetImg?filename=images/JYRJ201909052_033.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 ROP技术示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_033.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="34">图2左侧为ROP技术利用缓冲区溢出漏洞向函数栈空间注入的数据,其中gadget1、gadget2和gadget3分别为内存空间共享库代码的3个gadget的地址,gadget1所在位置指向函数返回地址。图2中间分别为地址gadget1、gadget2和gadget3指向的gadget指令片段。实施ROP攻击后的程序执行过程为:函数执行完毕返回到gadget1执行,pop eax指令取出0x10到eax寄存器,ret指令取出gadget2作为返回地址执行;然后pop ebx指令取出0x20到ebx寄存器,ret指令取出gadget3作为返回地址执行,add eax,ebx指令实现0x10与0x20相加;结果保存到eax寄存器,ret指令退出当前执行过程。图2通过精心构造数据注入到函数栈空间,实现3个gadget的连续调用执行,最终实现0x10与0x20的加法操作。相比传统的直接注入可执行代码的攻击方式,ROP技术通过复用程序内存空间代码,不仅减少了注入的数据量,而且提高了漏洞攻击的隐蔽性,能够绕过操作系统的安全防御机制。考虑到ROP技术在驱动大量代码片段连续执行等方面具有独特的实现方式和较好的隐蔽效果,因此本文将ROP技术应用到程序核心代码的混淆,进而提出新的基于ROP技术的代码混淆方法。</p>
                </div>
                <h3 id="35" name="35" class="anchor-tag"><b>2 方法描述</b></h3>
                <div class="p1">
                    <p id="36">借鉴ROP攻击技术的代码复用思想,本文提出一种基于ROP技术的代码混淆方法,具体的流程框架如图3所示。方法提取目标程序基本块内部需要保护的核心代码,利用内存空间实现等价功能的gadget指令序列予以混淆替换,进而达到隐藏核心代码和抵抗静动态分析的目的。其中gadget指令序列通过搜索系统共享函数库或等价指令变换构造等方式进行获取。</p>
                </div>
                <div class="area_img" id="37">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_037.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 基于ROP技术的代码混淆方法流程框架" src="Detail/GetImg?filename=images/JYRJ201909052_037.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 基于ROP技术的代码混淆方法流程框架  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_037.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="38">首先定义指令代码的完全语义等价和条件语义等价。</p>
                </div>
                <div class="p1">
                    <p id="39"><b>定义1</b>(完全语义等价):设目标指令<i>I</i>,指令序列<i>IS</i>={<i>I</i><sub>1</sub>,<i>I</i><sub>2</sub>,…,<i>I</i><sub><i>n</i></sub>},若<i>IS</i>能够实现<i>I</i>的等价功能,则称<i>IS</i>与<i>I</i>完全语义等价,记作<i>I</i>≌<i>IS</i>。如针对目标指令mov eax,1,执行push edx, mov edx,1, mov eax,edx, pop edx能够实现相同的语义功能,则有mov eax,1≌{push edx, mov edx,1, mov eax,edx, pop edx}。</p>
                </div>
                <div class="p1">
                    <p id="40"><b>定义2</b>(条件语义等价):设目标指令<i>I</i>,指令序列<i>IS</i>={<i>I</i><sub>1</sub>,<i>I</i><sub>2</sub>,…,<i>I</i><sub><i>n</i></sub>},数据集<i>DS</i>={<i>d</i><sub>1</sub>,<i>d</i><sub>2</sub>,…,<i>d</i><sub><i>s</i></sub>}。动态执行时,<i>DS</i>预先存储在栈空间,<i>d</i><sub>1</sub>到<i>d</i><sub><i>s</i></sub>自栈顶开始向栈底方向连续分布,若<i>IS</i>通过调用<i>DS</i>能够实现<i>I</i>的等价功能,则称<i>IS</i>与<i>I</i>条件语义等价,记作<i>I</i>∽<i>IS</i>@<i>DS</i>。如针对目标指令mov eax,1,栈顶数据为1时,执行pop eax能够实现相同的语义功能,则有mov eax,1∽{pop eax}@{1}。</p>
                </div>
                <div class="p1">
                    <p id="41">混淆方法通过调用完全语义等价或条件语义等价的指令序列实现核心代码的等价功能,下面描述混淆实现过程。</p>
                </div>
                <div class="p1">
                    <p id="42">首先针对目标程序进行反汇编,获取基本块集合<i>S</i>。选择目标基本块<i>B</i>内部的核心指令代码<i>K</i>={<i>I</i><sub>1</sub>,<i>I</i><sub>2</sub>,…,<i>I</i><sub><i>n</i></sub>}进行混淆。针对每条指令<i>I</i><sub><i>i</i></sub>,1≤<i>i</i>≤<i>n</i>,选取<i>m</i><sub><i>i</i></sub>个以ret指令结尾的gadget指令序列<i>G</i><mathml id="43"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>i</mi></msubsup></mrow></math></mathml>,<i>G</i><mathml id="44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>,…,<i>G</i><mathml id="45"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>i</mi></msubsup></mrow></math></mathml>,使得<i>G</i><mathml id="46"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>={<i>g</i><mathml id="47"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>,<i>ret</i>},<i>g</i><mathml id="48"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>是指令序列,1≤<i>j</i>≤<i>m</i><sub><i>i</i></sub>,满足<i>I</i><sub><i>i</i></sub>≌{<i>g</i><mathml id="49"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>i</mi></msubsup></mrow></math></mathml>,<i>g</i><mathml id="50"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>,…,<i>g</i><mathml id="51"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>i</mi></msubsup></mrow></math></mathml>}或<i>I</i><sub><i>i</i></sub>∽{<i>g</i><mathml id="52"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>i</mi></msubsup></mrow></math></mathml>,<i>g</i><mathml id="53"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>,…,<i>g</i><mathml id="54"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>i</mi></msubsup></mrow></math></mathml>}@{<i>DS</i><mathml id="55"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>i</mi></msubsup></mrow></math></mathml>,<i>DS</i><mathml id="56"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>,…,<i>DS</i><mathml id="57"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>i</mi></msubsup></mrow></math></mathml>},即指令序列{<i>g</i><mathml id="58"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>i</mi></msubsup></mrow></math></mathml>,<i>g</i><mathml id="59"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>,…,<i>g</i><mathml id="60"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>i</mi></msubsup></mrow></math></mathml>}能够实现指令<i>I</i><sub><i>i</i></sub>的等价功能,设指令序列<i>G</i><mathml id="61"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>的首条指令(即指令序列<i>g</i><mathml id="62"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>的首条指令)的地址为<i>A</i><mathml id="63"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>。</p>
                </div>
                <div class="p1">
                    <p id="64" class="code-formula">
                        <mathml id="64"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mtable columnalign="left"><mtr><mtd><mi>Ι</mi><msub><mrow></mrow><mn>1</mn></msub></mtd></mtr><mtr><mtd><mi>Ι</mi><msub><mrow></mrow><mn>2</mn></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>Ι</mi><msub><mrow></mrow><mi>i</mi></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>Ι</mi><msub><mrow></mrow><mi>n</mi></msub></mtd></mtr></mtable><mo>}</mo></mrow><mtext> </mtext><mo>⇒</mo><mtext> </mtext><mrow><mo>{</mo><mtable columnalign="left"><mtr><mtd><mi>G</mi><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mn>2</mn><mn>1</mn></msubsup><mtext> </mtext><mo>⋯</mo><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mn>1</mn></msubsup></mtd></mtr><mtr><mtd><mi>G</mi><msubsup><mrow></mrow><mn>1</mn><mn>2</mn></msubsup><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mn>2</mn><mn>2</mn></msubsup><mtext> </mtext><mo>⋯</mo><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mn>2</mn></msubsup></mtd></mtr><mtr><mtd><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>G</mi><msubsup><mrow></mrow><mn>1</mn><mi>i</mi></msubsup><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup><mtext> </mtext><mo>⋯</mo><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>i</mi></msubsup></mtd></mtr><mtr><mtd><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>G</mi><msubsup><mrow></mrow><mn>1</mn><mi>n</mi></msubsup><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mn>2</mn><mi>n</mi></msubsup><mtext> </mtext><mo>⋯</mo><mtext> </mtext><mi>G</mi><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mtd></mtr></mtable><mo>}</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="65">将指令代码<i>K</i>混淆成指令序列<i>G</i><mathml id="66"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml>,<i>G</i><mathml id="67"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>1</mn></msubsup></mrow></math></mathml>,…,<i>G</i><mathml id="68"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mn>1</mn></msubsup></mrow></math></mathml>,<i>G</i><mathml id="69"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>2</mn></msubsup></mrow></math></mathml>,<i>G</i><mathml id="70"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>2</mn></msubsup></mrow></math></mathml>,…,<i>G</i><mathml id="71"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mn>2</mn></msubsup></mrow></math></mathml>,…,<i>G</i><mathml id="72"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>n</mi></msubsup></mrow></math></mathml>,<i>G</i><mathml id="73"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>n</mi></msubsup></mrow></math></mathml>,…,<i>G</i><mathml id="74"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>的等价执行。混淆前后程序执行路径如图4所示,G<mathml id="75"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>(j&lt;m<sub>i</sub>)结尾处的<i>ret</i>指令返回到G<mathml id="76"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>执行,G<mathml id="77"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mi>i</mi></msubsup></mrow></math></mathml>(i&lt;n)结尾处的<i>ret</i>指令返回到G<mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>执行,G<mathml id="79"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>结尾的<i>ret</i>指令最终返回到基本块B,设G<mathml id="80"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>的返回地址为RB<mathml id="81"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>。因为<i>ret</i>指令弹出栈顶的4字节数据作为返回地址,故而应该根据<i>gadget</i>的调用执行顺序把相应的返回地址逆序压栈,即按RB<mathml id="82"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>,A<mathml id="83"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>,A<mathml id="84"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mn>1</mn></mrow><mi>n</mi></msubsup></mrow></math></mathml>,…,A<mathml id="85"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>1</mn></msubsup></mrow></math></mathml>,A<mathml id="86"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml>的顺序压栈,进而实现目标执行过程。</p>
                </div>
                <div class="area_img" id="87">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_087.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 程序执行路径" src="Detail/GetImg?filename=images/JYRJ201909052_087.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 程序执行路径  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_087.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="88">混淆时首先在基本块B内部插入push指令,用以实现将返回地址<i>RB</i><mathml id="89"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>,<i>A</i><mathml id="90"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>,<i>A</i><mathml id="91"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mn>1</mn></mrow><mi>n</mi></msubsup></mrow></math></mathml>,…,<i>A</i><mathml id="92"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>1</mn></msubsup></mrow></math></mathml>,<i>A</i><mathml id="93"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml>依次压栈。若<i>DS</i><mathml id="94"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>为空,则直接将<i>A</i><mathml id="95"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>压栈;若<i>DS</i><mathml id="96"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>不为空,则先将<i>DS</i><mathml id="97"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>压栈,作为<i>G</i><mathml id="98"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>执行的调用数据,再将<i>A</i><mathml id="99"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>压栈,设<i>DS</i><mathml id="100"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>={<i>d</i><mathml id="101"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>j</mi><mo>,</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>,<i>d</i><mathml id="102"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>j</mi><mo>,</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>,…,<i>d</i><mathml id="103"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>j</mi><mo>,</mo><mi>s</mi><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow><mi>i</mi></msubsup></mrow></math></mathml>},按<i>d</i><mathml id="104"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>j</mi><mo>,</mo><mi>s</mi><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow><mi>i</mi></msubsup></mrow></math></mathml>到<i>d</i><mathml id="105"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>j</mi><mo>,</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>的顺序依次压栈。最后插入ret指令,用以实现弹出返回地址<i>A</i><mathml id="106"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml>转到<i>G</i><mathml id="107"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml>执行。描述混淆过程的伪代码如算法1所示。</p>
                </div>
                <div class="p1">
                    <p id="108"><b>算法1</b> ROP混淆实现过程算法</p>
                </div>
                <div class="p1">
                    <p id="109">1. <b>function</b> RopObf (<i>K</i>)</p>
                </div>
                <div class="p1">
                    <p id="110">2. InsertInstruction(push <i>RB</i><mathml id="111"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>n</mi></msub></mrow><mi>n</mi></msubsup></mrow></math></mathml>)</p>
                </div>
                <div class="p1">
                    <p id="112">3. <b>for</b><i>i</i><b>from</b><i>n</i><b>to</b> 1 <b>do</b></p>
                </div>
                <div class="p1">
                    <p id="113">4.  <b>for</b> j <b>from</b><i>m</i><sub><i>i</i></sub><b>to</b> 1 <b>do</b></p>
                </div>
                <div class="p1">
                    <p id="114">5.  <b>if</b><i>DS</i><mathml id="115"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>≠ NULL <b>then</b></p>
                </div>
                <div class="p1">
                    <p id="116">6.  <b>for</b><i>k</i><b>from</b><i>s</i><mathml id="117"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml><b>to</b> 1 <b>do</b></p>
                </div>
                <div class="p1">
                    <p id="119">7.  InsertInstruction(push <i>d</i><mathml id="120"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow><mi>i</mi></msubsup></mrow></math></mathml>)</p>
                </div>
                <div class="p1">
                    <p id="121">8.  <b>end for</b></p>
                </div>
                <div class="p1">
                    <p id="122">9.  <b>end if</b></p>
                </div>
                <div class="p1">
                    <p id="123">10.  InsertInstruction(push <i>A</i><mathml id="124"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>)</p>
                </div>
                <div class="p1">
                    <p id="125">11. <b>end for</b></p>
                </div>
                <div class="p1">
                    <p id="126">12.  <b>end for</b></p>
                </div>
                <div class="p1">
                    <p id="127">13.  InsertInstruction(ret)</p>
                </div>
                <div class="p1">
                    <p id="128">14. <b>end function</b></p>
                </div>
                <div class="p1">
                    <p id="129">混淆后程序执行路径如图5所示。</p>
                </div>
                <div class="area_img" id="130">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 混淆后程序执行路径" src="Detail/GetImg?filename=images/JYRJ201909052_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 混淆后程序执行路径  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="131">经过前述混淆过程,指令代码<i>K</i>混淆成连续调用执行的gadget指令序列。为了增强混淆效果,针对指令代码<i>K</i>的每条指令<i>I</i><sub><i>i</i></sub>,同时选取<i>r</i><sub><i>i</i></sub>组实现等价功能的gadget进行混淆,程序动态执行时随机选择一组gadget执行,进而实现程序执行路径和执行代码的随机多样化,增加逆向分析的难度。随机多样化混淆后的程序执行效果如图6所示。</p>
                </div>
                <div class="area_img" id="132">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 随机多样化混淆效果" src="Detail/GetImg?filename=images/JYRJ201909052_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 随机多样化混淆效果  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="133" name="133" class="anchor-tag"><b>3 gadget指令序列获取</b></h3>
                <div class="p1">
                    <p id="134">混淆方法利用程序内存空间的gadget指令序列替换实现原始核心代码的等价功能。提出两种方法获取混淆所需要的gadget:一种是在目标程序代码或所调用的系统共享函数库代码中,搜索以ret指令结尾的gadget;另一种是有针对性的构造以ret指令结尾的gadget,嵌入到目标程序或自定义共享函数库。下面分别介绍两种gadget获取方法。</p>
                </div>
                <h4 class="anchor-tag" id="135" name="135"><b>3.1 搜索gadget</b></h4>
                <div class="p1">
                    <p id="136">程序执行时,在内存空间驻留的大量的可执行代码,包括程序自身代码以及系统共享函数库代码,都可以被直接调用执行。共享函数库通常在程序运行时加载到内存空间,提供函数给程序调用,如Windows操作系统的kernel32.dll、user32.dll等动态链接库。共享函数库含有大量丰富的代码,能够用来提取混淆需要的gadget。因为目标程序或共享函数库的代码段具有可执行权限,故而指定在代码段搜索gadget。下面给出逆序搜索获取gadget的算法。</p>
                </div>
                <div class="p1">
                    <p id="137">在代码段定位所有的ret指令,ret指令对应的十六进制字节是0xC3,因此直接搜索全部字节0xC3。从每个字节0xC3的位置开始,逆向搜索若干字节,若是有效的机器指令则进行记录,然后从当前位置继续逆向搜索若干字节,如此循环往复,直到不能得到有效的机器指令,或者搜索深度长度超过指定阈值。将按上述过程搜索得到的指令组织成以ret指令为根节点的指令序列树。每个节点都是一条指令,每个子节点指令是父节点指令前面紧邻的指令,每个父节点指令是子节点指令后面紧邻的指令。每个节点可能具有多个子节点,因为对于一条指令前面紧邻的字节,不同长度的字节可能翻译成不同的指令。每个非根节点到根节点的路径经过的所有指令按顺序串联起来即构成一个gadget指令序列。</p>
                </div>
                <div class="p1">
                    <p id="138">设ret指令对应的十六进制字节为<i>b</i><sub>0</sub>,以<i>b</i><sub>0</sub>结尾的字节流为<i>BS</i>=(…<i>b</i><sub>2</sub><i>b</i><sub>1</sub><i>b</i><sub>0</sub>),采用递归算法构造指令序列树<i>T</i>,初始化<i>T</i>的根节点为ret指令。定义递归函数GenerateTree(Instruction ins, Index pos, Short depth),参数pos是指令ins的首个字节<i>b</i><sub><i>pos</i></sub>的索引编号,depth是指令ins位于指令序列树<i>T</i>的深度,设根节点的深度为0。函数实现的功能是判断若指令ins的深度depth小于或等于阈值threshold,则把位于指令ins前面的字节流(…<i>b</i><sub><i>pos</i>-2</sub><i>b</i><sub><i>pos</i>-1</sub>)构造成以ins指令为根节点的指令序列树,作为<i>T</i>的子树,否则直接退出。输入二进制字节流<i>BS</i>,构造指令序列树<i>T</i>的伪代码如算法2所示。</p>
                </div>
                <div class="p1">
                    <p id="139"><b>算法2</b> 指令序列树构造算法</p>
                </div>
                <div class="p1">
                    <p id="140"><b>INPUT</b>: (…<i>b</i><sub>2</sub><i>b</i><sub>1</sub><i>b</i><sub>0</sub>) where <i>b</i><sub>0</sub> is disassembled into ret</p>
                </div>
                <div class="p1">
                    <p id="141"><b>OUTPUT</b>: <i>T</i></p>
                </div>
                <div class="p1">
                    <p id="142">1. let ret be the root node of T</p>
                </div>
                <div class="p1">
                    <p id="143">2. GenerateTree(ret, 0, 0)</p>
                </div>
                <div class="p1">
                    <p id="144">3. <b>function</b> GenerateTree(Instruction ins, Index pos, Short depth)</p>
                </div>
                <div class="p1">
                    <p id="145">4. <b>if</b><i>depth</i> ≤ <i>threshold</i><b>then</b></p>
                </div>
                <div class="p1">
                    <p id="146">5.  <b>for</b><i>step</i><b>from</b> 1 <b>to</b><i>max</i>_<i>len</i><b>do</b></p>
                </div>
                <div class="p1">
                    <p id="147">6.  <b>if</b> (<i>b</i><sub><i>pos</i>-<i>step</i></sub>…<i>b</i><sub><i>pos</i>-1</sub>) can be disassembled into a valid instruction childins <b>then</b></p>
                </div>
                <div class="p1">
                    <p id="148">7.  let <i>childins</i> be the child of <i>ins</i> in <i>T</i></p>
                </div>
                <div class="p1">
                    <p id="149">8.  GenerateTree(<i>childins</i>, <i>pos</i>-<i>step</i>, <i>depth</i>+1)</p>
                </div>
                <div class="p1">
                    <p id="150">9.  <b>end if</b></p>
                </div>
                <div class="p1">
                    <p id="151">10.  <b>end for</b></p>
                </div>
                <div class="p1">
                    <p id="152">11. <b>end if</b></p>
                </div>
                <div class="p1">
                    <p id="153">12. <b>end function</b></p>
                </div>
                <div class="p1">
                    <p id="154">指令序列树<i>T</i>构造完成后,把每个非根节点(包括叶子结点和内部节点)到根节点的路径所经过的所有节点指令按顺序串联起来,即得到以ret指令结尾的gadget指令序列。<i>T</i>的叶子结点和内部节点的数量等于在字节流BS中提取到的gadget的数量。</p>
                </div>
                <div class="p1">
                    <p id="155">图7为指令序列树<i>T</i>,设<i>I</i><sub>1</sub>=(<i>b</i><sub>2</sub><i>b</i><sub>1</sub>),<i>I</i><sub>2</sub>=(<i>b</i><sub>3</sub><i>b</i><sub>2</sub><i>b</i><sub>1</sub>),<i>I</i><sub>3</sub>=(<i>b</i><sub>5</sub><i>b</i><sub>4</sub><i>b</i><sub>3</sub>),<i>I</i><sub>4</sub>=(<i>b</i><sub>5</sub><i>b</i><sub>4</sub>),<i>I</i><sub>5</sub>=(<i>b</i><sub>6</sub><i>b</i><sub>5</sub><i>b</i><sub>4</sub>),<i>I</i><sub>6</sub>=(<i>b</i><sub>7</sub><i>b</i><sub>6</sub>),<i>I</i><sub>7</sub>=(<i>b</i><sub>7</sub><i>b</i><sub>6</sub>),可以提取7个gadget指令序列,分别为{<i>I</i><sub>1</sub>,<i>ret</i>},{<i>I</i><sub>2</sub>,<i>ret</i>},{<i>I</i><sub>3</sub>,<i>I</i><sub>1</sub>,<i>ret</i>},{<i>I</i><sub>4</sub>,<i>I</i><sub>2</sub>,<i>ret</i>},{<i>I</i><sub>5</sub>,<i>I</i><sub>2</sub>,<i>ret</i>},{<i>I</i><sub>6</sub>,<i>I</i><sub>3</sub>,<i>I</i><sub>1</sub>,<i>ret</i>},{<i>I</i><sub>7</sub>,<i>I</i><sub>4</sub>,<i>I</i><sub>2</sub>,<i>ret</i>}。</p>
                </div>
                <div class="area_img" id="156">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_156.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 指令序列树T" src="Detail/GetImg?filename=images/JYRJ201909052_156.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 指令序列树<i>T</i>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_156.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="157" name="157"><b>3.2 构造gadget</b></h4>
                <div class="p1">
                    <p id="158">虽然通过搜索能够获取到丰富多样的gadget,但是难以保证混淆过程需要的gadget都能匹配到,因此提出采用构造的方法获取gadget。通过对目标指令进行等价变换得到完全语义等价或条件语义等价的指令序列,在末尾添加ret指令即生成gadget,然后嵌入到目标程序的空闲空间或新增区块,或者嵌入到自定义共享函数库的导出函数内部。程序运行时加载到内存空间的gadget能够被调用执行。</p>
                </div>
                <div class="p1">
                    <p id="159">针对目标指令直接应用等价指令变换能够生成完全语义等价的指令序列。生成条件语义等价的指令序列的步骤如下:提取目标指令的常量操作数并假定常量操作数已经存储在栈顶空间;构造pop指令依次提取栈顶的常量操作数保存到寄存器;构造指令使用寄存器操作数替换常量操作数实现目标指令的等价功能;应用等价指令变换即生成条件语义等价的指令序列,如表1所示。</p>
                </div>
                <div class="area_img" id="160">
                    <p class="img_tit"><b>表1 目标指令的等价指令序列</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="160" border="1"><tr><td><br />目标指令</td><td>完全语义等价</td><td>条件语义等价</td></tr><tr><td><br />mov eax,1</td><td>mov eax,0<br />add eax,1</td><td>pop edx<br />mov eax,edx</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="161">下面给出几种等价指令变换方法,如表2所示。</p>
                </div>
                <div class="area_img" id="162">
                    <p class="img_tit"><b>表2 等价指令变换方法示例</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="162" border="1"><tr><td rowspan="4"><br />等价指令替换</td><td><br />目标指令</td><td>等价指令</td></tr><tr><td><br />xor eax,eax</td><td>mov eax,0</td></tr><tr><td><br />add eax,1</td><td>inc eax</td></tr><tr><td><br />not eax</td><td>xor eax,-1</td></tr><tr><td rowspan="2"><br />指令寄存器替换</td><td><br />目标指令</td><td>等价指令序列</td></tr><tr><td><br />xor eax,ebx</td><td>push ecx<br />mov ecx,eax<br />xor ecx,ebx<br />mov eax,ecx<br />pop ecx</td></tr><tr><td rowspan="2"><br />垃圾指令插入</td><td><br />目标指令</td><td>等价指令序列</td></tr><tr><td><br />mov eax,1</td><td>xor eax,ebx<br />mov eax,1<br />sub ebx,1<br />inc ebx</td></tr><tr><td colspan="3"><br />指令位置变换</td></tr><tr><td><br />目标指令序列</td><td>等价指令序列</td><td>等价指令序列</td></tr><tr><td><br />xor eax,ebx<br />add eax,1<br />inc ecx</td><td>inc ecx<br />xor eax,ebx<br />add eax,1</td><td>xor eax,eax<br />inc ecx<br />add eax,1</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="163">等价指令替换:使用单条指令实现目标指令等价的语义功能。</p>
                </div>
                <div class="p1">
                    <p id="164">指令寄存器替换:针对目标指令的通用寄存器进行替换而不影响语义功能,进而变换出等价指令序列。</p>
                </div>
                <div class="p1">
                    <p id="165">垃圾指令插入:在目标指令的前后位置分别插入若干垃圾指令而不影响语义功能,进而变换出等价指令序列。</p>
                </div>
                <div class="p1">
                    <p id="166">指令位置变换:若目标指令序列存在若干指令没有执行依赖关系,则变换指令前后位置不会改变指令序列执行功能,进而变换出多样化的等价指令序列。</p>
                </div>
                <div class="p1">
                    <p id="167">通过应用多样化的等价指令变换方法进行迭代变换,能够生成更加复杂的完全语义等价或条件语义等价的指令序列,增加逆向分析的难度。算法3给出针对单条指令的基于迭代的等价指令变换算法实现过程的伪代码。其中:Match(<i>I</i>,<i>R</i>)表示根据等价指令变换规则<i>R</i>匹配指令<i>I</i>的等价指令序列;Replace(<i>EIS</i>, <i>I</i>, Match(<i>I</i>, <i>R</i>))表示把指令序列<i>EIS</i>的指令<i>I</i>替换成匹配到的等价指令序列。</p>
                </div>
                <div class="p1">
                    <p id="168"><b>算法3</b> 基于迭代的等价指令变换算法</p>
                </div>
                <div class="p1">
                    <p id="169"><b>INPUT</b>: Target instruction <i>I</i>, equivalent instruction transformation rule <i>R</i>, iteration depth threshold <i>D</i></p>
                </div>
                <div class="p1">
                    <p id="170"><b>OUTPUT</b>: Equivalent instruction sequence <i>EIS</i></p>
                </div>
                <div class="p1">
                    <p id="171">1. <b>function</b> Transform(<i>I</i>, <i>R</i>, <i>D</i>)</p>
                </div>
                <div class="p1">
                    <p id="172">2. <i>EIS</i>={<i>I</i>}</p>
                </div>
                <div class="p1">
                    <p id="173">3. <b>if</b><i>D</i>==0 <b>or</b> Match(<i>I</i>, <i>R</i>)==NULL <b>then</b></p>
                </div>
                <div class="p1">
                    <p id="174">4.  <b>return</b><i>EIS</i></p>
                </div>
                <div class="p1">
                    <p id="175">5. <b>else then</b></p>
                </div>
                <div class="p1">
                    <p id="176">6.  <i>EIS</i>=Repalce(<i>EIS</i>, <i>I</i>, Match(<i>I</i>, <i>R</i>))</p>
                </div>
                <div class="p1">
                    <p id="177">7.  <b>for each</b><i>i</i><b>in</b><i>EIS</i><b>do</b></p>
                </div>
                <div class="p1">
                    <p id="178">8.  <i>EIS</i>=Replace(<i>EIS</i>, <i>i</i>, Transform(<i>i</i>, <i>R</i>, <i>D</i>-1))</p>
                </div>
                <div class="p1">
                    <p id="179">9.  <b>end for</b></p>
                </div>
                <div class="p1">
                    <p id="180">10. <b>end if</b></p>
                </div>
                <div class="p1">
                    <p id="181">11.  <b>return</b><i>EIS</i></p>
                </div>
                <div class="p1">
                    <p id="182">12. <b>end function</b></p>
                </div>
                <div class="p1">
                    <p id="183">直接嵌入gadget到目标程序或自定义共享函数库容易暴露代码内容,因此提出隐蔽嵌入gadget的方法,进而能够躲避静态反汇编。设gadget指令序列<i>G</i>={<i>i</i><sub>1</sub>,<i>i</i><sub>2</sub>,…,<i>i</i><sub><i>n</i></sub>,<i>ret</i>},对应的字节序列<i>B</i>=(<i>b</i><sub>1</sub><i>b</i><sub>2</sub>…<i>b</i><sub><i>m</i></sub>),若反汇编器在<i>b</i><sub>1</sub>的位置开始反汇编,则能够得到指令序列<i>G</i>,即Assemble(<i>B</i>)=<i>G</i>,Assemble表示反汇编过程。通过在字节序列<i>B</i>的前后位置分别插入字节序列<i>B</i><sub>1</sub>=(<i>b</i><mathml id="184"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml><i>b</i><mathml id="185"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>1</mn></msubsup></mrow></math></mathml>…<i>b</i><mathml id="186"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>s</mi><mn>1</mn></msubsup></mrow></math></mathml>)和<i>B</i><sub>2</sub>=(<i>b</i><mathml id="187"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>2</mn></msubsup></mrow></math></mathml><i>b</i><mathml id="188"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>2</mn></msubsup></mrow></math></mathml>…<i>b</i><mathml id="189"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>t</mi><mn>2</mn></msubsup></mrow></math></mathml>),生成字节序列<i>B</i><sup><i>SMT</i></sup>=<i>B</i><sub>1</sub>+<i>B</i>+<i>B</i><sub>2</sub>=(<i>b</i><mathml id="190"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml><i>b</i><mathml id="191"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>1</mn></msubsup></mrow></math></mathml>…<i>b</i><mathml id="192"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>s</mi><mn>1</mn></msubsup></mrow></math></mathml><i>b</i><sub>1</sub><i>b</i><sub>2</sub>…<i>b</i><sub><i>m</i></sub><i>b</i><mathml id="193"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>2</mn></msubsup></mrow></math></mathml><i>b</i><mathml id="194"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>2</mn></msubsup></mrow></math></mathml>…<i>b</i><mathml id="195"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>t</mi><mn>2</mn></msubsup></mrow></math></mathml>),使得字节<i>b</i><mathml id="196"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mn>1</mn></msubsup></mrow></math></mathml>成为反汇编的起始位置,<i>b</i><sub>1</sub>成为反汇编指令的中间字节,造成反汇编<i>B</i><sup><i>SMT</i></sup>得到完全不同的指令序列,即<i>G</i>∉<i>Assemble</i>(<i>B</i><sup><i>SMT</i></sup>),因此能够有效隐藏指令序列<i>G</i>。如图8所示,指令序列{pop edx,xor eax,ebx,ret}对应字节序列{0x5A,0x33,0xC2,0xC3},通过插入字节0x8B和0x10后,反汇编得到完全不同的指令序列{mov ebx,[edx+33h],ret 10C3h},进而实现隐蔽的效果。</p>
                </div>
                <div class="area_img" id="197">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_197.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 隐蔽嵌入gadget效果" src="Detail/GetImg?filename=images/JYRJ201909052_197.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图8 隐蔽嵌入gadget效果  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_197.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="198" name="198" class="anchor-tag"><b>4 方法分析</b></h3>
                <div class="p1">
                    <p id="199">本文提出的基于ROP技术的代码混淆方法,能够在一定程度上保护程序内部代码避免暴露给逆向工程。下面分别从有效性、空间开销和时间开销三个方面分析和评价方法的性能。</p>
                </div>
                <h4 class="anchor-tag" id="200" name="200"><b>4.1 有效性</b></h4>
                <div class="p1">
                    <p id="201">攻击者通过静态分析能够轻易获取程序内部核心代码,通过动态分析能够跟踪核心代码的执行功能。混淆方法利用ROP技术复用内存空间的指令代码,能够有效隐藏程序内部原始核心代码,导致攻击者难以通过静态分析判断核心代码存在及获取核心代码。</p>
                </div>
                <div class="p1">
                    <p id="202">通过使用多样化的等价指令变换方法针对目标指令进行迭代变换,能够生成形式多样、长度膨胀、执行复杂的等价指令序列,增加攻击者分析代码的难度,同时通过隐蔽嵌入gadget指令序列,能够有效抵抗静态反汇编分析。</p>
                </div>
                <div class="p1">
                    <p id="203">程序动态执行时,混淆指令序列随机分布在程序内存空间的不同位置,使得程序执行轨迹在内存空间不断跳变,执行过程的上下文环境不断变化,能够增加攻击者动态跟踪分析的难度。</p>
                </div>
                <div class="p1">
                    <p id="204">原始核心代码<i>K</i>的指令数量为<i>n</i>条。把<i>n</i>条指令混淆成<i>n</i>组实现等价功能的指令序列,设指令序列<i>G</i><mathml id="205"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>的指令数量为<i>c</i><mathml id="206"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup></mrow></math></mathml>条,混淆后的指令数量<i>N</i>如下:</p>
                </div>
                <div class="p1">
                    <p id="207" class="code-formula">
                        <mathml id="207"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ν</mi><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>m</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></munderover><mi>c</mi></mstyle></mrow></mstyle><msubsup><mrow></mrow><mi>j</mi><mi>i</mi></msubsup><mo>=</mo><mi>n</mi><mo>×</mo><mover accent="true"><mi>m</mi><mo>¯</mo></mover><mo>×</mo><mover accent="true"><mi>c</mi><mo>¯</mo></mover></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="208">攻击者需要分析的指令数量增加<mathml id="209"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi>m</mi><mo>¯</mo></mover><mo>×</mo><mover accent="true"><mi>c</mi><mo>¯</mo></mover></mrow></math></mathml>倍,因此逆向分析的难度显著增加,能够有效对抗逆向分析。</p>
                </div>
                <div class="p1">
                    <p id="210">原始核心代码<i>K</i>只有唯一执行路径,而经过随机多样化混淆后,代码执行路径数<i>P</i>如下:</p>
                </div>
                <div class="p1">
                    <p id="211" class="code-formula">
                        <mathml id="211"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>r</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="212">程序每次动态执行的路径动态随机变化,攻击者想要分析代码的执行功能,需要把全部的<i>P</i>条执行路径分析清楚,因此随机多样化的混淆策略能够进一步增加逆向分析的难度和时间成本。</p>
                </div>
                <div class="p1">
                    <p id="213">综上分析,混淆方法能够有效隐藏和保护程序内部核心代码,抵抗多种特定的逆向分析手段,在静态和动态两方面能够发挥较好的保护作用。</p>
                </div>
                <h4 class="anchor-tag" id="214" name="214"><b>4.2 空间和时间开销</b></h4>
                <div class="p1">
                    <p id="215">混淆后程序相比原始程序增加数据和代码,使得程序的空间开销和执行时间开销相应增大。混淆过程给目标程序增加的空间开销主要包括如下几部分:首先是通过等价变换生成的gadget指令代码,混淆阶段嵌入到程序内部或自定义共享函数库;其次是连续的压栈操作代码,实现gadget指令序列地址及数据依次压栈;最后是实现加载函数库以及获取内存地址等功能的辅助代码。设各部分混淆代码的大小分别为<i>S</i><sub>1</sub>、<i>S</i><sub>2</sub>、<i>S</i><sub>3</sub>,则混淆后程序增长的空间开销约为:</p>
                </div>
                <div class="p1">
                    <p id="216"><i>S</i>=<i>S</i><sub>1</sub>+<i>S</i><sub>2</sub>+<i>S</i><sub>3</sub></p>
                </div>
                <div class="p1">
                    <p id="217">混淆过程给目标程序增加的时间开销主要是代码<i>S</i><sub>1</sub>、<i>S</i><sub>2</sub>、<i>S</i><sub>3</sub>的执行引起的。设混淆代码<i>S</i><sub>1</sub>、<i>S</i><sub>2</sub>、<i>S</i><sub>3</sub>的平均执行时间分别为<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>、<i>T</i><sub>3</sub>,则混淆后程序增长的时间开销约为:</p>
                </div>
                <div class="p1">
                    <p id="218"><i>T</i>=<i>T</i><sub>1</sub>+<i>T</i><sub>2</sub>+<i>T</i><sub>3</sub></p>
                </div>
                <div class="p1">
                    <p id="219">根据混淆过程可知,混淆增加的空间开销应主要由构造嵌入的gadget指令代码所影响,在处理器运算速度极快的条件下,混淆代码的执行不会增加过多时间开销。可以推算,混淆不会给程序造成严重的空间和时间开销,应具有可接受的开销性能,后续通过实验进一步验证和分析。</p>
                </div>
                <h3 id="220" name="220" class="anchor-tag"><b>5 实验分析</b></h3>
                <div class="p1">
                    <p id="221">本节通过实验验证方法的有效性并评价方法的性能。实验环境为32位Windows 7操作系统,3.10 GHz Intel Core 5处理器以及4 GB内存。实验首先选取5款常用的系统共享函数库,在代码段递归搜索以ret指令结尾的gadget指令序列,分别设置搜索深度为1到4,记录搜索到的gadget数量,如表3所示。可以看到,系统共享函数库包含大量的gadget,混淆过程可以根据需要随机选择可用的gadget进行混淆。为了保证总能获得混淆需要的gadget,实验同时通过等价变换构造大量实现目标功能的gadget。</p>
                </div>
                <div class="area_img" id="222">
                    <p class="img_tit"><b>表3 gadget指令序列搜索结果</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="222" border="1"><tr><td><br />系统共享库</td><td>深度1</td><td>深度2</td><td>深度3</td><td>深度4</td></tr><tr><td><br />kernel32.dll</td><td>2 719</td><td>5 694</td><td>8 276</td><td>11 086</td></tr><tr><td><br />user32.dll</td><td>4 172</td><td>7 393</td><td>10 046</td><td>12 968</td></tr><tr><td><br />kernelBase.dll</td><td>7 090</td><td>14 088</td><td>20 565</td><td>26 831</td></tr><tr><td><br />gdi32.dll</td><td>4 776</td><td>8 458</td><td>11 611</td><td>14 853</td></tr><tr><td><br />ntdll.dll</td><td>6 056</td><td>11 958</td><td>16 913</td><td>22 028</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="223">实验选取6款测试程序进行混淆,分别为在VS2010环境下编译生成的3款Debug版本程序,包括冒泡排序程序Bubble.exe、汉诺塔程序Hanio.exe和八皇后程序Queue.exe,以及Windows7操作系统下的3款轻量级系统应用程序,包括计算器程序Calc.exe、网络测试程序Ping.exe和记事本程序Notepad.exe。实验选取测试程序的部分功能代码进行混淆,例如选取的冒泡排序程序代码以及针对其中两条指令的混淆示例。如图9所示,通过在栈空间预设指令地址和数据,实现gadget指令序列的连续调用执行。</p>
                </div>
                <div class="area_img" id="224">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_224.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 冒泡排序程序混淆示例" src="Detail/GetImg?filename=images/JYRJ201909052_224.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图9 冒泡排序程序混淆示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_224.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="225">混淆实验结果如表4所示,分别列出混淆的目标代码数,混淆前后程序体积大小及混淆后程序的执行情况,其中冒泡排序程序输入数组规模为2 000(将从大到小排列的数组通过冒泡排序排列成从小到大排列的数组),汉诺塔程序输入规模为24,设置八皇后程序棋盘大小为12×12。混淆后程序经过反复测试执行,均能实现原始程序的正常功能,证明混淆方法具有可行性,能够保持程序语义功能等价。</p>
                </div>
                <div class="area_img" id="226">
                    <p class="img_tit"><b>表4 混淆前后程序的执行和开销情况</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="226" border="1"><tr><td rowspan="2">测试<br />程序</td><td rowspan="2">混淆<br />代码</td><td colspan="2"><br />体积/KB</td><td rowspan="2">执行<br />功能</td><td rowspan="2">执行时间/ms</td></tr><tr><td><br />混淆前</td><td>混淆后</td></tr><tr><td>Bubble.exe</td><td>4</td><td>38.0</td><td>65.0</td><td>正常</td><td>15→42</td></tr><tr><td><br />Hanio.exe</td><td>3</td><td>28.0</td><td>47.5</td><td>正常</td><td>250→298</td></tr><tr><td><br />Queue.exe</td><td>3</td><td>28.5</td><td>45.0</td><td>正常</td><td>546→625</td></tr><tr><td><br />Calc.exe</td><td>7</td><td>758</td><td>815</td><td>正常</td><td>没有明显变化</td></tr><tr><td><br />Ping.exe</td><td>5</td><td>15.0</td><td>58.0</td><td>正常</td><td>没有明显变化</td></tr><tr><td><br />Notepad.exe</td><td>9</td><td>175</td><td>232</td><td>正常</td><td>没有明显变化</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="227">在时间开销方面,记录混淆前后的冒泡排序、汉诺塔和八皇后程序的精确执行时间以及另外三个程序的执行时间变化情况。实验结果显示冒泡排序、汉诺塔和八皇后程序的执行时间增长都非常小,另外三个程序正常执行过程均没有明显时间变化,说明混淆方法没有带来巨大时间开销,具有较好的时间开销性能。在空间开销方面,混淆后程序体积适当增长,而且随着混淆的目标代码数量越多,程序体积增长越大。然而程序载体通常具有足够的存储和处理资源,适当的体积增长基本不会影响程序的存储、加载和运行等过程,因此混淆方法依然具有较好的空间开销性能。</p>
                </div>
                <div class="p1">
                    <p id="228">由于没有统一的混淆强度度量标准,因此本文根据混淆方法的实际保护效果,提出适用本文方法的混淆强度指标并结合实验结果进行分析。首先混淆后程序的每个核心代码块的执行变成很多个gadget代码块的等价执行,与混淆前攻击者相比,需要分析数量更多的代码块以及更加复杂的控制转移关系,因此可以使用混淆代码块数量比例<i>RB</i>度量混淆方法在代码块层面的保护强度。设<i>NKB</i>表示混淆的原始程序核心代码块的数量,<i>NGB</i>表示混淆后程序gadget代码块的数量。<i>RB</i>的计算如下:</p>
                </div>
                <div class="p1">
                    <p id="229"><i>RB</i>=<i>NGB</i>/<i>NKB</i></p>
                </div>
                <div class="p1">
                    <p id="230">混淆使得攻击者需要分析的指令数量大大增加,因此可以使用指令数量比例<i>RI</i>度量混淆方法在指令层面的保护强度。设<i>NKI</i>表示原始程序核心代码的指令数量,<i>NGI</i>表示混淆后程序gadget指令序列的指令数量。<i>RI</i>的计算如下:</p>
                </div>
                <div class="p1">
                    <p id="231"><i>RI</i>=<i>NGI</i>/<i>NKI</i></p>
                </div>
                <div class="p1">
                    <p id="232">混淆所调用的gadget指令序列的二进制字节序列可能隐藏在正常指令代码的字节序列内部,使得静态反汇编获取不到实际执行的gadget指令序列,进而达到迷惑和干扰反汇编的效果。因此可以使用正确反汇编的gadget指令数量比例<i>RD</i>度量混淆方法抵抗静态反汇编的保护强度。设<i>NDGI</i>表示能够正确反汇编的gadget指令数量。<i>RD</i>的计算如下:</p>
                </div>
                <div class="p1">
                    <p id="233"><i>RD</i>=<i>NDGI</i>/<i>NGI</i></p>
                </div>
                <div class="p1">
                    <p id="234">根据<i>RB</i>、<i>RI</i>、<i>RD</i>的定义可知,<i>RB</i>和<i>RI</i>越大,攻击者需要分析的代码块和指令数量相对越多,需要分析gadget之间的控制转移关系越复杂;<i>RD</i>越小,攻击者静态反汇编能够正确获取的指令数量相对越少。实验分别统计6款测试程序混淆前后的<i>NKB</i>、<i>NGB</i>、<i>NKI</i>、<i>NGI</i>、<i>NDGI</i>值,计算相应的<i>RB</i>、<i>RI</i>、<i>RD</i>值,结果如表5所示。图10更直观地对比展示了混淆前后的统计结果。</p>
                </div>
                <div class="area_img" id="235">
                    <p class="img_tit"><b>表5 混淆前后程序相关数据</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="235" border="1"><tr><td rowspan="2"><br />度量值</td><td colspan="6"><br />测试程序</td></tr><tr><td>Bubble.<br />exe</td><td>Hanio.<br />exe</td><td>Queue.<br />exe</td><td>Calc.<br />exe</td><td>Ping.<br />exe</td><td>Notepad.<br />exe</td></tr><tr><td><i>NKB</i></td><td>4</td><td>3</td><td>3</td><td>7</td><td>5</td><td>9</td></tr><tr><td><br /><i>NKI</i></td><td>29</td><td>19</td><td>20</td><td>56</td><td>43</td><td>77</td></tr><tr><td><br /><i>NGB</i></td><td>62</td><td>55</td><td>53</td><td>118</td><td>72</td><td>166</td></tr><tr><td><br /><i>NGI</i></td><td>211</td><td>178</td><td>189</td><td>322</td><td>231</td><td>413</td></tr><tr><td><br /><i>NDGI</i></td><td>89</td><td>95</td><td>103</td><td>179</td><td>146</td><td>235</td></tr><tr><td><br /><i>RB</i></td><td>15.5</td><td>18.3</td><td>17.7</td><td>16.9</td><td>14.4</td><td>18.4</td></tr><tr><td><br /><i>RI</i></td><td>7.28</td><td>9.34</td><td>9.45</td><td>5.75</td><td>5.37</td><td>5.36</td></tr><tr><td><br /><i>RD</i></td><td>0.42</td><td>0.53</td><td>0.54</td><td>0.55</td><td>0.63</td><td>0.57</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="237">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_23700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图10 混淆前后代码块数量和指令数量对比" src="Detail/GetImg?filename=images/JYRJ201909052_23700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图10 混淆前后代码块数量和指令数量对比  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_23700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="237">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909052_23701.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图10 混淆前后代码块数量和指令数量对比" src="Detail/GetImg?filename=images/JYRJ201909052_23701.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图10 混淆前后代码块数量和指令数量对比  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909052_23701.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="238">由表5的实验结果可以看到,<i>RB</i>的取值范围为14.4～18.4,平均值为16.9,意味着攻击者需要分析的混淆后代码块数量是混淆前的16.9倍。<i>RI</i>的取值范围为5.36～9.45,平均值为7.09,意味着攻击者需要分析的混淆后指令数量是混淆前的7.09倍。<i>RD</i>的取值范围为0.42～0.63,平均值为0.54,意味着通过静态反汇编只能正确得到54%的混淆后gadget指令。实验结果证明,混淆方法能够有效增加静动态获取和分析核心代码的难度,在一定程度实现代码隐藏的保护效果。</p>
                </div>
                <h3 id="239" name="239" class="anchor-tag"><b>6 结 语</b></h3>
                <div class="p1">
                    <p id="240">本文针对程序核心代码容易暴露给逆向攻击的问题,提出一种基于ROP技术的代码混淆方法。方法借鉴ROP攻击技术的代码组织和调用方式,通过在栈空间预设指令地址和数据,利用程序内存空间随机分布的gadget指令序列动态组合执行,实现目标代码的等价功能。同时方法采取搜索和构造两种方法获取混淆所需要的gadget指令序列,进一步实现执行代码和路径的随机多样化。实验和分析证明,方法能够有效增加攻击者获取和分析核心代码的难度,在静态和动态两方面实现较好的保护效果,具有较好的时间和空间开销性能。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A taxonomy of obfuscating transformations">

                                <b>[1]</b> Collberg C,Thomborson C,Low D.A taxonomy of obfuscating transformations[R].Department of Computer Science,The University of Auckland,New Zealand,1997.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A New Code Obfuscation Scheme for Software Protection">

                                <b>[2]</b> Kulkarni A,Metta R.A new code obfuscation scheme for software protection[C]//Proceedings of the 2014 IEEE 8th International Symposium on Service Oriented System Engineering.IEEE,2014:409-414.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Mixed Obfuscation of Overlapping Instruction and Self-Modify Code Based on Hyper-Chaotic Opaque Predicates">

                                <b>[3]</b> Xie X,Liu F,Lu B,et al.Mixed obfuscation of overlapping instruction and self-modify code based on hyper-chaotic opaque predicates[C]//2014 Tenth International Conference on Computational Intelligence and Security.IEEE,2014:524-528.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJIG&amp;filename=SJIG88C1A86B6DF99029839B5DD9B09B0F01&amp;v=MTU3NTJCWFU1elI4YjZUWVBUUXVXcFdBMWNNQ1VNN3FlQ09OdkZTaVdXcjdKSUZwbWFCdUhZZk9HUWxmQnJMVTA1dHRoeExtOXhhZz1OaWZDYWJ1d2JkQzlwNGszWXA5NQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b> Behera C K,Bhaskari D L.Self-Modifying Code:A Provable Technique for Enhancing Program Obfuscation[J].International Journal of Secure Software Engineering (IJSSE),2017,8(3):24-41.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU201810020&amp;v=MDUyNzlJSVRmVGU3RzRIOW5OcjQ5SFpJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5amtVYnI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> 陈喆,贾春福,宗楠,等.随机森林在程序分支混淆中的应用[J].电子学报,2018,46(10):2458-2466.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201712023&amp;v=MDYwODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnlqa1VicklMejdCYjdHNEg5Yk5yWTlIWjRRS0RIODQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> 苏庆,孙金田.基于混沌不透明表达式的不透明谓词混淆技术研究[J].计算机科学,2017,44 (12):114-119.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Exploiting code mobility for dynamic binary obfuscation">

                                <b>[7]</b> Falcarin P,Di Carlo S,Cabutto A,et al.Exploiting code mobility for dynamic binary obfuscation[C]//2011 World Congress on Internet Security(WorldCIS-2011).IEEE,2011:114-120.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Software Watermarking Using Return-Oriented Programming,&amp;quot;">

                                <b>[8]</b> Ma H,Lu K,Ma X,et al.Software Watermarking using Return-Oriented Programming[C]//Proceedings of the 10th ACM Symposium on Information,Computer and Communications Security.ACM,2015:369-380.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=ROPOB:Obfuscating Binary Code via Return Oriented Programming">

                                <b>[9]</b> Mu D,Guo J,Ding W,et al.ROPOB:Obfuscating Binary Code via Return Oriented Programming[C]//International Conference on Security and Privacy in Communication Systems.Springer,Cham,2017:721-737.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=RopSteg:program steganography with return oriented programming">

                                <b>[10]</b> Lu K,Xiong S,Gao D.Ropsteg:program steganography with return oriented programming[C]//Proceedings of the 4th ACM conference on Data and application security and privacy.ACM,2014:265-272.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JYRJ201909052" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201909052&amp;v=MTQ1MzBqTXBvOUFab1FLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeWprVWJySUx6VFpaTEc0SDk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
