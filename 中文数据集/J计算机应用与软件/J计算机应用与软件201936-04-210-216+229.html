<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637135754070596250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJYRJ201904034%26RESULT%3d1%26SIGN%3dhH%252bnj8KV7ShQl0t8PQkRKnChNio%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201904034&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201904034&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201904034&amp;v=Mjc5ODFIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnl6bVViektMelRaWkxHNEg5ak1xNDlHWUlRS0Q=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#38" data-title="&lt;b&gt;0 引 言&lt;/b&gt; "><b>0 引 言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#42" data-title="&lt;b&gt;1 相关研究&lt;/b&gt; "><b>1 相关研究</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#47" data-title="&lt;b&gt;2 预处理算法分析&lt;/b&gt; "><b>2 预处理算法分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#49" data-title="&lt;b&gt;2.1 2-hop cover&lt;/b&gt;"><b>2.1 2-hop cover</b></a></li>
                                                <li><a href="#59" data-title="&lt;b&gt;2.2 索引算法&lt;/b&gt;"><b>2.2 索引算法</b></a></li>
                                                <li><a href="#108" data-title="&lt;b&gt;2.3 查询算法&lt;/b&gt;"><b>2.3 查询算法</b></a></li>
                                                <li><a href="#117" data-title="&lt;b&gt;2.4 复杂度分析&lt;/b&gt;"><b>2.4 复杂度分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#120" data-title="&lt;b&gt;3 动态更新算法分析&lt;/b&gt; "><b>3 动态更新算法分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#126" data-title="&lt;b&gt;3.1 索引集更新&lt;/b&gt;"><b>3.1 索引集更新</b></a></li>
                                                <li><a href="#153" data-title="&lt;b&gt;3.2 自循环标记表更新&lt;/b&gt;"><b>3.2 自循环标记表更新</b></a></li>
                                                <li><a href="#172" data-title="&lt;b&gt;3.3 距离标记表更新&lt;/b&gt;"><b>3.3 距离标记表更新</b></a></li>
                                                <li><a href="#194" data-title="&lt;b&gt;3.4 正确性证明&lt;/b&gt;"><b>3.4 正确性证明</b></a></li>
                                                <li><a href="#232" data-title="&lt;b&gt;3.5 复杂度分析&lt;/b&gt;"><b>3.5 复杂度分析</b></a></li>
                                                <li><a href="#239" data-title="&lt;b&gt;3.6 实例分析&lt;/b&gt;"><b>3.6 实例分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#249" data-title="&lt;b&gt;4 结 语&lt;/b&gt; "><b>4 结 语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#147" data-title="图1 一个示例:图中距离是与最左边节点top-2距离">图1 一个示例:图中距离是与最左边节点top-2距离</a></li>
                                                <li><a href="#148" data-title="图2 一个示例:图增加一条边后与最左边节点top-2距离">图2 一个示例:图增加一条边后与最左边节点top-2距离</a></li>
                                                <li><a href="#244" data-title="&lt;b&gt;表1 k对更新算法时间开销的影响&lt;/b&gt;"><b>表1 k对更新算法时间开销的影响</b></a></li>
                                                <li><a href="#246" data-title="&lt;b&gt;表2 &lt;i&gt;k&lt;/i&gt;对更新算法空间开销和平均访问节点数量的影响&lt;/b&gt;"><b>表2 <i>k</i>对更新算法空间开销和平均访问节点数量的影响</b></a></li>
                                                <li><a href="#248" data-title="图3 更新量对更新算法时间开销和访问节点数量的影响">图3 更新量对更新算法时间开销和访问节点数量的影响</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="4">


                                    <a id="bibliography_1" title=" Berclaz J, Fleuret F, T&#252;retken E, et al. Multiple object tracking using k-shortest paths optimization[J].IEEE Transactions on Pattern Analysis &amp;amp; Machine Intelligence, 2011, 33 (9) : 1806-1819." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Multiple object tracking using k-shortest paths optimization">
                                        <b>[1]</b>
                                         Berclaz J, Fleuret F, T&#252;retken E, et al. Multiple object tracking using k-shortest paths optimization[J].IEEE Transactions on Pattern Analysis &amp;amp; Machine Intelligence, 2011, 33 (9) : 1806-1819.
                                    </a>
                                </li>
                                <li id="6">


                                    <a id="bibliography_2" title=" Shih Y K, Parthasarathy S. A single source k-shortest paths algorithm to infer regulatory pathways in a gene network[J]. Bioinformatics, 2012, 28 (12) : i49-i58." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJRS&amp;filename=SJRS120719012443&amp;v=MzEyNzE5ZmJ2bktyaWZaZVp2RnlubVU3dkxJbDBXTmlmWmZiSzZIdGJOcG85RVp1OExEeE04enhVU21EZDlTSDduM3hF&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         Shih Y K, Parthasarathy S. A single source k-shortest paths algorithm to infer regulatory pathways in a gene network[J]. Bioinformatics, 2012, 28 (12) : i49-i58.
                                    </a>
                                </li>
                                <li id="8">


                                    <a id="bibliography_3" title=" Ozer B, Gezici G, Meydan C, et al. Multiple sequence alignment based on structural properties[C]//Health Informatics and Bioinformatics (HIBIT) , 2010 5th International Symposium on. IEEE, 2010: 39-44." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Multiple sequence alignment based on structural properties">
                                        <b>[3]</b>
                                         Ozer B, Gezici G, Meydan C, et al. Multiple sequence alignment based on structural properties[C]//Health Informatics and Bioinformatics (HIBIT) , 2010 5th International Symposium on. IEEE, 2010: 39-44.
                                    </a>
                                </li>
                                <li id="10">


                                    <a id="bibliography_4" title=" Hoffman W, Pavley R. A method for the solution of the nth best path problem[J]. Journal of the ACM, 1959, 6 (4) : 506-514." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000018020&amp;v=MjgxMTlpclJkR2VycVFUTW53WmVadEZpbmxVcnpJSkYwV2FSQT1OaWZJWTdLN0h0ak5yNDlGWk9vSERINDVvQk1UNlQ0UFFILw==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                         Hoffman W, Pavley R. A method for the solution of the nth best path problem[J]. Journal of the ACM, 1959, 6 (4) : 506-514.
                                    </a>
                                </li>
                                <li id="12">


                                    <a id="bibliography_5" title=" Dijkstra E W. A note on two problems in connexion with graphs[J].Numerische mathematik, 1959, 1 (1) :269-271." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00002467824&amp;v=MjQ3MDVqN0Jhck80SHRIT3E0bENiT2tMWTNrNXpCZGg0ajk5U1hxUnJ4b3hjTUg3UjdxZForWnVGaXZsVjd6S0kxdz1O&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         Dijkstra E W. A note on two problems in connexion with graphs[J].Numerische mathematik, 1959, 1 (1) :269-271.
                                    </a>
                                </li>
                                <li id="14">


                                    <a id="bibliography_6" title=" Aini A, Salehipour A. Speeding up the Floyd-Warshall algorithm for the cycled shortest path problem[J]. Applied Mathematics Letters, 2012, 25 (1) : 1-5." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300064906&amp;v=MDI1NjN3WmVadEZpbmxVcnpJSkYwV2FSQT1OaWZPZmJLN0h0RE9ySTlGWk8wTEJYdy9vQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         Aini A, Salehipour A. Speeding up the Floyd-Warshall algorithm for the cycled shortest path problem[J]. Applied Mathematics Letters, 2012, 25 (1) : 1-5.
                                    </a>
                                </li>
                                <li id="16">


                                    <a id="bibliography_7" title=" Cohen E, Halperin E, Kaplan H, et al. Reachability and distance queries via 2-hop labels[C]//Proceedings of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms.Society for Industrial and Applied Mathematics, 2002:937-946." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Reachability and distance queries via 2-hop labels">
                                        <b>[7]</b>
                                         Cohen E, Halperin E, Kaplan H, et al. Reachability and distance queries via 2-hop labels[C]//Proceedings of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms.Society for Industrial and Applied Mathematics, 2002:937-946.
                                    </a>
                                </li>
                                <li id="18">


                                    <a id="bibliography_8" title=" Wei F. TEDI: efficient shortest path query answering on graphs[C]//Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data. Indianapolis, Indiana, USA: ACM, 2010: 99-110." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=TEDI: Efficient Shortest Path Query Answering on Graphs">
                                        <b>[8]</b>
                                         Wei F. TEDI: efficient shortest path query answering on graphs[C]//Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data. Indianapolis, Indiana, USA: ACM, 2010: 99-110.
                                    </a>
                                </li>
                                <li id="20">


                                    <a id="bibliography_9" title=" Akiba T, Sommer C, Kawarabayashi K I. Shortest-path queries for complex networks: exploiting low tree-width outside the core[C]//Proceedings of the 15th International Conference on Extending Database Technology. Berlin, Germany: ACM, 2012: 144-155." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Shortest-path queries for complex networks: exploiting low tree-width outside the core">
                                        <b>[9]</b>
                                         Akiba T, Sommer C, Kawarabayashi K I. Shortest-path queries for complex networks: exploiting low tree-width outside the core[C]//Proceedings of the 15th International Conference on Extending Database Technology. Berlin, Germany: ACM, 2012: 144-155.
                                    </a>
                                </li>
                                <li id="22">


                                    <a id="bibliography_10" title=" Xu Q, Zhang X, Zhao J, et al. Fast shortest-path queries on large-scale graphs[C]//IEEE 24th International Conference on Network Protocols (ICNP) .Singapore:IEEE, 2016:1-10." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fast shortest-path queries on large-scale graphs">
                                        <b>[10]</b>
                                         Xu Q, Zhang X, Zhao J, et al. Fast shortest-path queries on large-scale graphs[C]//IEEE 24th International Conference on Network Protocols (ICNP) .Singapore:IEEE, 2016:1-10.
                                    </a>
                                </li>
                                <li id="24">


                                    <a id="bibliography_11" title=" Akiba T, Iwata Y, Yoshida Y. Fast exact shortest-path distance queries on large networks by pruned landmark labeling[C]//Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data.New York, USA:ACM, 2013: 349-360." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fast exact shortest-path distance queries on large networks by pruned landmark labeling">
                                        <b>[11]</b>
                                         Akiba T, Iwata Y, Yoshida Y. Fast exact shortest-path distance queries on large networks by pruned landmark labeling[C]//Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data.New York, USA:ACM, 2013: 349-360.
                                    </a>
                                </li>
                                <li id="26">


                                    <a id="bibliography_12" title=" Akiba T, Iwata Y, Yoshida Y. Dynamic and historical shortest-path distance queries on large evolving networks by pruned landmark labeling[C]//Proceedings of the 23rd International Conference on World Wide Web. ACM, 2014: 237-248." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Dynamic and historical shortest-path distance queries on large evolving networks by pruned landmark labeling.">
                                        <b>[12]</b>
                                         Akiba T, Iwata Y, Yoshida Y. Dynamic and historical shortest-path distance queries on large evolving networks by pruned landmark labeling[C]//Proceedings of the 23rd International Conference on World Wide Web. ACM, 2014: 237-248.
                                    </a>
                                </li>
                                <li id="28">


                                    <a id="bibliography_13" title=" Yen J Y. Finding the k shortest loopless paths in a network[J]. management Science, 1971, 17 (11) : 712-716." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJIF&amp;filename=SJIF13022100017514&amp;v=MDIyODVycVFUTW53WmVadEZpbmxVcnpJSkYwV2FSQT1OaWZDYUxLN0h0UE9ybzlGWk9vSUNYMDlvQk1UNlQ0UFFIL2lyUmRHZQ==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                         Yen J Y. Finding the k shortest loopless paths in a network[J]. management Science, 1971, 17 (11) : 712-716.
                                    </a>
                                </li>
                                <li id="30">


                                    <a id="bibliography_14" title=" Eppstein D. Finding the k shortest paths[C]//Proceedings of the 35th Annual Symposium on Foundations of Computer Science. IEEE Computer Society, 1994: 154-165." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Finding the k shortest paths">
                                        <b>[14]</b>
                                         Eppstein D. Finding the k shortest paths[C]//Proceedings of the 35th Annual Symposium on Foundations of Computer Science. IEEE Computer Society, 1994: 154-165.
                                    </a>
                                </li>
                                <li id="32">


                                    <a id="bibliography_15" title=" Akiba T, Hayashi T, Nori N, et al. Efficient top-k shortest-path distance queries on large networks by pruned landmark labeling[C]//Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, January 25-30, 2015, Austin, Texas, USA: AAAI Press, 2015: 349-360." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient top-k shortest-path distance queries on large networks by pruned landmark labeling">
                                        <b>[15]</b>
                                         Akiba T, Hayashi T, Nori N, et al. Efficient top-k shortest-path distance queries on large networks by pruned landmark labeling[C]//Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, January 25-30, 2015, Austin, Texas, USA: AAAI Press, 2015: 349-360.
                                    </a>
                                </li>
                                <li id="34">


                                    <a id="bibliography_16" title=" Mislove A E. Online social networks: measurement, analysis, and applications to distributed information systems[D]. Rice University, 2009." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Online social networks: measurement, analysis, and applications to distributed information systems">
                                        <b>[16]</b>
                                         Mislove A E. Online social networks: measurement, analysis, and applications to distributed information systems[D]. Rice University, 2009.
                                    </a>
                                </li>
                                <li id="36">


                                    <a id="bibliography_17" title=" SNAP: network datasets: Wikipedia vote network[EB/OL].[2018-11-08].http://snap.stanford.edu/data/wiki-Vote.html." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=SNAP: network datasets: Wikipedia vote network">
                                        <b>[17]</b>
                                         SNAP: network datasets: Wikipedia vote network[EB/OL].[2018-11-08].http://snap.stanford.edu/data/wiki-Vote.html.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JYRJ" target="_blank">计算机应用与软件</a>
                2019,36(04),210-216+229 DOI:10.3969/j.issn.1000-386x.2019.04.033            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>动态图上基于2-HOP COVER的TOP-K最短路径算法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%96%BD%E7%90%B4%E5%84%BF&amp;code=41485882&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">施琴儿</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%A4%8D%E6%97%A6%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2%E5%A4%8D%E6%97%A6-%E4%BC%97%E5%AE%89%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E8%81%94%E5%90%88%E5%AE%9E%E9%AA%8C%E5%AE%A4&amp;code=0075855&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">复旦大学计算机科学技术学院复旦-众安区块链与信息安全联合实验室</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%AD%E5%BF%83&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">上海市区块链工程技术中心</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>top-k最短路径问题是在给定图中查找两个节点的最短的<i>k</i>条路径的问题。对于大规模的图, 这一问题的算法通常分为两个步骤:耗时的一次性预处理和快速的查询应答。但是, 很多这样的算法都是针对静态图的。如果图进行了改变, 耗时的预处理就要重做。基于静态图中的2-hop cover的top-k最短路径算法, 提出一个适用于动态的有向带权图上的top-k最短路径算法, 其创新部分是一个更新预处理数据的子程序。该算法只需要修改原始图的很小一部分索引集就可以得到更新后图的索引集, 极大地减少了算法的总运行时间。证明了算法的正确性, 并分析了算法的时间和空间复杂度。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=top-k%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">top-k最短路径;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%8A%A8%E6%80%81%E5%9B%BE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">动态图;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%B4%A2%E5%BC%95%E9%9B%86&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">索引集;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=2-hop%20cover&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">2-hop cover;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    施琴儿, 硕士生, 主研领域:算法, 计算复杂性。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-10-29</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目 (61672166);</span>
                                <span>上海市领军人才计划项目 (2016-021);</span>
                                <span>2016年上海市优秀学术带头人项目 (16XD1400200);</span>
                                <span>上海市基础研究科技创新行动计划项目 (16JC1402700);</span>
                    </p>
            </div>
                    <h1><b>TOP-K SHORTEST-PATH ALGORITHM BASED ON 2-HOP COVER ON DYNAMIC GRAPH</b></h1>
                    <h2>
                    <span>Shi Qiner</span>
            </h2>
                    <h2>
                    <span>Fudan University and Zhongan Technology Blockchain and Information Security Joint Lab, School of Computer Science, Fudan University</span>
                    <span>The Shanghai Blockchain Institute of Engineering and Technology</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Top-k shortest-path problem can be described as finding the shortest K paths of two nodes in a given graph. The algorithm for this problem on large-scale graphs often follows 2 steps: me-consuming one-time pre-processing and fast query-answering. However, many algorithms are designed for static graphs. If the graphs are changed, the costly pre-processing has to be redone. Based on the 2-hop cover top-k shortest path algorithm in the static graph, we proposed top-k shortest-path algorithm for dynamic directed weighted graphs. The novel part was a subroutine for updating the pre-processing data. With our algorithm, the index set of the updated graph were obtained by only changing a small fraction of the index set of the original graph, which greatly reduced the overall running time. We prove the correctness of our algorithm, and analyze its time and space complexity.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Top-k%20shortest-path&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Top-k shortest-path;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Dynamic%20graph&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Dynamic graph;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Index%20set&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Index set;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=2-hop%20cover&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">2-hop cover;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-10-29</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="38" name="38" class="anchor-tag"><b>0 引 言</b></h3>
                <div class="p1">
                    <p id="39">图论中最短路径问题是一个经典的问题。在一个有向带权图中, 最短路径查询问题是查找图中两个节点之间的最短路径, 最短距离问题是求出两个节点之间的最短的路径长度。top-k最短路径查询是对前<i>k</i>条最短路径的查询。近年来top-k最短路径问题在实际中有诸多的应用, 如多目标跟踪<citation id="252" type="reference"><link href="4" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>、基因网络<citation id="253" type="reference"><link href="6" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>和多序列分析<citation id="254" type="reference"><link href="8" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>等等。</p>
                </div>
                <div class="p1">
                    <p id="40">很多现实中的网络是在随着时间而改变的。对于网络的实时变化, 这些针对静态的图的top-k算法需要对每次变化的图进行重新的计算。在实际生活中的网络点之间的关系很复杂, 网络的数据也在日益增多。对于大规模的图, 每一次的变化都会引起静态算法的重新计算。对于微小的变化而言, 绝大部分计算是重复的, 在实际运用中效率低下。同时, 我们也希望有方法分析图的改变趋势。例如, 在社交网络图中, 一个用户在一个时刻关注某件事的几个焦点, 下个时刻关注的焦点又可能发生了改变。通过记录top-k距离的改变, 可以分析用户行为。再例如, 在道路网中, 通过追踪两个城市之间道路的改变, 可以分析道路建造的趋势。</p>
                </div>
                <div class="p1">
                    <p id="41">传统的最短路径算法不能满足大规模图的top-k最短路径的计算, 需要预处理原始图的数据关系, 然后在图进行动态更新后, 通过更新原始图的部分数据, 动态图的更新算法能快速地得到新的top-k最短路径。</p>
                </div>
                <h3 id="42" name="42" class="anchor-tag"><b>1 相关研究</b></h3>
                <div class="p1">
                    <p id="43">1959年Hoffman和Pavley<citation id="255" type="reference"><link href="10" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>提出了KSP (k shortest path) 问题后, 一些研究人员提出了解决该问题的算法。</p>
                </div>
                <div class="p1">
                    <p id="44">KSP问题是基于最短路径问题提出的, 一部分解决该问题的算法也是基于最短路径算法的。经典的最短路径算法有Dijkstra算法<citation id="256" type="reference"><link href="12" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>、Floyd-Warshall<citation id="257" type="reference"><link href="14" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>算法等。其中, Dijkstra算法对于每次查询给定的节点对都需要重新计算最短路径;Floyd算法对于节点对的查询耗时很少, 但需要预先计算路径表。这些算法用于大规模图时, 其时间和空间消耗不能满足实际需要。为了提高大规模图最短路径计算的性能, 一些研究人员提出了两步骤算法, 这类算法在求解最短路径问题时分为了两个步骤:预处理和查询。目前该类算法中的主流是基于树分解或2-hop cover<citation id="258" type="reference"><link href="16" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>的。<citation id="264" type="reference"><link href="18" rel="bibliography" />Wei在2010</citation>年<citation id="259" type="reference"><link href="18" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>提出了一种高效的树分解方法:TEDI。在此之后Akiba等<citation id="260" type="reference"><link href="20" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>基于TEDI做了一些优化。Xu<citation id="261" type="reference"><link href="22" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>在2016年提出的BBQ优化了预处理时间以及提出了批量查询算法。Akiba等<citation id="262" type="reference"><link href="24" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>在2013年提出了一个剪枝的2-hop cover最短路径算法:PLL。为了弥补PLL局限于静态图的不足, Akiba等<citation id="263" type="reference"><link href="26" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>又提出了基于PLL的动态最短路径算法。</p>
                </div>
                <div class="p1">
                    <p id="45">近年来主要的KSP算法分为两类:一类是不可重复路径的top-k最短路径算法, 以Yen<citation id="265" type="reference"><link href="28" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>提出的Yen′s算法为代表;另一类是可重复路径的top-k最短路径算法, 以Eppstein<citation id="266" type="reference"><link href="30" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>提出的算法为代表, 该算法允许环的存在。<citation id="268" type="reference"><link href="32" rel="bibliography" />Akiba在2015</citation>年<citation id="267" type="reference"><link href="32" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>根据2-hop cover的思想提出了在大规模图中高效求解top-k的算法, 在预处理得到索引集后, 对于每一次查询能利用索引集快速得到top-k最短路径。</p>
                </div>
                <div class="p1">
                    <p id="46">这些对KSP问题的研究, 针对的都是静态图上KSP的计算。如果图进行了少许的更新改变, 对这些算法而言就相当于是另一幅图了。在实际中, 关系网等网络都是在实时更新的。对于静态图中的KSP算法, 这些路径计算的算法都需要重新再执行一遍, 极大地影响了效率。本文借鉴了两步骤算法中的2-hop cover的思想, 对图进行预处理, 建立索引集。如果图进行了更新, 只需要更改原始图中预处理得到的部分索引集, 就能得到更新后图的索引集。</p>
                </div>
                <h3 id="47" name="47" class="anchor-tag"><b>2 预处理算法分析</b></h3>
                <div class="p1">
                    <p id="48">图论中图分为两种:有向图和无向图。由于在大部分的社交网络关系图中, 两个人不一定是相互关注的, 并且在好友中亲密值也会不同, 对应的是有向带权图, 因此本文中主要研究的是有向带权图上的更新算法。动态top-k算法分为两个步骤:预处理步骤和查询步骤。然后根据预处理得到的索引集进行更新算法的操作。</p>
                </div>
                <h4 class="anchor-tag" id="49" name="49"><b>2.1 2-hop cover</b></h4>
                <div class="p1">
                    <p id="50">本文用的是基于2-hop cover的框架, 具体的定义 (参照文献<citation id="269" type="reference">[<a class="sup">7</a>]</citation>) 如下:</p>
                </div>
                <div class="p1">
                    <p id="51"><b>定义1</b> 在一个有向图<i>G</i>= (<i>V</i>, <i>E</i>) 中, 其对应距离标记集为<i>L</i><sub><i>G</i></sub>, <i>L</i><sub><i>G</i></sub>={<i>L</i> (<i>v</i>) }, 其中<i>v</i>∈<i>V</i>。距离标记<i>L</i> (<i>v</i>) = (<i>L</i><sub>in</sub> (<i>v</i>) , <i>L</i><sub>out</sub> (<i>v</i>) ) , 其中:</p>
                </div>
                <div class="p1">
                    <p id="52"> (1) 对于所有的<i>v</i>∈<i>V</i>, <i>L</i><sub>in</sub> (<i>v</i>) 是所有 (<i>u</i>, <i>δ</i> (<i>u</i>, <i>v</i>) ) 的集合, <i>δ</i> (<i>u</i>, <i>v</i>) =<i>d</i> (<i>u</i>, <i>v</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="53"> (2) 对于所有的<i>v</i>∈<i>V</i>, <i>L</i><sub>out</sub> (<i>v</i>) 是所有 (<i>u</i>, <i>δ</i> (<i>v</i>, <i>u</i>) ) 的集合, <i>δ</i> (<i>v</i>, <i>u</i>) =<i>d</i> (<i>v</i>, <i>u</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="54">任意两点<i>x</i>和<i>y</i>之间的距离定义为:</p>
                </div>
                <div class="p1">
                    <p id="55"><i>δ</i> (<i>x</i>, <i>y</i>) =min{<i>δ</i><sub><i>xv</i></sub>+<i>δ</i><sub><i>vy</i></sub> (<i>v</i>, <i>δ</i><sub><i>xv</i></sub>) ∈<i>L</i><sub>out</sub> (<i>x</i>) , </p>
                </div>
                <div class="p1">
                    <p id="56"> (<i>v</i>, <i>δ</i><sub><i>vy</i></sub>) ∈<i>L</i><sub>in</sub> (<i>y</i>) }      (1) </p>
                </div>
                <div class="p1">
                    <p id="57">如果对于图<i>G</i>中任意节点<i>x</i>和<i>y</i>, 通过上述的距离标记集<i>L</i><sub><i>G</i></sub>得到的距离等于它们在图中的实际距离, 那么<i>L</i><sub><i>G</i></sub>就是图<i>G</i>的2-hop cover。由上述的定义可知, 计算任意两个节点最短距离的时间为<i>O</i> (<mathml id="58"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><msub><mrow></mrow><mrow><mtext>o</mtext><mtext>u</mtext><mtext>t</mtext></mrow></msub><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>+</mo><mrow><mi>L</mi><msub><mrow></mrow><mrow><mtext>i</mtext><mtext>n</mtext></mrow></msub><mo stretchy="false"> (</mo><mi>y</mi><mo stretchy="false">) </mo><mo stretchy="false">|</mo><mo stretchy="false">) </mo><mo>。</mo></mrow></mrow></math></mathml></p>
                </div>
                <h4 class="anchor-tag" id="59" name="59"><b>2.2 索引算法</b></h4>
                <div class="p1">
                    <p id="60">动态top-k算法需要对原始图进行预处理计算, 对于给定的一个图<i>G</i>= (<i>V</i>, <i>E</i>) , 得到索引集<i>IN</i>= (<i>L</i>, <i>L</i><sub><i>r</i></sub>, <i>C</i>) 。记<i>G</i><sub><i>r</i></sub>是图<i>G</i>的反转图, <i>G</i><sub><i>r</i></sub>= (<i>V</i>, <i>E</i><sub><i>r</i></sub>) 。其中<i>V</i>是节点的集合, <i>E</i>是边的集合, <i>L</i>是图的距离标记表集合, <i>L</i><sub><i>r</i></sub>是反转图的距离标记表集合, <i>C</i>是自循环标记表集合。</p>
                </div>
                <div class="p1">
                    <p id="61">索引算法是对图的预处理过程。在算法中, 需要分别计算自循环标记表和距离标记表。默认节点编号按照度的大小给出 (为了方便后面能剪枝更多的节点) 。具体过程见算法1。</p>
                </div>
                <div class="area_img" id="272">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="75">算法1包含两个子程序:ComputeCircle和PrunedBFS, 分别计算自循环标记表和距离标记表。</p>
                </div>
                <div class="p1">
                    <p id="76">计算自循环标记表的基本思路为:对于每个节点<i>v</i>, 用BFS来计算它到自身的距离;在每个节点的BFS过程中, 剪枝掉已经访问过的节点;每个节点能被访问最多<i>k</i>次。这样得到一个自循环标记表。具体过程见算法2。</p>
                </div>
                <div class="area_img" id="273">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27300.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="91">计算距离标记表的基本思路为:对于每个节点<i>v</i>, 同样用剪枝的BFS来计算;在访问节点<i>v</i>时, 如果该节点已经被访问<i>k</i>次, 或者<i>δ</i><sub><i>vu</i></sub>≥min<sub><i>k</i></sub> (<i>L</i>, <i>C</i>, <i>v</i>, <i>u</i>) , 将节点<i>u</i>剪枝, 之后的搜索将不会再访问;否则, 即找到一条<i>v</i>到<i>u</i>的新路径, 该路径的长度小于现有索引集得到第<i>k</i>条路径的长度, 这时将二元组 (<i>u</i>, <i>δ</i><sub><i>vu</i></sub>) 放入<i>L</i> (<i>u</i>) 中。具体过程见算法3。</p>
                </div>
                <div class="area_img" id="274">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27400.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="274">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27401.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="108" name="108"><b>2.3 查询算法</b></h4>
                <div class="p1">
                    <p id="109">通过索引算法得到的索引集<i>IN</i>= (<i>L</i>, <i>L</i><sub><i>r</i></sub>, <i>C</i>) , 计算任意两点<i>u</i>和<i>v</i>的距离公式为:</p>
                </div>
                <div class="p1">
                    <p id="110"><i>dis</i> (<i>u</i>, <i>v</i>) ={<i>δ</i><sub><i>uw</i></sub>+<i>δ</i><sub><i>ww</i></sub>+<i>δ</i><sub><i>wv</i></sub>}      (2) </p>
                </div>
                <div class="p1">
                    <p id="111">式中: (<i>w</i>, <i>δ</i><sub><i>uw</i></sub>) ∈<i>L</i><sub><i>r</i></sub> (<i>u</i>) , <i>δ</i><sub><i>ww</i></sub>∈<i>C</i> (<i>w</i>) , (<i>w</i>, <i>δ</i><sub><i>wv</i></sub>) ∈<i>L</i> (<i>v</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="112">由式 (2) 可知, 在计算两个节点的最短top-k距离时, 需要查找到<i>L</i><sub><i>r</i></sub> (<i>u</i>) 和<i>L</i> (<i>v</i>) 中的都可到达的候选节点, 即<i>w</i><sub><i>i</i></sub>∈<i>L</i><sub><i>r</i></sub> (<i>u</i>) ∩<i>L</i> (<i>v</i>) 。先通过 (<i>L</i><sub><i>r</i></sub> (<i>u</i>) , <i>C</i>) 得到到达 (<i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, …, <i>w</i><sub><i>t</i></sub>) 的<i>k</i>个最短距离<i>δ</i><sub><i>u</i>, <i>w</i><sub><i>i</i></sub></sub>={<i>δ</i><sub>1</sub>, <i>δ</i><sub>2</sub>, …, <i>δ</i><sub><i>k</i></sub>}, 再通过<i>L</i> (<i>v</i>) 中的二元组 (<i>w</i><sub><i>i</i></sub>, <i>δ</i><sub><i>w</i><sub><i>i</i></sub>, <i>u</i></sub>) 得到节点<i>u</i>到<i>v</i>的top-k最短距离。</p>
                </div>
                <div class="p1">
                    <p id="113"><b>引理1</b> 对于每个点对 (<i>x</i>, <i>y</i>) , 通过<i>IN</i>= (<i>L</i>, <i>L</i><sub><i>r</i></sub>, <i>C</i>) , 其<i>k</i>个最短路径<i>dis</i> (<i>x</i>, <i>y</i>) 为:</p>
                </div>
                <div class="p1">
                    <p id="114"><i>dis</i> (<i>x</i>, <i>y</i>) ={<i>d</i><sub>1</sub> (<i>x</i>, <i>y</i>) , <i>d</i><sub>2</sub> (<i>x</i>, <i>y</i>) , …, <i>d</i><sub><i>k</i></sub> (<i>x</i>, <i>y</i>) }      (3) </p>
                </div>
                <div class="p1">
                    <p id="115">式中:<i>d</i><sub><i>i</i></sub> (<i>x</i>, <i>y</i>) 由式 (2) 得到。</p>
                </div>
                <div class="p1">
                    <p id="116">在算法3中可以得到节点<i>x</i>到所有节点<i>v</i>的最短的<i>t</i><sub>1</sub>个距离, 以及节点<i>v</i>到所有节点<i>y</i>的最短的<i>t</i><sub>2</sub>个距离, 其中 (<i>v</i>, <i>δ</i><sub><i>xv</i></sub>) ∈<i>L</i><sub><i>r</i></sub> (<i>x</i>) , (<i>v</i>, <i>δ</i><sub><i>vy</i></sub>) ∈<i>L</i> (<i>y</i>) , 1≤<i>t</i><sub>1</sub>, <i>t</i><sub>2</sub>≤<i>k</i>。这些距离所经过的路径点<i>v</i>满足<i>v</i>&lt;<i>x</i>并且<i>v</i>&lt;<i>y</i>。如果是这两个距离直接进行计算最短的<i>k</i>个距离, 那么对应的路径<i>P</i>所经过的节点都是在<i>x</i>和<i>y</i>之前被访问的节点, 没有比<i>x</i>和<i>y</i>更晚被访问的节点。假定路径<i>P</i>= (<i>x</i>, …, <i>v</i>, …, <i>y</i>) , 那么可能存在一个点<i>w</i>, 其中<i>w</i>&gt;max (<i>x</i>, <i>y</i>) , 即<i>w</i>是比<i>x</i>和<i>y</i>访问更晚的节点, 可以得到新的路径|<i>P</i>′|&lt;|<i>P</i>|且<i>P</i>′= (<i>x</i>, …, <i>v</i>, …, <i>w</i>, …, <i>v</i>, …, <i>y</i>) 。由于每个节点的自循环标记表中的路径可以访问所有访问顺序靠后的节点, 因此在计算距离公式时需要加上<i>C</i> (<i>v</i>) 来得到top-k最短距离。</p>
                </div>
                <h4 class="anchor-tag" id="117" name="117"><b>2.4 复杂度分析</b></h4>
                <div class="p1">
                    <p id="118">在索引算法中, 算法2中每个节点都被访问一遍, 在碰到已经访问过的节点时, 直接进行剪枝, 剩余的每个点最多被访问<i>k</i>次。因此, 合计下来, 每个节点最多被访问<i>k</i>次, 因此其时间复杂度为<i>O</i> (<i>nk</i>) 。算法3中, 假定距离标记表的平均长度为<i>len</i>, 那么我们总共需要访问<i>n</i>·<i>len</i>个节点, 平均需要访问<i>O</i> (<i>n</i>/<i>m</i>) 条边, 判断每条边是否加入到队列中所需的查询需要<i>O</i> (<i>len</i>·<i>k</i>log<i>k</i>) 的时间, 因此总的时间复杂度为<i>O</i> (<i>k</i>log<i>k</i> (<i>m</i>·<i>len</i>+<i>n</i>·<i>len</i><sup>2</sup>) ) 。而在实际世界的图中, 经过剪枝后得到的索引集的长度<i>len</i>=<i>n</i>, 并且需要的<i>k</i>也是一个相对比较小的值。至于空间复杂度, 自循环标记表需要<i>O</i> (<i>nk</i>) 的空间, 而距离标记表需要<i>O</i> (<i>nk</i>·<i>len</i>) 的空间, 因此总的空间复杂度为<i>O</i> (<i>nk</i>·<i>len</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="119">在查询算法中, 每个点的距离标记表的平均长度为<i>len</i>, 每个点的距离存储的数量为<i>k</i>, 因此查询算法的时间复杂度为<i>O</i> (<i>len</i>·<i>k</i>log<i>k</i>) 。</p>
                </div>
                <h3 id="120" name="120" class="anchor-tag"><b>3 动态更新算法分析</b></h3>
                <div class="p1">
                    <p id="121">在实际世界里, 数据及其关系是不断增加的, 在图中更新基本的操作是点或边的增加。在很多实际动态改变网络中, 移除点或边的操作是比较少的。在文献<citation id="270" type="reference">[<a class="sup">16</a>]</citation>中几种动态更新的图中, 可以看到增加的操作要远比删除操作频繁, 因此本文更新算法只是针对点或者边增加的更新。</p>
                </div>
                <div class="p1">
                    <p id="122">在索引集中增加一个点的记录很简单:如果在图中新增加了一个新的节点<i>a</i>, 只需要在索引集中加入<i>L</i> (<i>a</i>) = (<i>a</i>, 0) 、<i>L</i><sub><i>r</i></sub> (<i>a</i>) = (<i>a</i>, 0) 、<i>C</i> (<i>a</i>) = (0, ∞, …, ∞) 。因此更新算法着重于对边的更新。</p>
                </div>
                <div class="p1">
                    <p id="123">本文中记原图为<i>G</i>, 更新后的图为<i>G</i>′, 新的索引集记为<i>IN</i>′= (<i>L</i>′, <i>L</i>′<sub><i>r</i></sub>, <i>C</i>′) 。由于增加的是点或边, 则一定有<i>V</i> (<i>G</i>) ⊆<i>V</i> (<i>G</i>′) , <i>E</i> (<i>G</i>) ⊆<i>E</i> (<i>G</i>′) 。</p>
                </div>
                <div class="p1">
                    <p id="124"><b>引理2</b> 假设<i>G</i>和<i>G</i>′为两个图, 其中<i>E</i> (<i>G</i>) ⊆<i>E</i> (<i>G</i>′) , 那么对于任意两个节点<i>x</i>和<i>y</i>, <i>x</i>, <i>y</i>∈<i>V</i> (<i>G</i>) ∩<i>V</i> (<i>G</i>′) , 有<i>d</i> (<i>x</i>, <i>y</i>) ≥<i>d</i>′ (<i>x</i>, <i>y</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="125">由引理2中可知, 如果一个图包含另一个图的所有边, 在这个图中的两点间的距离要小于等于在另一个图中的距离。对于图中的任意两个节点, 若它们之间有一条通过新边更短的路径, 则这两点间距离减小;反之, 则这两点距离不变。</p>
                </div>
                <h4 class="anchor-tag" id="126" name="126"><b>3.1 索引集更新</b></h4>
                <div class="p1">
                    <p id="127">假设增加的一条边为 (<i>a</i>, <i>b</i>) , 权重为<i>e</i><sub><i>ab</i></sub>, 并且<i>a</i>和<i>b</i>两个节点已经在图中。我们只需要对新加入的边影响的节点进行部分索引集的更新, 即增加部分数据或更改部分数据。索引更新算法的伪代码如下:</p>
                </div>
                <div class="area_img" id="275">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="275">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27501.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="145">由上述的代码可知, 索引集更新中包括自循环标记表集和距离标记表集更新, 具体过程在算法5和算法6中给出。</p>
                </div>
                <div class="p1">
                    <p id="146">图1和图2是一个示例。图1标出了从最左边节点出发的到所有节点的top-2最短距离;图2标出了在加入了一条边之后, 从最左边节点出发得到的所有节点的 top-2 最短距离。可以看到只有<i>b</i>和在<i>b</i>之后的节点会有改变, 其余节点不变。</p>
                </div>
                <div class="area_img" id="147">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904034_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 一个示例:图中距离是与最左边节点top-2距离" src="Detail/GetImg?filename=images/JYRJ201904034_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 一个示例:图中距离是与最左边节点top-2距离  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904034_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="148">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904034_148.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 一个示例:图增加一条边后与最左边节点top-2距离" src="Detail/GetImg?filename=images/JYRJ201904034_148.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 一个示例:图增加一条边后与最左边节点top-2距离  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904034_148.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="149"><b>引理3</b> 如果在图更新后, 节点<i>v</i><sub><i>i</i></sub>到<i>u</i>的距离改变了, 那么所有更新了的top-k最短路径一定经过了边 (<i>a</i>, <i>b</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="150"><b>引理4</b> 假设一条从节点<i>v</i><sub><i>i</i></sub>到<i>u</i>的top-k最短路径<i>P</i>改变了, 其中<i>u</i>≠<i>a</i>, <i>b</i>, 那么路径中经过了节点<i>b</i>之后的节点<i>w</i>到<i>v</i><sub><i>i</i></sub>的top-k距离都改变了。</p>
                </div>
                <div class="p1">
                    <p id="151">由引理4可知, 如果两个节点<i>u</i>到<i>v</i>的top-k最短距离改变了, 那么改变的只是经过<i>b</i>之后的节点, 在路径到达<i>a</i>之前所经过的节点的距离不变。因此在更新中, 不需要从 (<i>v</i><sub><i>i</i></sub>, 0) 开始修改, 只需要从 (<i>b</i>, <i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>a</i>) +<i>g</i>) 开始。由于在索引集中得到的<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>a</i>) 有<i>k</i>个, 因此初始的集为 (<i>b</i>, <i>d</i><sub>1</sub> (<i>v</i><sub><i>i</i></sub>, <i>a</i>) +<i>g</i>) , (<i>b</i>, <i>d</i><sub>2</sub> (<i>v</i><sub><i>i</i></sub>, <i>a</i>) +<i>g</i>) , …, (<i>b</i>, <i>d</i><sub><i>k</i></sub> (<i>v</i><sub><i>i</i></sub>, <i>a</i>) +<i>g</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="152">在图<i>G</i>中增加的边为 (<i>a</i>, <i>b</i>) , 相应地在图<i>G</i><sub><i>r</i></sub>中增加的边为 (<i>b</i>, <i>a</i>) , 因此图<i>G</i>和<i>G</i><sub><i>r</i></sub>的距离标记表都需要更新。</p>
                </div>
                <h4 class="anchor-tag" id="153" name="153"><b>3.2 自循环标记表更新</b></h4>
                <div class="p1">
                    <p id="154">与算法1相对应, 需要有自循环标记表和距离标记表更新的两个过程。由引理3和引理4可知, 不是所有节点的自循环标记表需要更新, 只有在自循环经过的路径中包含了边 (<i>a</i>, <i>b</i>) 后才会改变该节点的自循环标记表。更新自循环标记表算法伪代码如下:</p>
                </div>
                <div class="area_img" id="276">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27600.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="171">如果<i>v</i><sub><i>i</i></sub>∈<i>L</i> (<i>a</i>) ∩<i>L</i><sub><i>r</i></sub> (<i>b</i>) , 即<i>v</i><sub><i>i</i></sub>→<i>a</i>和<i>b</i>→<i>v</i><sub><i>i</i></sub>可达, 加入边 (<i>a</i>, <i>b</i>) 后, 更新了<i>v</i><sub><i>i</i></sub>的自循环标记表, 可形成<i>v</i><sub><i>i</i></sub>→<i>a</i>→<i>b</i>→<i>v</i><sub><i>i</i></sub>。 因此需要更新的节点最多为max (|<i>L</i> (<i>a</i>) |, |<i>L</i><sub><i>r</i></sub> (<i>b</i>) |) 个, 其余的节点不需要更新。</p>
                </div>
                <h4 class="anchor-tag" id="172" name="172"><b>3.3 距离标记表更新</b></h4>
                <div class="p1">
                    <p id="173">如3.2所述, 自循环标记表的更新只需要更新<i>L</i> (<i>a</i>) ∩<i>L</i><sub><i>r</i></sub> (<i>b</i>) 个节点。相应地, 对于距离标记表的更新需要更新<i>L</i> (<i>a</i>) ∪<i>L</i><sub><i>r</i></sub> (<i>b</i>) 中的节点。如果一个节点<i>v</i>不属于<i>L</i> (<i>a</i>) ∪<i>L</i><sub><i>r</i></sub> (<i>b</i>) , 在计算其中一个PrunedBFS时, 该节点已经被剪枝, 所以增加的边对被剪枝删除的节点没有影响。算法伪代码如下:</p>
                </div>
                <div class="area_img" id="277">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="277">
                                <img alt="" src="Detail/GetImg?filename=images/JYRJ201904034_27701.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="190">在算法中的TopKQuery (<i>IN</i>, <i>x</i>, <i>y</i>, <i>t</i>) 定义如下:</p>
                </div>
                <div class="p1">
                    <p id="191">TopKQuery (<i>IN</i>, <i>x</i>, <i>y</i>, <i>t</i>) ={<i>δ</i><sub><i>xv</i><sub><i>u</i></sub></sub>+<i>δ</i><sub><i>v</i><sub><i>i</i></sub><i>v</i><sub><i>i</i></sub></sub>+<i>δ</i><sub><i>v</i><sub><i>i</i></sub><i>y</i></sub>}      (4) </p>
                </div>
                <div class="p1">
                    <p id="192">其中:<i>i</i>≤<i>t</i>, (<i>v</i><sub><i>i</i></sub>, <i>δ</i><sub><i>xv</i><sub><i>i</i></sub></sub>) ∈<i>L</i><sub><i>r</i></sub> (<i>x</i>) , <i>δ</i><sub><i>v</i><sub><i>i</i></sub><i>v</i><sub><i>i</i></sub></sub>∈<i>C</i> (<i>v</i><sub><i>i</i></sub>) , (<i>v</i><sub><i>i</i></sub>, <i>δ</i><sub><i>v</i><sub><i>i</i></sub><i>y</i></sub>) ∈<i>L</i> (<i>y</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="193">它计算的是节点<i>x</i>和<i>y</i>在索引集<i>IN</i>下的第<i>k</i>个距离, 如果节点<i>x</i>和<i>y</i>之间没有<i>k</i>条路径, 那么定义TopKQuery (<i>IN</i>, <i>x</i>, <i>y</i>, <i>t</i>) =∞。</p>
                </div>
                <h4 class="anchor-tag" id="194" name="194"><b>3.4 正确性证明</b></h4>
                <div class="p1">
                    <p id="195">在经过更新算法后得到新的索引集<i>IN</i>′, 要证明此为图<i>G</i>′的索引集。对于任意两个节点<i>x</i>和<i>y</i>, 以及<i>t</i> (0≤<i>t</i>≤<i>n</i>) , 我们定义:</p>
                </div>
                <div class="p1">
                    <p id="196"><i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>t</i>) =min<sub><i>k</i></sub> (<i>d</i> (<i>x</i>, <i>v</i><sub><i>i</i></sub>) +<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>v</i><sub><i>i</i></sub>) , <i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>y</i>) ) </p>
                </div>
                <div class="p1">
                    <p id="197">如果<i>t</i>=0或者没有一个<i>v</i><sub><i>i</i></sub>满足<i>i</i>≤<i>t</i>, 那么<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>t</i>) =∞。</p>
                </div>
                <div class="p1">
                    <p id="198"><b>引理5</b> 对于任意两个节点<i>x</i>和<i>y</i>, 以及<i>i</i> (0≤<i>i</i>≤<i>n</i>) , <i>IN</i>是图<i>G</i>的2-hop cover索引集, 我们有TopKQuery (<i>IN</i>, <i>x</i>, <i>y</i>, <i>i</i>-1) =<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>i</i>-1) 。对于任意一个节点<i>u</i>, 如果节点<i>v</i><sub><i>i</i></sub>满足<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>u</i>) &lt;<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>u</i>) 且<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>u</i>) &lt;<i>d</i>′<sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>u</i>, <i>i</i>-1) , 那么一定有 (<i>v</i><sub><i>i</i></sub>, <i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>u</i>) ∈<i>L</i>′ (<i>u</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="199">证明:由条件可知<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>u</i>) &lt;<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>u</i>) , 那么所有经过点<i>v</i><sub><i>i</i></sub>和<i>u</i>的路径都经过了新加入的边 (<i>a</i>, <i>b</i>) 。于是一定有<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>a</i>) &lt;<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>b</i>) 。假定节点<i>v</i><sub><i>i</i></sub>到节点<i>u</i>需要经过的中间节点为<i>z</i>, 其中一条距离的路径为:</p>
                </div>
                <div class="p1">
                    <p id="200"> (<i>v</i><sub><i>i</i></sub>, …, <i>z</i>, …, <i>z</i>, …, <i>a</i>, <i>b</i>=<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>…, <i>w</i><sub><i>s</i>-1</sub>, <i>u</i>=<i>w</i><sub><i>s</i></sub>) </p>
                </div>
                <div class="p1">
                    <p id="201">由此可知对于所有的<i>w</i><sub><i>i</i></sub>, 都有<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>) &lt;<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="202">由条件可知<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>u</i>) &lt;<i>d</i>′<sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>u</i>, <i>i</i>-1) , 那么在经过节点<i>v</i><sub><i>i</i></sub>到节点<i>u</i>的路径中, 除去节点<i>z</i>自循环的路径点, 不存在一个节点<i>v</i><sub><i>l</i></sub> (<i>l</i>&lt;<i>i</i>) , 否则<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>u</i>) =<i>d</i>′<sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>u</i>, <i>i</i>-1) 。</p>
                </div>
                <div class="p1">
                    <p id="203">同理<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>) &lt;<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>) , 也不存在其余节点。</p>
                </div>
                <div class="p1">
                    <p id="204">因此在进行距离标记表更新算法中, 对于所有的节点<i>w</i><sub><i>j</i></sub>, 我们有:</p>
                </div>
                <div class="p1">
                    <p id="205">TopKQuery (<i>IN</i>, <i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>, <i>i</i>) ≥</p>
                </div>
                <div class="p1">
                    <p id="206">min{<i>d</i><mathml id="207"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>k</mi><mn>1</mn></msubsup></mrow></math></mathml> (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>, <i>i</i>-1) , <i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>) }=<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>) , </p>
                </div>
                <div class="p1">
                    <p id="208">得到TopKQuery (<i>IN</i>, <i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>, <i>i</i>) ≥<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>w</i><sub><i>j</i></sub>) , 所以在算法6中, 节点<i>w</i><sub><i>j</i></sub>没有被剪枝, 该新的距离加入了<i>L</i>′ (<i>u</i>) 中。因此在新的索引集<i>IN</i>′中, 一定有 (<i>v</i><sub><i>i</i></sub>, <i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>u</i>) ) ∈<i>L</i>′ (<i>u</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="209">同理可证明 (<i>v</i><sub><i>i</i></sub>, <i>d</i> (<i>u</i>, <i>v</i><sub><i>i</i></sub>) ) ∈<i>L</i>′<sub><i>r</i></sub> (<i>u</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="210">综上所述, 引理5成立。</p>
                </div>
                <div class="p1">
                    <p id="211"><b>引理6</b> 对于任意两个节点<i>x</i>和<i>y</i>, 以及<i>i</i> (0≤<i>i</i>≤<i>n</i>) , 更新算法得到的索引集<i>IN</i>′, 也有TopKQuery (<i>IN</i>′, <i>x</i>, <i>y</i>, <i>i</i>) =<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>i</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="212">证明:如果<i>i</i>=0, 两个节点不可达, 距离都为无穷大, 成立。现在假设对于所有的<i>i</i>&gt;0, 对于任意两个节点<i>x</i>和<i>y</i>, 都有TopKQuery (<i>IN</i>′, <i>x</i>, <i>y</i>, <i>i</i>-1) =<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>i</i>-1) 。</p>
                </div>
                <div class="p1">
                    <p id="213">只需要证明:</p>
                </div>
                <div class="p1">
                    <p id="214">TopKQuery (<i>IN</i>′, <i>x</i>, <i>y</i>, <i>i</i>) =<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>i</i>) </p>
                </div>
                <div class="p1">
                    <p id="215">令<i>δ</i>=<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>t</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="216">1) 如果<i>δ</i>=<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>i</i>-1) , 那么一定成立。</p>
                </div>
                <div class="p1">
                    <p id="217">2) 如果<i>δ</i>&lt;<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>i</i>) , 那么:</p>
                </div>
                <div class="p1">
                    <p id="218"><i>δ</i>=<i>d</i>′ (<i>x</i>, <i>v</i><sub><i>i</i></sub>) +<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>v</i><sub><i>i</i></sub>) +<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) </p>
                </div>
                <div class="p1">
                    <p id="219">只需要证明:</p>
                </div>
                <div class="p1">
                    <p id="220"> (<i>v</i><sub><i>i</i></sub>, <i>d</i>′ (<i>x</i>, <i>v</i><sub><i>i</i></sub>) ) ∈<i>L</i>′<i>r</i> (<i>x</i>) </p>
                </div>
                <div class="p1">
                    <p id="221"> (<i>v</i><sub><i>i</i></sub>, <i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) ) ∈<i>L</i>′ (<i>y</i>) </p>
                </div>
                <div class="p1">
                    <p id="222">在这里证明 (<i>v</i><sub><i>i</i></sub>, <i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) ) ∈<i>L</i>′ (<i>y</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="223">如果<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) =<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>y</i>) , 从<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>t</i>) =min<sub><i>k</i></sub> (<i>d</i> (<i>x</i>, <i>v</i><sub><i>i</i></sub>) +<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>v</i><sub><i>i</i></sub>) , <i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>y</i>) ) &lt;<i>d</i><sup>1</sup> (<i>x</i>, <i>y</i>, <i>i</i>-1) 。</p>
                </div>
                <div class="p1">
                    <p id="224">可知, 在经过节点<i>v</i><sub><i>i</i></sub>到节点<i>y</i>的路径中, 不存在一个节点<i>v</i><sub><i>l</i></sub> (<i>l</i>&lt;<i>i</i>) 。由于<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) =<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>y</i>) , 有:</p>
                </div>
                <div class="p1">
                    <p id="225"><i>d</i><sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>y</i>, <i>i</i>-1) &gt;<i>d</i><sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>y</i>, <i>i</i>) </p>
                </div>
                <div class="p1">
                    <p id="226">如果 (<i>v</i><sub><i>i</i></sub>, <i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) ) ∉<i>L</i> (<i>y</i>) , 那么:</p>
                </div>
                <div class="p1">
                    <p id="227">TopKQuery (<i>IN</i>, <i>v</i><sub><i>i</i></sub><i>y</i>, <i>i</i>) =<i>d</i><sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>y</i>, <i>i</i>-1) &gt;<i>d</i><sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>y</i>, <i>i</i>) 存在矛盾, 因此一定有 (<i>v</i><sub><i>i</i></sub>, <i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) ) ∈<i>L</i> (<i>y</i>) ⊆<i>L</i>′ (<i>y</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="228">如果<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) &lt;<i>d</i> (<i>v</i><sub><i>i</i></sub>, <i>y</i>) , 那么可知<i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) &lt;<i>d</i>′<sup>1</sup> (<i>v</i><sub><i>i</i></sub>, <i>y</i>, <i>i</i>) 。从引理5可知 (<i>v</i><sub><i>i</i></sub>, <i>d</i>′ (<i>v</i><sub><i>i</i></sub>, <i>y</i>) ) ∈<i>L</i>′ (<i>y</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="229">同理可得 (<i>v</i><sub><i>i</i></sub>, <i>d</i>′ (<i>x</i>, <i>v</i><sub><i>i</i></sub>) ) ∈<i>L</i>′<sub><i>r</i></sub> (<i>x</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="230">综上所述, 引理6成立。</p>
                </div>
                <div class="p1">
                    <p id="231">由引理5和引理6可知, 如果增加了边 (<i>a</i>, <i>b</i>) , 所有经过该边的路径距离都加入到了新的索引集中, 得到的<i>IN</i>′为图<i>G</i>′的索引集。</p>
                </div>
                <h4 class="anchor-tag" id="232" name="232"><b>3.5 复杂度分析</b></h4>
                <div class="p1">
                    <p id="233">点更新的时间消耗是<i>O</i> (1) 。</p>
                </div>
                <div class="p1">
                    <p id="234">对于边更新, 假设距离标记表的平均长度为<i>len</i>, 即|<i>L</i> (<i>v</i>) |=<i>len</i>, |<i>L</i><sub><i>r</i></sub> (<i>v</i>) |=<i>len</i>。</p>
                </div>
                <div class="p1">
                    <p id="235">那么在UpdateCircle (<i>L</i>, <i>L</i><sub><i>r</i></sub>, <i>C</i>, <i>a</i>, <i>b</i>) 中要更新的节点数为<i>O</i> (<i>len</i>) , 由于需要对每个要更新节点查询当前的<i>k</i>短路, 每次查询时间为<i>O</i> (<i>k</i>log<i>k</i>) , 因此在线自循环标记表更新的时间复杂度为<i>O</i> (<i>len</i>·<i>k</i>log<i>k</i>) 。假设在UpdateIndex (<i>G</i>, <i>L</i>, <i>L</i><sub><i>r</i></sub>, <i>v</i><sub><i>i</i></sub>, <i>b</i>, <i>D</i>) 中需要访问的节点数量为<i>O</i> (<i>len</i>) , 那么访问的点对数为<i>O</i> (<i>kt</i>) , 在算法6中的TopKQuery需要<i>O</i> (<i>len</i>·<i>k</i>log<i>k</i>) 的时间, 算法4中需要访问该过程<i>O</i> (<i>len</i>) 次, 因此该过程的时间复杂度为<i>O</i> (<i>len</i><sup>2</sup>·<i>k</i><sup>2</sup><i>t</i>log<i>k</i>) 。在剪枝之后<i>len</i>, <i>t</i>≼<i>n</i>, 在平时应用中<i>k</i>也是比较小的数字。</p>
                </div>
                <div class="p1">
                    <p id="236">所以更新算法的时间复杂度为<i>O</i> (<i>len</i>·<i>k</i>log<i>k</i>+<i>len</i><sup>2</sup><i>k</i><sup>2</sup><i>t</i>log<i>k</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="237">在更新算法中, 使用的依旧是初始索引集的存储空间。被修改的节点数量为<i>O</i> (<i>len</i>) , 每个节点最多修改了<i>O</i> (<i>k</i>) 个值, 因此空间复杂度为<i>O</i> (<i>len</i>·<i>k</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="238">因此, 动态top-k更新算法的时间复杂度为<i>O</i> (<i>len</i>·<i>k</i>log<i>k</i>+<i>len</i><sup>2</sup>·<i>k</i><sup>2</sup><i>t</i>log<i>k</i>) , 空间复杂度为<i>O</i> (<i>len</i>·<i>k</i>) 。</p>
                </div>
                <h4 class="anchor-tag" id="239" name="239"><b>3.6 实例分析</b></h4>
                <div class="p1">
                    <p id="240">本节将通过实验评估动态更新算法的时间和空间开销。实验用计算机的配置为Intel Core i5 (2.7 GHz) 处理器, 8 GB内存。实验程序运行于单个CPU核心上。数据集选用了Wikipedia vote network<citation id="271" type="reference"><link href="36" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>, 其中包括7 115个节点, 103 689条边, 在这里默认所有边的权值为1。</p>
                </div>
                <div class="p1">
                    <p id="241">实验中, 更新量定义为网络更新时增加的边数, 每增加一条边, 运行一次更新算法。定义实验数据的单位平均值为实测值除以更新量, 即每增加一条边的平均数据指标。</p>
                </div>
                <div class="p1">
                    <p id="242">实际结果显示, 更新算法的总开销和单位平均开销与<i>k</i>和更新量有关。</p>
                </div>
                <div class="p1">
                    <p id="243">表1列出了更新量为1 000时不同的<i>k</i>对应的更新算法的时间开销。可以看到, 随着<i>k</i>的增加, 单位平均更新时间也在逐渐增加;在<i>k</i>不大于32时, 更新算法的时间开销较小, 性能较好。</p>
                </div>
                <div class="area_img" id="244">
                    <p class="img_tit"><b>表1 k对更新算法时间开销的影响</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="244" border="1"><tr><td><br /><i>k</i></td><td>预处理<br />时间/ms</td><td>自循环标记表单位<br />平均更新时间/μs</td><td>距离标记表单位<br />平均更新时间/ms</td></tr><tr><td><br />4</td><td>746.01</td><td>0.74</td><td>0.13</td></tr><tr><td><br />8</td><td>646.97</td><td>0.41</td><td>0.19</td></tr><tr><td><br />16</td><td>766.71</td><td>0.53</td><td>0.47</td></tr><tr><td><br />32</td><td>1 036.92</td><td>0.67</td><td>1.74</td></tr><tr><td><br />64</td><td>6 360</td><td>1.96</td><td>13.30</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="245">表2列出了更新量为1 000时不同的<i>k</i>对应的更新算法的空间开销和访问节点数量。可以看到, 访问节点单位平均数量约等于索引集中每节点索引的平均长度;<i>k</i>不大于32时, 访问节点单位平均数量和索引集总长度单位平均增长率都较小, 此时更新算法的空间开销和访问节点数量较小。</p>
                </div>
                <div class="area_img" id="246">
                    <p class="img_tit"><b>表2 <i>k</i>对更新算法空间开销和平均访问节点数量的影响</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="246" border="1"><tr><td><i>k</i></td><td>更新前<br />每节点索引<br />平均长度</td><td>1 000次更新后<br />每节点索引<br />平均长度</td><td>访问节点<br />单位平均<br />数量</td><td>索引集总长度<br />单位平均<br />增长率</td></tr><tr><td><br />4</td><td>166.89</td><td>179.33</td><td>149.15</td><td>5.09×10<sup>-5</sup></td></tr><tr><td><br />8</td><td>128.00</td><td>142.55</td><td>125.45</td><td>8.16×10<sup>-5</sup></td></tr><tr><td><br />16</td><td>119.79</td><td>137.01</td><td>119.12</td><td>10.87×10<sup>-5</sup></td></tr><tr><td><br />32</td><td>144.30</td><td>168.58</td><td>144.68</td><td>13.30×10<sup>-5</sup></td></tr><tr><td><br />64</td><td>266.09</td><td>298.41</td><td>260.36</td><td>5.46×10<sup>-5</sup></td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="247">图3显示了<i>k</i>=16时更新量对单位平均更新时间与访问节点单位平均数量的影响。可以看到三项数值都随着更新量的增大而增大, 但增长较为缓慢, 且自循环标记表单位平均更新时间仅为微秒级。由此说明算法在大更新量下仍能保持较好的性能。</p>
                </div>
                <div class="area_img" id="248">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201904034_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 更新量对更新算法时间开销和访问节点数量的影响" src="Detail/GetImg?filename=images/JYRJ201904034_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 更新量对更新算法时间开销和访问节点数量的影响  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201904034_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="249" name="249" class="anchor-tag"><b>4 结 语</b></h3>
                <div class="p1">
                    <p id="250">本文对于动态更新的有向带权图中的top-k最短路径问题设计并分析了基于2-hop cover的算法。更新算法利用预处理得到的索引集来更新, 从而显著地减少了图改变后计算top-k的时间, 只需要消耗更新算法的时间, 而且有效地利用了原图的数据集和性质。</p>
                </div>
                <div class="p1">
                    <p id="251">本文在理论上证明了更新算法的正确性, 分析了时间复杂度, 证明其更新时间远小于将更新后的图看作静态图重新预处理的计算时间, 并用实验评估了更新算法处理大规模网络的实际性能, 证实了其实用性。动态top-k更新算法在大规模图上可以进行快速更新和查询。在未来研究工作中, 我们将研究对于批量的更新如何提高效率、减少时间, 以此来提高更新算法在实际应用中的性能。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="4">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Multiple object tracking using k-shortest paths optimization">

                                <b>[1]</b> Berclaz J, Fleuret F, Türetken E, et al. Multiple object tracking using k-shortest paths optimization[J].IEEE Transactions on Pattern Analysis &amp; Machine Intelligence, 2011, 33 (9) : 1806-1819.
                            </a>
                        </p>
                        <p id="6">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJRS&amp;filename=SJRS120719012443&amp;v=MjMwNDhIdGJOcG85RVp1OExEeE04enhVU21EZDlTSDduM3hFOWZidm5LcmlmWmVadkZ5bm1VN3ZMSWwwV05pZlpmYks2&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> Shih Y K, Parthasarathy S. A single source k-shortest paths algorithm to infer regulatory pathways in a gene network[J]. Bioinformatics, 2012, 28 (12) : i49-i58.
                            </a>
                        </p>
                        <p id="8">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Multiple sequence alignment based on structural properties">

                                <b>[3]</b> Ozer B, Gezici G, Meydan C, et al. Multiple sequence alignment based on structural properties[C]//Health Informatics and Bioinformatics (HIBIT) , 2010 5th International Symposium on. IEEE, 2010: 39-44.
                            </a>
                        </p>
                        <p id="10">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000018020&amp;v=MzE5MDBIdGpOcjQ5RlpPb0hESDQ1b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcnpJSkYwV2FSQT1OaWZJWTdLNw==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b> Hoffman W, Pavley R. A method for the solution of the nth best path problem[J]. Journal of the ACM, 1959, 6 (4) : 506-514.
                            </a>
                        </p>
                        <p id="12">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00002467824&amp;v=MDUzNDdScnhveGNNSDdSN3FkWitadUZpdmxWN3pLSTF3PU5qN0Jhck80SHRIT3E0bENiT2tMWTNrNXpCZGg0ajk5U1hx&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> Dijkstra E W. A note on two problems in connexion with graphs[J].Numerische mathematik, 1959, 1 (1) :269-271.
                            </a>
                        </p>
                        <p id="14">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300064906&amp;v=MTgxNjlJOUZaTzBMQlh3L29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXJ6SUpGMFdhUkE9TmlmT2ZiSzdIdERPcg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> Aini A, Salehipour A. Speeding up the Floyd-Warshall algorithm for the cycled shortest path problem[J]. Applied Mathematics Letters, 2012, 25 (1) : 1-5.
                            </a>
                        </p>
                        <p id="16">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Reachability and distance queries via 2-hop labels">

                                <b>[7]</b> Cohen E, Halperin E, Kaplan H, et al. Reachability and distance queries via 2-hop labels[C]//Proceedings of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms.Society for Industrial and Applied Mathematics, 2002:937-946.
                            </a>
                        </p>
                        <p id="18">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=TEDI: Efficient Shortest Path Query Answering on Graphs">

                                <b>[8]</b> Wei F. TEDI: efficient shortest path query answering on graphs[C]//Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data. Indianapolis, Indiana, USA: ACM, 2010: 99-110.
                            </a>
                        </p>
                        <p id="20">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Shortest-path queries for complex networks: exploiting low tree-width outside the core">

                                <b>[9]</b> Akiba T, Sommer C, Kawarabayashi K I. Shortest-path queries for complex networks: exploiting low tree-width outside the core[C]//Proceedings of the 15th International Conference on Extending Database Technology. Berlin, Germany: ACM, 2012: 144-155.
                            </a>
                        </p>
                        <p id="22">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fast shortest-path queries on large-scale graphs">

                                <b>[10]</b> Xu Q, Zhang X, Zhao J, et al. Fast shortest-path queries on large-scale graphs[C]//IEEE 24th International Conference on Network Protocols (ICNP) .Singapore:IEEE, 2016:1-10.
                            </a>
                        </p>
                        <p id="24">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fast exact shortest-path distance queries on large networks by pruned landmark labeling">

                                <b>[11]</b> Akiba T, Iwata Y, Yoshida Y. Fast exact shortest-path distance queries on large networks by pruned landmark labeling[C]//Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data.New York, USA:ACM, 2013: 349-360.
                            </a>
                        </p>
                        <p id="26">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Dynamic and historical shortest-path distance queries on large evolving networks by pruned landmark labeling.">

                                <b>[12]</b> Akiba T, Iwata Y, Yoshida Y. Dynamic and historical shortest-path distance queries on large evolving networks by pruned landmark labeling[C]//Proceedings of the 23rd International Conference on World Wide Web. ACM, 2014: 237-248.
                            </a>
                        </p>
                        <p id="28">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJIF&amp;filename=SJIF13022100017514&amp;v=MDM4ODFMSzdIdFBPcm85RlpPb0lDWDA5b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcnpJSkYwV2FSQT1OaWZDYQ==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b> Yen J Y. Finding the k shortest loopless paths in a network[J]. management Science, 1971, 17 (11) : 712-716.
                            </a>
                        </p>
                        <p id="30">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Finding the k shortest paths">

                                <b>[14]</b> Eppstein D. Finding the k shortest paths[C]//Proceedings of the 35th Annual Symposium on Foundations of Computer Science. IEEE Computer Society, 1994: 154-165.
                            </a>
                        </p>
                        <p id="32">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient top-k shortest-path distance queries on large networks by pruned landmark labeling">

                                <b>[15]</b> Akiba T, Hayashi T, Nori N, et al. Efficient top-k shortest-path distance queries on large networks by pruned landmark labeling[C]//Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, January 25-30, 2015, Austin, Texas, USA: AAAI Press, 2015: 349-360.
                            </a>
                        </p>
                        <p id="34">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Online social networks: measurement, analysis, and applications to distributed information systems">

                                <b>[16]</b> Mislove A E. Online social networks: measurement, analysis, and applications to distributed information systems[D]. Rice University, 2009.
                            </a>
                        </p>
                        <p id="36">
                            <a id="bibliography_17" target="_blank" href="http://scholar.cnki.net/result.aspx?q=SNAP: network datasets: Wikipedia vote network">

                                <b>[17]</b> SNAP: network datasets: Wikipedia vote network[EB/OL].[2018-11-08].http://snap.stanford.edu/data/wiki-Vote.html.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JYRJ201904034" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201904034&amp;v=Mjc5ODFIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0Rnl6bVViektMelRaWkxHNEg5ak1xNDlHWUlRS0Q=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZKQ291S0FIT2hubWNrWXI0QkNHMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
