<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637135592232502500%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJYRJ201909011%26RESULT%3d1%26SIGN%3dtFRHffy%252bOf29zHM%252fCLyYtyoQPrM%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201909011&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JYRJ201909011&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201909011&amp;v=Mjk0MTBqTXBvOUVaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeW5oVWJyS0x6VFpaTEc0SDk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#29" data-title="&lt;b&gt;0 引 言&lt;/b&gt; "><b>0 引 言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#33" data-title="&lt;b&gt;1 定义及概念&lt;/b&gt; "><b>1 定义及概念</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#34" data-title="&lt;b&gt;1.1 事务的并发调度及可串行化调度&lt;/b&gt;"><b>1.1 事务的并发调度及可串行化调度</b></a></li>
                                                <li><a href="#55" data-title="&lt;b&gt;1.2 基于执行图的冲突可串行化判定&lt;/b&gt;"><b>1.2 基于执行图的冲突可串行化判定</b></a></li>
                                                <li><a href="#74" data-title="&lt;b&gt;1.3 事务执行优先关系的闭包计算&lt;/b&gt;"><b>1.3 事务执行优先关系的闭包计算</b></a></li>
                                                <li><a href="#117" data-title="&lt;b&gt;1.4 谓词逻辑公式&lt;/b&gt;"><b>1.4 谓词逻辑公式</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#130" data-title="&lt;b&gt;2 本文算法&lt;/b&gt; "><b>2 本文算法</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#153" data-title="&lt;b&gt;3 实例分析&lt;/b&gt; "><b>3 实例分析</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#195" data-title="&lt;b&gt;4 结 语&lt;/b&gt; "><b>4 结 语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#47" data-title="图1 串行化调度1:T&lt;sub&gt;1&lt;/sub&gt;先于T&lt;sub&gt;2&lt;/sub&gt;执行">图1 串行化调度1:T<sub>1</sub>先于T<sub>2</sub>执行</a></li>
                                                <li><a href="#50" data-title="图2 并发调度2">图2 并发调度2</a></li>
                                                <li><a href="#67" data-title="图3 调度&lt;i&gt;S&lt;/i&gt;&lt;sub&gt;1&lt;/sub&gt;的执行图">图3 调度<i>S</i><sub>1</sub>的执行图</a></li>
                                                <li><a href="#72" data-title="图4 调度&lt;i&gt;S&lt;/i&gt;&lt;sub&gt;2&lt;/sub&gt;的执行图">图4 调度<i>S</i><sub>2</sub>的执行图</a></li>
                                                <li><a href="#193" data-title="图5 例5中调度&lt;i&gt;S&lt;/i&gt;的执行图">图5 例5中调度<i>S</i>的执行图</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" 王晓波.计算机网络数据库安全管理技术的优化[J].信息与电脑(理论版),2019(1):238-239,242." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXDL201901108&amp;v=MDAxODc0SDlqTXJvNUZiSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeW5oVWJyS1BUWFBZckc=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         王晓波.计算机网络数据库安全管理技术的优化[J].信息与电脑(理论版),2019(1):238-239,242.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title=" 徐晨昊.探究关系型数据库[J].通讯世界,2019,26(1):208-209." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TXSJ201901137&amp;v=MjQyNDVMRzRIOWpNcm81R1k0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5bmhVYnJLTVRYWVo=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         徐晨昊.探究关系型数据库[J].通讯世界,2019,26(1):208-209.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" 裘是寅,杨子睿.基于“互联网+”的协同创新平台构建[J].电子技术与软件工程,2018(24):2." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZRU201824009&amp;v=MjQ2NzZiWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeW5oVWJyS0lUZlplN0c0SDluT3E0OUY=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         裘是寅,杨子睿.基于“互联网+”的协同创新平台构建[J].电子技术与软件工程,2018(24):2.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title=" 赵昱帆,邓玉辉.网络编码集群存储系统基于锁机制的热数据重建策略[J].小型微型计算机系统,2018,39(8):1707-1712." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXWX201808014&amp;v=MTI3ODhIOW5NcDQ5RVlJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVadEZ5bmhVYnJLUFRYY2RyRzQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                         赵昱帆,邓玉辉.网络编码集群存储系统基于锁机制的热数据重建策略[J].小型微型计算机系统,2018,39(8):1707-1712.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" 黄姝娟,容晓峰,茹媛,等.一种采用Lock-Free同步机制的数据结构的研究[J].微电子学与计算机,2016,33(10):72-77." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201610016&amp;v=MzIwMjdmWnVadEZ5bmhVYnJLTWpYU1pMRzRIOWZOcjQ5RVlvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3E=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         黄姝娟,容晓峰,茹媛,等.一种采用Lock-Free同步机制的数据结构的研究[J].微电子学与计算机,2016,33(10):72-77.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" 陈涵,林玫.锁机制在数据库并发访问中的研究与应用[J].软件导刊,2013,12(12):126-128." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJDK201312046&amp;v=MjA3NTF0RnluaFVicktOeWZQWmJHNEg5TE5yWTlCWW9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVo=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         陈涵,林玫.锁机制在数据库并发访问中的研究与应用[J].软件导刊,2013,12(12):126-128.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title=" Tu S,Zheng W,Kohler E,et al.Speedy Transactions in Multicore In-Memory Databases[C]//Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles.ACM,2013:18-32." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Speedy transactions in multicore in-memory databases">
                                        <b>[7]</b>
                                         Tu S,Zheng W,Kohler E,et al.Speedy Transactions in Multicore In-Memory Databases[C]//Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles.ACM,2013:18-32.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title=" Dimovski T,Mitrevski P.On the Performance Potential of Connection Fault-Tolerant Commit Processing in Mobile Environment[J].International Journal of Wireless &amp;amp; Mobile Networks,2012,4(5):29-44." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On the performance potential of connection fault-tolerant commit processing in mobile environment">
                                        <b>[8]</b>
                                         Dimovski T,Mitrevski P.On the Performance Potential of Connection Fault-Tolerant Commit Processing in Mobile Environment[J].International Journal of Wireless &amp;amp; Mobile Networks,2012,4(5):29-44.
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title=" Stuedi P,Mohomed I,Terry D.WhereStore:Location-Based Data Storage for Mobile Devices Interacting with the Cloud[C]//Proceedings of the 1st ACM Workshop on Mobile Cloud Computing &amp;amp; Services:Social Networks and Beyond.ACM,2010:137-143." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=WhereStore:locationbased data storage formobile devices interacting with the cloud">
                                        <b>[9]</b>
                                         Stuedi P,Mohomed I,Terry D.WhereStore:Location-Based Data Storage for Mobile Devices Interacting with the Cloud[C]//Proceedings of the 1st ACM Workshop on Mobile Cloud Computing &amp;amp; Services:Social Networks and Beyond.ACM,2010:137-143.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" >
                                        <b>[10]</b>
                                     严蔚敏,李冬梅,吴伟民.数据结构(C语言版)[M].北京:清华大学出版社,2011.</a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title=" 施伯乐,丁宝康,汪卫.数据库系统教程[M].北京:高等教育出版社,2008." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787040242249001&amp;v=MDU2NzlmWmVadkZ5bm1VNzdNSWxzV1hGcXpHYk84SHRQSXJZMUJiZXNQRFJNOHp4VVNtRGQ5U0g3bjN4RTlmYnZuS3Jp&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                         施伯乐,丁宝康,汪卫.数据库系统教程[M].北京:高等教育出版社,2008.
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" >
                                        <b>[12]</b>
                                     杜金莲.高级数据库技术[M].北京:清华大学出版社,2010.</a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title=" 王元元.离散数学教程[M].北京:高等教育出版社,2010." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787040294651001&amp;v=MDgyNjV0UEZxNGxBWmVzUERSTTh6eFVTbURkOVNIN24zeEU5ZmJ2bktyaWZaZVp2RnlubVU3N01JbHNXWEZxekdiTzhI&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                         王元元.离散数学教程[M].北京:高等教育出版社,2010.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JYRJ" target="_blank">计算机应用与软件</a>
                2019,36(09),52-57+99 DOI:10.3969/j.issn.1000-386x.2019.09.010            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于优先执行关系闭包运算的事务可串行化判定方法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="javascript:;">熊中敏</a>
                                <a href="javascript:;">王佳艳</a>
                                <a href="javascript:;">汪博</a>
                                <a href="javascript:;">陈明</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%8A%E6%B5%B7%E6%B5%B7%E6%B4%8B%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%99%A2&amp;code=1500138&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">上海海洋大学信息学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%86%9C%E4%B8%9A%E9%83%A8%E6%B8%94%E4%B8%9A%E4%BF%A1%E6%81%AF%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">农业部渔业信息重点实验室</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>现代数据库技术支持并发用户,会产生大量的并发事务。为了提高数据库系统的性能和维护系统的一致性,必须保证事务并发执行的可串行化调度。可串行化检测是数据库系统中事务管理的关键技术,一般采用执行图的判定方法。从关系运算的代数方法出发,提出基于事务执行优先关系的闭包运算和由此建立的联合逻辑公式的计算,通过逻辑判定来检验并发事务的可串行化。通过定理证明和实例验证,该方法取得了同执行图判定相同的效果,而且判定更直观,更易于操作实现,不需要建立复杂的图数据结构和在图搜索中检测环是否出现。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%95%B0%E6%8D%AE%E5%BA%93&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">数据库;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">并发事务;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">可串行化;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%97%AD%E5%8C%85%E8%AE%A1%E7%AE%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">闭包计算;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%80%BB%E8%BE%91%E5%85%AC%E5%BC%8F&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">逻辑公式;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    熊中敏,副教授,主研领域:数据库,数据挖掘。;
                                </span>
                                <span>
                                    王佳艳,硕士生。;
                                </span>
                                <span>
                                    汪博,硕士生。;
                                </span>
                                <span>
                                    陈明,教授。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2019-01-26</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目(61702325);</span>
                                <span>上海市自然科学基金项目(16ZR14100);</span>
                                <span>上海市科技创新行动(16391902902);</span>
                    </p>
            </div>
                    <h1><b>DECISION METHOD OF TRANSACTION SERIALIZABILITY BASED ON CLOSURE OF PRIORITY EXECUTION RELATIONS</b></h1>
                    <h2>
                    <span>Xiong Zhongmin</span>
                    <span>Wang Jiayan</span>
                    <span>Wang Bo</span>
                    <span>Chen Ming</span>
            </h2>
                                    <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Modern database technology supports concurrent users and generates a large number of concurrent transactions. In order to improve the performance of the database system and maintain the consistency of the system, it is necessary to ensure the serializable scheduling of concurrent transactions. Serializability detection is the key technology of transaction management in database system, and an execution graph is used for this task. Starting from the algebra method of relational operation, this paper presented the closure operation based on the priority relation of transaction execution and the calculation of the joint logic formula established therefrom. The serializability of concurrent transactions was tested by logical decision. Through theorem proving and examples analysis, the proposed method achieves the analysis results as same as the execution graph. It does not need to establish complex graph data structure and detect whether the ring appears in graph search.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Database&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Database;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Concurrent%20transaction&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Concurrent transaction;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Serializability&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Serializability;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Closure%20calculation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Closure calculation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Logical%20formula&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Logical formula;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2019-01-26</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="29" name="29" class="anchor-tag"><b>0 引 言</b></h3>
                <div class="p1">
                    <p id="30">随着移动互联网和数字化操作平台的发展,信息系统都支持并发用户,从而产生了大量的并发事务<citation id="197" type="reference"><link href="3" rel="bibliography" /><link href="5" rel="bibliography" /><link href="7" rel="bibliography" /><sup>[<a class="sup">1</a>,<a class="sup">2</a>,<a class="sup">3</a>]</sup></citation>。为了提高系统的性能,现代数据库技术支持并发事务的调度执行;为了维护整个系统上操作的正确性,必须确保并发事务调度是可串行化调度。并发事务的可串行化检测是事务并发管理的一项重要任务,也是系统执行并发控制的前提<citation id="198" type="reference"><link href="9" rel="bibliography" /><link href="11" rel="bibliography" /><link href="13" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">6</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="31">当前事务管理的研究大量集中在对新型应用中出现的新事务的并发控制协议的研究上,以便确保并行事务执行的可串行化调度。但对并行事务调度是否具有可串行化的判定,仍然基于传统的执行图的判定方法<citation id="200" type="reference"><link href="15" rel="bibliography" /><link href="17" rel="bibliography" /><link href="19" rel="bibliography" /><sup>[<a class="sup">7</a>,<a class="sup">8</a>,<a class="sup">9</a>]</sup></citation>。执行图的判定方法原理比较简单,首先判断在一个调度中、并发冲突事务集合中事务之间的执行优先关系,然后以有向图这种数据结构存储:事务表示为图中的节点,事务之间的执行优先关系表示为节点之间的有向边;在建立好完全的图结构后,通过图搜索方法遍历整个图,如果图中不存在环这种结构,就判断并发事务集的当前调度是可串行化的,否则就是不可串行化的。要实现这种传统的判定方法,需要建立复杂的图数据结构,并要建立便于图中节点的遍历和回溯的索引结构来实现图的搜索<citation id="199" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>,直接的图搜索算法没有相应的环的识别,还需要改进的图搜索算法来支持环的识别。</p>
                </div>
                <div class="p1">
                    <p id="32">本文从关系运算的代数方法出发,提出了基于事务执行优先关系的闭包运算和由此建立的联合逻辑公式的计算,通过逻辑判定来检验并发事务的可串行化。通过定理证明和实例验证,所提出的基于逻辑公式的代数判定方法取得了同执行图判定相同的效果,而且判定更直观,更易于操作实现,不需要建立复杂的图数据结构和在图搜索中检测环是否出现。</p>
                </div>
                <h3 id="33" name="33" class="anchor-tag"><b>1 定义及概念</b></h3>
                <h4 class="anchor-tag" id="34" name="34"><b>1.1 事务的并发调度及可串行化调度</b></h4>
                <div class="p1">
                    <p id="35">例如:从账户<i>A</i>向账户<i>B</i>转账1 000元,系统查找到账户<i>A</i>,检查账户的余额大于1 000时,读出余额并从中减去1 000元,然后把减去的余额写回到<i>A</i>账户中。找到<i>B</i>账户,读出<i>B</i>账户余额后加上1 000元,再把加后的余额写回到<i>B</i>账户中。这一系列的过程要么全部都发生,要么全不发生,这就是事务。</p>
                </div>
                <div class="p1">
                    <p id="36"><b>定义1</b><citation id="201" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation> 事务(Transaction)是构成单一逻辑工作单元的操作集合,要么完整的执行,要么完全不执行。无论发生何种情况,DBS必须保证事务能正确、完整的执行。</p>
                </div>
                <div class="p1">
                    <p id="37">以银行系统中多个事务对多个账户进行存取操作为例。事务<i>T</i><sub>1</sub>从账户<i>A</i>转100元到账户<i>B</i>,定义如下:</p>
                </div>
                <div class="p1">
                    <p id="38"><i>T</i><sub>1</sub>:<i>Read</i>(<i>A</i>);<i>A</i>:=<i>A</i>-100;<i>Write</i>(<i>A</i>);<i>Read</i>(<i>B</i>);</p>
                </div>
                <div class="p1">
                    <p id="39"><i>B</i>:=<i>B</i>+100;<i>Write</i>(<i>B</i>);</p>
                </div>
                <div class="p1">
                    <p id="40"><i>T</i><sub>2</sub>从账户<i>A</i>中转10%的存款到账户<i>B</i>,定义如下:</p>
                </div>
                <div class="p1">
                    <p id="41"><i>T</i><sub>2</sub>:<i>Read</i>(<i>A</i>);<i>X</i>=<i>A</i>×0.1;<i>A</i>:=<i>A</i>-<i>X</i>;<i>Write</i>(<i>A</i>);</p>
                </div>
                <div class="p1">
                    <p id="42"><i>Read</i>(<i>B</i>);<i>B</i>:=<i>B</i>+<i>X</i>;<i>Write</i>(<i>B</i>)</p>
                </div>
                <div class="p1">
                    <p id="43">如系统先执行<i>T</i><sub>1</sub>的前3条指令,然后转向<i>T</i><sub>2</sub>,并执行它的前四条指令,接着再转向<i>T</i><sub>1</sub>,执行<i>T</i><sub>1</sub>的后3条指令,最后转向<i>T</i><sub>2</sub>,执行它的后3条指令。在这种类型的执行顺序中,两个事务的指令交替执行,称为并发调度。</p>
                </div>
                <div class="p1">
                    <p id="44"><b>定义2</b><citation id="202" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation> 事务的执行次序称为调度。如果多个事务依次执行,则称为事务的串行调度;如果利用分时的方法同时处理多个事务,称为事务的并发调度。</p>
                </div>
                <div class="p1">
                    <p id="45"><b>定义3</b><citation id="203" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation> 如果事务的并发调度对数据库状态的影响与某个串行调度相同,那么这个并发调度能保持数据库状态的一致,这样的调度是正确的,并称为可串行化调度。</p>
                </div>
                <div class="p1">
                    <p id="46">一个可串行化的并发调度与某个串行调度对数据库的影响相同。例如文献<citation id="204" type="reference">[<a class="sup">12</a>]</citation>定义了两个事务<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>,两个数据项<i>A</i>、<i>B</i>,初始状态都为50。事务<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>的定义及其一个串行化调度如图1所示,将图1中的调度称为调度1。</p>
                </div>
                <div class="area_img" id="47">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909011_04700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 串行化调度1:T1先于T2执行" src="Detail/GetImg?filename=images/JYRJ201909011_04700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 串行化调度1:T<sub>1</sub>先于T<sub>2</sub>执行  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909011_04700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="49">再给出这两个事务的并发调度的例子,如图2所示,图2的调度称为调度2。</p>
                </div>
                <div class="area_img" id="50">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909011_05000.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 并发调度2" src="Detail/GetImg?filename=images/JYRJ201909011_05000.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 并发调度2  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909011_05000.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="52">通过对并发调度2分析可知,由于<i>T</i><sub>1</sub>中的操作“<i>Read</i>(<i>B</i>);<i>B</i>:=<i>B</i>+100;<i>Write</i>(<i>B</i>)”和<i>T</i><sub>2</sub>中的操作“<i>Read</i>(<i>A</i>);<i>A</i>:=<i>A</i>*2;<i>Write</i>(<i>A</i>)”可以非冲突交换(即相邻操作交换执行的先后次序不会影响操作的结果)至先执行<i>T</i><sub>1</sub>后执行<i>T</i><sub>2</sub>,即调度2对数据库状态的影响与调度1是相同的,故它是一个可串行化的并发调度<citation id="205" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="53"><b>定义4</b><citation id="206" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation> 对于两个调度<i>S</i><sub>1</sub>和<i>S</i><sub>2</sub>,如果<i>S</i><sub>1</sub>的一系列相邻动作经过非冲突交换能转换成<i>S</i><sub>2</sub>;同样地,如果<i>S</i><sub>2</sub>的一系列相邻动作经过非冲突交换能转换成<i>S</i><sub>1</sub>,则这两个调度是冲突等价的。当一个调度冲突等价于一个串行调度时,这个调度就是冲突可串行化的。</p>
                </div>
                <div class="p1">
                    <p id="54">调度2冲突等价于调度1,而且调度2是冲突可串行化的。</p>
                </div>
                <h4 class="anchor-tag" id="55" name="55"><b>1.2 基于执行图的冲突可串行化判定</b></h4>
                <div class="p1">
                    <p id="56">判断一个调度是否是冲突可串行化,只要检查该调度中出现冲突的操作的顺序是否与一个串行调度中出现的顺序相同即可。如果相同,则说明是冲突可串行化的;如果不同,就不是冲突可串行化的。</p>
                </div>
                <div class="p1">
                    <p id="57"><b>定义5</b><citation id="207" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation> 已知调度<i>S</i>,其中事务<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>,如果<i>T</i><sub>1</sub>的动作<i>A</i><sub>1</sub>和<i>T</i><sub>2</sub>的动作<i>A</i><sub>2</sub>满足下面的情况,则<i>T</i><sub>1</sub>的执行优先于<i>T</i><sub>2</sub>,记为<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>。</p>
                </div>
                <div class="p1">
                    <p id="58">(1) 在调度<i>S</i>中,<i>A</i><sub>1</sub>在<i>A</i><sub>2</sub>前;</p>
                </div>
                <div class="p1">
                    <p id="59">(2) <i>A</i><sub>1</sub>和<i>A</i><sub>2</sub>都涉及同一个数据库元素;</p>
                </div>
                <div class="p1">
                    <p id="60">(3) <i>A</i><sub>1</sub>和<i>A</i><sub>2</sub>中至少有一个是写。</p>
                </div>
                <div class="p1">
                    <p id="61">此时,任何一个与<i>S</i>冲突等价的调度中,<i>A</i><sub>1</sub>都要出现在<i>A</i><sub>2</sub>前。如果这个调度是与<i>S</i>冲突等价的串行调度,则<i>T</i><sub>1</sub>一定出现在<i>T</i><sub>2</sub>前。所以只要检查出一个调度中任何两个冲突操作的顺序,并确定其是否与冲突等价的串行调度中的事务的顺序相同。如果相同,该调度就是可串行化调度<citation id="208" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="62"><b>定义6</b><citation id="209" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation> 优先图由节点和有向弧两种元素构成,节点代表事务,有向弧表示事务执行的先后次序。如果<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,则有向弧从<i>T</i><sub>1</sub>开始,指向<i>T</i><sub>2</sub>。</p>
                </div>
                <div class="p1">
                    <p id="63">利用优先图判断是否是冲突可串行化的准则:如果调度<i>S</i>的优先图中没有环,则<i>S</i>是冲突可串行化的,如果优先图中有环,则<i>S</i>不是冲突可串行化的<citation id="210" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="64"><b>例1</b> 下面的调度由3个事务<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>、<i>T</i><sub>3</sub>的动作构成<citation id="211" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>:</p>
                </div>
                <div class="p1">
                    <p id="65"><i>S</i><sub>1</sub>:<i>r</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>3</sub>(<i>A</i>);<i>w</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>3</sub>(<i>A</i>);<i>r</i><sub>2</sub>(<i>B</i>);<i>w</i><sub>2</sub>(<i>B</i>)</p>
                </div>
                <div class="p1">
                    <p id="66">在调度<i>S</i>中,可以找到的相邻冲突操作有<i>w</i><sub>2</sub>(<i>A</i>)和<i>r</i><sub>3</sub>(<i>A</i>),<i>w</i><sub>1</sub>(<i>B</i>)和<i>r</i><sub>2</sub>(<i>B</i>)。<i>w</i><sub>2</sub>(<i>A</i>)在<i>r</i><sub>3</sub>(<i>A</i>)前,说明<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>;<i>w</i><sub>1</sub>(<i>B</i>)在<i>r</i><sub>2</sub>(<i>B</i>)前,说明<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>。如图3所示。</p>
                </div>
                <div class="area_img" id="67">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909011_067.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 调度S1的执行图" src="Detail/GetImg?filename=images/JYRJ201909011_067.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 调度<i>S</i><sub>1</sub>的执行图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909011_067.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="68">如果将调度<i>S</i><sub>1</sub>中<i>r</i><sub>2</sub>(<i>B</i>)向前移动3个位置,该调度就变为:</p>
                </div>
                <div class="p1">
                    <p id="69"><i>S</i><sub>2</sub>:<i>r</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>2</sub>(<i>B</i>);<i>r</i><sub>3</sub>(<i>A</i>);<i>w</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>3</sub>(<i>A</i>);<i>w</i><sub>2</sub>(<i>B</i>)</p>
                </div>
                <div class="p1">
                    <p id="70">在该调度中可以找到相邻的冲突操作有<i>r</i><sub>2</sub>(<i>B</i>)和<i>w</i><sub>1</sub>(<i>B</i>),<i>w</i><sub>2</sub>(<i>A</i>)和<i>r</i><sub>2</sub>(<i>A</i>),<i>w</i><sub>1</sub>(<i>B</i>)和<i>w</i><sub>2</sub>(<i>B</i>)。</p>
                </div>
                <div class="p1">
                    <p id="71"><i>r</i><sub>2</sub>(<i>B</i>)在<i>w</i><sub>1</sub>(<i>B</i>)之前,说明<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>;<i>w</i><sub>2</sub>(<i>A</i>)在<i>r</i><sub>3</sub>(<i>A</i>)之前,说明<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>;<i>w</i><sub>1</sub>(<i>B</i>)在<i>w</i><sub>2</sub>(<i>B</i>)之前,说明<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>。优先图如图4所示。</p>
                </div>
                <div class="area_img" id="72">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909011_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 调度S2的执行图" src="Detail/GetImg?filename=images/JYRJ201909011_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 调度<i>S</i><sub>2</sub>的执行图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909011_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="73">图3无环说明调度<i>S</i><sub>1</sub>是可串行化的,而且冲突等价于串行调度(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>);图4有环说明调度<i>S</i><sub>2</sub>不是冲突可串行化的,因为找不到一个冲突等价的串行化调度<citation id="212" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>。这种执行图判定方法在实现时,需要系统存贮“图”这种复杂的数据结构和便于图节点遍历和回溯访问的索引结构<citation id="213" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>,并需要在图的搜索方法中识别“环”,而我们的方法完全基于关系运算的代数方法,直接根据逻辑公式的运算进行判定,简单易行。</p>
                </div>
                <h4 class="anchor-tag" id="74" name="74"><b>1.3 事务执行优先关系的闭包计算</b></h4>
                <div class="p1">
                    <p id="75">事务执行优先关系<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>具有传递性,即有传递推理规则{<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>}⇒{<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>},其中符号⇒表示“推导出”。为了得到所有这种传递关系,与数据库模式设计中求函数依赖集的闭包<citation id="214" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>类似,我们提出以下改进的定义和算法。</p>
                </div>
                <div class="p1">
                    <p id="76"><b>定义7</b> 设<i>F</i>是并发事务集上的执行优先关系集合,<i>T</i>是其中任一个事务,那么(相对于<i>F</i>)事务<i>T</i>的闭包用<i>T</i><sup>+</sup>表示,它是一个从<i>F</i>集使用传递推理规则推出的、或为<i>F</i>包含的所有满足<i>T</i>&lt;<i>A</i>的事务<i>A</i>的集合:</p>
                </div>
                <div class="p1">
                    <p id="77"><i>T</i><sup>+</sup>={事务<mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo stretchy="false">|</mo><mi>F</mi><mo>⇒</mo><mi>Τ</mi><mo>&lt;</mo><mi>A</mi></mrow></math></mathml>或<i>T</i>&lt;<i>A</i>∈<i>F</i>}</p>
                </div>
                <div class="p1">
                    <p id="79"><b>算法1</b> 求事务<i>T</i>相对于执行优先关系集<i>F</i>的闭包<i>T</i><sup>+</sup></p>
                </div>
                <div class="p1">
                    <p id="80">输入:事务<i>T</i>;事务执行优先关系集<i>F</i></p>
                </div>
                <div class="p1">
                    <p id="81">输出:<i>T</i>相对于<i>F</i>的闭包<i>T</i><sup>+</sup></p>
                </div>
                <div class="p1">
                    <p id="82">步骤:</p>
                </div>
                <div class="p1">
                    <p id="83">{ <i>T</i><sup>+</sup>:=<i>T</i>;</p>
                </div>
                <div class="p1">
                    <p id="84">Do {</p>
                </div>
                <div class="p1">
                    <p id="85">Old <i>T</i><sup>+</sup>:=<i>T</i><sup>+</sup>;</p>
                </div>
                <div class="p1">
                    <p id="86">For each <i>Y</i>&lt;<i>Z</i>∈<i>F</i> do</p>
                </div>
                <div class="p1">
                    <p id="87">If <i>Y</i>⊆<i>T</i><sup>+</sup> then <i>T</i><sup>+</sup>:=<i>T</i><sup>+</sup>∪{<i>Z</i>};</p>
                </div>
                <div class="p1">
                    <p id="88">} while(<i>T</i><sup>+</sup>≠old <i>T</i><sup>+</sup>);</p>
                </div>
                <div class="p1">
                    <p id="89"><i>T</i><sup>+</sup>:=<i>T</i><sup>+</sup>-{<i>T</i>};</p>
                </div>
                <div class="p1">
                    <p id="90">Return(<i>T</i><sup>+</sup>);</p>
                </div>
                <div class="p1">
                    <p id="91">}</p>
                </div>
                <div class="p1">
                    <p id="92">和函数依赖属性集闭包计算中函数依赖关系<citation id="215" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>不同的是,事务执行优先关系并不具有自反性,即不存在<i>T</i><sub>1</sub>&lt;<i>T</i><sub>1</sub>这样的关系,故而在算法1求得事务<i>T</i>的闭包<i>T</i><sup>+</sup>时需将<i>T</i>本身除去。同时也不考虑增广性,即在事务执行优先关系中“&lt;”的左边和右边都是单一的事务(见定义5),故而在由事务<i>T</i>的闭包<i>T</i><sup>+</sup>得到所有蕴含的执行优先关系时,只考虑“&lt;”关系的左右两边皆为单一事务情况。</p>
                </div>
                <div class="p1">
                    <p id="93"><b>定义8</b> 设<i>F</i>是并发事务集上的执行优先关系集合,根据传递推理性规则得到的所有执行优先关系和<i>F</i>自身包含的优先关系构成的全体集合,称为<i>F</i>的闭包,记为<i>F</i><sup>+</sup>。形式化表达为:</p>
                </div>
                <div class="p1">
                    <p id="94" class="code-formula">
                        <mathml id="94"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><msup><mrow></mrow><mo>+</mo></msup><mo>=</mo><mi>F</mi><mstyle displaystyle="true"><mo>∪</mo><mo stretchy="false">{</mo></mstyle><mi>X</mi><mo>&lt;</mo><mi>Y</mi><mo stretchy="false">|</mo><mi>F</mi><mo>⇒</mo><mo stretchy="false">{</mo><mi>X</mi><mo>&lt;</mo><mi>Y</mi><mo stretchy="false">}</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="95"><b>算法2</b> 求并发事务集<i>TU</i>的优先执行关系集闭包<i>F</i><sup>+</sup></p>
                </div>
                <div class="p1">
                    <p id="96">输入:并发事务集合<i>TU</i>,事务优先执行关系集<i>F</i></p>
                </div>
                <div class="p1">
                    <p id="97">输出:<i>F</i><sup>+</sup></p>
                </div>
                <div class="p1">
                    <p id="98">步骤:</p>
                </div>
                <div class="p1">
                    <p id="99">{</p>
                </div>
                <div class="p1">
                    <p id="100"><i>F</i><sup>+</sup>:=Ø;</p>
                </div>
                <div class="p1">
                    <p id="101">For each <i>T</i>∈<i>TU</i> do</p>
                </div>
                <div class="p1">
                    <p id="102">{</p>
                </div>
                <div class="p1">
                    <p id="103">调用算法1,计算<i>T</i><sup>+</sup>;</p>
                </div>
                <div class="p1">
                    <p id="104">If <i>T</i><sup>+</sup>≠Ø then</p>
                </div>
                <div class="p1">
                    <p id="105">{</p>
                </div>
                <div class="p1">
                    <p id="106">For each <i>A</i>∈<i>T</i><sup>+</sup> do</p>
                </div>
                <div class="p1">
                    <p id="107"><i>F</i><sup>+</sup>:=<i>F</i><sup>+</sup>∪{<i>T</i>&lt;<i>A</i>};</p>
                </div>
                <div class="p1">
                    <p id="108">}</p>
                </div>
                <div class="p1">
                    <p id="109">}</p>
                </div>
                <div class="p1">
                    <p id="110"><i>Return</i>(<i>F</i><sup>+</sup>);</p>
                </div>
                <div class="p1">
                    <p id="111">}</p>
                </div>
                <div class="p1">
                    <p id="112"><b>例2</b> 已知并发事务<i>TU</i>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},事务执行优先关系集合<i>F</i>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>},求<i>F</i><sup>+</sup>。</p>
                </div>
                <div class="p1">
                    <p id="113">根据算法2,当<i>T</i>=<i>T</i><sub>1</sub>时,调用算法1得到<i>T</i><sup>+</sup>={<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},所以<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>};当<i>T</i>=<i>T</i><sub>2</sub>时,调用算法1得到<i>T</i><sup>+</sup>={<i>T</i><sub>3</sub>},所以<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>};当<i>T</i>=<i>T</i><sub>3</sub>时,调用算法1得到<i>T</i><sup>+</sup>=Ø,所以<i>F</i><sup>+</sup>不变,即<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>}。</p>
                </div>
                <div class="p1">
                    <p id="114">根据定义5,如果<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,在等价的冲突可串行化调度中<i>T</i><sub>1</sub>始终在<i>T</i><sub>2</sub>前面执行。为了便于后面的定理证明的描述,我们提出如下定义。</p>
                </div>
                <div class="p1">
                    <p id="115"><b>定义9</b> 如果一对事务<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>,已知<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,我们称<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>为<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>间的可串行化交换方向。</p>
                </div>
                <div class="p1">
                    <p id="116"><b>定义10</b> 类似(<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>)(<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>)∧…∧(<i>T</i><sub><i>m</i></sub>&lt;<i>T</i><sub><i>n</i></sub>)这样的逻辑“与”组成的合取公式为冲突事务集(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,…,<i>T</i><sub><i>n</i></sub>)的可串行化交换方向。</p>
                </div>
                <h4 class="anchor-tag" id="117" name="117"><b>1.4 谓词逻辑公式</b></h4>
                <div class="p1">
                    <p id="118">谓词表示个体性质或个体之间的关系,一些更复杂的关系和性质可用多元谓词或谓词与联结词复合形式描述<citation id="216" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>。例如“3小于2”可以表示为:<i>L</i>(3,2)。</p>
                </div>
                <div class="p1">
                    <p id="119"><b>定义11</b><citation id="217" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation> 原子公式、量词和联结词按照一定规则组成的,用以表示复杂命题的符号串,称为谓词逻辑合适公式,简称为谓词逻辑公式或谓词公式。谓词公式按如下方式生成:</p>
                </div>
                <div class="p1">
                    <p id="120">(1) 原子公式是谓词公式;</p>
                </div>
                <div class="p1">
                    <p id="121">(2) 如果<i>A</i>是谓词公式,则(<image id="122" type="" href="images/JYRJ201909011_12200.jpg" display="inline" placement="inline"><alt></alt></image><i>A</i>)是谓词公式;</p>
                </div>
                <div class="p1">
                    <p id="123">(3) 如果<i>A</i>和<i>B</i>是谓词公式,则(<i>A</i>∧<i>B</i>)、(<i>A</i>∨<i>B</i>)、(<i>A</i>→<i>B</i>)、(<i>A</i>↔<i>B</i>)是谓词公式;</p>
                </div>
                <div class="p1">
                    <p id="124">(4) 如果<i>A</i>是谓词公式,(∀<i>x</i>)<i>A</i>、(∃<i>x</i>)<i>A</i>是谓词公式;</p>
                </div>
                <div class="p1">
                    <p id="125">(5) 有限次使用(1)、(2)、(3)、(4)后得到的字符串才是谓词公式。</p>
                </div>
                <div class="p1">
                    <p id="126">对闭包<i>F</i><sup>+</sup>中逻辑关系符号化(已知传递闭包增加了所有可能传递关系,故可以看做关系相互独立),将<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>即<i>T</i><sub>1</sub>执行优先于<i>T</i><sub>2</sub>,定义为一阶二元谓词逻辑<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>),并且<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)=<image id="127" type="" href="images/JYRJ201909011_12700.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>)即<i>T</i><sub>1</sub>执行优先于<i>T</i><sub>2</sub>等价于“不是”<i>T</i><sub>2</sub>执行优先于<i>T</i><sub>1</sub>,其中符号<image id="128" type="" href="images/JYRJ201909011_12800.jpg" display="inline" placement="inline"><alt></alt></image>表示逻辑“非”即取反操作。然后将整个事务集按序号排序(比如事务编号由小到大次序),按上述转换公式将一阶二元谓词中两个参数转换为前后次序排序。按同一顺序整理后,发现存在一对类似于<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)∧<image id="129" type="" href="images/JYRJ201909011_12900.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)的逻辑冲突,即逻辑“与”合取公式的真值为false,则并发冲突事务集不可串行化。</p>
                </div>
                <h3 id="130" name="130" class="anchor-tag"><b>2 本文算法</b></h3>
                <div class="p1">
                    <p id="131">以下定理及证明作为本文提出的判定算法的理论基础,即表明该算法设计的正确性。</p>
                </div>
                <div class="p1">
                    <p id="132"><b>定理1</b> 若调度<i>S</i>中一对冲突事务&lt;<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>&gt;只有唯一的可串行化交换方向,则调度<i>S</i>中<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>可串行化,且得到冲突等价可串行化调度的交换方向为该方向,否则调度<i>S</i>中<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>必不可串行化。</p>
                </div>
                <div class="p1">
                    <p id="133">证明:假定<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>存在两个可串行化交换方向,<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>是可串行化的。不妨设<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>的一个可串行化方向为<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,则根据定义5可知:<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>中存在一个变量<i>X</i>的一对冲突操作&lt;<i>O</i><sub>1</sub>,<i>O</i><sub>2</sub>&gt;,即<i>O</i><sub>1</sub>和<i>O</i><sub>2</sub>是不可交换的;如果<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,在等价的冲突可串行化调度中<i>T</i><sub>1</sub>始终在<i>T</i><sub>2</sub>前面执行<citation id="218" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>,要想<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>可串行化,其余的相邻操作只能按<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>方向交换。</p>
                </div>
                <div class="p1">
                    <p id="134">同理,对于另一个可串行化方向<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>,存在一对冲突操作(<i>O</i>′<sub>2</sub>,<i>O</i>′<sub>1</sub>)使得在等价的冲突可串行化调度中<i>T</i><sub>2</sub>始终在<i>T</i><sub>1</sub>前面执行<citation id="219" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>,即<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>其余相邻操作只能按<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>方向交换才能实现<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>的并发调度可串行化,也即前面描述过的<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>中关于变量<i>X</i>的一对相邻冲突操作&lt;<i>O</i><sub>1</sub>,<i>O</i><sub>2</sub>&gt;必可交换为&lt;<i>O</i><sub>2</sub>,<i>O</i><sub>1</sub>&gt;使得<i>T</i><sub>2</sub>始终在<i>T</i><sub>1</sub>前面执行。但前面描述中已知&lt;<i>O</i><sub>1</sub>,<i>O</i><sub>2</sub>&gt;是冲突不可交换的。前后矛盾,故假设不成立,即定理成立。证毕。</p>
                </div>
                <div class="p1">
                    <p id="135">我们的判定方法需完全检测冲突事务集合,在事务集的两两事务检测中累积(<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>)∧(<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>)∧…∧(<i>T</i><sub><i>m</i></sub>&lt;<i>T</i><sub><i>n</i></sub>),一旦发现逻辑“与”的合取公式的真值为false,停止检测,断定不可串行化。而且该方法给出了可串行化交换的方向,即等价的可串行化事务调度,可进一步断定此串行化执行的逻辑是否与设计意图一致。该判定方法属于逻辑代数方法,无需做出执行图和识别环的存在来判定是否可串行化。</p>
                </div>
                <div class="p1">
                    <p id="136"><b>定理2</b> 冲突事务集&lt;<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,…,<i>T</i><sub><i>n</i></sub>&gt;的并发调度<i>S</i>中存在的每一对冲突事务&lt;<i>T</i><sub><i>m</i></sub>,<i>T</i><sub><i>n</i></sub>&gt;的可串行化交换方向<i>T</i><sub><i>m</i></sub>&lt;<i>T</i><sub><i>n</i></sub>看作是逻辑不等式。若所有的逻辑不等式的逻辑“与”公式(<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>)∧(<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>)∧…∧(<i>T</i><sub><i>m</i></sub>&lt;<i>T</i><sub><i>n</i></sub>)=false,则该调度<i>S</i>不可串行化;否则<i>S</i>必可串行化,且得到一个冲突可串行化调度的执行优先顺序为:(<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>)∧(<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>)∧…∧(<i>T</i><sub><i>m</i></sub>&lt;<i>T</i><sub><i>n</i></sub>)。</p>
                </div>
                <div class="p1">
                    <p id="137">证明:当(<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>)∧(<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>)∧…∧(<i>T</i><sub><i>m</i></sub>&lt;<i>T</i><sub><i>n</i></sub>)=false,则按1.4节描述的一阶二元谓词存在一对事务(<i>T</i><sub><i>i</i></sub>,<i>T</i><sub><i>j</i></sub>)使得:<i>Small</i>(<i>T</i><sub><i>i</i></sub>,<i>T</i><sub><i>j</i></sub>)∧(<image id="138" type="" href="images/JYRJ201909011_13800.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub><i>i</i></sub>,<i>T</i><sub><i>j</i></sub>))=false,即在事务<i>T</i><sub><i>i</i></sub>和<i>T</i><sub><i>j</i></sub>之间存在2个可串行化交换方向。</p>
                </div>
                <div class="p1">
                    <p id="139">由定理1可知,在调度<i>S</i>中<i>T</i><sub><i>i</i></sub>和<i>T</i><sub><i>j</i></sub>不可串行化,即调度<i>S</i>没有冲突等价的可串行化调度;反之,若(<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>)∧(<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>)∧…∧(<i>T</i><sub><i>m</i></sub>&lt;<i>T</i><sub><i>n</i></sub>)=true,则在调度<i>S</i>中每两个事务之间只存在一个可串行化交换方向,按定理1可知在调度<i>S</i>中这些事务之间都是可串行化的,即按这些可串行化执行优先次序,可以得到一个冲突等价的可串行化调度。故定理成立。证毕。</p>
                </div>
                <div class="p1">
                    <p id="140">根据以上定理,我们设计以下算法判定并发事务集<i>TU</i>的调度<i>S</i>是否可串行化。</p>
                </div>
                <div class="p1">
                    <p id="141"><b>算法3</b> 根据逻辑公式判定并发调度<i>S</i>的可串行性</p>
                </div>
                <div class="p1">
                    <p id="142">输入:并发事务集<i>TU</i>和并发调度<i>S</i></p>
                </div>
                <div class="p1">
                    <p id="143">输出:若具有可串行性则返回true,否则返回false</p>
                </div>
                <div class="p1">
                    <p id="144"><b>Step 1</b> 根据定义5,得到并发调度<i>S</i>中<i>TU</i>上事务之间的优先执行关系,所有这种优先关系形成集合<i>F</i>;</p>
                </div>
                <div class="p1">
                    <p id="145"><b>Step 2</b> 根据算法2,求<i>F</i><sup>+</sup>,将事务集<i>TU</i>上事务分配一个识别码<i>T</i><sub>id</sub>,按<i>T</i><sub>id</sub>由小到大排序;</p>
                </div>
                <div class="p1">
                    <p id="146"><b>Step 3</b> 将<i>F</i><sup>+</sup>上所有关系转化为谓词形式<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>),若有<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>),则参数转化为由小到大排序后变为<image id="147" type="" href="images/JYRJ201909011_14700.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>);</p>
                </div>
                <div class="p1">
                    <p id="148"><b>Step 4</b> 将所有谓词按逻辑“与”组合成合取公式:</p>
                </div>
                <div class="p1">
                    <p id="149"><i>ξ</i>=<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)∧…∧<i>Small</i>(<i>T</i><sub><i>m</i></sub>,<i>T</i><sub><i>n</i></sub>)</p>
                </div>
                <div class="p1">
                    <p id="150">若存在<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)∧<image id="151" type="" href="images/JYRJ201909011_15100.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)=false,即<i>ξ</i>=false,则return(false);否则,return(true)。</p>
                </div>
                <div class="p1">
                    <p id="152">由定理1和定理2的证明可知算法3是正确的,由文献<citation id="220" type="reference">[<a class="sup">11</a>]</citation>可知改进的闭包计算是可终止的,即算法3是可终止的。</p>
                </div>
                <h3 id="153" name="153" class="anchor-tag"><b>3 实例分析</b></h3>
                <div class="p1">
                    <p id="154">为了验证本文提出算法的实用性和有效性,采用文献<citation id="221" type="reference">[<a class="sup">12</a>]</citation>中的实例,并用本文算法进行详细分析。</p>
                </div>
                <div class="p1">
                    <p id="155"><b>例3</b> 如下调度由3个事务<i>T</i><sub>1</sub>、<i>T</i><sub>2</sub>、<i>T</i><sub>3</sub>的动作构成。</p>
                </div>
                <div class="p1">
                    <p id="156"><i>S</i>:<i>r</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>3</sub>(<i>A</i>);<i>w</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>3</sub>(<i>A</i>);<i>r</i><sub>2</sub>(<i>B</i>);<i>w</i><sub>2</sub>(<i>B</i>)。</p>
                </div>
                <div class="p1">
                    <p id="157">即有并发事务集<i>TU</i>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},按算法3分析如下:</p>
                </div>
                <div class="p1">
                    <p id="158">第一步:根据定义5在调度<i>S</i>中可以找到的相邻冲突操作有<i>w</i><sub>2</sub>(<i>A</i>)和<i>r</i><sub>3</sub>(<i>A</i>),<i>w</i><sub>1</sub>(<i>B</i>)和<i>r</i><sub>2</sub>(<i>B</i>)。<i>w</i><sub>2</sub>(<i>A</i>)在<i>r</i><sub>3</sub>(<i>A</i>)前,说明<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>;<i>w</i><sub>1</sub>(<i>B</i>)在<i>r</i><sub>2</sub>(<i>B</i>)前,说明<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>。即得到优先执行关系<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>和<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,即<i>F</i>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>}。</p>
                </div>
                <div class="p1">
                    <p id="159">第二步:调用算法2,计算<i>F</i><sup>+</sup>。</p>
                </div>
                <div class="p1">
                    <p id="160">当<i>T</i>=<i>T</i><sub>1</sub>时,<i>T</i><sup>+</sup>={<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>};</p>
                </div>
                <div class="p1">
                    <p id="161">当<i>T</i>=<i>T</i><sub>2</sub>时,<i>T</i><sup>+</sup>={<i>T</i><sub>3</sub>},<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>};</p>
                </div>
                <div class="p1">
                    <p id="162">当<i>T</i>=<i>T</i><sub>3</sub>时,<i>T</i><sup>+</sup>=Ø,<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>};</p>
                </div>
                <div class="p1">
                    <p id="163">第三步:根据<i>F</i><sup>+</sup>,建立谓词:<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>),<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>),<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>)。</p>
                </div>
                <div class="p1">
                    <p id="164">第四步:组成合取公式:<i>ξ</i>=<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)∧<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>)∧<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>)=true,即<i>TU</i>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>}的调度<i>S</i>可串行化,该结论与文献<citation id="222" type="reference">[<a class="sup">12</a>]</citation>中分析结果一致。</p>
                </div>
                <div class="p1">
                    <p id="165"><b>例4</b> 调度<i>S</i>:<i>r</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>2</sub>(<i>B</i>);<i>r</i><sub>3</sub>(<i>A</i>);<i>w</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>3</sub>(<i>A</i>);<i>w</i><sub>2</sub>(<i>B</i>)。即有并发事务集<i>TU</i>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},按算法3处理如下:</p>
                </div>
                <div class="p1">
                    <p id="166">第一步:根据定义5在该调度中可以找到相邻的冲突操作有<i>r</i><sub>2</sub>(<i>B</i>)和<i>w</i><sub>1</sub>(<i>B</i>)、<i>w</i><sub>2</sub>(<i>A</i>)和<i>r</i><sub>2</sub>(<i>A</i>)、<i>w</i><sub>1</sub>(<i>B</i>)和<i>w</i><sub>2</sub>(<i>B</i>)。<i>r</i><sub>2</sub>(<i>B</i>)在<i>w</i><sub>1</sub>(<i>B</i>)之前,说明<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>;<i>w</i><sub>2</sub>(<i>A</i>)在<i>r</i><sub>3</sub>(<i>A</i>)之前,说明<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>;<i>w</i><sub>1</sub>(<i>B</i>)在<i>w</i><sub>2</sub>(<i>B</i>)之前,说明<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>。即得到优先执行关系<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>、<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>、<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>,即<i>F</i>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>}。</p>
                </div>
                <div class="p1">
                    <p id="167">第二步:调用算法2,计算<i>F</i><sup>+</sup>。</p>
                </div>
                <div class="p1">
                    <p id="168">当<i>T</i>=<i>T</i><sub>1</sub>时,<i>T</i><sup>+</sup>={<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>};</p>
                </div>
                <div class="p1">
                    <p id="169">当<i>T</i>=<i>T</i><sub>2</sub>时,<i>T</i><sup>+</sup>={<i>T</i><sub>3</sub>,<i>T</i><sub>1</sub>},<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>};</p>
                </div>
                <div class="p1">
                    <p id="170">当<i>T</i>=<i>T</i><sub>3</sub>时,<i>T</i><sup>+</sup>=Ø,<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>};</p>
                </div>
                <div class="p1">
                    <p id="171">第三步:根据<i>F</i><sup>+</sup>,建立谓词:<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>),<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>),<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>),<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>);其中按顺序调整参数顺序有:<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>)=<image id="172" type="" href="images/JYRJ201909011_17200.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)。</p>
                </div>
                <div class="p1">
                    <p id="173">第四步,<i>ξ</i>=<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)∧<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>)∧<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>)∧(<image id="174" type="" href="images/JYRJ201909011_17400.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>))=false,即<i>TU</i>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>}的调度<i>S</i>不可串行化,该结论与文献<citation id="223" type="reference">[<a class="sup">12</a>]</citation>中分析结果一致。</p>
                </div>
                <div class="p1">
                    <p id="175"><b>例5</b> 考虑下面的调度<i>S</i>:<i>r</i><sub>2</sub>(<i>A</i>);<i>w</i><sub>2</sub>(<i>A</i>);<i>r</i><sub>3</sub>(<i>A</i>);<i>w</i><sub>1</sub>(<i>B</i>);<i>w</i><sub>3</sub>(<i>A</i>);<i>r</i><sub>2</sub>(<i>B</i>);<i>w</i><sub>2</sub>(<i>B</i>);<i>r</i><sub>1</sub>(<i>A</i>);<i>w</i><sub>1</sub>(<i>A</i>)。即有并发事务集<i>TU</i>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},按算法3分析如下:</p>
                </div>
                <div class="p1">
                    <p id="176">第一步:根据定义5在调度<i>S</i>中可以找到相邻冲突操作有<i>w</i><sub>2</sub>(<i>A</i>)和<i>r</i><sub>3</sub>(<i>A</i>)、<i>w</i><sub>1</sub>(<i>B</i>)和<i>r</i><sub>2</sub>(<i>B</i>)、<i>w</i><sub>3</sub>(<i>A</i>)和<i>r</i><sub>1</sub>(<i>A</i>)。<i>w</i><sub>2</sub>(<i>A</i>)在<i>r</i><sub>3</sub>(<i>A</i>)之前,则<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>;<i>w</i><sub>1</sub>(<i>B</i>)在<i>r</i><sub>2</sub>(<i>B</i>)前,则<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>;<i>w</i><sub>3</sub>(<i>A</i>)在<i>r</i><sub>1</sub>(<i>A</i>)前,则<i>T</i><sub>3</sub>&lt;<i>T</i><sub>1</sub>,即<i>F</i>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>3</sub>&lt;<i>T</i><sub>1</sub>}。</p>
                </div>
                <div class="p1">
                    <p id="177">第二步:调用算法2,计算<i>F</i><sup>+</sup>。</p>
                </div>
                <div class="p1">
                    <p id="178">当<i>T</i>=<i>T</i><sub>1</sub>时,<i>T</i><sup>+</sup>={<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>},<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>};</p>
                </div>
                <div class="p1">
                    <p id="179">当<i>T</i>=<i>T</i><sub>2</sub>时,<i>T</i><sup>+</sup>={<i>T</i><sub>3</sub>,<i>T</i><sub>1</sub>},<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>};</p>
                </div>
                <div class="p1">
                    <p id="180">当<i>T</i>=<i>T</i><sub>3</sub>时,<i>T</i><sup>+</sup>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>},<i>F</i><sup>+</sup>={<i>T</i><sub>1</sub>&lt;<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>&lt;<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>&lt;<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>&lt;<i>T</i><sub>2</sub>}。</p>
                </div>
                <div class="p1">
                    <p id="181">第三步:根据<i>F</i><sup>+</sup>建立谓词:<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>),<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>),<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>),<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>),<i>Small</i>(<i>T</i><sub>3</sub>,<i>T</i><sub>1</sub>),<i>Small</i>(<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>);按顺序调整参数顺序有:<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>1</sub>)=<image id="182" type="" href="images/JYRJ201909011_18200.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>),<i>Small</i>(<i>T</i><sub>3</sub>,<i>T</i><sub>1</sub>)=<image id="183" type="" href="images/JYRJ201909011_18300.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>),<i>Small</i>(<i>T</i><sub>3</sub>,<i>T</i><sub>2</sub>)=<image id="184" type="" href="images/JYRJ201909011_18400.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>)。</p>
                </div>
                <div class="p1">
                    <p id="185">第四步:<i>ξ</i>=<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)∧<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>)∧<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>)∧(<image id="186" type="" href="images/JYRJ201909011_18600.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>))∧(<image id="187" type="" href="images/JYRJ201909011_18700.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>))∧(<image id="188" type="" href="images/JYRJ201909011_18800.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>)),由于<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>)∧(<image id="189" type="" href="images/JYRJ201909011_18900.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>3</sub>))=false,<i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>)∧(<image id="190" type="" href="images/JYRJ201909011_19000.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>))=false,<i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>)∧(<image id="191" type="" href="images/JYRJ201909011_19100.jpg" display="inline" placement="inline"><alt></alt></image><i>Small</i>(<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>))=false,故<i>ξ</i>=false,即并发事务集<i>TU</i>={<i>T</i><sub>1</sub>,<i>T</i><sub>2</sub>,<i>T</i><sub>3</sub>}的调度<i>S</i>不可串行化。</p>
                </div>
                <div class="p1">
                    <p id="192">根据文献<citation id="224" type="reference">[<a class="sup">12</a>]</citation>可以建立如图5所示的执行图。</p>
                </div>
                <div class="area_img" id="193">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JYRJ201909011_193.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 例5中调度S的执行图" src="Detail/GetImg?filename=images/JYRJ201909011_193.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 例5中调度<i>S</i>的执行图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JYRJ201909011_193.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="194">由于图5中出现了环,可以判断调度<i>S</i>不可串行化,即本文算法3可取得利用文献<citation id="225" type="reference">[<a class="sup">12</a>]</citation>中执行图判定同样的效果。但本文方法完全是基于关系闭包计算和谓词公式计算的代数方法,算法实现时不用转换为图结构存贮,也无需在图搜索算法中“识别”环。</p>
                </div>
                <h3 id="195" name="195" class="anchor-tag"><b>4 结 语</b></h3>
                <div class="p1">
                    <p id="196">并发事务可串行化判定是事务并发控制的重要任务之一,现有方法采用执行图判定,具体实现判定功能时需要存贮为图这种复杂数据结构,而且需要用图搜索方法识别“环”的存在。与这种传统的、基于图论的方法不同,本文提出一种基于事务执行优先关系闭包运算和一阶二元谓词逻辑公式计算的代数方法,算法设计逻辑简明,不需要复杂的数据结构和算法流程。通过理论论证和实例分析,验证了本文所提方法的正确性和有效性。未来,将结合并发事务控制中锁机制和基于时间戳的版本控制方法,提出更加有效的并发事务控制方法。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXDL201901108&amp;v=MjQ2MzVxcUJ0R0ZyQ1VSN3FmWnVadEZ5bmhVYnJLUFRYUFlyRzRIOWpNcm81RmJJUUtESDg0dlI0VDZqNTRPM3o=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 王晓波.计算机网络数据库安全管理技术的优化[J].信息与电脑(理论版),2019(1):238-239,242.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TXSJ201901137&amp;v=MDE0MzF0RnluaFVicktNVFhZWkxHNEg5ak1ybzVHWTRRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVo=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 徐晨昊.探究关系型数据库[J].通讯世界,2019,26(1):208-209.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZRU201824009&amp;v=MDk3NTdCdEdGckNVUjdxZlp1WnRGeW5oVWJyS0lUZlplN0c0SDluT3E0OUZiWVFLREg4NHZSNFQ2ajU0TzN6cXE=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> 裘是寅,杨子睿.基于“互联网+”的协同创新平台构建[J].电子技术与软件工程,2018(24):2.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXWX201808014&amp;v=MDQ2NTZxQnRHRnJDVVI3cWZadVp0RnluaFVicktQVFhjZHJHNEg5bk1wNDlFWUlRS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b> 赵昱帆,邓玉辉.网络编码集群存储系统基于锁机制的热数据重建策略[J].小型微型计算机系统,2018,39(8):1707-1712.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201610016&amp;v=MDk5MTM0OUVZb1FLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeW5oVWJyS01qWFNaTEc0SDlmTnI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> 黄姝娟,容晓峰,茹媛,等.一种采用Lock-Free同步机制的数据结构的研究[J].微电子学与计算机,2016,33(10):72-77.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJDK201312046&amp;v=MjI5ODNQWmJHNEg5TE5yWTlCWW9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVp0RnluaFVicktOeWY=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> 陈涵,林玫.锁机制在数据库并发访问中的研究与应用[J].软件导刊,2013,12(12):126-128.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Speedy transactions in multicore in-memory databases">

                                <b>[7]</b> Tu S,Zheng W,Kohler E,et al.Speedy Transactions in Multicore In-Memory Databases[C]//Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles.ACM,2013:18-32.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On the performance potential of connection fault-tolerant commit processing in mobile environment">

                                <b>[8]</b> Dimovski T,Mitrevski P.On the Performance Potential of Connection Fault-Tolerant Commit Processing in Mobile Environment[J].International Journal of Wireless &amp; Mobile Networks,2012,4(5):29-44.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=WhereStore:locationbased data storage formobile devices interacting with the cloud">

                                <b>[9]</b> Stuedi P,Mohomed I,Terry D.WhereStore:Location-Based Data Storage for Mobile Devices Interacting with the Cloud[C]//Proceedings of the 1st ACM Workshop on Mobile Cloud Computing &amp; Services:Social Networks and Beyond.ACM,2010:137-143.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" >
                                    <b>[10]</b>
                                 严蔚敏,李冬梅,吴伟民.数据结构(C语言版)[M].北京:清华大学出版社,2011.
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787040242249001&amp;v=MTU4MjFZMUJiZXNQRFJNOHp4VVNtRGQ5U0g3bjN4RTlmYnZuS3JpZlplWnZGeW5tVTc3TUlsc1dYRnF6R2JPOEh0UEly&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b> 施伯乐,丁宝康,汪卫.数据库系统教程[M].北京:高等教育出版社,2008.
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" >
                                    <b>[12]</b>
                                 杜金莲.高级数据库技术[M].北京:清华大学出版社,2010.
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787040294651001&amp;v=Mjc3OTdSTTh6eFVTbURkOVNIN24zeEU5ZmJ2bktyaWZaZVp2RnlubVU3N01JbHNXWEZxekdiTzhIdFBGcTRsQVplc1BE&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b> 王元元.离散数学教程[M].北京:高等教育出版社,2010.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JYRJ201909011" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JYRJ201909011&amp;v=Mjk0MTBqTXBvOUVaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnRGeW5oVWJyS0x6VFpaTEc0SDk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJtNEYxa3hKZG9XL1JrZXNhdGVWVEdvM0tSMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
