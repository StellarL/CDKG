<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637136664475315000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJY201907024%26RESULT%3d1%26SIGN%3dwon3InD8bdijAUHkT9AJl1kUMeQ%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJY201907024&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJY201907024&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJY201907024&amp;v=MjQ3MjZHNEg5ak1xSTlIWUlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVpzRnkvZ1VydktMejdCZDc=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#71" data-title="0 引言 ">0 引言</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#79" data-title="1 相关工作 ">1 相关工作</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#80" data-title="1.1 &lt;b&gt;形态学重建&lt;/b&gt;">1.1 <b>形态学重建</b></a></li>
                                                <li><a href="#85" data-title="1.2 &lt;b&gt;基于图形处理器的并行数据结构&lt;/b&gt;">1.2 <b>基于图形处理器的并行数据结构</b></a></li>
                                                <li><a href="#88" data-title="1.3 &lt;b&gt;并行优先队列&lt;/b&gt;">1.3 <b>并行优先队列</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#96" data-title="2 基于图形处理器的形态学重建系统 ">2 基于图形处理器的形态学重建系统</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#97" data-title="2.1 &lt;b&gt;系统概述&lt;/b&gt;">2.1 <b>系统概述</b></a></li>
                                                <li><a href="#113" data-title="2.2 &lt;b&gt;并行堆&lt;/b&gt;">2.2 <b>并行堆</b></a></li>
                                                <li><a href="#121" data-title="2.3 &lt;b&gt;并行策略&lt;/b&gt;">2.3 <b>并行策略</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#126" data-title="3 开发环境及实验结果 ">3 开发环境及实验结果</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#136" data-title="4 结语 ">4 结语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#77" data-title="图1 形态学重建示例图">图1 形态学重建示例图</a></li>
                                                <li><a href="#99" data-title="图2 MR_GPU流程">图2 MR_GPU流程</a></li>
                                                <li><a href="#120" data-title="图3 并行堆入堆、出堆示例图">图3 并行堆入堆、出堆示例图</a></li>
                                                <li><a href="#132" data-title="&lt;b&gt;表&lt;/b&gt;1 &lt;b&gt;标记图像和掩膜图像的基本信息&lt;/b&gt;"><b>表</b>1 <b>标记图像和掩膜图像的基本信息</b></a></li>
                                                <li><a href="#133" data-title="&lt;b&gt;表&lt;/b&gt;2 &lt;b&gt;不同并行堆个数下集群的实验数据&lt;/b&gt;"><b>表</b>2 <b>不同并行堆个数下集群的实验数据</b></a></li>
                                                <li><a href="#135" data-title="&lt;b&gt;表&lt;/b&gt;3 &lt;b&gt;不同并行堆节点尺寸下的实验数据&lt;/b&gt;"><b>表</b>3 <b>不同并行堆节点尺寸下的实验数据</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="164">


                                    <a id="bibliography_1" title=" VINCENT L.Morphological grayscale reconstruction in image analysis:applications and efficient algorithms [J].IEEE Transactions on Image Processing, 1993, 2 (2) :176-201." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Morphological grayscale reconstruction in image analysis: applications and efficient algorithms">
                                        <b>[1]</b>
                                         VINCENT L.Morphological grayscale reconstruction in image analysis:applications and efficient algorithms [J].IEEE Transactions on Image Processing, 1993, 2 (2) :176-201.
                                    </a>
                                </li>
                                <li id="166">


                                    <a id="bibliography_2" title=" ROBINSON K, WHELAN P F.Efficient morphological reconstruction:a downhill filter [J].Pattern Recognition Letters, 2004, 25 (15) :1759-1767." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300415347&amp;v=Mjc5NzBnK29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXIzSUoxc1ZiaFk9TmlmT2ZiSzdIdERPckk5RllPb0tEMw==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         ROBINSON K, WHELAN P F.Efficient morphological reconstruction:a downhill filter [J].Pattern Recognition Letters, 2004, 25 (15) :1759-1767.
                                    </a>
                                </li>
                                <li id="168">


                                    <a id="bibliography_3" title=" ZHOU K, HOU Q, WANG R, et al.Real-time KD-tree construction on graphics hardware [J].ACM Transactions on Graphics, 2008, 27 (5) :Article No.126." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000098690&amp;v=Mjg4NjYvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXIzSUoxc1ZiaFk9TmlmSVk3SzdIdGpOcjQ5RlpPSUhDblU1b0JNVDZUNFBRSA==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         ZHOU K, HOU Q, WANG R, et al.Real-time KD-tree construction on graphics hardware [J].ACM Transactions on Graphics, 2008, 27 (5) :Article No.126.
                                    </a>
                                </li>
                                <li id="170">


                                    <a id="bibliography_4" title=" HOU Q, XIN S, ZHOU K, et al.Memory-scalable GPU spatial hierarchy construction [J].IEEE Transactions on Visualization and Computer Graphics, 2011, 17 (4) :466-474." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Memory-Scalable GPU Spatial Hierarchy Construction">
                                        <b>[4]</b>
                                         HOU Q, XIN S, ZHOU K, et al.Memory-scalable GPU spatial hierarchy construction [J].IEEE Transactions on Visualization and Computer Graphics, 2011, 17 (4) :466-474.
                                    </a>
                                </li>
                                <li id="172">


                                    <a id="bibliography_5" title=" 吴哲锋, 赵福凯, 刘新国.图形处理器上的表面积启发式构建KD树并行方法:中国, CN201110241419.2[P].2011-08-22. (WU Z F, ZHAO F K, LIU X G.An surface-based heuristic algorithm for constructing KD-tree on GPUs:China, CN201110241419.2[P].2011- 08- 22.) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SCPD&amp;filename=CN102426710A&amp;v=MzExNDRIckc4SE5mTHJvODBDKzRQRDMxTHh4WVQ2em9PUzNmbXBXRmFlN0tXUmJxZVorVnVFQzNrVjdzPUppTzY=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         吴哲锋, 赵福凯, 刘新国.图形处理器上的表面积启发式构建KD树并行方法:中国, CN201110241419.2[P].2011-08-22. (WU Z F, ZHAO F K, LIU X G.An surface-based heuristic algorithm for constructing KD-tree on GPUs:China, CN201110241419.2[P].2011- 08- 22.) 
                                    </a>
                                </li>
                                <li id="174">


                                    <a id="bibliography_6" title=" BENSON D, DAVIS J.Octree textures [J].ACM Transactions on Graphics, 2002, 21 (3) :785-790." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000097976&amp;v=MTM1NTZvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyM0lKMXNWYmhZPU5pZklZN0s3SHRqTnI0OUZaT0lJQlhzLw==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         BENSON D, DAVIS J.Octree textures [J].ACM Transactions on Graphics, 2002, 21 (3) :785-790.
                                    </a>
                                </li>
                                <li id="176">


                                    <a id="bibliography_7" title=" ZIEGLER G, DIMITROV R, THEOBALT C, et al.Real-time quadtree analysis using HistoPyramids [C]// Proceedings of the SPIE 2007 Real-time Image Processing.Bellingham, WA:SPIE, 2007:64960L." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Real-Time Quadtree Analysis Using HistoPyramids">
                                        <b>[7]</b>
                                         ZIEGLER G, DIMITROV R, THEOBALT C, et al.Real-time quadtree analysis using HistoPyramids [C]// Proceedings of the SPIE 2007 Real-time Image Processing.Bellingham, WA:SPIE, 2007:64960L.
                                    </a>
                                </li>
                                <li id="178">


                                    <a id="bibliography_8" title=" AJMERA P, GORADIA R, CHANDRAN S, et al.Fast, parallel, GPU-based space filling curves and octrees [C]// Proceedings of the 2008 Symposium on Interactive 3D Graphics and Games.New York:ACM, 2008:10." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fast,parallel,GPU-based space filling curves and octrees">
                                        <b>[8]</b>
                                         AJMERA P, GORADIA R, CHANDRAN S, et al.Fast, parallel, GPU-based space filling curves and octrees [C]// Proceedings of the 2008 Symposium on Interactive 3D Graphics and Games.New York:ACM, 2008:10.
                                    </a>
                                </li>
                                <li id="180">


                                    <a id="bibliography_9" title=" CASTRO R, LEWINER T, LOPES H, et al.Statistical optimization of octree searches [J].Computer Graphics Forum, 2010, 27 (6) :1557-1566." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJWD&amp;filename=SJWD00000018026&amp;v=MDQyMzN0SE1yNDVOWk9rSlkzazV6QmRoNGo5OVNYcVJyeG94Y01IN1I3cWRaK1p1RmlybFZMckpKRm89TmlmY2FyTzRI&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[9]</b>
                                         CASTRO R, LEWINER T, LOPES H, et al.Statistical optimization of octree searches [J].Computer Graphics Forum, 2010, 27 (6) :1557-1566.
                                    </a>
                                </li>
                                <li id="182">


                                    <a id="bibliography_10" title=" SUN X, ZHOU K, STOLLNITZ E, et al.Interactive relighting of dynamic refractive objects [J].ACM Transactions on Graphics, 2008, 27 (3) :Article No.35." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000098603&amp;v=MjYzODM9TmlmSVk3SzdIdGpOcjQ5RlpPSUhDbnc2b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSjFzVmJoWQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                         SUN X, ZHOU K, STOLLNITZ E, et al.Interactive relighting of dynamic refractive objects [J].ACM Transactions on Graphics, 2008, 27 (3) :Article No.35.
                                    </a>
                                </li>
                                <li id="184">


                                    <a id="bibliography_11" title=" LEFEBVRE S, HORNUS S, NEYRET F.Octree textures on the GPU[J].GPU Gems, 2005, 2:595-613." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Octree textures on the GPU">
                                        <b>[11]</b>
                                         LEFEBVRE S, HORNUS S, NEYRET F.Octree textures on the GPU[J].GPU Gems, 2005, 2:595-613.
                                    </a>
                                </li>
                                <li id="186">


                                    <a id="bibliography_12" title=" ZHOU K, GONG M, HUANG X, et al.Data-parallel octrees for surface reconstruction [J].IEEE Transactions on Visualization and Computer Graphics, 2011, 17 (5) :669-681." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Data-parallel octrees for surface reconstruction">
                                        <b>[12]</b>
                                         ZHOU K, GONG M, HUANG X, et al.Data-parallel octrees for surface reconstruction [J].IEEE Transactions on Visualization and Computer Graphics, 2011, 17 (5) :669-681.
                                    </a>
                                </li>
                                <li id="188">


                                    <a id="bibliography_13" title=" GRAHN H, LAVESSON N, LAPAJNE M H, et al.CudaRF:a CUDA implementation of random forests[C]// Proceedings of the 2011 IEEE/ACS International Conference on Computer Systems and Applications.Piscataway, NJ:IEEE, 2011:95-101." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=CudaRF:a CUDA implementation of random forests">
                                        <b>[13]</b>
                                         GRAHN H, LAVESSON N, LAPAJNE M H, et al.CudaRF:a CUDA implementation of random forests[C]// Proceedings of the 2011 IEEE/ACS International Conference on Computer Systems and Applications.Piscataway, NJ:IEEE, 2011:95-101.
                                    </a>
                                </li>
                                <li id="190">


                                    <a id="bibliography_14" title=" SHARP T.Implementing decision trees and forests on a GPU[C]// Proceedings of the 10th European Conference on Computer Vision.Berlin:Springer, 2008:595-608." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Implementing decision trees and forests on a GPU">
                                        <b>[14]</b>
                                         SHARP T.Implementing decision trees and forests on a GPU[C]// Proceedings of the 10th European Conference on Computer Vision.Berlin:Springer, 2008:595-608.
                                    </a>
                                </li>
                                <li id="192">


                                    <a id="bibliography_15" >
                                        <b>[15]</b>
                                     LAUTERBACH C, GARLAND M, SENGUPTA S, et al.Fast BVH construction on GPUs[J].Computer Graphics Forum, 2009, 28 (2) :375-384.</a>
                                </li>
                                <li id="194">


                                    <a id="bibliography_16" title=" 李怀明, 邓仰东.基于图形处理器的高性能跳表 (Skiplist) 数据结构[J].微电子学与计算机, 2014, 31 (12) :1-5. (LI H M, DENG Y D.High performance Skiplist for GPU computing [J].Microelectronics and Computer, 2014, 31 (12) :1-5.) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201412001&amp;v=MTI5NTVnVXJ2TU1qWFNaTEc0SDlYTnJZOUZaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnNGeS8=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                         李怀明, 邓仰东.基于图形处理器的高性能跳表 (Skiplist) 数据结构[J].微电子学与计算机, 2014, 31 (12) :1-5. (LI H M, DENG Y D.High performance Skiplist for GPU computing [J].Microelectronics and Computer, 2014, 31 (12) :1-5.) 
                                    </a>
                                </li>
                                <li id="196">


                                    <a id="bibliography_17" title=" ALCANTARA D, SHARF A, ABBASINEJAD F, et al.Real-time parallel hashing on the GPU [J].ACM Transactions on Graphics, 2009, 28 (5) :Article No.154." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000098888&amp;v=MDA0NjJubFVyM0lKMXNWYmhZPU5pZklZN0s3SHRqTnI0OUZaT0lIQkhReG9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                         ALCANTARA D, SHARF A, ABBASINEJAD F, et al.Real-time parallel hashing on the GPU [J].ACM Transactions on Graphics, 2009, 28 (5) :Article No.154.
                                    </a>
                                </li>
                                <li id="198">


                                    <a id="bibliography_18" title=" FREDMAN M L, KOMLOS J, SZEMEREDI E.Storing a sparse table with O (1) worst case access time[J].Journal of the ACM, 1984, 31 (3) :538-544." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000019377&amp;v=MjQ4NjZud1plWnRGaW5sVXIzSUoxc1ZiaFk9TmlmSVk3SzdIdGpOcjQ5RlpPb0dEM3Mrb0JNVDZUNFBRSC9pclJkR2VycVFUTQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[18]</b>
                                         FREDMAN M L, KOMLOS J, SZEMEREDI E.Storing a sparse table with O (1) worst case access time[J].Journal of the ACM, 1984, 31 (3) :538-544.
                                    </a>
                                </li>
                                <li id="200">


                                    <a id="bibliography_19" title=" PAGH R, RODLER F F.Cuckoo hashing [J].Journal of Algorithms, 2004, 51 (2) :122-144." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012201522397&amp;v=Mjk5NjRUTW53WmVadEZpbmxVcjNJSjFzVmJoWT1OaWZPZmJLN0h0RE9yWTlFWWVrTkQzVStvQk1UNlQ0UFFIL2lyUmRHZXJxUQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[19]</b>
                                         PAGH R, RODLER F F.Cuckoo hashing [J].Journal of Algorithms, 2004, 51 (2) :122-144.
                                    </a>
                                </li>
                                <li id="202">


                                    <a id="bibliography_20" title=" MA L, CHAMBERLAIN R D, BUHLER J D, et al.Bloom filter performance on graphics engines[C]// Proceedings of the 2011 International Conference on Parallel Processing.Piscataway, NJ:IEEE, 2011:522-531." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Bloom Filter Performance on Graphics Engines">
                                        <b>[20]</b>
                                         MA L, CHAMBERLAIN R D, BUHLER J D, et al.Bloom filter performance on graphics engines[C]// Proceedings of the 2011 International Conference on Parallel Processing.Piscataway, NJ:IEEE, 2011:522-531.
                                    </a>
                                </li>
                                <li id="204">


                                    <a id="bibliography_21" title=" AMOSSEN R R, PAGH R.A new data layout for set intersection on GPUs[C]// Proceedings of the 2011 Parallel and Distributed Processing Symposium.Piscataway, NJ:IEEE, 2011:698-708." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A new data layout for set intersection on GPUs">
                                        <b>[21]</b>
                                         AMOSSEN R R, PAGH R.A new data layout for set intersection on GPUs[C]// Proceedings of the 2011 Parallel and Distributed Processing Symposium.Piscataway, NJ:IEEE, 2011:698-708.
                                    </a>
                                </li>
                                <li id="206">


                                    <a id="bibliography_22" title=" LUO L, WONG M, HWU W.An effective GPU implementation of breadth first search [C]// Proceedings of the 2010 Design Automation Conference.New York:ACM, 2010:52-55." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=&amp;quot;An Effective GPU Implementation ofBreadth-First Search,&amp;quot;">
                                        <b>[22]</b>
                                         LUO L, WONG M, HWU W.An effective GPU implementation of breadth first search [C]// Proceedings of the 2010 Design Automation Conference.New York:ACM, 2010:52-55.
                                    </a>
                                </li>
                                <li id="208">


                                    <a id="bibliography_23" title=" VINEET V, HARISH P, PATIDAR S, et al.Fast minimum spanning tree for large graphs on the GPU[C]// Proceedings of the 2009 Conference on High Performance Graphics.New York:ACM, 2009:167-171." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fast Minimum Spanning Tree for Large Graphs on the GPU">
                                        <b>[23]</b>
                                         VINEET V, HARISH P, PATIDAR S, et al.Fast minimum spanning tree for large graphs on the GPU[C]// Proceedings of the 2009 Conference on High Performance Graphics.New York:ACM, 2009:167-171.
                                    </a>
                                </li>
                                <li id="210">


                                    <a id="bibliography_24" title=" CORMEN T H, LEISERSON C E, RIVEST R L, et al.Introduction to Algorithms [M].Cambridge, MA:MIT Press, 2009:151-153." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Introduction to Algorithms">
                                        <b>[24]</b>
                                         CORMEN T H, LEISERSON C E, RIVEST R L, et al.Introduction to Algorithms [M].Cambridge, MA:MIT Press, 2009:151-153.
                                    </a>
                                </li>
                                <li id="212">


                                    <a id="bibliography_25" title=" VUILLEMIN J.A data structure for manipulating priority queues[J].Communications of the ACM, 1978, 21 (4) :309-315." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000024694&amp;v=MDY1NDI5RlpPa0xDblU5b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSjFzVmJoWT1OaWZJWTdLN0h0ak5yNA==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[25]</b>
                                         VUILLEMIN J.A data structure for manipulating priority queues[J].Communications of the ACM, 1978, 21 (4) :309-315.
                                    </a>
                                </li>
                                <li id="214">


                                    <a id="bibliography_26" title=" FREDMAN M L, TARJAN R E.Fibonacci heaps and their uses in improved network optimization algorithms [J].Journal of the ACM, 1987, 34 (3) :596-615." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000019487&amp;v=MjY5OTU9TmlmSVk3SzdIdGpOcjQ5RlpPb0dDSFErb0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSjFzVmJoWQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[26]</b>
                                         FREDMAN M L, TARJAN R E.Fibonacci heaps and their uses in improved network optimization algorithms [J].Journal of the ACM, 1987, 34 (3) :596-615.
                                    </a>
                                </li>
                                <li id="216">


                                    <a id="bibliography_27" title=" BRODAL G S.Priority queues on parallel machines [J].Parallel Computing, 1999, 25 (8) :987-1011." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300420256&amp;v=MjYzNTZlcnFRVE1ud1plWnRGaW5sVXIzSUoxc1ZiaFk9TmlmT2ZiSzdIdERPckk5RllPa1BEbmsvb0JNVDZUNFBRSC9pclJkRw==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[27]</b>
                                         BRODAL G S.Priority queues on parallel machines [J].Parallel Computing, 1999, 25 (8) :987-1011.
                                    </a>
                                </li>
                                <li id="218">


                                    <a id="bibliography_28" title=" NAGESHWARA R, KUMAR V.Concurrent access of priority queues [J].IEEE Transactions on Computers, 1988, 37 (12) :1657-1665." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Concurrent access of priority queues">
                                        <b>[28]</b>
                                         NAGESHWARA R, KUMAR V.Concurrent access of priority queues [J].IEEE Transactions on Computers, 1988, 37 (12) :1657-1665.
                                    </a>
                                </li>
                                <li id="220">


                                    <a id="bibliography_29" title=" He X, AGARWAL D, PRASAD S K.Design and implementation of a parallel priority queue on many-core architectures[C]// Proceedings of the 2012 International Conference on High Performance Computing.Piscataway, NJ:IEEE, 2012:1-10." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Design and implementation of a parallel priority queue on many-core architectures">
                                        <b>[29]</b>
                                         He X, AGARWAL D, PRASAD S K.Design and implementation of a parallel priority queue on many-core architectures[C]// Proceedings of the 2012 International Conference on High Performance Computing.Piscataway, NJ:IEEE, 2012:1-10.
                                    </a>
                                </li>
                                <li id="222">


                                    <a id="bibliography_30" title=" SATISH N, HARRIS M, GARLAND M.Designing efficient sorting algorithms for many-core GPUS[C]// Proceedings of the 2009 IEEE International Symposium on Parallel and Distributed Processing.Piscataway, NJ:IEEE, 2009:1-10." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Designing efficient sorting algorithms for manycore gpus">
                                        <b>[30]</b>
                                         SATISH N, HARRIS M, GARLAND M.Designing efficient sorting algorithms for many-core GPUS[C]// Proceedings of the 2009 IEEE International Symposium on Parallel and Distributed Processing.Piscataway, NJ:IEEE, 2009:1-10.
                                    </a>
                                </li>
                                <li id="224">


                                    <a id="bibliography_31" title=" CEDERMAN D, TSIGAS P.A practical quicksort algorithm for graphics processors[C]// Proceedings of the 2008 European Symposium on Algorithms.Berlin:Springer, 2008:246-258." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A practical quicksort algorithm for graphics processors">
                                        <b>[31]</b>
                                         CEDERMAN D, TSIGAS P.A practical quicksort algorithm for graphics processors[C]// Proceedings of the 2008 European Symposium on Algorithms.Berlin:Springer, 2008:246-258.
                                    </a>
                                </li>
                                <li id="226">


                                    <a id="bibliography_32" title=" GOVINDARAJU N, GRAY J, KUMAR R, et al.GPUTerasort:high performance graphics co-processor sorting for large database management[C]// Proceedings of the 2006 ACM SIGMOD International Conference on Management of Data.New York:ACM, 2006:325-336." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=GPUTeraSort:High performance graphics co-processor sorting for large databasemanagement">
                                        <b>[32]</b>
                                         GOVINDARAJU N, GRAY J, KUMAR R, et al.GPUTerasort:high performance graphics co-processor sorting for large database management[C]// Proceedings of the 2006 ACM SIGMOD International Conference on Management of Data.New York:ACM, 2006:325-336.
                                    </a>
                                </li>
                                <li id="228">


                                    <a id="bibliography_33" title=" GREB A, ZACHMANN G.GPU-ABiSort:optimal parallel sorting on stream architectures [C]// Proceedings of the 2006 International Parallel and Distributed Processing Symposium.Piscataway, NJ:IEEE, 2006:Article No.45." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=GPU-ABiSort:optimal parallel sortingon stream architectures">
                                        <b>[33]</b>
                                         GREB A, ZACHMANN G.GPU-ABiSort:optimal parallel sorting on stream architectures [C]// Proceedings of the 2006 International Parallel and Distributed Processing Symposium.Piscataway, NJ:IEEE, 2006:Article No.45.
                                    </a>
                                </li>
                                <li id="230">


                                    <a id="bibliography_34" title=" DAVIDSON A, TARJAN D, GARLAND M, et al.Efficient parallel merge sort for fixed and variable length keys[C]// Proceedings of the 2012 Innovative Parallel Computing.Piscataway, NJ:IEEE, 2012:1-9." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient parallel merge sort for fixed and variable length keys">
                                        <b>[34]</b>
                                         DAVIDSON A, TARJAN D, GARLAND M, et al.Efficient parallel merge sort for fixed and variable length keys[C]// Proceedings of the 2012 Innovative Parallel Computing.Piscataway, NJ:IEEE, 2012:1-9.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">

    <div class="head-tag">   
            <p>
               <b> 网络首发时间: 2019-03-29 17:08</b>
            </p>     
    </div>


        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJY" target="_blank">计算机应用</a>
                2019,39(07),2008-2013 DOI:10.11772/j.issn.1001-9081.2018122549            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于图形处理器的形态学重建系统</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E4%BD%95%E5%B8%8C&amp;code=42203550&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">何希</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%90%B4%E7%82%8E%E6%A1%83&amp;code=42203551&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">吴炎桃</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%82%B8%E8%87%BB%E7%82%9C&amp;code=31098435&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">邸臻炜</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%99%88%E4%BD%B3&amp;code=15566424&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">陈佳</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%A2%A7%E5%B7%9E%E5%AD%A6%E9%99%A2%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2&amp;code=0275804&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">梧州学院大数据与软件工程学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%B9%BF%E8%A5%BF%E9%AB%98%E6%A0%A1%E8%A1%8C%E4%B8%9A%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4(%E6%A2%A7%E5%B7%9E%E5%AD%A6%E9%99%A2)&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">广西高校行业软件技术重点实验室(梧州学院)</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>形态学重建是医学图像处理中非常基础和重要的操作。它根据掩膜图像的特征对标记图像反复进行膨胀操作, 直到标记图像中的像素值不再变化为止。对于传统基于中央处理器 (CPU) 的形态学重建系统计算效率不高的问题, 提出了使用图形处理器 (GPU) 来加速形态学重建。首先, 设计了适合GPU处理的数据结构:并行堆集群;然后, 基于并行堆集群, 设计和实现了一套基于GPU的形态学重建系统。实验结果表明, 相比传统基于CPU的形态学重建系统, 基于GPU的形态学重建系统可以获取超过20倍的加速比。基于GPU的形态学重建系统展示了如何把基于复杂数据结构的软件系统高效地移植到GPU上。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">图形处理器;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%BD%A2%E6%80%81%E5%AD%A6%E9%87%8D%E5%BB%BA&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">形态学重建;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">并行计算;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B9%B6%E8%A1%8C%E5%A0%86&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">并行堆;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">并行数据结构;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    何希 (1978—) , 男, 广西梧州人, 讲师, 博士, 主要研究方向:并行计算、分布式计算、数据可视化;;
                                </span>
                                <span>
                                    吴炎桃 (1978—) , 女, 广西苍梧人, 讲师, 主要研究方向:软件工程;;
                                </span>
                                <span>
                                    邸臻炜 (1980—) , 女, 广西梧州人, 讲师, 硕士, 主要研究方向:数据可视化、虚拟现实;;
                                </span>
                                <span>
                                    *陈佳 (1982—) , 女, 重庆人, 副教授, 主要研究方向:图像处理、机器学习。电子邮箱402809743@qq.com;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-12-26</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金资助项目 (61562074);</span>
                    </p>
            </div>
                    <h1><b>GPU-based morphological reconstruction system</b></h1>
                    <h2>
                    <span>HE Xi</span>
                    <span>WU Yantao</span>
                    <span>DI Zhenwei</span>
                    <span>CHEN Jia</span>
            </h2>
                    <h2>
                    <span>College of Data Science and Software Engineering, Wuzhou University</span>
                    <span>Guangxi Colleges and Universities Key Laboratory of Professional Software Technology (Wuzhou University)</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Morphological reconstruction is a fundamental and critical operation in medical image processing, in which dilation operations are repeatedly carried out on the marker image based on the characteristics of mask image, until no change occurs on the pixels of the marker image. Concerning the problem that traditional CPU-based morphological reconstruction system has low computational efficiency, using Graphics Processing Unit (GPU) to quicken the morphological reconstruction was proposed. Firstly, a GPU-friendly data structure: parallel heap cluster was proposed. Then, based on the parallel heap cluster, a GPU-based morphological reconstruction system was designed and implemented. The experimental results show that compared with traditional CPU-based morphological reconstruction system, the proposed GPU-based morphological reconstruction system can achieve speedup ratio over 20 times. The proposed system demonstrates how to efficiently port complex data structure-based software system onto GPU.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Graphics%20Processing%20Unit%20(GPU)%20&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Graphics Processing Unit (GPU) ;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=morphological%20reconstruction&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">morphological reconstruction;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=parallel%20computing&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">parallel computing;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=parallel%20heap&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">parallel heap;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=parallel%20data%20structure&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">parallel data structure;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    HE Xi, born in 1978, Ph. D. , lecturer. His research interests include parallel computing, distributed computing, data visualization. ;
                                </span>
                                <span>
                                    WU Yantao, born in 1978, lecturer. Her research interests include software engineering. ;
                                </span>
                                <span>
                                    DI Zhenwei, born in 1980, M. S. , lecturer. Her research interests include data visualization, virtual reality. ;
                                </span>
                                <span>
                                    CHEN Jia, born in 1982, associated professor. Her research interests include image processing, machine learning.;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2018-12-26</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>partially supported by the National Natural Science Foundation of China (61562074);</span>
                    </p>
            </div>


        <!--brief start-->
                        <h3 id="71" name="71" class="anchor-tag">0 引言</h3>
                <div class="p1">
                    <p id="72">形态学重建 (morphological reconstruction) 是医学图像处理中非常基础和重要的操作。它根据掩膜图像的特征对标记图像反复进行膨胀操作, 直到标记图像中的像素值不再变化为止。其中的标记图像 (Marker Image) 和掩膜图像 (Mask Image) 是两张尺寸相同的高像素医学图像。在标记图像的膨胀操作中, 符合扩散条件的像素点会不断地向邻接的像素点传播其像素值。假设<i>I</i> (<i>e</i>) 、<i>I</i> (<i>f</i>) 是标记图像中相邻的两个像素点, <i>J</i> (<i>e</i>) 是掩膜图像中与<i>I</i> (<i>e</i>) 位置相对应的像素点, 那么<i>I</i> (<i>f</i>) 对<i>I</i> (<i>e</i>) 发生扩散的条件如下:</p>
                </div>
                <div class="p1">
                    <p id="73"><i>I</i> (<i>e</i>) &lt;<i>I</i> (<i>f</i>) &amp;&amp; <i>I</i> (<i>e</i>) &lt;<i>J</i> (<i>e</i>)      (1) </p>
                </div>
                <div class="p1">
                    <p id="74">而扩散后<i>I</i> (<i>e</i>) 的像素值如下:</p>
                </div>
                <div class="p1">
                    <p id="75"><i>I</i> (<i>e</i>) =min (<i>I</i> (<i>f</i>) , <i>J</i> (<i>e</i>) )      (2) </p>
                </div>
                <div class="p1">
                    <p id="76">如图1 (a) 所示, 标记图像中像素点O的像素值 (32) 比其邻接像素点C的像素值 (17) 大, 而且C在掩膜图像中位置相对应的像素点C1的像素值 (45) 也比C的数值大, 于是O的像素值在膨胀操作中扩散到了它的邻接像素点C (如图1 (c) ) 。接着, C的像素值又会通过其邻接像素点进一步地扩散。这种像素值的扩散会不断迭代地进行下去, 直到标记图像中的像素值不再变化为止。形象地理解形态学重建, 标记图像中较大的像素值会像“水”一样四处扩散。如果没有掩膜图像, 那么当形态学重建结束时标记图像里所有的像素值都会变成标记图像中某个最大的像素值, 而掩膜图像就像“高山”一样阻挡了标记图像中像素值任意的传播, 使得像素值扩散只在若干个隔绝的区域中发生。由于标记图像, 掩膜图像的超高分辨率 (有些图像分辨率可以达到51 200×51 200, 102 400×102 400) , 并且随着传感器技术和扫描设备的提高, 图像的分辨率会越来越高, 形态学重建是一个计算量很大的问题。考虑到形态学重建里像素值扩散的迭代特性, 传统的算法使用了队列来跟踪像素点的扩散过程, 然而队列是按照像素值的扩散顺序而不是像素值的大小来决定下一次迭代中像素值扩散的先后顺序, 使用队列会导致频繁出现对于同一个像素点的多次像素值扩散。形态学重建的计算量会因此大幅度提高。这个问题促使了在形态学重建中使用以像素值大小为优先级的优先队列, 由优先队列先选出具有较大像素值的像素点让其像素值先扩散以避免较小像素值的扩散, 从而可以大幅度减少形态学重建的计算量。</p>
                </div>
                <div class="area_img" id="77">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201907024_077.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 形态学重建示例图" src="Detail/GetImg?filename=images/JSJY201907024_077.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 形态学重建示例图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201907024_077.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 Example of morphological reconstruction</p>

                </div>
                <div class="p1">
                    <p id="78">现代的NVIDIA图形处理器 (Graphics Processing Unit, GPU) 是一个可编程的基于众核架构的处理器。每一个图形处理器包含若干个流处理器 (Streaming Multiprocessors) 。每个流处理器上有32个或者更多的计算单元以及存取速度很快但数量有限的寄存器和共享内存 (Shared Memory) 。同时, 每个图形处理器上还配有所有流处理器都可以访问的全局内存 (Global Memory) 。运行在图形处理器上的CUDA (Compute Unified Device Architecture) 程序可以启动成百上千线程同时执行任务。这些线程是以线程组的形式组织起来的, 每个线程组会由图形处理器的硬件调度系统分配到最空闲的流处理器上执行。图形处理器强大的计算能力使得很多传统问题的计算时间缩短至原来的十几分之一甚至几十分之一。形态学重建问题涉及的是高像素图像以及由此产生的很多的细粒度任务, 它非常适合使用图形处理器来加速其计算过程, 而如何设计基于图形处理器并且适合形态学重建的并行优先队列决定了能否高效地把形态学重建以及别的类似应用移植到图形处理器上进行加速处理。</p>
                </div>
                <h3 id="79" name="79" class="anchor-tag">1 相关工作</h3>
                <h4 class="anchor-tag" id="80" name="80">1.1 <b>形态学重建</b></h4>
                <div class="p1">
                    <p id="81">文献<citation id="232" type="reference">[<a class="sup">1</a>]</citation>详细描述了传统上形态学重建的几种算法, 本文简单地介绍三种。</p>
                </div>
                <div class="p1">
                    <p id="82">第一种算法称为顺序重建法 (Sequential Reconstruction) , 这种算法依赖不断地正向扫描和反向扫描标记图像, 直到在一轮扫描以后再也找不到符合扩散条件的像素点为止。正向扫描指的是从图像中最左上的像素点开始, 到最右下的像素点为止, 以从上到下、从左到右的顺序扫描图像中的每一个像素点, 而反向扫描恰恰和正向扫描相反, 它是从图像中最右下的像素点开始, 到最左上的像素点为止, 以从下到上、从右到左的顺序扫描图像中的每一个像素点。在扫描过程中, 一旦发现某个像素点符合扩散的条件, 就会立即执行像素值扩散操作, 将其像素值赋给邻接像素点。</p>
                </div>
                <div class="p1">
                    <p id="83">第二种算法称为快速混合重建法 (Fast Hybrid Reconstruction) 。这种算法首先会运行一次正向扫描和一次反向扫描, 对标记图像执行初步的膨胀操作, 并把有扩散可能的像素点收集起来放进一个先进先出队列中, 然后, 对于队列里的像素点, 快速混合重建法会逐个取出来, 尝试把像素点上的像素值向其邻接像素点扩散, 并且把被扩散的邻接像素点添加到队列里。上述操作会持续进行下去, 直到队列为空为止。对比顺序重建法, 快速混合重建法更加有效率, 因为它只需要处理有扩散可能的像素点, 而不需要像顺序重建法一样反复进行全局的扫描, 但是快速混合重建法也有可以提高的地方, 例如其中很多像素值的扩散操作是对同一个像素点执行的, 因而是重复的计算。</p>
                </div>
                <div class="p1">
                    <p id="84">第三种算法称为下坡过滤器 (Downhill Filter) <citation id="233" type="reference"><link href="166" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>, 与第二种算法不一样的是, 它使用了一个队列, 把有扩散可能的像素点按像素值大小进行排序, 先处理像素值较大的像素点, 避免了像素值较小的像素点的扩散, 从而减少了整个形态学重建的计算量。</p>
                </div>
                <h4 class="anchor-tag" id="85" name="85">1.2 <b>基于图形处理器的并行数据结构</b></h4>
                <div class="p1">
                    <p id="86">基于中央处理器的数据结构已经被研究了很多年, 但是基于图形处理器的并行数据结构研究还是非常有限。考虑到本文涉及了图形处理器上并行数据结构, 首先对这个领域作一个简述。</p>
                </div>
                <div class="p1">
                    <p id="87">当图形处理器开始应用于解决一般问题时, 研究人员尝试把各种传统数据结构转变成适合众核架构的并行数据结构。文献<citation id="234" type="reference">[<a class="sup">3</a>]</citation>按照广度优先的顺序构造KD-树, 并且对大节点采用了新颖的构造算法以充分利用图形处理器的计算能力。文献<citation id="235" type="reference">[<a class="sup">4</a>]</citation>针对前者在构造KD-树过程中消耗了过多图形处理器内存的问题提出了按照部分广度优先的顺序构造KD-树, 牺牲一部分并发性以换取内存的大量节省。文献<citation id="236" type="reference">[<a class="sup">5</a>]</citation>中提出了一种在图形处理器上表面积启发式构建KD树的并行方法。其他基于树的数据结构, 例如八叉树 (Octree) <citation id="246" type="reference"><link href="174" rel="bibliography" /><link href="176" rel="bibliography" /><link href="178" rel="bibliography" /><link href="180" rel="bibliography" /><link href="182" rel="bibliography" /><link href="184" rel="bibliography" /><link href="186" rel="bibliography" /><sup>[<a class="sup">6</a>,<a class="sup">7</a>,<a class="sup">8</a>,<a class="sup">9</a>,<a class="sup">10</a>,<a class="sup">11</a>,<a class="sup">12</a>]</sup></citation>、决策树<citation id="247" type="reference"><link href="188" rel="bibliography" /><link href="190" rel="bibliography" /><sup>[<a class="sup">13</a>,<a class="sup">14</a>]</sup></citation>、层次包围盒 (Bounding Volume Hierarchy) <citation id="237" type="reference"><link href="192" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>也已经在文献中被讨论了如何移植到图形处理器上。文献<citation id="238" type="reference">[<a class="sup">16</a>]</citation>通过把包含指针的操作转化为数组操作, 设计出了一种高效率、适合图形处理器的跳表结构 (Skiplist) 。在文献<citation id="239" type="reference">[<a class="sup">17</a>]</citation>里, 研究者们在完美哈希表 (Perfect Hash) <citation id="240" type="reference"><link href="198" rel="bibliography" /><sup>[<a class="sup">18</a>]</sup></citation>和布谷鸟哈希表 (Cuckoo Hash) <citation id="241" type="reference"><link href="200" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>的基础上设计出了一个适合图形处理器的并行哈希表。文献<citation id="242" type="reference">[<a class="sup">20</a>]</citation>中提出了在图形处理器中实现布隆过滤器 (Bloom Filter) 的方案。对于集合, 文献<citation id="243" type="reference">[<a class="sup">21</a>]</citation>中提出了图形处理器中新颖的集合数据组织方式以及实现集合相交的算法。在图方面, 文献<citation id="244" type="reference">[<a class="sup">22</a>]</citation>使用了多层队列的方式在图形处理器中加速了广度优先图的遍历。文献<citation id="245" type="reference">[<a class="sup">23</a>]</citation>解决了如何并行计算最小生成树的问题。</p>
                </div>
                <h4 class="anchor-tag" id="88" name="88">1.3 <b>并行优先队列</b></h4>
                <div class="p1">
                    <p id="89">单线程优先队列有不同的实现方式, 包括二元堆 (Binary Heap) <citation id="248" type="reference"><link href="210" rel="bibliography" /><sup>[<a class="sup">24</a>]</sup></citation>、二项堆 (Binomial Heap) <citation id="249" type="reference"><link href="212" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>、斐波那契堆 (Fibonacci Heap) <citation id="250" type="reference"><link href="214" rel="bibliography" /><sup>[<a class="sup">26</a>]</sup></citation>等。一般来说有三种方式来并行化优先队列。</p>
                </div>
                <div class="p1">
                    <p id="90">第一种方式是使用多个计算单元来并行化单个元素的入队列或者出队列操作<citation id="251" type="reference"><link href="216" rel="bibliography" /><sup>[<a class="sup">27</a>]</sup></citation>, 缩短了单个操作的时间。</p>
                </div>
                <div class="p1">
                    <p id="91">第二种方式是允许优先队列里同时有多个单线程入队列和出队列操作<citation id="252" type="reference"><link href="218" rel="bibliography" /><sup>[<a class="sup">28</a>]</sup></citation>, 减少了单个操作的平均时间。</p>
                </div>
                <div class="p1">
                    <p id="92">第三种方式则是既允许入队列操作和出队列操作同时进行, 又使用多个计算单元来并行化入队列和出队列操作<citation id="253" type="reference"><link href="220" rel="bibliography" /><sup>[<a class="sup">29</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="93">本文的主要工作有两点:</p>
                </div>
                <div class="p1">
                    <p id="94">1) 在图形处理器上设计和实现了并行堆集群。并行堆是并行优先队列在图形处理器上的实现, 而并行堆集群则是并行堆的集合, 出于性能考虑而设计, 可以理解为并线优先队列在图形处理器上的近似实现。</p>
                </div>
                <div class="p1">
                    <p id="95">2) 基于并行堆集群, 在图形处理器上设计和实现了形态学重建系统。</p>
                </div>
                <h3 id="96" name="96" class="anchor-tag">2 基于图形处理器的形态学重建系统</h3>
                <h4 class="anchor-tag" id="97" name="97">2.1 <b>系统概述</b></h4>
                <div class="p1">
                    <p id="98">为了充分利用图形处理器的并行计算能力以缩短形态学重建的计算时间, 本文设计开发了一套基于图形处理器的形态学重建系统, 取名为MR_GPU (Morphological Reconstruction_GPU) 。MR_GPU设计的一个重要原则是把计算量大、适合使用并行计算的操作放在图形处理器端处理, 而中央处理器端则负责系统的初始化、输入输出以及与图形处理器的协调工作。图2展示的是MR_GPU的流程。<i>r</i>是并行堆节点可容纳的最大像素点个数。系统的输入是一张标记图像和一张掩膜图像, 输出是一张膨胀后的标记图像。系统内的处理主要分为三个阶段:准备阶段、建堆阶段和迭代膨胀阶段。在准备阶段, 系统会完成初始化和数据准备的工作。初始化工作主要包括配置系统参数, 初始化系统中引用的各种外部类库和在中央处理器和图形处理器两端计算并分配存储空间。数据准备工作则包括:1) 从标记图像和掩膜图像文件里把图像信息数据读取出来, 并存放在二维数组里;2) 对图像信息进行必要的类型转换和数据清洗;3) 把图像信息传输到图像处理器端的全局内存;4) 扫描图像信息, 找出符合扩散条件的种子像素点, 并且把这些种子像素点均匀地分组。在建堆阶段, 上一阶段留下的每一个像素点组, 会被按照像素值进行排序以构造一个最大并行堆。在迭代膨胀阶段, 每一个最大并行堆都会独立地、迭代地执行膨胀操作, 其步骤如算法1所示。细节会在介绍并行堆时一起讨论。</p>
                </div>
                <div class="area_img" id="99">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201907024_099.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 MR_GPU流程" src="Detail/GetImg?filename=images/JSJY201907024_099.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 MR_GPU流程  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201907024_099.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 Flow chart of MR_GPU</p>

                </div>
                <div class="p1">
                    <p id="100">算法1 并行膨胀操作。</p>
                </div>
                <div class="area_img" id="258">
                                <img alt="" src="Detail/GetImg?filename=images/JSJY201907024_25800.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="258">
                                <img alt="" src="Detail/GetImg?filename=images/JSJY201907024_25801.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="113" name="113">2.2 <b>并行堆</b></h4>
                <div class="p1">
                    <p id="114">并行堆是专门为图形处理器设计的优先队列, 可以看成是二元堆的升级版本。与二元堆类似, 并行堆实际上是一棵完全二叉树, 并且同样维护堆的属性, 即每个节点里元素的值都比孩子节点元素的值要大 (最大堆) 或者小 (最小堆) 。在本文中, 所讨论的并行堆都为最大堆。与二元堆不同的是, 并行堆里的节点可以包含多个元素。实际上, 在本文的形态学重建系统里, 并行堆节点的元素数是几十甚至上百, 这样可以方便分配多个线程同时对并行堆进行操作, 也符合图形处理器中通过多线程调度来解决内存存取延迟问题的硬件特性。</p>
                </div>
                <div class="p1">
                    <p id="115">与二元堆类似, 并行堆也有入堆和出堆操作。出堆操作从缓冲区内取回<i>r</i>个元素并放到根节点上, 然后执行出堆调整操作, 使并行堆保持堆的属性。具体的调整方案是把根节点上的<i>r</i>个元素和它的两个孩子节点<i>n</i>1、<i>n</i>2内的2<i>r</i>元素合并。假设<i>n</i>1里的最小元素比<i>n</i>2里的最小元素要小, 那么合并后最大的<i>r</i>个元素存放在根节点, 最小的<i>r</i>个元素放在<i>n</i>2节点, 其余的<i>r</i>个元素放在<i>n</i>1节点。可以证明只有<i>n</i>2节点及它的子节点需要继续调整<citation id="254" type="reference"><link href="218" rel="bibliography" /><sup>[<a class="sup">28</a>]</sup></citation>。出堆调整操作会继续迭代地调整<i>n</i>2节点及其子节点, 直到到达了叶子节点。</p>
                </div>
                <div class="p1">
                    <p id="116">入堆操作是要把新的<i>r</i>元素添加到并行堆现有元素之后, 并且调整并行堆使其保持堆的属性。具体的调整方案如下:计算一条从根节点到待插入节点之间由上往下的入堆路线。从根节点开始, 新的<i>r</i>个元素与根节点的<i>r</i>个元素合并。较大的<i>r</i>个元素留在根节点, 较小的<i>r</i>个元素继续流向入堆路线上的下一个节点里, 然后在下一个节点上继续合并, 保留较大的<i>r</i>个元素, 让较小的<i>r</i>个元素继续流向再下一个节点。上述步骤持续进行, 直到较小的元素到达待插入节点。</p>
                </div>
                <div class="p1">
                    <p id="117">传统的二元堆入堆调整由下往上进行, 而出堆调整是由上往下进行的。由于在多线程环境下会存在多个出堆调整和入堆调整线程, 这种出堆、入堆调整方向不一致的情况会导致死锁问题的出现。实际上, 并行堆根据图形处理器同步的特点, 采用了流水线 (Pipeline) 的并行策略, 堆中每一个层次同时都有一组入堆调整线程和一组出堆调整线程在运行, 因此, 在并行堆中, 把出堆、入堆调整的方向都设计为由上到下以避免死锁的出现。</p>
                </div>
                <div class="p1">
                    <p id="118">在形态学重建系统里需要一个缓冲区, 缓冲区内存放的是最近产生的待扩散的像素点。每次迭代中, 并行堆根节点的像素点会被取出来, 与缓冲区内的像素点合并成有序序列, 然后最大的<i>r</i>个像素点会被取出进行扩散处理, 次大的<i>r</i>个像素点会被放在并行堆的根节点, 然后进行由上到下的出堆调整操作。另外的<i>r</i>像素点则会沿着计算好的路径由上而下, 最终把经过调整后较小的像素点添加到并行堆的待插入节点中。</p>
                </div>
                <div class="p1">
                    <p id="119">图3 (a) 显示的是一个简化版本的并行堆例子。它共有11个节点, 每个节点都有一个编号, 最多可以包含2个像素点, 缓冲区内有上次迭代收集的4个像素点 (62, 45, 38, 35) 。在当前迭代中, 出堆操作会从并行堆取出根节点内的像素点 (57, 59) 放到缓冲区内, 然后对缓冲区内的像素点的值进行排序, 然后, 如图3 (b) 所示, 对于像素值最大的2个像素点 (62, 59) , 系统会对它们进行扩散处理, 并把扩散所涉及的邻接像素点收集到缓冲区为下一轮迭代做准备。对于缓冲区像素值排第3第4的像素点 (57, 45) , 系统会把它们放回到并行堆的根节点, 然后从根节点开始对并行堆进行出堆调整。至于剩下的像素点 (38, 35) , 则会执行入堆操作。调整后具有较小像素值的两个像素点 (35, 38) 将会被放到节点12上去。因为待插入节点已知, 系统由此可以计算入堆路线, 并由上往下进行入调整。图3 (c) 显示是入堆、出堆调整后的并行堆。</p>
                </div>
                <div class="area_img" id="120">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201907024_120.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 并行堆入堆、出堆示例图" src="Detail/GetImg?filename=images/JSJY201907024_120.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 并行堆入堆、出堆示例图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201907024_120.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 Schematic diagrams of insertion and extraction operation of parallel heap</p>

                </div>
                <h4 class="anchor-tag" id="121" name="121">2.3 <b>并行策略</b></h4>
                <div class="p1">
                    <p id="122">行之有效的并行策略是MR_GPU中重要的一环。在准备阶段, 分配了数量众多的线程来并行扫描标记图像和掩膜图像。由于图形处理器独特的硬件线程调度实现, 数量众多的线程不但不会因为线程调度而影响性能, 反而可以隐藏读写内存带来的延迟从而提高整体的性能。在建堆阶段和迭代膨胀阶段, 适用的并行策略可以分为三个层次。</p>
                </div>
                <div class="p1">
                    <p id="123">并行策略的第一层次是在图形处理器集群上。图形处理器集群上部署了多个图形处理器, 可以切割大图像文件并分配到每个图形处理器上, 由这些图形处理器独立地、并行地进行形态学重建。同时, 图形处理器间有同步策略, 可以在不同图像文件分割块间进行同步。</p>
                </div>
                <div class="p1">
                    <p id="124">并行策略第二层次是在每个图形处理器上运行的并行堆集群上, 可以配置多个并行堆同时执行形态学重建中的膨胀操作。在最开始的设计中只维护了一个并行堆。一个并行堆可以保证具有较大像素值的像素点首先可以得到扩散的机会, 从而避免很多较小像素值不必要的扩散, 但是问题在于如果一个图形处理器中只维护一个并行堆的话, 图形处理器的计算能力远远得不到充分的利用, 整个形态学重建的效率并没有得到最大化。现在MR_GPU中设计的并行堆集群中各个并行堆是相互独立的, 保证了效率不会因为并行堆之间的相互依赖关系而下降。每个并行堆内部也是保证具有较大像素值的像素点首先可以得到扩散的机会从而减少了不必要的计算, 而并行堆之间由于是相互独立, 没有同步的机制, 会导致一些重复的像素值扩散操作。然而, 相对于采用并行堆集群而获取的图形处理器计算能力的充分利用, 这些重复计算的代价是可以承受的。</p>
                </div>
                <div class="p1">
                    <p id="125">并行策略的第三层次是在并行堆内部。在建堆阶段, 需要对初始化阶段找出的首先扩散的像素点进行并行排序从而构造并行堆。在图形处理器上并行排序是一个已经有很多研究者在研究的课题<citation id="255" type="reference"><link href="222" rel="bibliography" /><link href="224" rel="bibliography" /><link href="226" rel="bibliography" /><link href="228" rel="bibliography" /><sup>[<a class="sup">30</a>,<a class="sup">31</a>,<a class="sup">32</a>,<a class="sup">33</a>]</sup></citation>。可以直接采用已经优化的并行排序方案。在迭代膨胀阶段, 采用了流水线 (pipeline) 的并行机制, 出堆和入堆调整线程从根节点开始, 一层一层往下对并行堆进行调整。当一组出堆调整和一组入堆调整线程完成了对根节点的调整, 开始对并行堆的第二层进行调整时, 系统会启动另外一组出堆调整和一组入堆调整线程执行下一轮出堆入堆操作。一般来说, 对于一个有<i>n</i>层的并行堆, 会有<i>n</i>组出堆调整线程和<i>n</i>组入堆调整线程。每一个出堆或入堆调整线程组内会有<i>r</i>个线程, <i>r</i>是并行堆节点里最大的元素数, 而为节点里每一个元素分配一个线程无论从实现角度还是效率角度来看都是不错的选择。出堆和入堆调整线程还涉及了并行合并操作和并行收集像素点操作, 对于前者, 别的研究已经提供了解决方案<citation id="256" type="reference"><link href="222" rel="bibliography" /><link href="230" rel="bibliography" /><sup>[<a class="sup">30</a>,<a class="sup">34</a>]</sup></citation>。对于并行收集像素点到缓冲区问题, 本文的策略是为每个产生待扩散的像素点的线程分配临时空间存放待扩散像素点, 然后统计像素点的个数。线程同步以后使用并行扫描的方式统计像素点总的个数以确定每个线程产生的像素点在缓冲区内的位置, 然后让每个线程分别把各自的像素点从临时空间拷贝到缓冲区内。</p>
                </div>
                <h3 id="126" name="126" class="anchor-tag">3 开发环境及实验结果</h3>
                <div class="p1">
                    <p id="127">形态学重建系统的开发环境是cmake 3.11.4, CUDA 9.0, g++ 11和OpenCV 4。系统运行在CentOS 7上, 图形处理器是NVIDIA Tesla K20。这个图形处理器基于Fermi架构, 含有512个计算单元以及2 GB的全局内存。</p>
                </div>
                <div class="p1">
                    <p id="128">实验的目的在于测量和评估MR_GPU的性能, 为此本文在快速混合重建法<citation id="257" type="reference"><link href="164" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>的基础上实现了基于中央处理器的形态学重建系统, 取名MR_CPU, 并以此系统作为比较基准。实验主要采用加速比来评估形态学重建系统的性能。</p>
                </div>
                <div class="p1">
                    <p id="129">加速比=MR_CPU执行时间/MR_GPU执行时间      (3) </p>
                </div>
                <div class="p1">
                    <p id="130">通过调整形态学重建系统中并行堆集群里并行堆的个数以及并行堆节点的尺寸 (即并行堆节点中包含的元素数) , 可以进一步理解这些并行堆里的参数对于整个形态学重建系统性能的影响。表1列举了实验中标记图像和掩膜图像的基本信息。</p>
                </div>
                <div class="p1">
                    <p id="131">表2列举了不同并行堆个数下, MR_CPU的执行时间和MR_GPU的执行时间, 以及它们之间的加速比。可以看到在并行堆节点尺寸一定的情况下 (实验中为128) , 随着并行堆集群中并行堆个数的增加, 加速比也在增加。这个结果符合之前的分析:当并行堆集群中有更多独立的并行堆参与处理膨胀操作时, 图形处理器的计算能力得到更加充分的利用, 系统的性能也可以得到进一步的提高。</p>
                </div>
                <div class="area_img" id="132">
                    <p class="img_tit"><b>表</b>1 <b>标记图像和掩膜图像的基本信息</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit">Tab. 1 Basic information of marker and mask images in experiment</p>
                    <p class="img_note"></p>
                    <table id="132" border="1"><tr><td><br />图像类型</td><td>格式</td><td>分辨率</td><td>大小/MB</td></tr><tr><td><br />标记图像</td><td>jpg</td><td>4 096×4 096</td><td>3.5</td></tr><tr><td><br />掩膜图像</td><td>jpg</td><td>4 096×4 096</td><td>7.8</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="133">
                    <p class="img_tit"><b>表</b>2 <b>不同并行堆个数下集群的实验数据</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit">Tab. 2 Experimental result with different number of parallel heaps in cluster</p>
                    <p class="img_note"></p>
                    <table id="133" border="1"><tr><td rowspan="2"><br />并行堆<br />个数</td><td rowspan="2">节点<br />尺寸</td><td colspan="2"><br />执行时间/μs</td><td rowspan="2">加速比</td></tr><tr><td><br />MR_CPU</td><td>MR_GPU</td></tr><tr><td>2</td><td>128</td><td>6 902 924</td><td>4 638 605</td><td>1.488</td></tr><tr><td><br />4</td><td>128</td><td>6 902 924</td><td>2 529 835</td><td>2.728</td></tr><tr><td><br />8</td><td>128</td><td>6 902 924</td><td>1 431 794</td><td>4.821</td></tr><tr><td><br />16</td><td>128</td><td>6 902 924</td><td>961 152</td><td>7.181</td></tr><tr><td><br />32</td><td>128</td><td>6 902 924</td><td>574 997</td><td>12.005</td></tr><tr><td><br />64</td><td>128</td><td>6 902 924</td><td>444 492</td><td>15.529</td></tr><tr><td><br />128</td><td>128</td><td>6 902 924</td><td>380 938</td><td>18.120</td></tr><tr><td><br />256</td><td>128</td><td>6 902 924</td><td>353 674</td><td>19.517</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="134">表3列举了不同并行堆节点尺寸下, MR_CPU的执行时间和MR_GPU的执行时间, 以及它们之间的加速比。对于一个并行堆而言, 它的并行性能取决于两个方面:一方面是并行堆节点的尺寸;另一方面是并行堆的高度, 它决定了并行堆出堆、入堆线程组的数目。当并行堆节点尺寸增加时, 它的高度会减少。当并行堆节点尺寸减少时, 它的高度会增加, 而且它们增减的关系并不是按比例的。在并行堆个数一定的情况下 (实验中为256) , 当开始增加并行堆节点尺寸时, 系统的性能得到了迅速提高, 因为并行堆节点尺寸增加而增加的并行性超过了因为并行堆高度减少而减少的并行性。当并行堆节点尺寸达到128时, 并行堆节点尺寸的增加而提高的并行性和并行堆高度减少而减少的并行性已经达到了一个平衡, 这个时候再继续增加并行堆节点的尺寸, 并不会使系统性能有明显的提高。</p>
                </div>
                <div class="area_img" id="135">
                    <p class="img_tit"><b>表</b>3 <b>不同并行堆节点尺寸下的实验数据</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit">Tab. 3 Experiment result with different parallel heap size</p>
                    <p class="img_note"></p>
                    <table id="135" border="1"><tr><td rowspan="2"><br />并行堆<br />个数</td><td rowspan="2">节点<br />尺寸</td><td colspan="2"><br />执行时间/μs</td><td rowspan="2">加速比</td></tr><tr><td><br />MR_CPU</td><td>MR_GPU</td></tr><tr><td>256</td><td>8</td><td>6 902 924</td><td>1 877 182</td><td>3.677</td></tr><tr><td><br />256</td><td>16</td><td>6 902 924</td><td>913 903</td><td>7.553</td></tr><tr><td><br />256</td><td>32</td><td>6 902 924</td><td>724 444</td><td>9.528</td></tr><tr><td><br />256</td><td>64</td><td>6 902 924</td><td>485 127</td><td>14.229</td></tr><tr><td><br />256</td><td>128</td><td>6 902 924</td><td>365 072</td><td>18.908</td></tr><tr><td><br />256</td><td>256</td><td>6 902 924</td><td>347 028</td><td>19.891</td></tr><tr><td><br />256</td><td>512</td><td>6 902 924</td><td>361 831</td><td>19.077</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h3 id="136" name="136" class="anchor-tag">4 结语</h3>
                <div class="p1">
                    <p id="137">本文讨论了基于图形处理器的形态学重建系统MR_GPU的设计与实现, 其中重点讨论了基于图形处理器并行堆集群以及其出堆、入堆操作的设计。相对于传统上基于中央处理器的形态学重建系统MR_CPU, MR_GPU获得了超过20倍的加速比。通过进一步拓展MR_GPU, 使其支持大图像的有效分割和快速同步、使其可以高效地运行在包含多个图形处理器的集群上, 形态学重建的性能可以得到进一步的提高。今后可以对现有的出堆、入堆操作进行进一步的优化设计以提高这些操作的效率。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="164">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Morphological grayscale reconstruction in image analysis: applications and efficient algorithms">

                                <b>[1]</b> VINCENT L.Morphological grayscale reconstruction in image analysis:applications and efficient algorithms [J].IEEE Transactions on Image Processing, 1993, 2 (2) :176-201.
                            </a>
                        </p>
                        <p id="166">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300415347&amp;v=MzAzNTVUNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyM0lKMXNWYmhZPU5pZk9mYks3SHRET3JJOUZZT29LRDNnK29CTQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> ROBINSON K, WHELAN P F.Efficient morphological reconstruction:a downhill filter [J].Pattern Recognition Letters, 2004, 25 (15) :1759-1767.
                            </a>
                        </p>
                        <p id="168">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000098690&amp;v=MDAwNzFJWTdLN0h0ak5yNDlGWk9JSENuVTVvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyM0lKMXNWYmhZPU5pZg==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> ZHOU K, HOU Q, WANG R, et al.Real-time KD-tree construction on graphics hardware [J].ACM Transactions on Graphics, 2008, 27 (5) :Article No.126.
                            </a>
                        </p>
                        <p id="170">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Memory-Scalable GPU Spatial Hierarchy Construction">

                                <b>[4]</b> HOU Q, XIN S, ZHOU K, et al.Memory-scalable GPU spatial hierarchy construction [J].IEEE Transactions on Visualization and Computer Graphics, 2011, 17 (4) :466-474.
                            </a>
                        </p>
                        <p id="172">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SCPD&amp;filename=CN102426710A&amp;v=MDE3MDEzMUx4eFlUNnpvT1MzZm1wV0ZhZTdLV1JicWVaK1Z1RUMza1Y3cz1KaU82SHJHOEhOZkxybzgwQys0UEQ=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> 吴哲锋, 赵福凯, 刘新国.图形处理器上的表面积启发式构建KD树并行方法:中国, CN201110241419.2[P].2011-08-22. (WU Z F, ZHAO F K, LIU X G.An surface-based heuristic algorithm for constructing KD-tree on GPUs:China, CN201110241419.2[P].2011- 08- 22.) 
                            </a>
                        </p>
                        <p id="174">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000097976&amp;v=MjQ5NzA5RlpPSUlCWHMvb0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSjFzVmJoWT1OaWZJWTdLN0h0ak5yNA==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> BENSON D, DAVIS J.Octree textures [J].ACM Transactions on Graphics, 2002, 21 (3) :785-790.
                            </a>
                        </p>
                        <p id="176">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Real-Time Quadtree Analysis Using HistoPyramids">

                                <b>[7]</b> ZIEGLER G, DIMITROV R, THEOBALT C, et al.Real-time quadtree analysis using HistoPyramids [C]// Proceedings of the SPIE 2007 Real-time Image Processing.Bellingham, WA:SPIE, 2007:64960L.
                            </a>
                        </p>
                        <p id="178">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fast,parallel,GPU-based space filling curves and octrees">

                                <b>[8]</b> AJMERA P, GORADIA R, CHANDRAN S, et al.Fast, parallel, GPU-based space filling curves and octrees [C]// Proceedings of the 2008 Symposium on Interactive 3D Graphics and Games.New York:ACM, 2008:10.
                            </a>
                        </p>
                        <p id="180">
                            <a id="bibliography_9" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJWD&amp;filename=SJWD00000018026&amp;v=MTU3NjFPa0pZM2s1ekJkaDRqOTlTWHFScnhveGNNSDdSN3FkWitadUZpcmxWTHJKSkZvPU5pZmNhck80SHRITXI0NU5a&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[9]</b> CASTRO R, LEWINER T, LOPES H, et al.Statistical optimization of octree searches [J].Computer Graphics Forum, 2010, 27 (6) :1557-1566.
                            </a>
                        </p>
                        <p id="182">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000098603&amp;v=MzI1ODRyNDlGWk9JSENudzZvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyM0lKMXNWYmhZPU5pZklZN0s3SHRqTg==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b> SUN X, ZHOU K, STOLLNITZ E, et al.Interactive relighting of dynamic refractive objects [J].ACM Transactions on Graphics, 2008, 27 (3) :Article No.35.
                            </a>
                        </p>
                        <p id="184">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Octree textures on the GPU">

                                <b>[11]</b> LEFEBVRE S, HORNUS S, NEYRET F.Octree textures on the GPU[J].GPU Gems, 2005, 2:595-613.
                            </a>
                        </p>
                        <p id="186">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Data-parallel octrees for surface reconstruction">

                                <b>[12]</b> ZHOU K, GONG M, HUANG X, et al.Data-parallel octrees for surface reconstruction [J].IEEE Transactions on Visualization and Computer Graphics, 2011, 17 (5) :669-681.
                            </a>
                        </p>
                        <p id="188">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=CudaRF:a CUDA implementation of random forests">

                                <b>[13]</b> GRAHN H, LAVESSON N, LAPAJNE M H, et al.CudaRF:a CUDA implementation of random forests[C]// Proceedings of the 2011 IEEE/ACS International Conference on Computer Systems and Applications.Piscataway, NJ:IEEE, 2011:95-101.
                            </a>
                        </p>
                        <p id="190">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Implementing decision trees and forests on a GPU">

                                <b>[14]</b> SHARP T.Implementing decision trees and forests on a GPU[C]// Proceedings of the 10th European Conference on Computer Vision.Berlin:Springer, 2008:595-608.
                            </a>
                        </p>
                        <p id="192">
                            <a id="bibliography_15" >
                                    <b>[15]</b>
                                 LAUTERBACH C, GARLAND M, SENGUPTA S, et al.Fast BVH construction on GPUs[J].Computer Graphics Forum, 2009, 28 (2) :375-384.
                            </a>
                        </p>
                        <p id="194">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201412001&amp;v=MDk0NTJPM3pxcUJ0R0ZyQ1VSN3FmWnVac0Z5L2dVcnZNTWpYU1pMRzRIOVhOclk5RlpZUUtESDg0dlI0VDZqNTQ=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b> 李怀明, 邓仰东.基于图形处理器的高性能跳表 (Skiplist) 数据结构[J].微电子学与计算机, 2014, 31 (12) :1-5. (LI H M, DENG Y D.High performance Skiplist for GPU computing [J].Microelectronics and Computer, 2014, 31 (12) :1-5.) 
                            </a>
                        </p>
                        <p id="196">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000098888&amp;v=Mjg0Mzg5RlpPSUhCSFF4b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSjFzVmJoWT1OaWZJWTdLN0h0ak5yNA==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b> ALCANTARA D, SHARF A, ABBASINEJAD F, et al.Real-time parallel hashing on the GPU [J].ACM Transactions on Graphics, 2009, 28 (5) :Article No.154.
                            </a>
                        </p>
                        <p id="198">
                            <a id="bibliography_18" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000019377&amp;v=MTE1MjI0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyM0lKMXNWYmhZPU5pZklZN0s3SHRqTnI0OUZaT29HRDNzK29CTVQ2VA==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[18]</b> FREDMAN M L, KOMLOS J, SZEMEREDI E.Storing a sparse table with O (1) worst case access time[J].Journal of the ACM, 1984, 31 (3) :538-544.
                            </a>
                        </p>
                        <p id="200">
                            <a id="bibliography_19" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012201522397&amp;v=Mjk5MzlORDNVK29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXIzSUoxc1ZiaFk9TmlmT2ZiSzdIdERPclk5RVllaw==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[19]</b> PAGH R, RODLER F F.Cuckoo hashing [J].Journal of Algorithms, 2004, 51 (2) :122-144.
                            </a>
                        </p>
                        <p id="202">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Bloom Filter Performance on Graphics Engines">

                                <b>[20]</b> MA L, CHAMBERLAIN R D, BUHLER J D, et al.Bloom filter performance on graphics engines[C]// Proceedings of the 2011 International Conference on Parallel Processing.Piscataway, NJ:IEEE, 2011:522-531.
                            </a>
                        </p>
                        <p id="204">
                            <a id="bibliography_21" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A new data layout for set intersection on GPUs">

                                <b>[21]</b> AMOSSEN R R, PAGH R.A new data layout for set intersection on GPUs[C]// Proceedings of the 2011 Parallel and Distributed Processing Symposium.Piscataway, NJ:IEEE, 2011:698-708.
                            </a>
                        </p>
                        <p id="206">
                            <a id="bibliography_22" target="_blank" href="http://scholar.cnki.net/result.aspx?q=&amp;quot;An Effective GPU Implementation ofBreadth-First Search,&amp;quot;">

                                <b>[22]</b> LUO L, WONG M, HWU W.An effective GPU implementation of breadth first search [C]// Proceedings of the 2010 Design Automation Conference.New York:ACM, 2010:52-55.
                            </a>
                        </p>
                        <p id="208">
                            <a id="bibliography_23" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fast Minimum Spanning Tree for Large Graphs on the GPU">

                                <b>[23]</b> VINEET V, HARISH P, PATIDAR S, et al.Fast minimum spanning tree for large graphs on the GPU[C]// Proceedings of the 2009 Conference on High Performance Graphics.New York:ACM, 2009:167-171.
                            </a>
                        </p>
                        <p id="210">
                            <a id="bibliography_24" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Introduction to Algorithms">

                                <b>[24]</b> CORMEN T H, LEISERSON C E, RIVEST R L, et al.Introduction to Algorithms [M].Cambridge, MA:MIT Press, 2009:151-153.
                            </a>
                        </p>
                        <p id="212">
                            <a id="bibliography_25" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000024694&amp;v=MjEyOTc0OUZaT2tMQ25VOW9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXIzSUoxc1ZiaFk9TmlmSVk3SzdIdGpOcg==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[25]</b> VUILLEMIN J.A data structure for manipulating priority queues[J].Communications of the ACM, 1978, 21 (4) :309-315.
                            </a>
                        </p>
                        <p id="214">
                            <a id="bibliography_26" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000019487&amp;v=MDkzOTg5RlpPb0dDSFErb0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSjFzVmJoWT1OaWZJWTdLN0h0ak5yNA==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[26]</b> FREDMAN M L, TARJAN R E.Fibonacci heaps and their uses in improved network optimization algorithms [J].Journal of the ACM, 1987, 34 (3) :596-615.
                            </a>
                        </p>
                        <p id="216">
                            <a id="bibliography_27" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300420256&amp;v=MDAwMjlUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSjFzVmJoWT1OaWZPZmJLN0h0RE9ySTlGWU9rUERuay9vQk1UNg==&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[27]</b> BRODAL G S.Priority queues on parallel machines [J].Parallel Computing, 1999, 25 (8) :987-1011.
                            </a>
                        </p>
                        <p id="218">
                            <a id="bibliography_28" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Concurrent access of priority queues">

                                <b>[28]</b> NAGESHWARA R, KUMAR V.Concurrent access of priority queues [J].IEEE Transactions on Computers, 1988, 37 (12) :1657-1665.
                            </a>
                        </p>
                        <p id="220">
                            <a id="bibliography_29" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Design and implementation of a parallel priority queue on many-core architectures">

                                <b>[29]</b> He X, AGARWAL D, PRASAD S K.Design and implementation of a parallel priority queue on many-core architectures[C]// Proceedings of the 2012 International Conference on High Performance Computing.Piscataway, NJ:IEEE, 2012:1-10.
                            </a>
                        </p>
                        <p id="222">
                            <a id="bibliography_30" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Designing efficient sorting algorithms for manycore gpus">

                                <b>[30]</b> SATISH N, HARRIS M, GARLAND M.Designing efficient sorting algorithms for many-core GPUS[C]// Proceedings of the 2009 IEEE International Symposium on Parallel and Distributed Processing.Piscataway, NJ:IEEE, 2009:1-10.
                            </a>
                        </p>
                        <p id="224">
                            <a id="bibliography_31" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A practical quicksort algorithm for graphics processors">

                                <b>[31]</b> CEDERMAN D, TSIGAS P.A practical quicksort algorithm for graphics processors[C]// Proceedings of the 2008 European Symposium on Algorithms.Berlin:Springer, 2008:246-258.
                            </a>
                        </p>
                        <p id="226">
                            <a id="bibliography_32" target="_blank" href="http://scholar.cnki.net/result.aspx?q=GPUTeraSort:High performance graphics co-processor sorting for large databasemanagement">

                                <b>[32]</b> GOVINDARAJU N, GRAY J, KUMAR R, et al.GPUTerasort:high performance graphics co-processor sorting for large database management[C]// Proceedings of the 2006 ACM SIGMOD International Conference on Management of Data.New York:ACM, 2006:325-336.
                            </a>
                        </p>
                        <p id="228">
                            <a id="bibliography_33" target="_blank" href="http://scholar.cnki.net/result.aspx?q=GPU-ABiSort:optimal parallel sortingon stream architectures">

                                <b>[33]</b> GREB A, ZACHMANN G.GPU-ABiSort:optimal parallel sorting on stream architectures [C]// Proceedings of the 2006 International Parallel and Distributed Processing Symposium.Piscataway, NJ:IEEE, 2006:Article No.45.
                            </a>
                        </p>
                        <p id="230">
                            <a id="bibliography_34" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient parallel merge sort for fixed and variable length keys">

                                <b>[34]</b> DAVIDSON A, TARJAN D, GARLAND M, et al.Efficient parallel merge sort for fixed and variable length keys[C]// Proceedings of the 2012 Innovative Parallel Computing.Piscataway, NJ:IEEE, 2012:1-9.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJY201907024" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJY201907024&amp;v=MjQ3MjZHNEg5ak1xSTlIWUlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVpzRnkvZ1VydktMejdCZDc=&amp;uid=WEEvREcwSlJHSldRa1Fhb09pSnNveUxSWmZRblJCWGhwbXU2MEpGM0M3ND0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
