<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637136459964190000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJY201910038%26RESULT%3d1%26SIGN%3dxn1Jqeznr%252b42Je%252bzQa7KGM7K6Yg%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJY201910038&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJY201910038&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJY201910038&amp;v=MDg2MjJDVVI3cWZadVpzRnluaFc3dklMejdCZDdHNEg5ak5yNDlHYklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnI=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#35" data-title="0 引言 ">0 引言</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#40" data-title="1 相关工作 ">1 相关工作</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#46" data-title="2 半自动验证方法 ">2 半自动验证方法</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#55" data-title="2.1 &lt;b&gt;污点分析&lt;/b&gt;">2.1 <b>污点分析</b></a></li>
                                                <li><a href="#60" data-title="2.2 &lt;b&gt;路径条件反转&lt;/b&gt;">2.2 <b>路径条件反转</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#95" data-title="3 原型实现 ">3 原型实现</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#98" data-title="3.1 &lt;b&gt;别名分析模块&lt;/b&gt;">3.1 <b>别名分析模块</b></a></li>
                                                <li><a href="#131" data-title="3.2 &lt;b&gt;污点分析模块&lt;/b&gt;">3.2 <b>污点分析模块</b></a></li>
                                                <li><a href="#152" data-title="3.3 &lt;b&gt;路径条件反转验证模块&lt;/b&gt;">3.3 <b>路径条件反转验证模块</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#218" data-title="4 实验分析 ">4 实验分析</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#358" data-title="5 结语 ">5 结语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#54" data-title="图1 总体结构">图1 总体结构</a></li>
                                                <li><a href="#58" data-title="图2 分析模块的层次结构">图2 分析模块的层次结构</a></li>
                                                <li><a href="#68" data-title="图3 程序流图实例">图3 程序流图实例</a></li>
                                                <li><a href="#97" data-title="图4 原型系统模块">图4 原型系统模块</a></li>
                                                <li><a href="#104" data-title="&lt;b&gt;表&lt;/b&gt;1 &lt;b&gt;内存块记录的信息&lt;/b&gt;"><b>表</b>1 <b>内存块记录的信息</b></a></li>
                                                <li><a href="#109" data-title="图5 Trace执行语句片段示例">图5 Trace执行语句片段示例</a></li>
                                                <li><a href="#126" data-title="图6 别名示意图">图6 别名示意图</a></li>
                                                <li><a href="#270" data-title="&lt;b&gt;表&lt;/b&gt;2 &lt;b&gt;采用本文方法验证&lt;/b&gt;FlowDroid&lt;b&gt;告警的实验结果&lt;/b&gt;"><b>表</b>2 <b>采用本文方法验证</b>FlowDroid<b>告警的实验结果</b></a></li>
                                                <li><a href="#353" data-title="&lt;b&gt;表&lt;/b&gt;3 MultiFlow&lt;b&gt;实验结果&lt;/b&gt;"><b>表</b>3 MultiFlow<b>实验结果</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="385">


                                    <a id="bibliography_1" title="王蕾,李丰,李炼,等.污点分析技术的原理和实践应用[J].软件学报,2017,28(4):860-882.(WANG L,LI F,LI L,et al.Principle and practice of taint analysis[J].Journal of Software,2017,28(4):860-882.)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201704009&amp;v=MTQ3ODY0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVac0Z5bmhXN3ZMTnlmVGJMRzRIOWJNcTQ5RmJZUUtESDg0dlI=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                        王蕾,李丰,李炼,等.污点分析技术的原理和实践应用[J].软件学报,2017,28(4):860-882.(WANG L,LI F,LI L,et al.Principle and practice of taint analysis[J].Journal of Software,2017,28(4):860-882.)
                                    </a>
                                </li>
                                <li id="387">


                                    <a id="bibliography_2" title="赵云山,宫云战,王前,等.静态缺陷检测中的误报消除技术研究[J].计算机研究与发展,2012,49(9):1822-1831.(ZHAO Y S,GONG Y Z,WANG Q,et al.False positive elimination in static defect detection[J].Journal of Computer Research and Development,2012,49(9):1822-1831.)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201209003&amp;v=MjUwMjF5dlNkTEc0SDlQTXBvOUZaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnNGeW5oVzd2TEw=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                        赵云山,宫云战,王前,等.静态缺陷检测中的误报消除技术研究[J].计算机研究与发展,2012,49(9):1822-1831.(ZHAO Y S,GONG Y Z,WANG Q,et al.False positive elimination in static defect detection[J].Journal of Computer Research and Development,2012,49(9):1822-1831.)
                                    </a>
                                </li>
                                <li id="389">


                                    <a id="bibliography_3" title="李筱,周严,李孟宸,等.C/C++程序静态内存泄漏警报自动确认方法[J].软件学报,2017,28(4):827-844.(LI X,ZHOU Y,LI M C,et al.Automatically validating static memory leak warnings for C/C++programs[J].Journal of Software,2017,28(4):827-844.)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201704007&amp;v=MjA5NTM0OUZZNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1WnNGeW5oVzd2TE55ZlRiTEc0SDliTXE=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                        李筱,周严,李孟宸,等.C/C++程序静态内存泄漏警报自动确认方法[J].软件学报,2017,28(4):827-844.(LI X,ZHOU Y,LI M C,et al.Automatically validating static memory leak warnings for C/C++programs[J].Journal of Software,2017,28(4):827-844.)
                                    </a>
                                </li>
                                <li id="391">


                                    <a id="bibliography_4" title="GE X,TANEJA K,XIE T,et al.Dy Ta:dynamic symbolic execution guided with static verification results[C]//Proceedings of the33rd International Conference on Software Engineering.New York:ACM,2011:992-994." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Dy Ta:dynamic symbolic execution guided with static verification results">
                                        <b>[4]</b>
                                        GE X,TANEJA K,XIE T,et al.Dy Ta:dynamic symbolic execution guided with static verification results[C]//Proceedings of the33rd International Conference on Software Engineering.New York:ACM,2011:992-994.
                                    </a>
                                </li>
                                <li id="393">


                                    <a id="bibliography_5" title="王蕾,周卿,何东杰,等.面向Android应用隐私泄露检测的多源污点分析技术[J].软件学报,2019,30(2):211-230.(WANG L,ZHOU Q,HE D J,et al.Multi-sources taint analysis technique for privacy leak detection of Android apps[J].Journal of Software,2019,30(2):211-230.)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201902002&amp;v=MjQzOTh0R0ZyQ1VSN3FmWnVac0Z5bmhXN3ZMTnlmVGJMRzRIOWpNclk5RlpvUUtESDg0dlI0VDZqNTRPM3pxcUI=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                        王蕾,周卿,何东杰,等.面向Android应用隐私泄露检测的多源污点分析技术[J].软件学报,2019,30(2):211-230.(WANG L,ZHOU Q,HE D J,et al.Multi-sources taint analysis technique for privacy leak detection of Android apps[J].Journal of Software,2019,30(2):211-230.)
                                    </a>
                                </li>
                                <li id="395">


                                    <a id="bibliography_6" title="RICE H G.Classes of recursively enumerable sets and their decision problems[J].Transactions of the American Mathematical Society,1953,74(2):358-366." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJAM&amp;filename=SJAM15060200059132&amp;v=MDcxMDdpclJkR2VycVFUTW53WmVadEZpbmxVcjNJSVZvY2JoRT1OaWZLWTdLOUh0Zk1yWTlGWk80R0RYODdvQk1UNlQ0UFFILw==&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                        RICE H G.Classes of recursively enumerable sets and their decision problems[J].Transactions of the American Mathematical Society,1953,74(2):358-366.
                                    </a>
                                </li>
                                <li id="397">


                                    <a id="bibliography_7" title="YANG Z,YANG M,ZHANG Y,et al.App Intent:analyzing sensitive data transmission in Android for privacy leakage detection[C]//Proceedings of the 2013 ACM SIGSAC Conference on Computer&amp;amp;Communications Security.New York:ACM,2013:1043-1054." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Appintent:Analyzing sensitive data transmission in android for privacy leakage detection">
                                        <b>[7]</b>
                                        YANG Z,YANG M,ZHANG Y,et al.App Intent:analyzing sensitive data transmission in Android for privacy leakage detection[C]//Proceedings of the 2013 ACM SIGSAC Conference on Computer&amp;amp;Communications Security.New York:ACM,2013:1043-1054.
                                    </a>
                                </li>
                                <li id="399">


                                    <a id="bibliography_8" title="ARZT S,RASTHOFER S,HAHN R,et al.Using targeted symbolic execution for reducing false-positives in dataflow analysis[C]//Proceedings of the 4th ACM SIGPLAN International Workshop on State of the Art in Program Analysis.New York:ACM,2015:1-6." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Using targeted symbolic execution for reducing false-positives in dataflow analysis">
                                        <b>[8]</b>
                                        ARZT S,RASTHOFER S,HAHN R,et al.Using targeted symbolic execution for reducing false-positives in dataflow analysis[C]//Proceedings of the 4th ACM SIGPLAN International Workshop on State of the Art in Program Analysis.New York:ACM,2015:1-6.
                                    </a>
                                </li>
                                <li id="401">


                                    <a id="bibliography_9" title="JUNKER M,HUUCK R,FEHNKER A,et al.SMT-based false positive elimination in static program analysis[C]//Proceedings of the 2012 International Conference on Formal Engineering Methods,LNCS 7635.Berlin:Springer,2012:316-331." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=SMT-based false positive elimination in static program analysis">
                                        <b>[9]</b>
                                        JUNKER M,HUUCK R,FEHNKER A,et al.SMT-based false positive elimination in static program analysis[C]//Proceedings of the 2012 International Conference on Formal Engineering Methods,LNCS 7635.Berlin:Springer,2012:316-331.
                                    </a>
                                </li>
                                <li id="403">


                                    <a id="bibliography_10" title="ZHANG L,THING V L L.A hybrid symbolic execution assisted fuzzing method[C]//Proceedings of the 2017 IEEE Region 10Conference.Piscataway:IEEE,2017:822-825." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A hybrid symbolic execution assisted fuzzing method">
                                        <b>[10]</b>
                                        ZHANG L,THING V L L.A hybrid symbolic execution assisted fuzzing method[C]//Proceedings of the 2017 IEEE Region 10Conference.Piscataway:IEEE,2017:822-825.
                                    </a>
                                </li>
                                <li id="405">


                                    <a id="bibliography_11" title="CAI J,YANG S,MEN J,et al.Automatic software vulnerability detection based on guided deep fuzzing[C]//Proceedings of the IEEE 5th International Conference on Software Engineering and Service Science.Piscataway:IEEE,2014:231-234." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Automatic software vulnerability detection based on guided deep fuzzing">
                                        <b>[11]</b>
                                        CAI J,YANG S,MEN J,et al.Automatic software vulnerability detection based on guided deep fuzzing[C]//Proceedings of the IEEE 5th International Conference on Software Engineering and Service Science.Piscataway:IEEE,2014:231-234.
                                    </a>
                                </li>
                                <li id="407">


                                    <a id="bibliography_12" title="PENG H,SHOSHITAISHVILI Y,PAYER M.T-Fuzz:fuzzing by program transformation[C]//Proceedings of the 2018 IEEE Symposium on Security and Privacy.Piscataway:IEEE,2018:697-710." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=T-Fuzz:fuzzing by program transformation">
                                        <b>[12]</b>
                                        PENG H,SHOSHITAISHVILI Y,PAYER M.T-Fuzz:fuzzing by program transformation[C]//Proceedings of the 2018 IEEE Symposium on Security and Privacy.Piscataway:IEEE,2018:697-710.
                                    </a>
                                </li>
                                <li id="409">


                                    <a id="bibliography_13" title="GODEFROID P,LEVIN M Y,MOLNAR D.SAGE:whitebox fuzzing for security testing[J].Communications of the ACM,2012,55(3):40-44." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000012571&amp;v=MzIwOTJiaEU9TmlmSVk3SzdIdGpOcjQ5RlpPb05DWHM0b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSVZvYw==&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                        GODEFROID P,LEVIN M Y,MOLNAR D.SAGE:whitebox fuzzing for security testing[J].Communications of the ACM,2012,55(3):40-44.
                                    </a>
                                </li>
                                <li id="411">


                                    <a id="bibliography_14" title="TANEJA K,XIE T,TILLMANN N,et al.Guided path exploration for regression test generation[C]//Proceedings of the 31st International Conference on Software Engineering.Piscataway:IEEE,2009:311-314." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Guided path exploration for regression test generation">
                                        <b>[14]</b>
                                        TANEJA K,XIE T,TILLMANN N,et al.Guided path exploration for regression test generation[C]//Proceedings of the 31st International Conference on Software Engineering.Piscataway:IEEE,2009:311-314.
                                    </a>
                                </li>
                                <li id="413">


                                    <a id="bibliography_15" title="ARZT S,RASTHOFER S,FRITZ C,et al.Flow Droid:precise context,flow,field,object-sensitive and lifecycle-aware taint analysis for Android apps[J].ACM SIGPLAN Notices,2014,49(6):259-269." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=FlowDroid:Precise context,flow,field,object-sensitive and lifecycle-aware taint analysis for Android apps">
                                        <b>[15]</b>
                                        ARZT S,RASTHOFER S,FRITZ C,et al.Flow Droid:precise context,flow,field,object-sensitive and lifecycle-aware taint analysis for Android apps[J].ACM SIGPLAN Notices,2014,49(6):259-269.
                                    </a>
                                </li>
                                <li id="415">


                                    <a id="bibliography_16" title="BODDEN E.Inter-procedural data-flow analysis with IFDS/IDEand soot[C]//Proceedings of the ACM SIGPLAN International Workshop on State of the Art in Java Program Analysis.New York:ACM,2012:3-8." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Inter-procedural data-flow analysis with IFDS/IDE and Soot">
                                        <b>[16]</b>
                                        BODDEN E.Inter-procedural data-flow analysis with IFDS/IDEand soot[C]//Proceedings of the ACM SIGPLAN International Workshop on State of the Art in Java Program Analysis.New York:ACM,2012:3-8.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">

    <div class="head-tag">   
            <p>
               <b> 网络首发时间: 2019-08-19 09:00</b>
            </p>     
    </div>


        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJY" target="_blank">计算机应用</a>
                2019,39(10),3018-3027 DOI:10.11772/j.issn.1001-9081.2019040644            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>面向Android应用的静态污点分析结果的正确性验证</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%A7%A6%E5%BD%AA&amp;code=42379571&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">秦彪</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%83%AD%E5%B8%86&amp;code=10668165&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">郭帆</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%B6%82%E9%A3%8E%E6%B6%9B&amp;code=38239787&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">涂风涛</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B1%9F%E8%A5%BF%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2&amp;code=0240878&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">江西师范大学计算机信息工程学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E8%B1%AB%E7%AB%A0%E5%B8%88%E8%8C%83%E5%AD%A6%E9%99%A2%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB&amp;code=1701730&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">豫章师范学院计算机系</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>应用静态污点分析检测Android应用的隐私泄露漏洞会产生许多虚警,为此提出一种上下文敏感、路径敏感和域敏感的半自动程序分析方法,仅需遍历少量执行路径即可判定漏洞是否虚警。首先,运行插桩后的应用来获得一条覆盖Source和Sink的种子Trace。然后,应用基于Trace的污点分析方法来验证Trace中是否存在污点传播路径,是则表明漏洞真实存在;否则进一步收集Trace的条件集合和污点信息,结合活变量分析和基于条件反转的程序变换方法设计约束选择策略,以删除大部分与污点传播无关的可执行路径。最后,遍历剩余执行路径并分析相应Trace来验证漏洞是否虚警。基于FlowDroid实现原型系统,对DroidBench的75个应用和10个真实应用进行验证,每个应用平均仅需遍历15.09%的路径,虚警率平均降低58.17%。实验结果表明该方法可以较高效地减少静态分析结果的虚警。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A8%8B%E5%BA%8F%E9%AA%8C%E8%AF%81&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">程序验证;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">污点分析;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%B4%BB%E5%8F%98%E9%87%8F%E5%88%86%E6%9E%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">活变量分析;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A8%8B%E5%BA%8F%E5%8F%98%E6%8D%A2&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">程序变换;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B7%AF%E5%BE%84%E6%95%8F%E6%84%9F&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">路径敏感;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    秦彪(1993—),男,江西南昌人,硕士研究生,主要研究方向:信息安全、程序验证;;
                                </span>
                                <span>
                                    *郭帆(1977—),男,江西南昌人,副教授,博士,主要研究方向:网络安全、程序安全;电子邮箱121171528@qq.com;
                                </span>
                                <span>
                                    涂风涛(1976—),男,江西南昌人,讲师,硕士,主要研究方向:网络安全。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2019-04-17</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金资助项目(61562040,61762049);</span>
                                <span>江西省教育厅科技项目(GJJ161305,GJJ151330);</span>
                    </p>
            </div>
                    <h1><b>Correctness verification of static taint analysis results for Android application</b></h1>
                    <h2>
                    <span>QIN Biao</span>
                    <span>GUO Fan</span>
                    <span>TU Fengtao</span>
            </h2>
                    <h2>
                    <span>College of Computer Information Engineering, Jiangxi Normal University</span>
                    <span>Department of Computer Science, Yuzhang Normal University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Many false positives are generated when an Android application is detected by static taint analysis to discover potential privacy-leak bugs. For that, a context-sensitive, path-sensitive and field-sensitive semi-auto analysis method was proposed to verify if a potential bug is a true positive by only traversing a few executable paths. Firstly, a seed Trace covering both Source and Sink was obtained manually by running the instrumented application. Then, a Trace-based taint analysis method was used to verify if there was a taint propagating path in the Trace. If there was a taint propagating path, it meaned a real privacy leak bug existed. If not, the conditioin set and taint information of the Trace were further collected, and by combining the live-variable analysis and the program transformation approach based on conditional inversion, a constraint selection policy was designed to prune most executable paths irrelevant to taint propagation. Finally, remaining executable paths were traversed and corresponding Traces were analyzed to verify if the bug is a false positive. Seventy-five applications of DroidBench and ten real applications were tested by a prototype system implemented on FlowDroid. Results show that only 15.09% paths traversed averagely in each application, the false positive rate decreases 58.17% averagely. Experimental results demonstrate the analysis can effectively reduce the false positives generated by static taint analysis.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=program%20verification&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">program verification;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=taint%20analysis&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">taint analysis;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=live-variable%20analysis&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">live-variable analysis;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=program%20transformation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">program transformation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=path%20sensitive&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">path sensitive;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    QIN Biao,born in 1993,M.S.candidate.His research interests include information security,program verification.;
                                </span>
                                <span>
                                    GUO Fan,born in 1977,Ph.D.,associate professor.His research interests include network security,application security.;
                                </span>
                                <span>
                                    TU Fengtao,born in 1976,M.S.,lecturer.His research interests include network security.;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2019-04-17</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>partially supported by the National Natural Science Foundation of China(61562040,61762049);</span>
                                <span>the Science-Technology Project of Education Bureau of Jiangxi Province(GJJ161305,GJJ151330);</span>
                    </p>
            </div>


        <!--brief start-->
                        <h3 id="35" name="35" class="anchor-tag">0 引言</h3>
                <div class="p1">
                    <p id="36">随着智能手机的普及,Android应用的安全性备受关注。隐私泄露是Android手机最严重的安全问题之一,它是指应用程序中存在一条从读取隐私数据的Source方法调用语句到送出隐私输出的Sink方法调用的执行路径,并且未经用户许可。污点分析是检测隐私泄露的主流检测方法之一,它从Source开始跟踪外部引入的数据(污点),检查它们是否未经验证就直接传播到Sink位置,如果是则可能存在漏洞。</p>
                </div>
                <div class="p1">
                    <p id="37">污点分析分为静态分析和动态分析。静态分析不运行代码,直接对代码或者转换后的中间代码扫描,提取其中的词法、语法和语义,结合控制流分析和数据流分析,判定污点是否能从Source传递到Sink<citation id="417" type="reference"><link href="385" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。静态分析可靠性高,但是需要耗费大量资源并且时间性能较差,为了实现精度和效率的平衡,往往会对所有分支的数据流信息进行保守的合并,从而产生大量虚警。动态分析指插桩并监控程序运行时行为,动态获取程序的控制流和数据流,实时跟踪污点传播,在Sink位置检测是否有污点信息输出<citation id="418" type="reference"><link href="385" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。动态分析的精确度高,但是动态分析难以覆盖程序的所有可执行路径,会遗漏许多潜在漏洞,可靠性不高。</p>
                </div>
                <div class="p1">
                    <p id="38">为了降低静态分析的虚警率,研究人员提出了不少方案,主要分为基于约束求解<citation id="420" type="reference"><link href="387" rel="bibliography" /><link href="389" rel="bibliography" /><link href="391" rel="bibliography" /><sup>[<a class="sup">2</a>,<a class="sup">3</a>,<a class="sup">4</a>]</sup></citation>和基于机器学习<citation id="419" type="reference"><link href="393" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>两类。约束求解常常与控制流分析和动态符号执行(Dynamic Symbolic Execution, DSE)技术相结合,在收集执行路径约束集合后,使用可满足性模理论(Satisfiability Modulo Theories, SMT)求解器判定路径是否可行,进而验证是否虚警。然而在实际应用中,路径条件复杂多变,约束求解存在约束表达困难和无法获得正确解的问题,导致虚警验证失败。机器学习通过统计方法或神经网络分析真实报警和虚警之间的特征差异,但是存在虚警验证错误的问题。</p>
                </div>
                <div class="p1">
                    <p id="39">本文提出一种路径敏感、上下文敏感和域敏感的半自动分析方法,可以高效可靠地验证静态污点分析结果的正确性,在插桩和运行应用获得覆盖Source和Sink的运行Trace后,结合程序插桩、基于Trace的污点分析、活变量分析和程序变换方法,对程序的执行路径集合进行剪枝和遍历,进而验证分析结果是否虚警,针对DroidBench和真实应用的实验结果表明了该方法的有效性。</p>
                </div>
                <h3 id="40" name="40" class="anchor-tag">1 相关工作</h3>
                <div class="p1">
                    <p id="41">静态分析技术是检查程序漏洞的有效手段,它通过静态扫描程序来找到匹配规则模式的代码从而发现代码中的问题。静态分析往往采用基于近似的分析方法,其分析结果不够精确,所以大多数静态分析工具生成的控制流图存在许多不确定性,如弱类型检查、未定义的行为以及别名指针等。根据Rice定理<citation id="421" type="reference"><link href="395" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>,静态分析针对程序的任何非平凡属性(例如程序是否存在数组越界),无法做到既完备又可靠,导致静态分析结果存在误报和漏报<citation id="422" type="reference"><link href="387" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="42">国内外学者为消除静态分析结果中的误报,提出了不同的解决方法并进行大量的研究工作,设计和实现了各种静态漏洞检测工具。王蕾等<citation id="423" type="reference"><link href="393" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>认为恶意应用的多个Source之间的相关性与正常应用存在差异,提出一种分析结果中的多个Source是否绑定触发Sink的污点分析技术,利用这种差异可以降低虚警率。赵云山等<citation id="424" type="reference"><link href="387" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>以静态分析的结果作为输入,逆向搜索可能发生缺陷的约束条件,使用约束求解判断缺陷的可满足性,进而验证结果是否虚警。李筱等<citation id="425" type="reference"><link href="389" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>对目标程序进行控制流分析,判断警报的可达性并得到制导信息,再利用混合执行测试的方法,跟踪程序运行时内存状态并判断内存是否泄漏,验证漏洞是否虚警。AppIntent<citation id="426" type="reference"><link href="397" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>从可疑敏感数据泄露路径中抽取事件处理方法集合,形成事件处理方法约束图,并根据约束条件产生用户输入,验证该路径是否是用户许可的路径,从而排除虚警。DyTa<citation id="427" type="reference"><link href="391" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>是一种自动漏洞检测工具,它的检测过程分为静态和动态两个阶段,静态阶段中利用静态检测技术发现程序的潜在漏洞;动态阶段中通过动态符号执行(DSE)技术生成测试用例,以新的测试用例执行被测程序来验证静态阶段中发现的漏洞是否真实存在。TASMAN<citation id="428" type="reference"><link href="399" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>基于动态符号执行技术,结合污点分析收集程序控制流图的路径约束,通过SMT求解器<citation id="429" type="reference"><link href="401" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>计算路径约束的可满足性以判断路径是否可行,过滤掉不可行路径中的警报来消除误报。</p>
                </div>
                <div class="p1">
                    <p id="43">Fuzzing测试<citation id="430" type="reference"><link href="403" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>和动态符号执行是两种对程序安全进行动态测试的主流技术,经典Fuzzing测试使用随机产生的程序输入,会导致路径覆盖率较低,无法发现复杂执行路径中潜在的漏洞。Cai等<citation id="431" type="reference"><link href="405" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>结合符号执行的优点,搜索更多目标问题的执行路径,从而提高代码覆盖率,同时运用污点分析检测每条路径,并用依赖路径的污点信息指导Fuzzing测试生成相关的测试用例,以此发现程序内的问题。T-Fuzz<citation id="432" type="reference"><link href="407" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation> 采用程序变换技术删除被测程序中复杂的完整性检查过程,从而暴露目标程序的潜在漏洞,然后跟踪触发漏洞的执行过程信息,收集源程序的路径约束,判断它们的可满足性以消除误报。</p>
                </div>
                <div class="p1">
                    <p id="44">动态符号执行技术存在路径爆炸问题,为此业界提出了不同的路径搜索算法,通过选择策略覆盖关键路径,其中最具代表性的是SAGE系统<citation id="433" type="reference"><link href="409" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>。它设计了代搜索(generation search)算法,使用启发式搜索策略,对搜集到的路径条件中的分支约束依次进行取反求解,生成新用例并将它们依次执行然后统计代码覆盖率,依据代码覆盖率为各新用例打分,接着在符号执行过程中选取打分高的用例执行,然后重复上述过程。代搜索虽然有利于提高代码覆盖率、缓解路径爆炸问题,但是打分过程开销大,影响了算法的性能。另外,DyTa在动态阶段,采用文献<citation id="434" type="reference">[<a class="sup">14</a>]</citation>方法,根据静态阶段获得的信息指导DSE搜索程序的路径,并使用静态发现潜在缺陷的定位技术,对与反转不相关的分支节点进行剪枝,从而使DSE过程更高效。</p>
                </div>
                <div class="p1">
                    <p id="45">约束求解是动态符号执行的必要过程,但是现有求解器无法求解所有约束,同时求解器的运行效率较低导致动态符号执行的效率低下。本文提出一种验证污点分析结果正确性的半自动方法,首先插桩并手工运行Android应用获得一条覆盖Source和Sink的Trace。接着对Trace进行污点分析判定是否存在从Source到Sink的污点传播路径,是则验证结果正确;否则收集Trace的条件约束和污点信息,结合活变量分析和程序变换<citation id="435" type="reference"><link href="407" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>的方法设计约束选择策略,对可行路径集合进行剪枝和遍历,判定是否存在污点传播路径,进而验证分析结果是否虚警。该方法没有采用动态符号执行生成测试用例,而是使用程序变换技术将程序中的条件约束逐一取反,生成变换后的程序并按照原有执行动作重复执行,进而获得其他执行路径信息,从而有效提高路径覆盖率。</p>
                </div>
                <h3 id="46" name="46" class="anchor-tag">2 半自动验证方法</h3>
                <div class="p1">
                    <p id="47">本文方法的总体结构如图1所示,其执行流程如下:</p>
                </div>
                <div class="p1">
                    <p id="48">1)被检测的APK静态插桩,生成新的.dex文件,使转换后的Android应用在执行时能够记录程序的执行路径信息(Trace)。</p>
                </div>
                <div class="p1">
                    <p id="49">2)将新生成的.dex文件打包成插桩后的APK,并安装到Android模拟器或真机中。</p>
                </div>
                <div class="p1">
                    <p id="50">3)在保证程序执行时能同时覆盖Source和Sink的前提下,手工执行插桩后的Android应用并记录执行时的操作序列(events),得到程序执行结束后的Trace,即种子Trace。</p>
                </div>
                <div class="p1">
                    <p id="51">4)分析模块对种子Trace进行别名分析和污点分析,获得程序执行过程中的运行时信息。</p>
                </div>
                <div class="p1">
                    <p id="52">5)根据污点分析结果,如果发现一条从Source到Sink的污点传播路径,则整个验证过程结束,报告缺陷真实存在;否则,遍历Source与Sink之间的所有其他可能的执行路径,并对遍历过程中产生的每一条Trace进行污点分析,判断其中是否存从Source到Sink的未经验证的污点传播路径,如果存在则停止遍历,验证结束并报告缺陷真实存在。</p>
                </div>
                <div class="p1">
                    <p id="53">6)直到遍历完所有路径后都没有发现一条从Source到Sink的污点传播路径,则结束验证过程,报告该缺陷是虚警。</p>
                </div>
                <div class="area_img" id="54">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201910038_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 总体结构" src="Detail/GetImg?filename=images/JSJY201910038_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 总体结构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201910038_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.1 Overall structure</p>

                </div>
                <h4 class="anchor-tag" id="55" name="55">2.1 <b>污点分析</b></h4>
                <div class="p1">
                    <p id="56">手工执行经插桩的Android应用获得的种子Trace本质上是一条顺序的代码序列,污点分析的目标是根据Trace中的信息分析它记录的每条指令处的全局污点信息。Java定义的变量都是以引用的形式标识程序运行时具体的内存位置,因此会有不同变量指向同一块内存空间,即它们互为别名,污点分析必须建立在准确的别名信息基础之上。 Android应用存在大量的方法调用,特别是事件触发的回调方法和注册监听组件事件的处理方法,在进行别名分析之前需要收集Trace中的方法调用现场信息,包括发生方法调用的位置信息和实参与形参之间的映射关系。</p>
                </div>
                <div class="p1">
                    <p id="57">图2是分析模块的内部层次结构,方法调用现场信息收集子模块处在最底层,作为整个分析模块的基石,在别名分析时需要查找方法调用现场信息以确定实参到形参的别名数据流走向,进而别名分析又为污点分析提供支撑。</p>
                </div>
                <div class="area_img" id="58">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201910038_058.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 分析模块的层次结构" src="Detail/GetImg?filename=images/JSJY201910038_058.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 分析模块的层次结构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201910038_058.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.2 Hierarchical structure of analysis module</p>

                </div>
                <div class="p1">
                    <p id="59">本文方法没有对底层系统调用库、JDK和SDK库方法的内部数据流进行污点分析,而是采用建模的方式定义库方法的污点传播摘要,根据摘要来记录调用库方法前后内存中污点信息的变化,同时,也对库方法中的验证方法(Sanitizer)建模定义无害化处理的污点传播摘要。方法采用白名单结合正则匹配的策略对自定义验证方法进行识别,主要基于方法名称、传递参数类型和返回值类型。例如,对于名字中包含“validate”“encrypt”或“check”等子串的方法调用语句,如果参数类型和返回值类型的签名满足预定义规则,就使用预定义的污点传播摘要直接生成方法调用后的内存污点信息。</p>
                </div>
                <h4 class="anchor-tag" id="60" name="60">2.2 <b>路径条件反转</b></h4>
                <div class="p1">
                    <p id="61">在遍历Source到Sink之间的所有可执行路径时,为缓解路径爆炸的问题,方法设计了一种路径条件的选择策略,以程序变换的方式反转选取的路径条件,重新生成新转换的Android应用,然后将原执行动作序列(events)重放于转换后的Android应用,进而获得包含其他分支路径信息的Trace。选择策略是选取同时满足以下两点的条件语句:</p>
                </div>
                <div class="p1">
                    <p id="62">1)在程序的反向跨方法控制流图(Interprocedural Reverse Control Flow Graph, IRCFG)中,剪去位于Sink前方的子图,在剩下的子图中,以Sink为起点进行跨方法的活变量分析,要求条件语句的活变量集合中必须至少有一个污点变量。</p>
                </div>
                <div class="p1">
                    <p id="63">2)如果一条条件语句与Sink属于同一个方法体,那么在这个方法体对应的控制流图(Control Flow Graph, CFG)中,从这条条件语句的另一个分支出发的路径集合中至少有一条路径会经过Sink节点。</p>
                </div>
                <div class="p1">
                    <p id="64">如果在某条条件语句处已经不存在任何活的污点变量,说明Source在该条件语句之前已经被验证过或后续没有任何与Source相关的数据流传播,那么在该条件语句后面的所有分支路径就不可能从Source传播到Sink处,即不存在从Source到Sink的污点传播路径,因此没有必要反转此条件。而与Sink属于同一方法体的条件语句,必须满足从该条件语句的另一个分支出发的路径集合中至少有一条路径会经过Sink语句;否则反转后产生的新Trace不会经过Sink,更不可能存在Source到Sink的污点传播路径。</p>
                </div>
                <div class="p1">
                    <p id="65">条件语句处的活变量信息通过对Android应用进行跨方法的活变量分析得到。活变量分析问题是一种典型的数据流分析问题,FlowDroid<citation id="436" type="reference"><link href="413" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>将跨方法的数据流分析问题统一转换为程序间的有限分配子集(Interprocedural, Finite, Distributive Subset, IFDS)<citation id="437" type="reference"><link href="415" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>问题,按照框架抽取的“exploded super graph”中的不同流边定义相应的流处理方法,操作具体数据事实的传播动作即可实现活变量分析。Android程序在执行过程会大量调用系统回调方法,例如Activity的onCreate、onResume, Button按钮注册的点击事件方法等,这些方法没有显示调用。在FlowDroid构建的跨方法控制流图(Inter-procedural CFG, ICFG)中,这些回调方法可能会成为孤立节点,也就是说,从ICFG中的入口节点无法到达这些孤立点。因此在进行静态分析时,通过它们传递的方法间数据流事实将会丢失,导致分析结果不精确。因此,方法在实现活变量分析时作了保守处理,认为这类回调方法将出口处的活变量数据流事实传递给了ICFG中所有其他节点,但是不包括调用方法内部的节点。</p>
                </div>
                <div class="p1">
                    <p id="66">为判定从条件语句的另一个分支出发的路径集合中是否至少存在一条路径经过Sink,方法引入必经节点(dominator)的概念,如果每一条从流图的入口节点到节点<i>n</i>的路径都经过节点<i>d</i>,则认为<i>d</i>支配(dominate)<i>n</i>,称作<i>d</i>是<i>n</i>的必经节点,记为“<i>d</i> dom <i>n</i>”。例如图3(a),从节点0出发,3号节点是4号节点的必经节点;并且每个节点都是自己的必经节点。</p>
                </div>
                <div class="p1">
                    <p id="67">通过反转路径条件来遍历Source到Sink每条可行路径时,需要反转的每条条件语句的分支汇聚点必须在Sink之前。也就是说,沿着其在CFG中不同分支路径的汇聚点开始深度遍历CFG产生的节点序列必须包含Sink节点。因为Trace中出现的每条条件语句已经有一条分支路径经过了Sink节点,所以如果从该条件语句的两个不同分支出发的两个路径集合都至少存在一条经过Sink节点的路径,显然该条件语句的另一个分支出发的路径集合满足至少存在一条经过Sink的路径。</p>
                </div>
                <div class="area_img" id="68">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201910038_068.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 程序流图实例" src="Detail/GetImg?filename=images/JSJY201910038_068.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 程序流图实例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201910038_068.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.3 Example of program flow graph</p>

                </div>
                <div class="p1">
                    <p id="69">根据上述分析,在判断条件语句是否满足第2)条选择策略的方法时,生成方法体的反向控制流图(Reverse Control Flow Fraph, RCFG),选择同时满足以下条件的条件语句进行反转:</p>
                </div>
                <div class="p1">
                    <p id="70">1)以Sink节点作为起点,Sink节点是条件语句节点的必经节点(dominator);</p>
                </div>
                <div class="p1">
                    <p id="71">2)从Sink节点开始深度遍历RCFG得到的节点序列,包含条件语句节点的两个直接前继节点。</p>
                </div>
                <div class="p1">
                    <p id="72">Java代码片段如下:</p>
                </div>
                <div class="p1">
                    <p id="73">public static void main(String args) {</p>
                </div>
                <div class="p1">
                    <p id="74">1)String line=source();</p>
                </div>
                <div class="p1">
                    <p id="76">2)if (line.equals("save") {</p>
                </div>
                <div class="p1">
                    <p id="78">3)if (Math.random() &gt; 10) {</p>
                </div>
                <div class="p1">
                    <p id="80">4)System.out.println("Inner branch1.");</p>
                </div>
                <div class="p1">
                    <p id="82">5)} else {</p>
                </div>
                <div class="p1">
                    <p id="84">6)System.out.println("Inner branch2.");</p>
                </div>
                <div class="p1">
                    <p id="86">7)}</p>
                </div>
                <div class="p1">
                    <p id="88">8)sink(line);</p>
                </div>
                <div class="p1">
                    <p id="90">9)}</p>
                </div>
                <div class="p1">
                    <p id="92">10)System.out.println("Finish!");}</p>
                </div>
                <div class="p1">
                    <p id="94">图3(b)中每个节点的标号对应代码行号。以这个CFG为例,置反后就得到图3(c)中的RCFG。在RCFG子图中,以节点8作为起点,它是节点3的必经节点,满足条件1)。然后从节点8开始深度遍历,获得的节点序列是8→4→3→2→1→6,其中包含节点3的直接前继节点4和节点6,满足条件2),所以可以选择反转节点3处的条件。然而,前面得到的深度遍历序列中,只包含了节点2的直接前继3,没有包含另一个前继节点10,所以不满足条件2),因此对节点2处的条件语句不能进行反转。</p>
                </div>
                <h3 id="95" name="95" class="anchor-tag">3 原型实现</h3>
                <div class="p1">
                    <p id="96">原型系统由插桩模块、别名分析模块、污点分析模块和路径条件反转验证模块组成,如图4所示。</p>
                </div>
                <div class="area_img" id="97">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201910038_097.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 原型系统模块" src="Detail/GetImg?filename=images/JSJY201910038_097.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 原型系统模块  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201910038_097.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.4 Diagram of prototype system modules</p>

                </div>
                <h4 class="anchor-tag" id="98" name="98">3.1 <b>别名分析模块</b></h4>
                <div class="p1">
                    <p id="99">别名分析的基础是方法调用现场信息,重点是方法调用过程中的实参与形参的映射关系。定义数据结构“Stack〈HashMap〈String, Object〉〉”记录方法调用现场信息,每个现场元素以HashMap〈String, Object〉键-值对的形式存储,包含两种信息:一是“position”,表示方法调用语句在Trace中的位置信息,直接从Trace中记录的语句信息获得。二是“actual_formal_map”,使用“LinkedList〈Pair〈Object, Object〉〉”类型,根据方法签名存储实参与形参之间的映射关系,Pair的第一个元素表示实参,第二个元素表示形参;LinkedList中最后一个元素用于记录实例方法的this引用的传递信息,如果不是实例方法调用语句则不记录。</p>
                </div>
                <div class="p1">
                    <p id="100">别名分析模块按Trace中的指令顺序模拟实际运行时动态分配的内存空间,在每块内存空间中记录所有指向该内存空间的别名引用,即别名集合。根据不同语句类型判断别名信息的传递,进而跟踪内存空间的别名信息的变化。内存空间的数据结构定义如下:</p>
                </div>
                <div class="p1">
                    <p id="101">LinkedList〈Pair〈HashSet〈HashMap〈String, Object〉〉,</p>
                </div>
                <div class="p1">
                    <p id="102">HashSet〈HashMap〈String, Object〉〉〉〉</p>
                </div>
                <div class="p1">
                    <p id="103">以链表的形式存储程序申请的所有内存块,其中每一个Pair代表一个内存块,在每个内存块中记录了两种信息:别名信息和内存块信息。它们各映射成一个集合(HashSet),分别是PointsToSet和BlocksSet。PointsToSet记录所有指向该内存块的变量,集合中的所有变量它们之间都互为别名。BlocksSet记录的是内存块集合。集合中的元素类型是HashMap〈String, Object〉,每个元素记录了申请内存块的位置信息、内存块的子空间位置信息和内存块的污点信息,具体字段记录的内容如表1所示。</p>
                </div>
                <div class="area_img" id="104">
                    <p class="img_tit"><b>表</b>1 <b>内存块记录的信息</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit">Tab.1 Recorded information of memory block</p>
                    <p class="img_note"></p>
                    <table id="104" border="1"><tr><td><br />字段名</td><td>记录内容含义</td></tr><tr><td><br />block_id</td><td>内存块在内存块链中的编号</td></tr><tr><td><br />block_position</td><td>在Trace中分配内存块的位置</td></tr><tr><td><br />block_sub_instances</td><td>内存块的所有子域对象指向的内存块位置信息</td></tr><tr><td><br />block_sub_arrayItems</td><td>内存块的所有数组元素对象指向的内存块位置信息</td></tr><tr><td><br />block_tainted_state</td><td>内存块的污点状态信息</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="105">依照表1的定义,顺序遍历Trace中的语句信息,分析每条指令并跟踪别名信息的传递过程。对Android应用执行时的别名信息产生影响的语句类型共有四种,分别是参数传递语句(IdentityStmt)、赋值语句(AssignStmt)、方法调用语句(InvokeStmt)和方法返回语句(ReturnStmt)。</p>
                </div>
                <h4 class="anchor-tag" id="106" name="106">3.1.1 参数传递语句(IdentityStmt)</h4>
                <div class="p1">
                    <p id="107">在分析参数传递语句时,查找记录的方法调用现场信息中是否包含实参与形参之间的映射关系,如果包含则将形参指针信息添加到实参所指向的内存块的别名指针集合(PointsToSet)中。例如图5中第13)行发生的自定义方法调用,后面紧跟着参数的传递过程,实参$r6、“Jordan”和26分别传递给下面的$r1、$r0和$i0(图5中箭头①②③),即它们两两互为别名。</p>
                </div>
                <div class="p1">
                    <p id="108">由于Android程序中存在大量的底层系统回调方法,并且Trace仅包含APK的应用程序代码,不包含Android框架代码,所以有时会无法匹配方法调用时实参和形参的映射关系。在这种情形下需要按参数传递语句右值的不同类型分别记录数据流传递:</p>
                </div>
                <div class="area_img" id="109">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201910038_109.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 Trace执行语句片段示例" src="Detail/GetImg?filename=images/JSJY201910038_109.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 Trace执行语句片段示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201910038_109.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.5 Example of Trace snippet</p>

                </div>
                <div class="p1">
                    <p id="110">1)右值类型是ThisRef(图5第4)行语句),代表这是this引用的传递。在记录的内存块链中反向查询与方法this引用类型一致的内存块,如果找到则近似认为左值引用是指向该内存块,否则直接视为在当前语句位置为左值分配新的内存空间;在图5第4)行语句处没有与$r9匹配的实参,所以反向查找类型一致的内存块,定位到第1)行的$r0所指向的内存块,即$r0与$r9互为别名。</p>
                </div>
                <div class="p1">
                    <p id="111">2)右值类型是ParameterRef(图5第5)行语句),代表这是方法调用的参数传递,可直接认为左值在该语句处分配新的内存空间。</p>
                </div>
                <div class="p1">
                    <p id="112">3)此外,参数传递语句中右值还有一种类型:CaughtExceptionRef,表示传递抛出异常变量的信息,如图5中第65)行的语句;它实际上是接收上面第64)行抛出的异常变量$r26,别名信息的传递如图中④号箭头方向所示。为记录异常抛出时参数的传递,方法在遍历Trace的过程中定义一个栈(throw_value_stack),每遇到一条异常抛出语句(ThrowStmt)抛出异常变量时,就压栈记录抛出的异常变量所指向的内存块的位置信息。当遇到接收抛出异常变量的参数传递语句时,可直接将语句的左值引用指向throw_value_stack的栈顶元素代表的内存块。</p>
                </div>
                <h4 class="anchor-tag" id="113" name="113">3.1.2 赋值语句(AssignStmt)</h4>
                <div class="p1">
                    <p id="114">赋值语句的特点是将左值引用指向右值标识的内存空间,记录赋值语句的别名数据流事实传递分为三步:</p>
                </div>
                <div class="p1">
                    <p id="115">1)在别名指针集合中清除已记录的与左值相关的指针信息,同时清除包括记录相关内存块之间关系(父子域或数组元素域)的信息;</p>
                </div>
                <div class="p1">
                    <p id="116">2)具体定位右值引用指向的内存块,将左值指针信息加入该内存块的别名指针集合中;</p>
                </div>
                <div class="p1">
                    <p id="117">3)调整与左值相关的别名信息,如访问路径中父域记录的子域信息。</p>
                </div>
                <div class="p1">
                    <p id="118">第2)～3)需要根据赋值语句的右值和左值的具体类型进行不同的操作。</p>
                </div>
                <div class="p1">
                    <p id="119">第2)步定位右值引用指向的内存块,分为几种情况:</p>
                </div>
                <div class="p1">
                    <p id="120">①右值是Local(局部变量)或CastExpr(强制类型转换表达式)时,在记录的内存块链中查找右值指向的内存块,然后直接将左值指针添加到内存块的别名指针集合中。例如图5中第32)行的$r7[1]指向$r11原来的内存块,第37)行语句执行后$r13和$r14互为别名。</p>
                </div>
                <div class="p1">
                    <p id="121">②右值类型是InvokeExpr、NewExpr、BinopExpr、InstanceOfExpr、UnopExpr或Constant时,分别对应图5第8)、10)、39)、34)、43)和11)行的语句,即认为在执行语句处为左值分配新的内存空间。</p>
                </div>
                <div class="p1">
                    <p id="122">③右值类型属于StaticFieldRef、InstanceFieldRef或ArrayRef时,分别对应图5第51)、58)和33)行,如果不能找到右值对应的内存块,可以在满足污点传播一致性约束的前提下,根据父域的污点状态分配新的内存块。例如a已经是完全污染的,当第一次使用a.f对象时为其分配新的内存块,新内存块也标记为完全污染;但如果a是部分污染或可信时,新分配的a.f的内存块应该标记为可信。定位好右值指向的内存块后,直接将左值引用添加到内存块的别名集合中即可。</p>
                </div>
                <div class="p1">
                    <p id="123">第3)步调整与左值相关的别名信息,主要是对左值类型是静态域(StaticFieldRef)、实例域(InstanceFieldRef)和数组元素(ArrayRef)三种情形做调整:</p>
                </div>
                <div class="p1">
                    <p id="124">1)左值是静态域时,找出所有类型是静态域所在类的类型的内存块,将这些内存块中记录的相应静态子域空间的位置标识修改为右值所指向的位置。例如图5第11)行的静态域type所在类的类型是Person,所以查找所有类型是Person的内存块,并将这些内存块的type子域的内存空间位置标识成第11)行右值所指向的内存位置。</p>
                </div>
                <div class="p1">
                    <p id="125">2)左值是实例域或数组元素时,分别找到实例域的父对象或数组对象所指向的内存块,将记录子域内存块位置的标识修改为相应的右值的内存块位置。例如图5第18)和19)行$r1的两个子域对象name和age分别指向$r0和$i0,那么父对象$r1中记录的子域集合中的信息也需要调整,如图6(a)所示。再有图5第26)和32)行,分别将$r10和$r11赋值给数组元素$r7[0]和$r7[1],那么对应的数组对象$r7中记录的数组下标0和1的元素分别指向$r10和$r11指向的内存块,如图6(b)所示。</p>
                </div>
                <div class="area_img" id="126">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJY201910038_126.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 别名示意图" src="Detail/GetImg?filename=images/JSJY201910038_126.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 别名示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJY201910038_126.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.6 Diagram of alias</p>

                </div>
                <h4 class="anchor-tag" id="127" name="127">3.1.3 方法调用语句(InvokeStmt)</h4>
                <div class="p1">
                    <p id="128">在Java中,方法调用语句不会对已记录的内存块链和别名集合造成太大的影响,加上之前已经对参数传递语句进行过分析(确保实参-形参互为别名),所以在方法调用语句处无需过多的操作。但有一种情况例外,就是调用对象实例初始化方法(〈init〉),该方法表示在被调用位置给方法调用的this变量分配内存空间;因此需要将this变量所对应的内存块分配位置(position)修改为〈init〉方法的调用位置。如图5中第2)行的变量$r0,它指向的内存块的分配位置应该修改成这条语句所在的位置。一般调用〈init〉方法都是紧跟在实例对象New完之后,所以在调用〈init〉方法之前在内存块链中就已经记录了实例对象的内存块。</p>
                </div>
                <h4 class="anchor-tag" id="129" name="129">3.1.4 方法返回语句(ReturnStmt)</h4>
                <div class="p1">
                    <p id="130">如果在方法调用现场接收方法的返回值,即方法调用现场是赋值语句,那么接收变量就与方法的返回值变量互为别名,如图5中⑤号箭头标识的$r1接收返回语句的返回值r0,它们互为别名。随后具体别名信息传递的操作与前面赋值语句的处理过程类似,相当于把赋值语句中的右值替换成方法返回语句的返回变量。</p>
                </div>
                <h4 class="anchor-tag" id="131" name="131">3.2 <b>污点分析模块</b></h4>
                <div class="p1">
                    <p id="132">根据获得的别名分析结果,将污点状态信息标记到别名变量指向的内存块上,以此来跟踪污点传播过程。污点分析中传递的数据流事实是被污染变量的污染状态集合,称为污点状态集合。在污点状态集合中的每个元素以二元组的形式定义(var, taint_level),其中:var表示变量的访问路径(Access Path);taint_level表示被污染变量的受污染程度。方法规定三种污染程度:部分污染(pa)、完全污染(ta)和可信(trust)。影响污点数据流传播的执行语句包括方法调用语句和赋值语句。</p>
                </div>
                <div class="p1">
                    <p id="133">方法调用语句分为调用库方法和调用自定义方法。分析库方法调用时,以污点传播摘要的方式对库方法执行产生的污点信息流建模,根据具体的摘要调整并记录方法执行后各相关内存块的污点状态信息。分析自定义方法调用时需进一步递归分析方法体内部每条语句的污点传播语义来实现跨方法污点传播过程。</p>
                </div>
                <div class="p1">
                    <p id="134">分析赋值语句时,首先按赋值语句右值的不同类型定义污点传播语义规则,依照规则记录污点传播过程;然后再按左值的不同类型,调整相关变量的污点状态信息。对内存块的污点状态信息的修改或调整都必须满足污点传播的一致性约束,避免错误记录污点传播信息。</p>
                </div>
                <div class="p1">
                    <p id="135">在污点分析过程中,如果变量a.f的污点状态改变,那么a的污点状态应该作相应的调整。同时,对所有与a互为别名的实例域、数组元素和静态域,需要对与它们相关的内存块(父域内存块、数组对象内存块)的污点信息作进一步调整。此时存在一个向上递归调整相关变量的污点状态信息的过程,方法将它定义为up_transmit_taint(var, tainted_level, deepth),其中:参数var表示发生污点状态改变的变量,tainted_level表示改变的污染程度。递归深度变量deepth记录每次递归的深度,用于控制向上递归调整污点状态信息的最大递归层数(一般不超过5层)。up_transmit_taint方法根据已发生污点状态改变的变量类型调整污点状态信息,分为如下三种情形(MustAlias(a)表示所有肯定与a互为别名的变量集合)。</p>
                </div>
                <h4 class="anchor-tag" id="136" name="136">1)发生污点状态变化的变量是实例域对象。</h4>
                <div class="p1">
                    <p id="137">根据实例域和它的父域的污点状态信息的不同,分别对污点状态信息做不同的调整操作,共存在三种情况:</p>
                </div>
                <div class="p1">
                    <p id="138">① (a.f, pa)∉X∧(a.f, ta)∉X∧(a, ta)∈X</p>
                </div>
                <div class="p1">
                    <p id="139">→(b, pa)∈Y∧Y∪up_taint_transmit(b, pa,</p>
                </div>
                <div class="p1">
                    <p id="140">--deepth); ∀b.c∈MustAlias(a)</p>
                </div>
                <div class="p1">
                    <p id="141">② (a.f, pa)∈X</p>
                </div>
                <div class="p1">
                    <p id="142">→(a, pa)∈Y∧(b, pa)∈Y ∧Y∪up_taint_transmit(b,</p>
                </div>
                <div class="p1">
                    <p id="143">pa, --deepth); ∀b.c∈MustAlias(a)</p>
                </div>
                <div class="p1">
                    <p id="144">③ (a.f, ta)∈X∧(a, ta)∉X</p>
                </div>
                <div class="p1">
                    <p id="145">→(a, pa)∈Y∧Y∪up_taint_transmit(b, pa,</p>
                </div>
                <div class="p1">
                    <p id="146">--deepth); ∀b.c∈MustAlias(a)</p>
                </div>
                <div class="p1">
                    <p id="147">第①种情况表示如果实例域是可信的并且父域是完全污染,那么将父域调整为部分污染,接着对父域的别名继续向上递归调整;第②种情况表示实例域是部分污染,那么直接将父域标记成部分污染,然后对父域的别名向上递归调整;第③种情况表示如果实例域完全污染,并且父域不是完全污染,那么父域应该调整为部分污染,接着对父域的别名递归向上调整。</p>
                </div>
                <h4 class="anchor-tag" id="148" name="148">2)发生污点状态改变的变量是数组元素时。</h4>
                <div class="p1">
                    <p id="149">为保证数组对象和各元素的污点状态信息的一致性,方法保守地规定数组中只要有一个元素不可信,就将整个数组标记为被完全污染,其中所有元素都标记为不可信,而且数组中所有元素的污点状态都保持一致,即数组元素要么可信要么完全污染。</p>
                </div>
                <h4 class="anchor-tag" id="150" name="150">3)发生污点状态改变的变量是静态域对象。</h4>
                <div class="p1">
                    <p id="151">调整相关污点状态信息的操作与1)相同,但需要对其他与静态域所属类的类型相同的所有变量都进行调整,因为静态域属性被所有实例对象共享。</p>
                </div>
                <h4 class="anchor-tag" id="152" name="152">3.3 <b>路径条件反转验证模块</b></h4>
                <div class="p1">
                    <p id="153">为遍历Source到Sink的所有可执行路径,方法通过收集Source到Sink之间的条件语句,结合程序变换方法,反转路径条件来覆盖所有路径。为缓解路径爆炸问题,设计了反转条件的选择策略,即选择满足2.2节中的两条选择策略。</p>
                </div>
                <div class="p1">
                    <p id="154">第1)条选择策略判断是否存在活的被污染变量,通过静态的跨方法分析,收集每条语句处的活变量信息。方法基于FlowDroid中提供的IFDS框架,定义四种相应的流方法,完成对活变量数据流事实的传递,实现跨方法的活变量分析。算法1用于判断第2)条选择策略,结合反向Dominator和深度遍历方法。Global声明全局变量,共定义了4个函数:Is_reverse、Domination、DFS和Contain。其中DFS是经典深度遍历算法,Domination判断在图graph中以start为起点的图中各节点之间的必经节点(dominator)关系。Contain分别从条件语句的两个分支开始遍历路径,判断遍历的节点序列是否都经过参数stmt的语句节点,结果记录在全局变量contains中。Is_reverse函数判断条件语句是否可以加入反转条件的集合中。</p>
                </div>
                <div class="p1">
                    <p id="155">算法1 判断从条件语句的另一个分支出发的所有路径中至少有一条路径会经过Sink。</p>
                </div>
                <div class="p1">
                    <p id="156">输入 方法体的反向控制流图RCFG;条件语句IfStmt;污点汇聚节点Sink。</p>
                </div>
                <div class="p1">
                    <p id="157">输出 是否反转输入的条件语句。</p>
                </div>
                <div class="p1">
                    <p id="158">Global: N, adjacent_matrix, domination, visited, contains, nodeToId;</p>
                </div>
                <div class="p1">
                    <p id="159">function Is_reverse(sink, IfStmt, RCFG)</p>
                </div>
                <div class="p1">
                    <p id="160">Domination(sink, RCFG);</p>
                </div>
                <div class="p1">
                    <p id="161">if domination then</p>
                </div>
                <div class="p1">
                    <p id="162">foreach pre in graph.getPredsOf(IfStmt) do</p>
                </div>
                <div class="p1">
                    <p id="163">/*getPredsOf是在RCFG中得到IfStmt的所有前继节点*/</p>
                </div>
                <div class="p1">
                    <p id="164">contains ← false;</p>
                </div>
                <div class="p1">
                    <p id="165">Contains(IfStmt, sink, RCFG, set);</p>
                </div>
                <div class="p1">
                    <p id="166">if (contains= false) then</p>
                </div>
                <div class="p1">
                    <p id="167">return false;</p>
                </div>
                <div class="p1">
                    <p id="168">end if</p>
                </div>
                <div class="p1">
                    <p id="169">end foreach</p>
                </div>
                <div class="p1">
                    <p id="170">end if</p>
                </div>
                <div class="p1">
                    <p id="171">return true;</p>
                </div>
                <div class="p1">
                    <p id="172">end function</p>
                </div>
                <div class="p1">
                    <p id="173">function Domination(graph, start)</p>
                </div>
                <div class="p1">
                    <p id="174">N ← graph.size();</p>
                </div>
                <div class="p1">
                    <p id="175">count ← 0;</p>
                </div>
                <div class="p1">
                    <p id="176">foreach node in graph do</p>
                </div>
                <div class="p1">
                    <p id="177">nodeToId.put(node,++count);</p>
                </div>
                <div class="p1">
                    <p id="178">end foreach</p>
                </div>
                <div class="p1">
                    <p id="179">foreach node in graph do</p>
                </div>
                <div class="p1">
                    <p id="180">foreach succ in graph.getSuccsOf(node) do</p>
                </div>
                <div class="p1">
                    <p id="181">/* getSuccsOf是在graph中得到start的所有后继节点 */</p>
                </div>
                <div class="p1">
                    <p id="182">adjacent_matrix ← true</p>
                </div>
                <div class="p1">
                    <p id="183">end foreach</p>
                </div>
                <div class="p1">
                    <p id="184">end foreach</p>
                </div>
                <div class="p1">
                    <p id="185">DFS(nodeToId.get(start), -1);</p>
                </div>
                <div class="p1">
                    <p id="186">reachable ← visited;</p>
                </div>
                <div class="p1">
                    <p id="187">for i ← 0 to N do</p>
                </div>
                <div class="p1">
                    <p id="188">DFS(nodeToId.get(start), i);</p>
                </div>
                <div class="p1">
                    <p id="189">for j ← 0 to N do</p>
                </div>
                <div class="p1">
                    <p id="190">if reachable[j]=true and visited[j]= false then</p>
                </div>
                <div class="p1">
                    <p id="191">domination[i]=true;</p>
                </div>
                <div class="p1">
                    <p id="192">end if</p>
                </div>
                <div class="p1">
                    <p id="193">end for</p>
                </div>
                <div class="p1">
                    <p id="194">end for</p>
                </div>
                <div class="p1">
                    <p id="195">end function</p>
                </div>
                <div class="p1">
                    <p id="196">function DFS(start, ignore)</p>
                </div>
                <div class="p1">
                    <p id="197">if start=ignore then</p>
                </div>
                <div class="p1">
                    <p id="198">return;</p>
                </div>
                <div class="p1">
                    <p id="199">end if</p>
                </div>
                <div class="p1">
                    <p id="200">visited ← true;</p>
                </div>
                <div class="p1">
                    <p id="201">for i ← 0 to N - 1 do</p>
                </div>
                <div class="p1">
                    <p id="202">if (adjacent_matrix[i]=true and visited[i] ≠ true) then</p>
                </div>
                <div class="p1">
                    <p id="203">DFS(i, ignore);</p>
                </div>
                <div class="p1">
                    <p id="204">end if</p>
                </div>
                <div class="p1">
                    <p id="205">end for</p>
                </div>
                <div class="p1">
                    <p id="206">end function</p>
                </div>
                <div class="p1">
                    <p id="207">function Contain(stmt, start, graph, set)</p>
                </div>
                <div class="p1">
                    <p id="208">put start into set;</p>
                </div>
                <div class="p1">
                    <p id="209">if (start=stmt) then</p>
                </div>
                <div class="p1">
                    <p id="210">contains ← true;</p>
                </div>
                <div class="p1">
                    <p id="211">end if</p>
                </div>
                <div class="p1">
                    <p id="212">foreach succ in graph.getSuccsOf(start) do</p>
                </div>
                <div class="p1">
                    <p id="213">if (set not contains succ) then</p>
                </div>
                <div class="p1">
                    <p id="214">Contain(stmt, succ, graph, set);</p>
                </div>
                <div class="p1">
                    <p id="215">end if</p>
                </div>
                <div class="p1">
                    <p id="216">end foreach</p>
                </div>
                <div class="p1">
                    <p id="217">End function</p>
                </div>
                <h3 id="218" name="218" class="anchor-tag">4 实验分析</h3>
                <div class="p1">
                    <p id="219">原型系统基于Soot-trunk 3.0和FlowDroid 2.0框架实现,使用JDK 1.8开发,总计8 000余行代码,其中插桩模块1 400余行,分析模块4 300余行,路径条件反转验证模块2 200余行。实验环境为Genymotion搭建的模拟器,运行系统版本为Android 4.4,操作系统版本是Ubuntu 18.04.1 LTS,处理器i5-3230M,CPU 2.6 GHz,内存8 GB。</p>
                </div>
                <div class="p1">
                    <p id="220">实验测试选取DroidBench 2.0作为测试数据集,它包含了13类共119个Android应用。剔除跨组件通信、应用间通信和多线程等3类测试样本共34个,原型系统目前还不支持这三类的应用程序。另外还剔除了实验环境无法模拟的10个样本,并在Android开源软件仓库F-Droid和Github上采集10个真实的Android应用,最后,对85个Android应用样本进行实验。</p>
                </div>
                <div class="p1">
                    <p id="221">FlowDroid对其中77个样本报告71个泄露缺陷,每个缺陷都只存在一条可执行路径。经过别名分析和污点分析后,方法准确地验证其中7个泄露是虚警。</p>
                </div>
                <div class="p1">
                    <p id="222">下面以实验中的一段Android程序源码片段作为例,简述在实验过程中,验证只存在一条可执行路径的泄露缺陷是否虚警的流程。</p>
                </div>
                <div class="p1">
                    <p id="223">…</p>
                </div>
                <div class="p1">
                    <p id="224">3)protected void onCreate(Bundle savedInstanceState) {</p>
                </div>
                <div class="p1">
                    <p id="226">…</p>
                </div>
                <div class="p1">
                    <p id="227">7)button1.setOnClickListener(new View.OnClickListener() {</p>
                </div>
                <div class="p1">
                    <p id="229">8)public void onClick(View view) {</p>
                </div>
                <div class="p1">
                    <p id="231">9)SmsManager sms=SmsManager.getDefault();</p>
                </div>
                <div class="p1">
                    <p id="233">…</p>
                </div>
                <div class="p1">
                    <p id="234">11)sms.sendTextMessage(number, null. imei, null, null);  // sink, potential leak;</p>
                </div>
                <div class="p1">
                    <p id="236">12)Log.i("TAG", "sendIMEI:"+imei);  // sink potential leak</p>
                </div>
                <div class="p1">
                    <p id="238">13)imei=null;</p>
                </div>
                <div class="p1">
                    <p id="240">14)}</p>
                </div>
                <div class="p1">
                    <p id="242">15)});</p>
                </div>
                <div class="p1">
                    <p id="244">17)button2.setOnClickListener(new View.OnClickListener() {</p>
                </div>
                <div class="p1">
                    <p id="246">18)public void onClick(View v) {</p>
                </div>
                <div class="p1">
                    <p id="248">19)imei=null;</p>
                </div>
                <div class="p1">
                    <p id="250">20)Log.i("TAG", "Button2:"+imei);  // sink, leak</p>
                </div>
                <div class="p1">
                    <p id="252">21)}</p>
                </div>
                <div class="p1">
                    <p id="254">22)  });</p>
                </div>
                <div class="p1">
                    <p id="255">23)}</p>
                </div>
                <div class="p1">
                    <p id="257">24)public void clickOnButton3(View view) {</p>
                </div>
                <div class="p1">
                    <p id="259">25)TelephonyManager telephonyManager=(TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);</p>
                </div>
                <div class="p1">
                    <p id="261">26)imei=telephonyManager.getDeviceId();  // source</p>
                </div>
                <div class="p1">
                    <p id="263">27)Log.i("TAG", "Button3:"+imei);  // sink, leak</p>
                </div>
                <div class="p1">
                    <p id="265">28)}</p>
                </div>
                <div class="p1">
                    <p id="267">…</p>
                </div>
                <div class="p1">
                    <p id="268">FlowDroid报告其中第26)行Source分别传播到第11)、12)、20)和27)行Sink的4条泄露。但其中button2按钮点击事件的处理方法在第20)行Sink调用Source变量imei之前,imei变量已经被置空,即此时imei变为可信的,同时,由于这对Source-Sink之间只存在一条路径,因此方法判断这条(Source,Sink)泄露是虚警。</p>
                </div>
                <div class="p1">
                    <p id="269">针对其余的8个样本程序的实验结果如表2所示。</p>
                </div>
                <div class="area_img" id="270">
                    <p class="img_tit"><b>表</b>2 <b>采用本文方法验证</b>FlowDroid<b>告警的实验结果</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit">Tab.2 Experimental results of validation for alarm in FlowDroid by the proposed method</p>
                    <p class="img_note"></p>
                    <table id="270" border="1"><tr><td>编号</td><td>名称</td><td>代码行数</td><td>验证条目数</td><td>反转路径数</td><td>总路径数</td><td>验证结果</td><td>平均减少反转路径占比/%</td></tr><tr><td><br />1</td><td>Merge1</td><td>83</td><td>1</td><td>2</td><td>2</td><td>虚警</td><td>—</td></tr><tr><td rowspan="2"><br />2</td><td rowspan="2">VirtualDispath1</td><td rowspan="2">68</td><td><br />1</td><td>0</td><td>2</td><td>泄露</td><td>—</td></tr><tr><td><br />1</td><td>4</td><td>4</td><td>虚警</td><td>0.00</td></tr><tr><td><br />3</td><td>PrivateDataLeak1</td><td>94</td><td><br />1</td><td>0</td><td>8</td><td>泄露</td><td>—</td></tr><tr><td rowspan="2"><br />4</td><td rowspan="2">Encrypt</td><td rowspan="2">100</td><td><br />1</td><td>4</td><td>32</td><td>虚警</td><td>87.50</td></tr><tr><td><br />1</td><td>0</td><td>1</td><td>泄露</td><td>—</td></tr><tr><td rowspan="5"><br />5</td><td rowspan="5">LocalLogin</td><td rowspan="5">220</td><td><br />6</td><td>0</td><td>1</td><td>泄露</td><td>—</td></tr><tr><td><br />3</td><td>0</td><td>8</td><td>泄露</td><td>—</td></tr><tr><td><br />2</td><td>0</td><td>4</td><td>泄露</td><td>—</td></tr><tr><td><br />2</td><td>4</td><td>64</td><td>虚警</td><td>93.75</td></tr><tr><td><br />2</td><td>4</td><td>8</td><td>虚警</td><td>50.00</td></tr><tr><td rowspan="7"><br />6</td><td rowspan="7">SendMail</td><td rowspan="7">554</td><td><br />3</td><td>0</td><td>8</td><td>泄露</td><td>—</td></tr><tr><td><br />2</td><td>0</td><td>32</td><td>泄露</td><td>—</td></tr><tr><td><br />2</td><td>0</td><td>8</td><td>虚警</td><td>87.50</td></tr><tr><td><br />1</td><td>0</td><td>2 048</td><td>虚警</td><td>99.90</td></tr><tr><td><br />1</td><td>0</td><td>4 096</td><td>虚警</td><td>99.90</td></tr><tr><td><br />2</td><td>4</td><td>1 024</td><td>虚警</td><td>99.60</td></tr><tr><td><br />1</td><td>4</td><td>64</td><td>虚警</td><td>93.75</td></tr><tr><td><br />7</td><td>KnonWeather</td><td>119</td><td><br />1</td><td>0</td><td>4</td><td>虚警</td><td>75.00</td></tr><tr><td rowspan="13"><br />8</td><td rowspan="13">通讯管家</td><td rowspan="13">2 279</td><td><br />2</td><td>0</td><td>256</td><td>泄露</td><td>—</td></tr><tr><td><br />1</td><td>0</td><td>128</td><td>泄露</td><td>—</td></tr><tr><td><br />4</td><td>0</td><td>1</td><td>虚警</td><td>—</td></tr><tr><td><br />6</td><td>0</td><td>1</td><td>泄露</td><td>—</td></tr><tr><td><br />5</td><td>0</td><td>2</td><td>泄露</td><td>—</td></tr><tr><td><br />5</td><td>0</td><td>8</td><td>泄露</td><td>—</td></tr><tr><td><br />2</td><td>0</td><td>16</td><td>泄露</td><td>—</td></tr><tr><td><br />4</td><td>0</td><td>64</td><td>泄露</td><td>—</td></tr><tr><td><br />1</td><td>0</td><td>128</td><td>虚警</td><td>99.90</td></tr><tr><td><br />1</td><td>0</td><td>4</td><td>虚警</td><td>75.00</td></tr><tr><td><br />3</td><td>0</td><td>4</td><td>泄露</td><td>—</td></tr><tr><td><br />1</td><td>0</td><td>8</td><td>虚警</td><td>87.50</td></tr><tr><td><br />1</td><td>0</td><td>2</td><td>虚警</td><td>—</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="271">表2中第2组实验获得的种子Trace片段结构如下:</p>
                </div>
                <div class="p1">
                    <p id="272">1)$r0 = source();</p>
                </div>
                <div class="p1">
                    <p id="274">…</p>
                </div>
                <div class="p1">
                    <p id="275">2)if $i3 != 0 goto r0 = new de.ecspride.DataLeak</p>
                </div>
                <div class="p1">
                    <p id="277">…</p>
                </div>
                <div class="p1">
                    <p id="278">3)sink1($r0);</p>
                </div>
                <div class="p1">
                    <p id="280">…</p>
                </div>
                <div class="p1">
                    <p id="281">4)if $i3 != 0 goto r0 = new  de.ecspride.DataLeak</p>
                </div>
                <div class="p1">
                    <p id="283">…</p>
                </div>
                <div class="p1">
                    <p id="284">5)sink2("no leak");</p>
                </div>
                <div class="p1">
                    <p id="286">…</p>
                </div>
                <div class="p1">
                    <p id="287">6)use($r0)</p>
                </div>
                <div class="p1">
                    <p id="289">FlowDroid报告了2条泄露,分别是从第1)行source执行到第3)和5)行的sink1和sink2。对于从source到sink1的隐私泄露,在对种子Trace作污点分析时可以发现从source到sink1的污点传播路径,因此直接报告隐私泄露真实存在,无需反转。</p>
                </div>
                <div class="p1">
                    <p id="290">而验证source到sink2的隐私泄露,分析它们之间总共存在4条路径,路径遍历过程收集的反转路径条件语句是第2)和4)行的条件语句。经反转,包括种子Trace在内共遍历4条路径,没有发现任何从source到sink2的污点传播路径,验证结果是虚警。</p>
                </div>
                <div class="p1">
                    <p id="291">表2中第4组实验过程中记录的种子Trace片段如下:</p>
                </div>
                <div class="p1">
                    <p id="292">1)$r1 = source();</p>
                </div>
                <div class="p1">
                    <p id="294">…</p>
                </div>
                <div class="p1">
                    <p id="295">2)  if $z1 == 0 goto $r9 = $r4.&lt;com.example.encrypt.MainActivity: java.lang.String selected_algorithm&gt;</p>
                </div>
                <div class="p1">
                    <p id="296">…</p>
                </div>
                <div class="p1">
                    <p id="297">3)if $z3 == 0 goto $r10 = $r4.&lt;com.example.encrypt.MainActivity: java.lang.String selected_algorithm&gt;</p>
                </div>
                <div class="p1">
                    <p id="299">…</p>
                </div>
                <div class="p1">
                    <p id="300">4)encrypt($r1);</p>
                </div>
                <div class="p1">
                    <p id="302">…</p>
                </div>
                <div class="p1">
                    <p id="303">5)if $i0 &lt; $i2 goto $r10 = new java.lang.StringBuilder</p>
                </div>
                <div class="p1">
                    <p id="305">…</p>
                </div>
                <div class="p1">
                    <p id="306">6)if $z2 == 0 goto $r11 = $r4.&lt;com.example.encrypt.MainActivity: java.lang.String selected_length&gt;</p>
                </div>
                <div class="p1">
                    <p id="308">…</p>
                </div>
                <div class="p1">
                    <p id="309">7)if $z0 == 0 goto virtualinvoke $r0.&lt;android.widget.TextView: void setText(java.lang.CharSequence)&gt;($r6)</p>
                </div>
                <div class="p1">
                    <p id="311">…</p>
                </div>
                <div class="p1">
                    <p id="312">8)sink($r1);</p>
                </div>
                <div class="p1">
                    <p id="314">虽然在第8)行的sink处引用了第1)行的污点变量$r1,但是在第4)行调用的encrypt方法对$r1作了无害化处理,所以从第4)行往下的变量$r1变成可信。根据路径条件反转策略,虽然$r1在第5)～7)行都是活变量,但已经不是污点变量,因此不满足第①条选择策略,只需将第2)和3)行的条件语句加入到路径条件反转集合中。</p>
                </div>
                <div class="p1">
                    <p id="315">在第5组实验里获得的种子Trace片段如下所示:</p>
                </div>
                <div class="p1">
                    <p id="316">1)$r6 = source();</p>
                </div>
                <div class="p1">
                    <p id="318">…</p>
                </div>
                <div class="p1">
                    <p id="319">2)if $r3 != null goto $r5 = &lt;com.example.testtargetsample.DBHelper: com.example. testtargetsample.DBHelper instance&gt;</p>
                </div>
                <div class="p1">
                    <p id="321">…</p>
                </div>
                <div class="p1">
                    <p id="322">3)if $z0 == 0 goto $r43 = new java.lang.StringBuilder</p>
                </div>
                <div class="p1">
                    <p id="324">…</p>
                </div>
                <div class="p1">
                    <p id="325">4)sqlEscapeString($r6);</p>
                </div>
                <div class="p1">
                    <p id="327">…</p>
                </div>
                <div class="p1">
                    <p id="328">5)if $z2 == 0 goto $z3 = virtualinvoke $r8.&lt;java.lang.String: Boolean equals(java.lang.Object)&gt; ("administrator")</p>
                </div>
                <div class="p1">
                    <p id="330">…</p>
                </div>
                <div class="p1">
                    <p id="331">6)if $z3 == 0 goto (branch)</p>
                </div>
                <div class="p1">
                    <p id="333">…</p>
                </div>
                <div class="p1">
                    <p id="334">7)if $z4 == 0 goto (branch)</p>
                </div>
                <div class="p1">
                    <p id="336">…</p>
                </div>
                <div class="p1">
                    <p id="337">8)if $z5 != 0 goto $i2 = interfaceinvoke $r37.&lt;android.database.Cursor: int getInt(int)&gt;(1)</p>
                </div>
                <div class="p1">
                    <p id="339">…</p>
                </div>
                <div class="p1">
                    <p id="340">9)sink($r6);  // (sink反转在6、7、8的分支内部)</p>
                </div>
                <div class="p1">
                    <p id="342">在第4)行位置调用sqlEscapeString方法对污点变量$r6作了无害化处理,所以第4)行之后的语句已经没有活的污点变量。并且第6)～8)行的条件语句不满足第②条路径条件反转的选择策略。虽然存在64条执行路径,但只需要反转执行3条路径即可。</p>
                </div>
                <div class="p1">
                    <p id="343">第8组实验报告总共存在128条路径,但是无需反转即可验证结果是虚警,获得的种子Trace如下所示:</p>
                </div>
                <div class="p1">
                    <p id="344">1)$r0 = source();</p>
                </div>
                <div class="p1">
                    <p id="346">…(中间存在多条条件语句)</p>
                </div>
                <div class="p1">
                    <p id="347">2)sink("no leak");</p>
                </div>
                <div class="p1">
                    <p id="349">… (没有使用到污点变量$r0)</p>
                </div>
                <div class="p1">
                    <p id="350">Source到Sink之间的所有条件语句处的污点变量$r0都已经死了,即后续根本没有使用污点变量,所以这些条件语句都不用反转。</p>
                </div>
                <div class="p1">
                    <p id="351">MultiFlow通过检测是否组合绑定的多对Source能同时触发Sink来降低虚警率,包括两个分析阶段:1)单源分析,检测每一个Source是否传播到Sink;2)多源分析,以组合的方式检测多个Source能否绑定同时触发Sink。</p>
                </div>
                <div class="p1">
                    <p id="352">对比实验使用MultiFlow对相同的应用测试集进行分析,表3给出了MultiFlow与本文分析方法的实验结果对比。</p>
                </div>
                <div class="area_img" id="353">
                    <p class="img_tit"><b>表</b>3 MultiFlow<b>实验结果</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit">Tab.3 Experimental results of Multiflow</p>
                    <p class="img_note"></p>
                    <table id="353" border="1"><tr><td rowspan="2">编<br />号</td><td rowspan="2">名称</td><td rowspan="2">单源<br />分析数</td><td rowspan="2">多源<br />分析数</td><td colspan="2"><br />减少虚警率对比</td></tr><tr><td><br />本文方法<br />结果</td><td>MultiFlow<br />分析结果</td></tr><tr><td>1</td><td>Merge1</td><td>1</td><td>0</td><td>100.00</td><td>0.00</td></tr><tr><td><br />2</td><td>VirtualDispatch1</td><td>1</td><td>0</td><td>50.00</td><td>50.00</td></tr><tr><td><br />3</td><td>PrivateDataLeakage1</td><td>1</td><td>0</td><td>—</td><td>—</td></tr><tr><td><br />4</td><td>Encrypt</td><td>2</td><td>0</td><td>50.00</td><td>0.00</td></tr><tr><td><br />5</td><td>LocalLogin</td><td>10</td><td>3</td><td>26.67</td><td>33.33</td></tr><tr><td><br />6</td><td>SendMail</td><td>8</td><td>0</td><td>58.33</td><td>33.33</td></tr><tr><td><br />7</td><td>KnowWeather</td><td>1</td><td>0</td><td>100.00</td><td>0.00</td></tr><tr><td><br />8</td><td>通讯管家</td><td>32</td><td>0</td><td>22.22</td><td>11.11</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="354">第1组和第7组应用只存在一个Source,MultiFlow的多源分析阶段被阻断,导致MultiFlow未能正确验证虚警。虽然MutiFlow对第5和第8组应用正确验证了不少虚警,但是经过进一步人工分析源码,MultiFlow没有精确跟踪回调方法间的污点传播,导致将发生在回调方法间传递的污点传播路径误判为虚警。</p>
                </div>
                <div class="p1">
                    <p id="355">在MultiFlow对DroidBench的验证结果中,有3组应用的真实报警被误判为虚警。两组发生在回调方法中:一组是回调方法修改SharedPreference过程中的污点传播;另一组是回调方法构造Fragment过程中的污点传播;第三组是在多源分析阶段将2条泄露报警错误地合并成一条泄露报警。因此,本文方法相比MultiFlow的验证结果更为可靠。</p>
                </div>
                <div class="p1">
                    <p id="356">在85个样本应用中,平均遍历路径比为15.09%,虚警率平均降低58.17%,MultiFow将虚警率平均降低了18.25%。</p>
                </div>
                <div class="p1">
                    <p id="357">实验结果表明,本文方法能高效可靠地验证静态分析结果的正确性,在验证过程中裁剪不必要的路径遍历,极大缓解路径爆炸问题,提升验证效率。</p>
                </div>
                <h3 id="358" name="358" class="anchor-tag">5 结语</h3>
                <div class="p1">
                    <p id="359">本文提出一种半自动验证污点分析结果的正确性的方法,实现基于Trace的别名分析和污点分析,判定Trace中是否有Source到Sink的污点传播。设计一种路径剪枝方法,提出结合活变量分析的路径约束选择策略,以程序变换的方式搜索路径,极大缓解路径爆炸问题,基于FlowDroid实现的原型系统对真实的Android应用分析表明了方法的有效性。</p>
                </div>
                <div class="p1">
                    <p id="360">本文方法的不足主要包括:1)不支持跨组件、跨应用程序之间的数据通信过程的污点分析,对多线程并发的处理也不够完善;2)不支持Java语言的某些特性如反射,另外,对Android库方法的建模不完备,可能导致污点分析不精确;3)需要手工执行Android应用获得同时覆盖Source和Sink的初始种子Trace,当程序规模较大时,该项工作费时费力。</p>
                </div>
                <div class="p1">
                    <p id="361">未来工作主要包括:1)研究跨组件污点数据流事实的传播;2)对Android库方法的污点传播语义进行更为完备的建模;3)研究结合Fuzzing测试和动态符号执行来获得初始种子Trace。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="385">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201704009&amp;v=MDA4NTdZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVac0Z5bmhXN3ZMTnlmVGJMRzRIOWJNcTQ5RmI=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b>王蕾,李丰,李炼,等.污点分析技术的原理和实践应用[J].软件学报,2017,28(4):860-882.(WANG L,LI F,LI L,et al.Principle and practice of taint analysis[J].Journal of Software,2017,28(4):860-882.)
                            </a>
                        </p>
                        <p id="387">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201209003&amp;v=MjUwODJ2U2RMRzRIOVBNcG85Rlo0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVac0Z5bmhXN3ZMTHk=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b>赵云山,宫云战,王前,等.静态缺陷检测中的误报消除技术研究[J].计算机研究与发展,2012,49(9):1822-1831.(ZHAO Y S,GONG Y Z,WANG Q,et al.False positive elimination in static defect detection[J].Journal of Computer Research and Development,2012,49(9):1822-1831.)
                            </a>
                        </p>
                        <p id="389">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201704007&amp;v=MjQ5NTN5bmhXN3ZMTnlmVGJMRzRIOWJNcTQ5Rlk0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVac0Y=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b>李筱,周严,李孟宸,等.C/C++程序静态内存泄漏警报自动确认方法[J].软件学报,2017,28(4):827-844.(LI X,ZHOU Y,LI M C,et al.Automatically validating static memory leak warnings for C/C++programs[J].Journal of Software,2017,28(4):827-844.)
                            </a>
                        </p>
                        <p id="391">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Dy Ta:dynamic symbolic execution guided with static verification results">

                                <b>[4]</b>GE X,TANEJA K,XIE T,et al.Dy Ta:dynamic symbolic execution guided with static verification results[C]//Proceedings of the33rd International Conference on Software Engineering.New York:ACM,2011:992-994.
                            </a>
                        </p>
                        <p id="393">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201902002&amp;v=MDIzNzA1NE8zenFxQnRHRnJDVVI3cWZadVpzRnluaFc3dkxOeWZUYkxHNEg5ak1yWTlGWm9RS0RIODR2UjRUNmo=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b>王蕾,周卿,何东杰,等.面向Android应用隐私泄露检测的多源污点分析技术[J].软件学报,2019,30(2):211-230.(WANG L,ZHOU Q,HE D J,et al.Multi-sources taint analysis technique for privacy leak detection of Android apps[J].Journal of Software,2019,30(2):211-230.)
                            </a>
                        </p>
                        <p id="395">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJAM&amp;filename=SJAM15060200059132&amp;v=MzAxNTFUNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp0RmlubFVyM0lJVm9jYmhFPU5pZktZN0s5SHRmTXJZOUZaTzRHRFg4N29CTQ==&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b>RICE H G.Classes of recursively enumerable sets and their decision problems[J].Transactions of the American Mathematical Society,1953,74(2):358-366.
                            </a>
                        </p>
                        <p id="397">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Appintent:Analyzing sensitive data transmission in android for privacy leakage detection">

                                <b>[7]</b>YANG Z,YANG M,ZHANG Y,et al.App Intent:analyzing sensitive data transmission in Android for privacy leakage detection[C]//Proceedings of the 2013 ACM SIGSAC Conference on Computer&amp;Communications Security.New York:ACM,2013:1043-1054.
                            </a>
                        </p>
                        <p id="399">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Using targeted symbolic execution for reducing false-positives in dataflow analysis">

                                <b>[8]</b>ARZT S,RASTHOFER S,HAHN R,et al.Using targeted symbolic execution for reducing false-positives in dataflow analysis[C]//Proceedings of the 4th ACM SIGPLAN International Workshop on State of the Art in Program Analysis.New York:ACM,2015:1-6.
                            </a>
                        </p>
                        <p id="401">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=SMT-based false positive elimination in static program analysis">

                                <b>[9]</b>JUNKER M,HUUCK R,FEHNKER A,et al.SMT-based false positive elimination in static program analysis[C]//Proceedings of the 2012 International Conference on Formal Engineering Methods,LNCS 7635.Berlin:Springer,2012:316-331.
                            </a>
                        </p>
                        <p id="403">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A hybrid symbolic execution assisted fuzzing method">

                                <b>[10]</b>ZHANG L,THING V L L.A hybrid symbolic execution assisted fuzzing method[C]//Proceedings of the 2017 IEEE Region 10Conference.Piscataway:IEEE,2017:822-825.
                            </a>
                        </p>
                        <p id="405">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Automatic software vulnerability detection based on guided deep fuzzing">

                                <b>[11]</b>CAI J,YANG S,MEN J,et al.Automatic software vulnerability detection based on guided deep fuzzing[C]//Proceedings of the IEEE 5th International Conference on Software Engineering and Service Science.Piscataway:IEEE,2014:231-234.
                            </a>
                        </p>
                        <p id="407">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=T-Fuzz:fuzzing by program transformation">

                                <b>[12]</b>PENG H,SHOSHITAISHVILI Y,PAYER M.T-Fuzz:fuzzing by program transformation[C]//Proceedings of the 2018 IEEE Symposium on Security and Privacy.Piscataway:IEEE,2018:697-710.
                            </a>
                        </p>
                        <p id="409">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000012571&amp;v=MTY1MjZmSVk3SzdIdGpOcjQ5RlpPb05DWHM0b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcjNJSVZvY2JoRT1OaQ==&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b>GODEFROID P,LEVIN M Y,MOLNAR D.SAGE:whitebox fuzzing for security testing[J].Communications of the ACM,2012,55(3):40-44.
                            </a>
                        </p>
                        <p id="411">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Guided path exploration for regression test generation">

                                <b>[14]</b>TANEJA K,XIE T,TILLMANN N,et al.Guided path exploration for regression test generation[C]//Proceedings of the 31st International Conference on Software Engineering.Piscataway:IEEE,2009:311-314.
                            </a>
                        </p>
                        <p id="413">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=FlowDroid:Precise context,flow,field,object-sensitive and lifecycle-aware taint analysis for Android apps">

                                <b>[15]</b>ARZT S,RASTHOFER S,FRITZ C,et al.Flow Droid:precise context,flow,field,object-sensitive and lifecycle-aware taint analysis for Android apps[J].ACM SIGPLAN Notices,2014,49(6):259-269.
                            </a>
                        </p>
                        <p id="415">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Inter-procedural data-flow analysis with IFDS/IDE and Soot">

                                <b>[16]</b>BODDEN E.Inter-procedural data-flow analysis with IFDS/IDEand soot[C]//Proceedings of the ACM SIGPLAN International Workshop on State of the Art in Java Program Analysis.New York:ACM,2012:3-8.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJY201910038" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJY201910038&amp;v=MDg2MjJDVVI3cWZadVpzRnluaFc3dklMejdCZDdHNEg5ak5yNDlHYklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnI=&amp;uid=WEEvREcwSlJHSldRa1FhcEFLUmVhZDN5c0dERktQNlNvSG5VV2tqWXgrbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
