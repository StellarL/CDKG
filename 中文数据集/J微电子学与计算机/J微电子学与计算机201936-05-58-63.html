<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637133885499631250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dWXYJ201905013%26RESULT%3d1%26SIGN%3dJ59W8twT%252fxKfpcTDTj4s5nwZciU%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=WXYJ201905013&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=WXYJ201905013&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201905013&amp;v=MjM5NDc0SDlqTXFvOUVaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplVnVGeWptVzcvSU1qWFNaTEc=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#23" data-title="1 &lt;b&gt;引言&lt;/b&gt; ">1 <b>引言</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#28" data-title="2 &lt;b&gt;算法描述&lt;/b&gt; ">2 <b>算法描述</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#29" data-title="2.1 &lt;b&gt;基本原理&lt;/b&gt;">2.1 <b>基本原理</b></a></li>
                                                <li><a href="#33" data-title="2.2 &lt;b&gt;逻辑区间热度定度&lt;/b&gt;">2.2 <b>逻辑区间热度定度</b></a></li>
                                                <li><a href="#43" data-title="2.3 &lt;b&gt;数据冷热分离&lt;/b&gt;">2.3 <b>数据冷热分离</b></a></li>
                                                <li><a href="#50" data-title="2.4 &lt;b&gt;回收块选择策略&lt;/b&gt;">2.4 <b>回收块选择策略</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#66" data-title="3 &lt;b&gt;实验及分析&lt;/b&gt; ">3 <b>实验及分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#67" data-title="3.1 &lt;b&gt;实验环境&lt;/b&gt;">3.1 <b>实验环境</b></a></li>
                                                <li><a href="#70" data-title="3.2 &lt;b&gt;算法性能分析&lt;/b&gt;">3.2 <b>算法性能分析</b></a></li>
                                                <li><a href="#79" data-title="3.3 &lt;b&gt;内存消耗&lt;/b&gt;">3.3 <b>内存消耗</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#83" data-title="4 &lt;b&gt;结束语&lt;/b&gt; ">4 <b>结束语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#31" data-title="&lt;b&gt;图&lt;/b&gt;1 &lt;b&gt;基于&lt;/b&gt;NAND&lt;b&gt;闪存存储系统结构&lt;/b&gt;"><b>图</b>1 <b>基于</b>NAND<b>闪存存储系统结构</b></a></li>
                                                <li><a href="#69" data-title="&lt;b&gt;表&lt;/b&gt;1 &lt;b&gt;仿真实验参数值&lt;/b&gt;"><b>表</b>1 <b>仿真实验参数值</b></a></li>
                                                <li><a href="#73" data-title="&lt;b&gt;图&lt;/b&gt;2 &lt;b&gt;总的擦除次数对比&lt;/b&gt;"><b>图</b>2 <b>总的擦除次数对比</b></a></li>
                                                <li><a href="#74" data-title="&lt;b&gt;图&lt;/b&gt;3 &lt;b&gt;总的拷贝次数对比&lt;/b&gt;"><b>图</b>3 <b>总的拷贝次数对比</b></a></li>
                                                <li><a href="#75" data-title="&lt;b&gt;图&lt;/b&gt;4 &lt;b&gt;擦除次数的最大差值对比&lt;/b&gt;"><b>图</b>4 <b>擦除次数的最大差值对比</b></a></li>
                                                <li><a href="#78" data-title="&lt;b&gt;图&lt;/b&gt;5 &lt;b&gt;擦除次数的标准差对比&lt;/b&gt;"><b>图</b>5 <b>擦除次数的标准差对比</b></a></li>
                                                <li><a href="#81" data-title="&lt;b&gt;表&lt;/b&gt;2 &lt;b&gt;算法内存消耗对比 (以&lt;/b&gt;64M&lt;b&gt;为例&lt;/b&gt;) "><b>表</b>2 <b>算法内存消耗对比 (以</b>64M<b>为例</b>) </a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="97">


                                    <a id="bibliography_1" title=" 张旋, 余娟.基于加权比特翻转的MLC型NAND闪存系统[J].微电子学与计算机, 2018, 35 (2) :75-78." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201802016&amp;v=MTg3MDhaZVZ1RnlqbVc3L0lNalhTWkxHNEg5bk1yWTlFWW9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2U=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         张旋, 余娟.基于加权比特翻转的MLC型NAND闪存系统[J].微电子学与计算机, 2018, 35 (2) :75-78.
                                    </a>
                                </li>
                                <li id="99">


                                    <a id="bibliography_2" title=" 拓晶, 唐磊.基于多阈值的闪存磨损均衡算法[J].微电子学与计算机, 2018, 35 (1) :6-9." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201801002&amp;v=MzIyODFqWFNaTEc0SDluTXJvOUZab1FLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplVnVGeWptVzcvSU0=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         拓晶, 唐磊.基于多阈值的闪存磨损均衡算法[J].微电子学与计算机, 2018, 35 (1) :6-9.
                                    </a>
                                </li>
                                <li id="101">


                                    <a id="bibliography_3" title=" CHEN R, LIN M.Energy aware buffer management scheme for NAND and flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2015, 61 (4) :484-490." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Energy aware buffer management scheme for NAND and flash based consumer electronics">
                                        <b>[3]</b>
                                         CHEN R, LIN M.Energy aware buffer management scheme for NAND and flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2015, 61 (4) :484-490.
                                    </a>
                                </li>
                                <li id="103">


                                    <a id="bibliography_4" title=" WU M, ZWAENEPOEL W.eNVy:a non volatile, main memory storage system[J].Acm Sigops Operating Systems Review, 1994, 28 (5) :86-97." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000054243&amp;v=MDkzNzFtVWIvSUlGMGNhaEk9TmlmSVk3SzdIdGpOcjQ5RlpPNExEbmc2b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5ag==&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                         WU M, ZWAENEPOEL W.eNVy:a non volatile, main memory storage system[J].Acm Sigops Operating Systems Review, 1994, 28 (5) :86-97.
                                    </a>
                                </li>
                                <li id="105">


                                    <a id="bibliography_5" title=" KAWAGUCHI A, NISHIOKA S, MOTODA H.A flash memory based file system[C]// Proceedings of the USENIX 1995 Technical Conference.Berkeley:USENIX Association, 1995:155-164." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A Flash-Memory based File System">
                                        <b>[5]</b>
                                         KAWAGUCHI A, NISHIOKA S, MOTODA H.A flash memory based file system[C]// Proceedings of the USENIX 1995 Technical Conference.Berkeley:USENIX Association, 1995:155-164.
                                    </a>
                                </li>
                                <li id="107">


                                    <a id="bibliography_6" title=" CHIANG M L, CHANG R C.Cleaning policies in mobile computers using flash memory[J].Journal of Systems &amp;amp; Software, 1999, 48 (3) :213-231." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300677409&amp;v=MDY5MzZOaWZPZmJLN0h0RE9ySTlGWXV3SUNId3dvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVViL0lJRjBjYWhJPQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         CHIANG M L, CHANG R C.Cleaning policies in mobile computers using flash memory[J].Journal of Systems &amp;amp; Software, 1999, 48 (3) :213-231.
                                    </a>
                                </li>
                                <li id="109">


                                    <a id="bibliography_7" title=" YAN H, YAO Q.An efficient file aware garbage collection algorithm for NAND flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2015, 60 (4) :623-627." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An efficient file aware garbage collection algorithm for NAND flash based consumer electronics">
                                        <b>[7]</b>
                                         YAN H, YAO Q.An efficient file aware garbage collection algorithm for NAND flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2015, 60 (4) :623-627.
                                    </a>
                                </li>
                                <li id="111">


                                    <a id="bibliography_8" title=" 雷兵兵, 严华.基于逻辑区间热度的NAND闪存垃圾回收算法[J].计算机应用, 2017, 37 (4) :1149-1152." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJY201704042&amp;v=MDI0MzdCdEdGckNVUkxPZVplVnVGeWptVzcvSUx6N0JkN0c0SDliTXE0OUJab1FLREg4NHZSNFQ2ajU0TzN6cXE=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[8]</b>
                                         雷兵兵, 严华.基于逻辑区间热度的NAND闪存垃圾回收算法[J].计算机应用, 2017, 37 (4) :1149-1152.
                                    </a>
                                </li>
                                <li id="113">


                                    <a id="bibliography_9" title=" KIM H, SHIN D.Clustered page level mapping for flash memory based storage devices[J].IEEE Transactions on Consumer Electronics, 2015, 61 (1) :47-55." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Clustered page-level mapping for flash memorybased storage devices">
                                        <b>[9]</b>
                                         KIM H, SHIN D.Clustered page level mapping for flash memory based storage devices[J].IEEE Transactions on Consumer Electronics, 2015, 61 (1) :47-55.
                                    </a>
                                </li>
                                <li id="115">


                                    <a id="bibliography_10" title=" LIN M, CHEN S.Efficient and intelligent garbage collection policy for NAND flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2013, 59 (3) :538-543." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient and intelligent garbage collection policy for NAND flash-based consumer electronics">
                                        <b>[10]</b>
                                         LIN M, CHEN S.Efficient and intelligent garbage collection policy for NAND flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2013, 59 (3) :538-543.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=WXYJ" target="_blank">微电子学与计算机</a>
                2019,36(05),58-63             </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于逻辑区间冷热分离的NAND闪存垃圾回收算法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%A6%83%E4%BB%81%E8%B0%85&amp;code=40851773&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">覃仁谅</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%AE%81%E8%8A%8A&amp;code=08749786&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">宁芊</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E4%B8%A5%E5%8D%8E&amp;code=08738360&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">严华</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%99%A2&amp;code=0054367&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">四川大学电子信息学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E6%8E%A7%E5%88%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4&amp;code=0064809&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">电子信息控制重点实验室</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>针对现有的NAND闪存垃圾回收算法对回收效率和磨损均衡考虑不足, 以及算法内存开销大的问题, 提出了一种基于逻辑区间冷热分离的NAND闪存垃圾回收算法.该算法同时考虑了回收效率和磨损均衡, 采用了一种回收效率和磨损均衡比重动态可调的回收块选择策略.同时, 算法还提出一种新的逻辑区间热度计算的方法, 并将回收块中的有效页数据按照逻辑区间的热度分为热数据、温热数据和冷数据, 以实现对有效页数据的冷热分离.仿真实验结果表明, 该算法相比于GR、CB、CAT、FaGC以及LRGC算法, 不仅在磨损均衡、总的擦除次数以及总的拷贝次数方面取得了更好的效果, 而且内存消耗也大幅度减少.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=NAND%E9%97%AA%E5%AD%98&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">NAND闪存;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A3%A8%E6%8D%9F%E5%9D%87%E8%A1%A1&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">磨损均衡;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">垃圾回收;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%86%B7%E7%83%AD%E5%88%86%E7%A6%BB&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">冷热分离;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%80%BB%E8%BE%91%E5%8C%BA%E9%97%B4&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">逻辑区间;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%9B%9E%E6%94%B6%E5%9D%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">回收块;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    覃仁谅, 男, (1993) , 硕士研究生.研究方向为模式识别、智能控制.E-mail:516564862@qq.com.;
                                </span>
                                <span>
                                    宁芊, 女, (1969) , 博士, 副教授.研究方向为智能控制系统、信息技术与人工智能.;
                                </span>
                                <span>
                                    严华, 男, (1971) , 博士, 教授.研究方向为模式识别、智能控制.;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-08-20</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金 (61172181);</span>
                    </p>
            </div>
                    <h1><b>Garbage collection algorithm for NAND flash memory based on separation of hot and cold logical region</b></h1>
                    <h2>
                    <span>QIN Ren-liang</span>
                    <span>NING Qian</span>
                    <span>YAN Hua</span>
            </h2>
                    <h2>
                    <span>College of Electronics and Information Engineering, Sichuan University</span>
                    <span>Science & Technology on Electronic Information Control Laboratory</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Aiming at the problem that the existing NAND flash garbage collection algorithms have insufficient considerations on collection efficiency and wear leveling and large memory overhead, a NAND flash garbage collection algorithm based on logical interval cold and hot separation is proposed. The proposed algorithm considers both collection efficiency and wear leveling, and adopts a victim block selection strategy which can dynamically adjust the ratio between collection efficiency and wear leveling. At the same time, a novel method of calculating the heat of the logical region is presented, and the valid data in victim block are divided into hot data, warm data and cold data according to the heat of the logical region. Thus, the valid data in the victim block can be effectively separated. The simulation results show that compared with GR, CB, CAT, FaGC and LRGC algorithms, the proposed algorithm not only achieves better results in wear leveling, total erasure times and total copy times, but also reduces the memory consumption greatly.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=NAND%20flash%20memory&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">NAND flash memory;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=wear%20leveling&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">wear leveling;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=garbage%20collection&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">garbage collection;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=hot%20and%20cold%20separation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">hot and cold separation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=logical%20region&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">logical region;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=victim%20block&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">victim block;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-08-20</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="23" name="23" class="anchor-tag">1 <b>引言</b></h3>
                <div class="p1">
                    <p id="24">NAND闪存由于具有非易失、数据访问速度快、抗冲击性强、功耗低、体积小、低噪声<citation id="117" type="reference"><link href="97" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>等优点, 目前越来越多的消费类电子产品以NAND闪存作为数据存储设备.NAND闪存的存储空间由若干个物理块 (block) 组成, 每个物理块又分为多个物理页 (page) .NAND闪存提供页读取、页写入、块擦除三种基本操作, 且页读写与块删除在操作时间和功耗上具有非对称性<sup>.</sup>.为了克服NAND闪存写前擦除的特性, 它采用“异地更新”策略对数据进行更新.“异地更新”策略使得闪存中无效页越来越多, 空闲页越来越少, 当闪存空闲空间不足时, 需要通过垃圾回收策略来回收无效页数据所占用的闪存空间, 从而来获得更多可用的空闲空间.垃圾回收过程中存在一系列额外的读写和擦除操作, 由于擦除操作非常缓慢且功耗大, 较大的垃圾回收代价, 不仅会降低存储系统的性能, 也会增加存储系统的功耗.另外, NAND闪存中每个物理块存在擦除上限, 一旦某物理块擦除次数达到其上限, 则该物理块将无法用于正常数据存储<citation id="118" type="reference"><link href="99" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>, 并会导致NAND闪存的数据存储性能和寿命受到影响.由于基于NAND闪存的消费类电子产品内存容量有限, 过大的系统内存消耗也将会影响其性能<citation id="119" type="reference"><link href="101" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>.</p>
                </div>
                <div class="p1">
                    <p id="25">因此, 垃圾回收算法不仅需要考虑垃圾回收的代价和闪存磨损均衡的程度, 同时也要考虑算法对系统的内存消耗.为了改善NAND闪存垃圾回收的性能, 国内外学者们提出了很多的垃圾回收算法.如GR (GReedy) 算法<citation id="120" type="reference"><link href="103" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>、CB (Cost-Benefit) 算法<citation id="121" type="reference"><link href="105" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>、CAT (Cost-Age-Time) 算法<citation id="122" type="reference"><link href="107" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>、FaGC (File-aware Garbage Collection) 算法<citation id="123" type="reference"><link href="109" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>、LRGCLogicRegionbasedGarbageCollection算法<citation id="124" type="reference"><link href="111" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>.GR算法在进行垃圾回收时, 只选择有效页数目最少的物理块, 而闪存的磨损均衡却没有被考虑.对于CB、CAT算法, 这两种算法仅考虑了物理块上一次被更新的时间, 使得物理块年龄的计算不够准确, 同时数据冷热程度的判定仅取决于物理块的擦除次数, 这导致数据冷热识别和冷热分离效果不佳.FaGC算法基于文件结构, 逻辑页热度定义准确, 并对回收块中有效页数据进行了冷热分离, 与GR、CB和CAT算法相比, 该算法在垃圾回收整体性能上有了很大的提升.但FaGC算法在选择回收块时采用了GR算法的回收块选择策略, 导致其回收代价很大, 在磨损均衡方面仅考虑了最冷块, 使得在磨损均衡方面仍然存在不足, 同时为了保存逻辑页的热度信息, 该算法额外开辟了很大的内存空间.</p>
                </div>
                <div class="p1">
                    <p id="26">LRGC算法基于逻辑区间热度, 该算法将连续逻辑地址空间划分为同一个热度区间, 在垃圾回收过程中, 同时考虑了回收效率和闪存块的磨损均衡两个因素.与FaGC算法相比, 该算法有效地减少了系统的内存消耗, 同时在垃圾回收性能上也有进一步提升.但LRGC算法仍然存在不足:在回收块选择策略上, 由于采用固定权重因子控制磨损均衡因素在回收块选择策略中的比重, 使得它不能很好地调控闪存的磨损均衡.同时, 对于逻辑区间热度值的计算, LRGC算法不能准确表示其逻辑区间的热度值.</p>
                </div>
                <div class="p1">
                    <p id="27">针对上述垃圾回收算法存在的不足, 通过对NAND闪存垃圾回收性能进行深入的研究与分析, 对逻辑区间热度计算公式、数据冷热分离策略以及回收块选择策略进行了重新定义, 提出了一种新的垃圾回收算法, 即LRGC+ (LogicRegionbased Garbage Collection Plus算法.为了验证算法的有效性, 实验借助Qemu软件建立Linux嵌入式仿真平台, 从闪存物理块总的擦除次数、总的拷贝次数、擦除次数的最大最小差值、擦除次数的标准差、以及内存消耗等方面与上述算法分别进行对比分析.</p>
                </div>
                <h3 id="28" name="28" class="anchor-tag">2 <b>算法描述</b></h3>
                <h4 class="anchor-tag" id="29" name="29">2.1 <b>基本原理</b></h4>
                <div class="p1">
                    <p id="30">基于NAND闪存存储系统的通用体系结构如图1所示, 其主要组成部分有文件系统、FTL (Flash Translation Layer) 层、MTD (MemoryTechnologyDevice) 层、以及NAND闪存设备.与基于硬盘的存储系统相比, NAND闪存存储系统在文件系统和闪存设备之间存在闪存转换层 (FTL) 和内存技术设备层 (MTD) .FTL层提供物理地址和逻辑地址之间的地址转换, 以便于对闪存设备提供透明的访问.而MTD层为上层的文件系统提供统一的接口, 用来处理基于闪存的存储系统的读、写和擦除操作.</p>
                </div>
                <div class="area_img" id="31">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/WXYJ201905013_031.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 基于NAND闪存存储系统结构" src="Detail/GetImg?filename=images/WXYJ201905013_031.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图</b>1 <b>基于</b>NAND<b>闪存存储系统结构</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/WXYJ201905013_031.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="32">文件系统通常都有提供页级、块级、混合映射等逻辑地址到物理地址之间的映射方式.虽然页级映射可以提供很好的数据冷热识别效果, 但页级映射的系统内存消耗较大, 不利于消费类电子产品的性能.由于逻辑地址的访问具有空间局部性<citation id="125" type="reference"><link href="113" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>, 通过采用逻辑区间映射方式, 在较为准确的数据冷热判断下, 可以减少系统由于地址映射带来的内存消耗.</p>
                </div>
                <h4 class="anchor-tag" id="33" name="33">2.2 <b>逻辑区间热度定度</b></h4>
                <div class="p1">
                    <p id="34">鉴于闪存逻辑地址访问具有空间局部性, 引入热度区间<citation id="126" type="reference"><link href="111" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>, 即连续的多个逻辑地址空间用一个热度区间来表示, 不同热度区间拥有不同编号, 且位于同一个热度区间内的所有逻辑地址可用同一个区间编号来表示.逻辑区间定义如下:</p>
                </div>
                <div class="p1">
                    <p id="35" class="code-formula">
                        <mathml id="35"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Η</mi><msub><mrow></mrow><mi>n</mi></msub><mo>=</mo><mrow><mo>[</mo><mrow><mi>l</mi><mi>a</mi><mo>/</mo><mi>Μ</mi></mrow><mo>]</mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="36">式中, <i>la</i>表示当前逻辑页地址;<i>M</i>表示逻辑区间的长度;<i>H</i><sub><i>n</i></sub>表示当前逻辑页所在热度区间的编号.</p>
                </div>
                <div class="p1">
                    <p id="37">为了使逻辑区间的热度能够被准确定义, 考虑了逻辑区间更新频率和上一次逻辑区间热度值, 即将逻辑区间更新频率先进行分段阈值处理, 再结合当前逻辑区间的上一次热度, 从而计算出当前逻辑区间的热度.定义如下:</p>
                </div>
                <div class="p1">
                    <p id="38" class="code-formula">
                        <mathml id="38"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>Η</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>c</mi><mo>, </mo></mtd><mtd columnalign="left"><mi>w</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub><mo>≤</mo><mi>w</mi><mo>≤</mo><mi>w</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>/</mo><mn>4</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>Η</mi><msub><mrow></mrow><mi>i</mi></msub><mo>, </mo></mtd><mtd columnalign="left"><mi>w</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>/</mo><mn>4</mn><mo>&lt;</mo><mi>w</mi><mo>&lt;</mo><mi>w</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>×</mo><mn>3</mn><mo>/</mo><mn>4</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>Η</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>c</mi><mo>, </mo></mtd><mtd columnalign="left"><mi>w</mi><mo>≥</mo><mi>w</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>×</mo><mn>3</mn><mo>/</mo><mn>4</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>Η</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>, </mo></mtd><mtd columnalign="left"><mi>Η</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&gt;</mo><mi>Η</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>w</mi><mo>=</mo><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mn>2</mn><mo>-</mo><mrow><mo> (</mo><mrow><mi>t</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mo>) </mo></mrow><mo>/</mo><mi>Ν</mi><msub><mrow></mrow><mi>t</mi></msub><mo>, </mo></mtd><mtd columnalign="left"><mn>0</mn><mo>≤</mo><mrow><mo> (</mo><mrow><mi>t</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mo>) </mo></mrow><mo>/</mo><mi>Ν</mi><msub><mrow></mrow><mi>t</mi></msub><mo>&lt;</mo><mn>2</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn><mo>, </mo></mtd><mtd columnalign="left"><mrow><mo> (</mo><mrow><mi>t</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mo>) </mo></mrow><mo>/</mo><mi>Ν</mi><msub><mrow></mrow><mi>t</mi></msub><mo>≥</mo><mn>2</mn></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="39">式中, <i>H</i><sub><i>i</i>+1</sub>和<i>H</i><sub><i>i</i></sub>分别表示当前逻辑区间的热度值、当前逻辑区间最近一次更新后的热度值;<i>c</i>是一个常量, 表示逻辑区间最小热度值, 即<i>H</i><sub>min</sub>=<i>c</i>;<i>H</i><sub>max</sub>表示逻辑区间最大热度值, 一般取其值为逻辑区间长度的3倍;<i>w</i>表示逻辑区间更新频率, <i>w</i><sub>min</sub>、<i>w</i><sub>max</sub>分别表示逻辑区间更新频率最大值和最小值, 通常取0和2;<i>t</i><sub><i>i</i>+1</sub>-<i>t</i><sub><i>i</i></sub>表示当前逻辑区间前后两次更新操作的时间间隔;<i>N</i><sub><i>t</i></sub>是一个常量, 主要是用来降低时间对计算逻辑区间热度值的影响.</p>
                </div>
                <div class="p1">
                    <p id="40">LRGC+算法的逻辑区间热度定义通过将逻辑区间更新频率进行阈值处理, 把处理后的更新频率分为3类.当<i>w</i><sub>min</sub>≤<i>w</i>≤<i>w</i><sub>max</sub>/4时, 表示当前逻辑区间更新频率较小, 此时逻辑区间热度为最小热度值<i>c</i>;当<i>w</i><sub>max</sub>/4&lt;<i>w</i>&lt;<i>w</i><sub>max</sub>×3/4时, 表示当前逻辑区间更新频率适中, 此时逻辑区间热度保持为上一次更新时的热度值;当<i>w</i>≥<i>w</i><sub>max</sub>×3/4时, 表示当前逻辑区间更新频率较高, 此时逻辑区间热度开始线性增长, 即等于逻辑区间上一次热度值加上常量<i>c</i>, 若逻辑区间热度值大于<i>H</i><sub>max</sub>时, 则当前逻辑区间热度为<i>H</i><sub>max</sub>.</p>
                </div>
                <div class="p1">
                    <p id="41">LRGC算法在计算逻辑区间热度时, 由于直接采用上一次逻辑区间热度值与当前逻辑区间更新频率的乘积来做为当前逻辑区间的热度, 使得逻辑区间内的少数逻辑页更新就能导致整个逻辑区间的数据热度发生冷热剧变, 即从冷数据变为热数据, 而实际上逻辑区间内大部分逻辑页还未进行更新, 此时逻辑区间热度对于大多数未更新的逻辑页来说就是一种热度误判, 而且随着逻辑区间的增大, 这种热度误判概率将会越来越大.</p>
                </div>
                <div class="p1">
                    <p id="42">而LRGC+算法通过对不同更新频率的逻辑区间热度进行分段计算, 使得更新频率较高的逻辑区间热度线性增长, 避免逻辑区间热度增长过快, 从而可以解决逻辑区间内由于少数逻辑页更新而导致数据冷热剧变的问题, 同时也能降低逻辑区间内逻辑页热度的误判概率.</p>
                </div>
                <h4 class="anchor-tag" id="43" name="43">2.3 <b>数据冷热分离</b></h4>
                <div class="p1">
                    <p id="44">由于NAND闪存在数据更新时采用“异地更新”策略, 通过对数据进行冷热分离, 可以减少闪存在垃圾回收过程中的拷贝和擦除次数.因此, 为了更好地对数据进行冷热分离, 本文将逻辑区间数据分为热数据页、温热数据页、冷数据页这3种数据, 以提高对数据冷热分离的精度.具体的数据冷热分离步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="45"> (1) 利用式 (1) 确定有效页数据所对应的逻辑区间编号, 该编号所对应的逻辑区间热度值由式 (2) ～ (3) 计算可得;</p>
                </div>
                <div class="p1">
                    <p id="46"> (2) 若步骤 (1) 计算出的逻辑区间热度<i>H</i><sub><i>i</i>+1</sub>&gt;<i>H</i><sub>max</sub><i>x</i>×2/3, 则有效页数据为热数据页, 该热数据页将被写入最小擦除次数的物理块;</p>
                </div>
                <div class="p1">
                    <p id="47"> (3) 若步骤 (1) 计算出的逻辑区间热度<i>H</i><sub>max</sub>×1/3&lt;<i>H</i><sub><i>i</i>+1</sub>≤<i>H</i><sub>max</sub>×2/3, 则有效页数据为温热数据页, 该温热数据页将被写入任意空闲物理块;</p>
                </div>
                <div class="p1">
                    <p id="48"> (4) 若步骤 (1) 计算出的逻辑区间热度<i>H</i><sub><i>i</i>+1</sub>≤<i>H</i><sub>max</sub>×1/3, 则有效页数据为冷数据页, 该冷数据页将被写入最大擦除次数的物理块;</p>
                </div>
                <div class="p1">
                    <p id="49"> (5) 对有效页数据进行冷热数据分离后, 逻辑区间的更新时间和热度值信息将被重新记录.</p>
                </div>
                <h4 class="anchor-tag" id="50" name="50">2.4 <b>回收块选择策略</b></h4>
                <div class="p1">
                    <p id="51">在回收块选择策略中, 为了综合考虑回收效率和块的磨损均衡度两个指标, 以及提高算法的灵活性, 提出了一种回收效率和磨损均衡比重动态可调的回收块选择策略, 即回收块的选择策略根据磨损均衡度的不同而动态调节回收效率和磨损均衡因素在回收代价函数中的比重, 回收代价函数如下:</p>
                </div>
                <div class="p1">
                    <p id="52" class="code-formula">
                        <mathml id="52"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mtext>C</mtext><mtext>o</mtext><mtext>s</mtext><mtext>t</mtext><mo>=</mo><mi>λ</mi><mfrac><mrow><mn>1</mn><mo>-</mo><mi>μ</mi></mrow><mrow><mn>1</mn><mo>+</mo><mi>μ</mi></mrow></mfrac><mo>+</mo><mrow><mo> (</mo><mrow><mn>1</mn><mo>-</mo><mi>λ</mi></mrow><mo>) </mo></mrow><mfrac><mrow><mi>ε</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>-</mo><mi>ε</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>Ν</mi><msub><mrow></mrow><mi>p</mi></msub></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>λ</mi><mo>=</mo><mfrac><mrow><mi>G</mi><msub><mrow></mrow><mi>r</mi></msub></mrow><mrow><mi>G</mi><msub><mrow></mrow><mi>r</mi></msub><mo>+</mo><mi>ε</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>-</mo><mi>ε</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>5</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="53">式中, <i>μ</i>表示一个物理块中有效页数与该块总页数的比值;<i>ε</i><sub>max</sub>和<i>ε</i><sub>min</sub>分别表示当前物理块擦除次数最大值、最小值;<i>N</i><sub><i>p</i></sub>表示每个块上页的总数;<i>ε</i><sub><i>i</i></sub>表示当前物理块已擦除次数;<i>λ</i>表示磨损均衡动态权重, 用于动态控制磨损均衡因素在回收块选择策略中的比重;<i>G</i><sub><i>r</i></sub>表示可自行调节的磨损均衡权重灵敏度参数, 以便于调节磨损均衡权重与磨损均衡之间的变化缓慢程度.</p>
                </div>
                <div class="p1">
                    <p id="54">由于采用固定权重因子控制磨损均衡因素在回收块选择策略中的比重具有一定的局限性, 它不能很好地调控闪存的磨损均衡.因此, LRGC+算法采用了回收效率和磨损均衡比重动态可调的回收块选择策略, 权重<i>λ</i>的大小根据当前闪存块的磨损均衡程度自动调节.当闪存块的磨损均衡程度较好时, 即<i>ε</i><sub>max</sub>-<i>ε</i><sub>min</sub>值较小, 此时权重<i>λ</i>比较大, 从而对回收效率的偏重更大, 提高垃圾回收的效率;当闪存块的磨损均衡程度较差时, 即<i>ε</i><sub>max</sub>-<i>ε</i><sub>min</sub>值较大, 此时权重<i>λ</i>比较小, 从而对磨损均衡因素的偏重更大, 改善了磨损均衡效果.</p>
                </div>
                <div class="p1">
                    <p id="55">在垃圾回收过程中, 对于有效页比例高且长时间未更新的最冷块, 通过式 (4) ～ (5) 很难被选中, 若大量存在这样的最冷块, 将不利于磨损均衡的改善.为此采用了一个最冷块回收阈值<i>R</i><sub><i>wl</i></sub>, 定义如下:</p>
                </div>
                <div class="p1">
                    <p id="56" class="code-formula">
                        <mathml id="56"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><msub><mrow></mrow><mrow><mi>w</mi><mi>l</mi></mrow></msub><mo>=</mo><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>R</mi><msub><mrow></mrow><mrow><mi>t</mi><mi>h</mi></mrow></msub><mo>-</mo><mrow><mo> (</mo><mrow><mi>ε</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>-</mo><mi>ε</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub></mrow><mo>) </mo></mrow><mo>, </mo></mtd><mtd columnalign="left"><mi>ε</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>-</mo><mi>ε</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub><mo>≤</mo><mi>R</mi><msub><mrow></mrow><mrow><mi>t</mi><mi>h</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn><mo>, </mo></mtd><mtd columnalign="left"><mi>ε</mi><msub><mrow></mrow><mrow><mi>max</mi></mrow></msub><mo>-</mo><mi>ε</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub><mo>&gt;</mo><mi>R</mi><msub><mrow></mrow><mrow><mi>t</mi><mi>h</mi></mrow></msub></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>6</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="57">式中, <i>R</i><sub><i>th</i></sub>表示控制最冷块回收的初始阈值;<i>ε</i><sub>max</sub>表示当前所有物理块中擦除次数的最大值;<i>ε</i><sub>min</sub>表示当前所有物理块中擦除次数的最小值.通过式 (4) ～ (5) 进行垃圾回收时, 若上一次最冷块回收时的物理块回收次数与当前物理块的回收次数之差大于阈值<i>R</i><sub><i>wl</i></sub>, 此时就需要执行一次最冷块回收, 并且随后就利用式 (6) 对阈值<i>R</i><sub><i>wl</i></sub>进行更新.</p>
                </div>
                <div class="p1">
                    <p id="58">为了提高垃圾回收的效率, 减少垃圾回收的次数, 引入分散度<citation id="127" type="reference"><link href="109" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>来做为启动垃圾回收的触发条件.分散度<i>F</i><sub><i>sc</i></sub>的定义如下:</p>
                </div>
                <div class="p1">
                    <p id="59" class="code-formula">
                        <mathml id="59"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><msub><mrow></mrow><mrow><mi>s</mi><mi>c</mi></mrow></msub><mo>=</mo><mrow><mo> (</mo><mrow><mi>Ν</mi><msub><mrow></mrow><mi>f</mi></msub><mo>-</mo><mi>Ν</mi><msub><mrow></mrow><mi>b</mi></msub><mo>×</mo><mi>Ν</mi><msub><mrow></mrow><mi>p</mi></msub></mrow><mo>) </mo></mrow><mo>/</mo><mi>Ν</mi><msub><mrow></mrow><mi>f</mi></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>7</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="60">式中, <i>N</i><sub><i>f</i></sub>表示当前所有物理块上的空闲页数量;<i>N</i><sub><i>b</i></sub>表示当前所有物理块中的空闲块数量;<i>N</i><sub><i>p</i></sub>表示单个物理块上的物理页总数量.数值越大的分散度<i>F</i><sub><i>sc</i></sub>, 则表示空闲页在闪存块中分布越分散且系统中空闲块越少.因此, 为了提高垃圾回收效率, 垃圾回收策略在分散度达到设定阈值<i>F</i><sub><i>th</i></sub>才触发.</p>
                </div>
                <div class="p1">
                    <p id="61">对于LRGC+算法, 其垃圾回收处理步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="62"> (1) 当分散度<i>F</i><sub><i>sc</i></sub>大于阈值<i>F</i><sub><i>th</i></sub>时, 启动垃圾回收策略;</p>
                </div>
                <div class="p1">
                    <p id="63"> (2) 若物理块的回收次数满足最冷块回收条件时, 则进行最冷块回收.否则, 利用式 (4) ～ (5) 来选择当前需要回收的块, 即当前所有物理块中Cost值最大的块;</p>
                </div>
                <div class="p1">
                    <p id="64"> (3) 利用式 (1) 确定当前有效页的逻辑区间编号, 该编号对应的逻辑区间热度值由式 (2) ～ (3) 计算可得;</p>
                </div>
                <div class="p1">
                    <p id="65"> (4) 根据数据冷热分离策略对回收块中的有效页数据进行冷热分离.即热数据、温热数据、冷数据将分别拷贝到擦除次数最少块、任意空闲块、擦除次数最大块上.</p>
                </div>
                <h3 id="66" name="66" class="anchor-tag">3 <b>实验及分析</b></h3>
                <h4 class="anchor-tag" id="67" name="67">3.1 <b>实验环境</b></h4>
                <div class="p1">
                    <p id="68">实验基于Linux系统搭建了Qemu嵌入式开发仿真环境, 并对嵌入式文件系统Yaffs2进行了移植, 而NAND闪存存储设备是用NANDSim来进行模拟.选取存储容量大小为64 MB的NAND闪存作为实验对象, 其共有512个物理块且每个块有64个物理页, 每个块和页的存储容量分别为128 kB和2 kB.使NAND闪存的存储容量利用率为90%, 测试文件大小在16 kB～1 024 kB之间, 按照齐夫分布<citation id="128" type="reference"><link href="115" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>更新其中15%的数据.为对算法性能进行客观公平比较, Yaffs2的后台垃圾回收和缓存都被关闭, 采用aggressive模式进行垃圾回收, 且FaGC、LRGC以及LRGC+算法的初始阈值设置相等.仿真实验中各项参数如表1所示.</p>
                </div>
                <div class="area_img" id="69">
                    <p class="img_tit"><b>表</b>1 <b>仿真实验参数值</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="69" border="1"><tr><td>参数</td><td>值</td><td>参数</td><td>值</td></tr><tr><td><br /><i>M</i></td><td>1 8 16 64</td><td><i>N</i><sub><i>t</i></sub></td><td>1 024</td></tr><tr><td><br /><i>H</i><sub>max</sub></td><td>3 24 48 192</td><td><i>G</i><sub><i>r</i></sub></td><td>32</td></tr><tr><td><br /><i>c</i></td><td>1</td><td><i>R</i><sub><i>th</i></sub></td><td>100</td></tr><tr><td><br /><i>N</i><sub><i>p</i></sub></td><td>64</td><td><i>F</i><sub><i>th</i></sub></td><td>90%</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="70" name="70">3.2 <b>算法性能分析</b></h4>
                <div class="p1">
                    <p id="71">实验对比对象为GR、CB、CAT、FaGC和LRGC算法, 算法性能主要从四个方面来分别进行对比分析, 即闪存物理块总的擦除次数、总的拷贝次数、擦除次数的最大最小差值、擦除次数的标准差.</p>
                </div>
                <div class="p1">
                    <p id="72">由图2和图3可知, LRGC+算法在总的拷贝和擦除次数方面均少于GR、CB、CAT、FaGC和LRGC, 即使在逻辑区间<i>M</i>=64时, LRGC+算法在性能上依然要比FaGC算法好.而LRGC算法随着逻辑区间长度<i>M</i>的增大, 擦除次数和拷贝次数的增加速度越来越快, 这是由于随着逻辑区间长度的增大, LRGC算法的逻辑区间热度定义变得不够准确, 导致越来越多有效页数据的热度误判, 从而数据冷热分离效果不佳, 使得垃圾回收过程中总的擦除次数和总的拷贝次数快速增加.相比较LRGC算法, LRGC+算法通过对逻辑区间更新频率进行阈值处理, 把处理后的更新频率分为3类, 并采用了一种逻辑区间热度线性增长的方法, 能够更好地反映逻辑区间的热度, 在数据冷热分离时, 将有效页数据分为3类, 提高了数据冷热分离的精度, 使得在垃圾回收过程中有效地减少了总的擦除次数和总的拷贝次数.因此, 相比较LRGC算法, 在逻辑区间<i>M</i>值较大时, 对于擦除次数和拷贝次数这两项性能, LRGC+算法可以取得较好的效果.</p>
                </div>
                <div class="area_img" id="73">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/WXYJ201905013_073.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 总的擦除次数对比" src="Detail/GetImg?filename=images/WXYJ201905013_073.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图</b>2 <b>总的擦除次数对比</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/WXYJ201905013_073.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="74">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/WXYJ201905013_074.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 总的拷贝次数对比" src="Detail/GetImg?filename=images/WXYJ201905013_074.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图</b>3 <b>总的拷贝次数对比</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/WXYJ201905013_074.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="75">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/WXYJ201905013_075.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 擦除次数的最大差值对比" src="Detail/GetImg?filename=images/WXYJ201905013_075.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图</b>4 <b>擦除次数的最大差值对比</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/WXYJ201905013_075.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="76">由图4可知, LRGC+算法的擦除次数最大差值均小于GR、CB、CAT、FaGC和LRGC算法, 这是因为LRGC+算法在执行回收块选择策略时, 块的回收效率和磨损均衡都有被综合考虑, 并且回收效率和磨损均衡之间的比重可随着整个闪存的磨损均衡程度来进行动态调节, 从而取得更好的磨损均衡效果.而FaGC算在回收块选择策略上总是选择无效页最多的物理块, 且只对最冷块进行磨损均衡处理, 因此其磨损均衡效果明显差于LRGC+算法.虽然回收效率和磨损均衡在LRGC算法的垃圾回收过程中也有被综合考虑, 但是它采用固定比重因子, 在垃圾回收过程中不能很好地平衡回收效率和磨损均衡之间的权重.</p>
                </div>
                <div class="p1">
                    <p id="77">由于在<i>M</i>=16时, LRGC算法和FaGC算法在擦除次数、拷贝次数上相近, <i>M</i>=64时, LRGC+算法和FaGC算法在擦除次数、拷贝次数上相近, 为了较好对比各种算法的擦除次数标准差, 选取GR、CB、CAT、FaGC、<i>M</i>=16时的LRGC算法和<i>M</i>=64时LRGC+算法进行对比.由图5可知, 对于GR、CB和CAT算法, 它们的擦除次数标准差随着擦除次数的增加而不断地增加, 即擦除次数标准差曲线不收敛;而FaGC、LRGC和LRGC+算法随着擦除次数的增加, 它们的擦除次数标准差曲线相对稳定且收敛, 这是由于在垃圾回收过程中FaGC、LRGC和LRGC+算法都有考虑磨损均衡, 使得各物理块的擦除操作比较均匀.但是LRGC+算法在擦除次数标准差上的明显小于其他两种算法, 这也表明LRGC+算法在垃圾回收过程中闪存物理块擦除次数两极分化较少, 这是由于LRGC+算法在垃圾回收过程中采用动态比重来调节回收效率和磨损均衡因素, 同时根据最冷块回收阈值对最冷块进行动态回收处理.因此, 综合图4和图5可知, 相对于GR、CB、CAT、FaGC和LRGC算法, LRGC+算法在磨损均衡方面具有更好的效果.</p>
                </div>
                <div class="area_img" id="78">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/WXYJ201905013_078.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 擦除次数的标准差对比" src="Detail/GetImg?filename=images/WXYJ201905013_078.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图</b>5 <b>擦除次数的标准差对比</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/WXYJ201905013_078.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="79" name="79">3.3 <b>内存消耗</b></h4>
                <div class="p1">
                    <p id="80">对于存储容量大小为64 MB的NAND闪存, 其中每个物理块和物理页的存储容量分别为128 kB和2kB, 则整个闪存的物理页总数为64×1 024/2=32 768, 物理块总数为64×1 024/128=512.GR算法由于选择有效页数目最少的物理块进行垃圾回收, 则不需要额外的内存消耗;CB算法需要记录每个物理块的年龄, 则每个物理块需要4字节内存消耗;CAT算法需要记录每个物理块的年龄和擦除次数, 则每个物理块需要8字节内存消耗;FaGC算法需要记录每个逻辑页的更新时间和热度值以及每个物理块的擦除次数, 则每个逻辑页需要8字节内存消耗, 每个物理块需要4字节内存消耗;逻辑区间长度为16的LRGC算法, 只需记录32 768/16个逻辑区间的更新时间和热度值以及每个物理块的擦除次数;逻辑区间长度为64的LRGC+算法, 则只需记录32 768/64个逻辑区间的更新时间和热度值以及每个物理块的擦除次数.算法内存消耗对比如表2所示.</p>
                </div>
                <div class="area_img" id="81">
                    <p class="img_tit"><b>表</b>2 <b>算法内存消耗对比 (以</b>64M<b>为例</b>)  <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="81" border="1"><tr><td><br />算法类型</td><td>算法内存消耗</td></tr><tr><td><br />GR</td><td>0 KB</td></tr><tr><td><br />CB</td><td>512*4=2 kB</td></tr><tr><td><br />CAT</td><td>512*8=4 kB</td></tr><tr><td><br />FaGC</td><td>32768*8+512*4=258 kB</td></tr><tr><td><br />LRGC (<i>M</i>=16) </td><td>32768/16*8+512*4=18 kB</td></tr><tr><td><br />LRGC+ (<i>M</i>=64) </td><td>32768/64*8+512*4=6 kB</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="82">由表2可知, GR、CB、CAT、LRGC和LRGC+的内存消耗明显小于FaGC.虽然GR、CB和CAT的内存消耗小, 但从图2～5可知, GR、CB和CAT的回收效率和磨损均衡都较差.此外, 在相同逻辑区间长度下, LRGC+的各项性能均比LRGC好, 并且<i>M</i>=64的LRGC+在性能上依然优于FaGC和<i>M</i>=16的LRGC.因此, LRGC+算法在保证垃圾回收性能优势的同时, 进一步有效地减少了算法对系统的内存消耗.</p>
                </div>
                <h3 id="83" name="83" class="anchor-tag">4 <b>结束语</b></h3>
                <div class="p1">
                    <p id="84">通过重新定义逻辑区间热度的计算方法, 实现了对热数据、温热数据和冷数据的分离, 在垃圾回收过程中综合考虑了垃圾回收效率和磨损均衡因素, 且回收效率和磨损均衡比重动态可调, 从而形成了新的垃圾回收策略.实验结果表明, 与GR、CB、CAT、FaGC和LRGC算法相比, LRGC+算法不仅有效地提高了垃圾回收的效率和闪存的磨损均衡效果, 同时也大幅度地减少了系统的内存消耗.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="97">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201802016&amp;v=MjI3MTZxQnRHRnJDVVJMT2VaZVZ1RnlqbVc3L0lNalhTWkxHNEg5bk1yWTlFWW9RS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 张旋, 余娟.基于加权比特翻转的MLC型NAND闪存系统[J].微电子学与计算机, 2018, 35 (2) :75-78.
                            </a>
                        </p>
                        <p id="99">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201801002&amp;v=MTEwMjVMT2VaZVZ1RnlqbVc3L0lNalhTWkxHNEg5bk1ybzlGWm9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 拓晶, 唐磊.基于多阈值的闪存磨损均衡算法[J].微电子学与计算机, 2018, 35 (1) :6-9.
                            </a>
                        </p>
                        <p id="101">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Energy aware buffer management scheme for NAND and flash based consumer electronics">

                                <b>[3]</b> CHEN R, LIN M.Energy aware buffer management scheme for NAND and flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2015, 61 (4) :484-490.
                            </a>
                        </p>
                        <p id="103">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000054243&amp;v=MDE0OTU9TmlmSVk3SzdIdGpOcjQ5RlpPNExEbmc2b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VYi9JSUYwY2FoSQ==&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b> WU M, ZWAENEPOEL W.eNVy:a non volatile, main memory storage system[J].Acm Sigops Operating Systems Review, 1994, 28 (5) :86-97.
                            </a>
                        </p>
                        <p id="105">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A Flash-Memory based File System">

                                <b>[5]</b> KAWAGUCHI A, NISHIOKA S, MOTODA H.A flash memory based file system[C]// Proceedings of the USENIX 1995 Technical Conference.Berkeley:USENIX Association, 1995:155-164.
                            </a>
                        </p>
                        <p id="107">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300677409&amp;v=MDI4NTFjYWhJPU5pZk9mYks3SHRET3JJOUZZdXdJQ0h3d29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVWIvSUlGMA==&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> CHIANG M L, CHANG R C.Cleaning policies in mobile computers using flash memory[J].Journal of Systems &amp; Software, 1999, 48 (3) :213-231.
                            </a>
                        </p>
                        <p id="109">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An efficient file aware garbage collection algorithm for NAND flash based consumer electronics">

                                <b>[7]</b> YAN H, YAO Q.An efficient file aware garbage collection algorithm for NAND flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2015, 60 (4) :623-627.
                            </a>
                        </p>
                        <p id="111">
                            <a id="bibliography_8" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJY201704042&amp;v=MjI5MzJxNDlCWm9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVZ1RnlqbVc3L0lMejdCZDdHNEg5Yk0=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[8]</b> 雷兵兵, 严华.基于逻辑区间热度的NAND闪存垃圾回收算法[J].计算机应用, 2017, 37 (4) :1149-1152.
                            </a>
                        </p>
                        <p id="113">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Clustered page-level mapping for flash memorybased storage devices">

                                <b>[9]</b> KIM H, SHIN D.Clustered page level mapping for flash memory based storage devices[J].IEEE Transactions on Consumer Electronics, 2015, 61 (1) :47-55.
                            </a>
                        </p>
                        <p id="115">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient and intelligent garbage collection policy for NAND flash-based consumer electronics">

                                <b>[10]</b> LIN M, CHEN S.Efficient and intelligent garbage collection policy for NAND flash based consumer electronics[J].IEEE Transactions on Consumer Electronics, 2013, 59 (3) :538-543.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="WXYJ201905013" />
        <input id="dpi" type="hidden" value="800" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201905013&amp;v=MjM5NDc0SDlqTXFvOUVaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplVnVGeWptVzcvSU1qWFNaTEc=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUUo3bEY3Zm5LZEo2VXlXemZUQTF2RT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
