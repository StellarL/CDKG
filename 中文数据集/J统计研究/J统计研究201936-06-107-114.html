

<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>

</head>

<body>

    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2fKXReader%2fDetail%3fTIMESTAMP%3d637140103312318750%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dTJYJ201906009%26RESULT%3d1%26SIGN%3dyihqq7k5NlAhfLeSR6zlY2HU%252bCg%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=TJYJ201906009&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=TJYJ201906009&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>


    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TJYJ201906009&amp;v=MDA1MTE0TzN6cXFCdEdGckNVUjdxZlp1Wm9GeS9sVUwvSU1TZlNaTEc0SDlqTXFZOUZiWVFLREg4NHZSNFQ2ajU=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#34" data-title="一、引言 ">一、引言</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#39" data-title="二、模型描述 ">二、模型描述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#49" data-title="三、已知初始状态的状态估计 ">三、已知初始状态的状态估计</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#88" data-title="四、已知首末状态的状态估计 ">四、已知首末状态的状态估计</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#111" data-title="五、应用分析 ">五、应用分析</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#130" data-title="六、结论 ">六、结论</a><i></i></p>
                                                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="163">


                                    <a id="bibliography_1" title="Lember J, Koloydenko A.The adjusted Viterbi training for hidden Markov models [J].Bernoulli, 2008, 14:180-206." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJST&amp;filename=SJST14120500890573&amp;v=MjI5MzZDWHM2b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcm5JSjE0WGFoST1OaWZZZXJLOEg5UE1xbzlGYk9JUA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                        Lember J, Koloydenko A.The adjusted Viterbi training for hidden Markov models [J].Bernoulli, 2008, 14:180-206.
                                    </a>
                                </li>
                                <li id="165">


                                    <a id="bibliography_2" title="Viterbi A J.Error bounds for convolutional codes and an asymptotically optimum decoding algorithm [J].IEEE Transactions on Information Theory, 1967, 13:260-269." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Error bounds for convolutional codes and an asymptotically optimum decoding algorithm">
                                        <b>[2]</b>
                                        Viterbi A J.Error bounds for convolutional codes and an asymptotically optimum decoding algorithm [J].IEEE Transactions on Information Theory, 1967, 13:260-269.
                                    </a>
                                </li>
                                <li id="167">


                                    <a id="bibliography_3" title="Elmezain M, Al-Hamadi A, Appenrodt J.A hidden Markov model-based isolated and meaningful hand gesture recognition [J].International Journal of Electrical, 2009, 3:156-163." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A Hidden MarkovModel-Based Isolated and Meaningful Hand Gesture Recognition">
                                        <b>[3]</b>
                                        Elmezain M, Al-Hamadi A, Appenrodt J.A hidden Markov model-based isolated and meaningful hand gesture recognition [J].International Journal of Electrical, 2009, 3:156-163.
                                    </a>
                                </li>
                                <li id="169">


                                    <a id="bibliography_4" title="覃龙, 高琳, 张权.人类交互行为的隐马尔可夫模型[J].生物医学工程学杂志, 2019 (1) :40-49." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=SWGC201901006&amp;v=MDMxNDFIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI3cWZadVpvRnkvbFVML0lOanJNYmJHNEg5ak1ybzlGWW9RS0Q=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                        覃龙, 高琳, 张权.人类交互行为的隐马尔可夫模型[J].生物医学工程学杂志, 2019 (1) :40-49.
                                    </a>
                                </li>
                                <li id="171">


                                    <a id="bibliography_5" title="Boutros T, Liang M.Detection and diagnosis of bearing and cutting tool faults using hidden Markov models [J].Mechanical Systems and Signal Processing, 2011, 25:2102-2124." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012100144501&amp;v=MjAyMzAvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXJuSUoxNFhhaEk9TmlmT2ZiSzdIdERPcm85RlplOExDWHc0b0JNVDZUNFBRSA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                        Boutros T, Liang M.Detection and diagnosis of bearing and cutting tool faults using hidden Markov models [J].Mechanical Systems and Signal Processing, 2011, 25:2102-2124.
                                    </a>
                                </li>
                                <li id="173">


                                    <a id="bibliography_6" title="冯超, 景小宁, 李秋妮等.基于隐马尔可夫模型的空战决策点理论研究[J].北京航空航天大学学报, 2017 (3) :615-626." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=BJHK201703025&amp;v=MDg0MTFNckk5SFlZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVab0Z5L2xVTC9JSnlmRFpiRzRIOWI=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                        冯超, 景小宁, 李秋妮等.基于隐马尔可夫模型的空战决策点理论研究[J].北京航空航天大学学报, 2017 (3) :615-626.
                                    </a>
                                </li>
                                <li id="175">


                                    <a id="bibliography_7" title="Scott S L.Bayesian methods for hidden Markov models [J].Journal of the American Statistical Association, 2002, 97:337-351." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=STJD&amp;filename=STJD13062800007231&amp;v=MDc2MTdqbkJhcks3SHRmT3A0OUZaT3NJRG44NG9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnRGaW5sVXJuSUoxNFhhaEk9Tg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                        Scott S L.Bayesian methods for hidden Markov models [J].Journal of the American Statistical Association, 2002, 97:337-351.
                                    </a>
                                </li>
                                <li id="177">


                                    <a id="bibliography_8" title="Zoubin G.An introduction to hidden Markov models and Bayesian networks [J].International Journal of Pattern Recognition and Artificial Intelligence, 2001, 15 (1) , 9-42." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An Introduction to Hidden Markov Models and Bayesian Networks">
                                        <b>[8]</b>
                                        Zoubin G.An introduction to hidden Markov models and Bayesian networks [J].International Journal of Pattern Recognition and Artificial Intelligence, 2001, 15 (1) , 9-42.
                                    </a>
                                </li>
                                <li id="179">


                                    <a id="bibliography_9" title="刘鹤飞, 王坤, 蒋成飞.隐状态个数未知的隐马尔可夫多元正态分布的贝叶斯推断[J].统计研究, 2017 (12) , 119-125." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TJYJ201712011&amp;v=MTk5MTVsVUwvSU1TZlNaTEc0SDliTnJZOUVaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUjdxZlp1Wm9GeS8=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[9]</b>
                                        刘鹤飞, 王坤, 蒋成飞.隐状态个数未知的隐马尔可夫多元正态分布的贝叶斯推断[J].统计研究, 2017 (12) , 119-125.
                                    </a>
                                </li>
                                <li id="181">


                                    <a id="bibliography_10" title="万稚慧, 刘金山.基于隐马尔可夫模型的array-CGH数据贝叶斯分析[J].系统工程理论与实践, 2016 (3) :684-693." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XTLL201603014&amp;v=MDQwMTBab0Z5L2xVTC9JUFRuSFlyRzRIOWZNckk5RVlJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnU=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                        万稚慧, 刘金山.基于隐马尔可夫模型的array-CGH数据贝叶斯分析[J].系统工程理论与实践, 2016 (3) :684-693.
                                    </a>
                                </li>
                                <li id="183">


                                    <a id="bibliography_11" title="Cuayahuitl H, Renals S, Lemon O.Human-computer dialogue simulation using hidden Markov models [J].IEEE Workshop on Automatic Speech Recognition &amp;amp; Understanding, 2005, 290-295." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Human-computer dialogue simulation using hidden Markov models">
                                        <b>[11]</b>
                                        Cuayahuitl H, Renals S, Lemon O.Human-computer dialogue simulation using hidden Markov models [J].IEEE Workshop on Automatic Speech Recognition &amp;amp; Understanding, 2005, 290-295.
                                    </a>
                                </li>
                                <li id="185">


                                    <a id="bibliography_12" title="Hinton G, Deng L, Dong Y.Deep neural networks for acoustic modeling in speech recognition:the shared views of four research groups [J].IEEE Signal Processing Magazine, 2012, 29:82-97." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Deep Neural Networks for Acoustic Modeling in Speech Recognition">
                                        <b>[12]</b>
                                        Hinton G, Deng L, Dong Y.Deep neural networks for acoustic modeling in speech recognition:the shared views of four research groups [J].IEEE Signal Processing Magazine, 2012, 29:82-97.
                                    </a>
                                </li>
                                <li id="187">


                                    <a id="bibliography_13" title="Mohamed A, Hinton G.Phone recognition using restricted Boltzmann machines [J].IEEE International Conference on Acoustics Speech &amp;amp; Signal Processing, 2010, 23:4354-4357." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Phone recognition using restricted Boltzmann machines">
                                        <b>[13]</b>
                                        Mohamed A, Hinton G.Phone recognition using restricted Boltzmann machines [J].IEEE International Conference on Acoustics Speech &amp;amp; Signal Processing, 2010, 23:4354-4357.
                                    </a>
                                </li>
                                <li id="189">


                                    <a id="bibliography_14" title="Kelley R, Tavakkoli A, King C.Understanding human intentions via hidden Markov models in autonomous mobile robots [J].ACM/IEEE International Conference on Human-robot Interaction, 2008, 367-374." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Understanding human intentions via hidden Markov models in autonomous mobile robots">
                                        <b>[14]</b>
                                        Kelley R, Tavakkoli A, King C.Understanding human intentions via hidden Markov models in autonomous mobile robots [J].ACM/IEEE International Conference on Human-robot Interaction, 2008, 367-374.
                                    </a>
                                </li>
                                <li id="191">


                                    <a id="bibliography_15" title="Yu S Z, Kobayashi H.An efficient forward-backward algorithm for an explicit-duration hidden Markov model [J].IEEE Signal Processing Letters, 2003, 10 (1) :11-14." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An efficient forward-backward algorithm for an explicit-duration hidden Markov model">
                                        <b>[15]</b>
                                        Yu S Z, Kobayashi H.An efficient forward-backward algorithm for an explicit-duration hidden Markov model [J].IEEE Signal Processing Letters, 2003, 10 (1) :11-14.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=TJYJ" target="_blank">统计研究</a>
                2019,36(06),107-114 DOI:10.19343/j.cnki.11-1302/c.2019.06.009            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>部分状态可见的隐马尔可夫模型状态序列的估计方法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%A5%BC%E6%8C%AF%E5%87%AF&amp;code=37544990&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">楼振凯</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E4%BE%AF%E7%A6%8F%E5%9D%87&amp;code=06337388&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">侯福均</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%A5%BC%E6%97%AD%E6%98%8E&amp;code=29869530&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">楼旭明</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%8C%97%E4%BA%AC%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E7%AE%A1%E7%90%86%E4%B8%8E%E7%BB%8F%E6%B5%8E%E5%AD%A6%E9%99%A2&amp;code=0188644&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">北京理工大学管理与经济学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E8%A5%BF%E5%AE%89%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A6%E7%BB%8F%E6%B5%8E%E7%AE%A1%E7%90%86%E5%AD%A6%E9%99%A2&amp;code=0188644&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">西安邮电大学经济管理学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>本文考虑了部分状态可见的隐马尔可夫模型的状态序列估计问题, 在分析了现有算法无法合理估计状态路径之后, 以状态转移概率、观测概率和可见状态作为先验信息, 通过贝叶斯分析计算可见状态前后向状态的后验概率, 并给出初始条件和递推公式, 运用动态规划递推得到每个观测值对应的最可能状态以及最可能的状态路径。最后, 本文给出一个系统故障识别的应用例子, 验证了所设计算法的可行性。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%83%A8%E5%88%86%E7%8A%B6%E6%80%81%E5%8F%AF%E8%A7%81&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">部分状态可见;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E6%9E%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">贝叶斯分析;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">动态规划;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">状态估计;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%9C%80%E5%8F%AF%E8%83%BD%E8%B7%AF%E5%BE%84&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">最可能路径;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    楼振凯, 男, 北京理工大学管理与经济学院在读博士研究生。研究方向为决策与对策理论。;
                                </span>
                                <span>
                                    侯福均, 男, 北京理工大学管理与经济学院副教授。研究方向为群决策理论。;
                                </span>
                                <span>
                                    楼旭明, 男, 西安邮电大学经济管理学院教授。研究方向为运营管理。;
                                </span>
                    </p>
                
                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金面上项目“多准则决策中几个问题的探讨以及基于准测度的群决策研究” (71571019) 的资助;</span>
                    </p>
            </div>
                    <h1><b>Methods for State Sequence Estimation of Hidden Markov Model with Partially Visible States</b></h1>
                    <h2>
                    <span>Lou Zhenkai</span>
                    <span>Hou Fujun</span>
                    <span>Lou Xuming</span>
            </h2>
                                    <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>In this paper, problems of state sequence estimation in HMM with partially visible states are studied. After analyzing the shortcoming of the existing algorithms when handling state estimation in this type of HMM, this paper calculates the posterior probabilities of the states before and after the visible state via Bayesian analysis by treating state transfer probabilities, observation probabilities and visible states as prior information, presents the initial condition and recursion formula, and obtains the most possible state corresponding to every observation symbol as well as the best estimation of the state path by using dynamic programming recursion. An application example of failure recognition is given and the proposed algorithm is verified to be feasible.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Partially%20Visible%20States&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Partially Visible States;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Bayesian%20Analysis&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Bayesian Analysis;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Dynamic%20Programming&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Dynamic Programming;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=State%20Estimation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">State Estimation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Most%20Possible%20Path&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Most Possible Path;</a>
                </p>
            </div>
        

        <!--brief start-->
                        <h3 id="34" name="34" class="anchor-tag">一、引言</h3>
                <div class="p1">
                    <p id="35">隐马尔可夫模型被称为近半个世纪以来最成功的统计学模型之一, 广泛地应用于行为研究、基因识别、信息解码、软件测试等领域 (Lember和Koloydenko, 2008) <citation id="193" type="reference"><link href="163" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。在实际应用中, 隐马尔可夫模型需要解决三个基本问题, 即模型识别、状态估计和参数估计。本文的研究主要是基于部分状态可见的隐马尔可夫模型的状态估计展开的。</p>
                </div>
                <div class="p1">
                    <p id="36">半个世纪前, Viterbi (1967) <citation id="194" type="reference"><link href="165" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation> 面对卷积码数据解码, 提出了从后向前、逐步优化的Viterbi算法, 对隐藏的状态进行估计。该算法考虑了状态链路上前后状态之间的关系, 根据动态规划原理, 逐步递推得到整条最大可能状态路径。由于Viterbi算法理论上的合理性和应用上的可操作性, 半个世纪以来得到了广泛应用。Elmezain等 (2009) <citation id="195" type="reference"><link href="167" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>把Viterbi算法应用于手势运动轨迹的识别中, 并通过图像验证了该方法应用的可靠性。许多学者将Viterbi算法和Baum-Welch算法结合来解决带有未知参数的隐马尔可夫模型状态估计问题, 成功应用于行为预测、故障检测、决策点预测等问题的研究中 (覃龙等, 2019<citation id="196" type="reference"><link href="169" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>; Boutros和Liang, 2011<citation id="197" type="reference"><link href="171" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>; 冯超等, 2017<citation id="198" type="reference"><link href="173" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>) 。另外, 还有许多学者运用贝叶斯分析对隐马尔可夫模型中的未知参数进行估计 (Scott, 2002<citation id="199" type="reference"><link href="175" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>; Zoubin, 2001<citation id="200" type="reference"><link href="177" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>; 刘鹤飞等, 2017<citation id="201" type="reference"><link href="179" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>; 万稚慧和刘金山, 2016<citation id="202" type="reference"><link href="181" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>) 。</p>
                </div>
                <div class="p1">
                    <p id="37">上述文献都有个共同点, 就是将隐马尔可夫模型应用于状态预测中, 问题中对应的所有状态都是隐藏的。然而现实中并不是所有状态都是不可见的, Cuayahuitl等 (2005) <citation id="203" type="reference"><link href="183" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>针对人机对话模拟建立了输入—输出隐马尔可夫模型, 在该模型中部分状态是可见的;Hinton等 (2012) <citation id="204" type="reference"><link href="185" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>研究玻尔兹曼机的过程中提出了一种包含可见和不可见状态的隐马尔可夫学习模型;此外, 在Mohamed和Hinton (2010) <citation id="205" type="reference"><link href="187" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>以及Kelley等 (2008) <citation id="206" type="reference"><link href="189" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>研究的隐马尔可夫模型中, 都出现了部分可见的状态。上述文献表明许多隐马尔可夫模型中存在可见状态。另外, Yu和Kobayashi (2003) <citation id="207" type="reference"><link href="191" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>给出了只有最终状态可见的隐马尔可夫模型状态估计的前向—后向算法, 然而这种算法在估计每个时刻状态的概率是并不满足概率的规范性。</p>
                </div>
                <div class="p1">
                    <p id="38">不难发现, 许多问题可以建模为部分状态可见的隐马尔可夫模型。对这类问题的过去或将来状态进行估计的时候, 由于有了部分可见状态这一已知信息, 直接运用Viterbi算法或前向—后向递推算法并不能合理地解决。本文设计了基于贝叶斯分析的动态规划递推法, 来解决部分状态可见的隐马尔可夫模型状态序列估计问题, 同时处理了先验信息和后验信息所得结果不一致的问题。</p>
                </div>
                <h3 id="39" name="39" class="anchor-tag">二、模型描述</h3>
                <div class="p1">
                    <p id="40">隐马尔可夫模型中包含不可见的系统状态和可见的观测变量, 每个状态的发生对应可能观测到的若干离散或连续的观测值, 本文假设状态数量和观测变量个数有限, 且所讨论的隐马尔可夫模型是时齐的。</p>
                </div>
                <div class="p1">
                    <p id="41">一个标准的隐马尔可夫模型包括以下几部分:</p>
                </div>
                <div class="p1">
                    <p id="42"> (1) 模型中的状态。尽管状态一般是隐藏的, 但在应用中都具有实际意义。记有限状态空间Ω={1, 2, …, <i>k</i>}, 第<i>n</i>时刻的状态记为<i>S</i><sub><i>n</i></sub>=<i>i</i>, ∀<i>i</i>∈Ω。</p>
                </div>
                <div class="p1">
                    <p id="43"> (2) 状态的初始分布与转移概率。记<i>π</i>={<i>π</i><sub>1</sub>, <i>π</i><sub>2</sub>, …, <i>π</i><sub><i>k</i></sub>}为<i>S</i><sub><i>n</i></sub>的初始分布, 其中<i>π</i><sub><i>i</i></sub>=<i>P</i> (<i>S</i><sub>1</sub>=<i>i</i>) , ∀<i>i</i>∈Ω。记<i>a</i><sub><i>ij</i></sub>=<i>P</i> (<i>S</i><sub><i>n</i></sub><sub>+1</sub>=<i>j</i>|<i>S</i><sub><i>n</i></sub>=<i>i</i>) 为<i>S</i><sub><i>n</i></sub>的一步转移概率, ∀<i>i</i>、<i>j</i> ∈Ω, A= (<i>a</i><sub><i>ij</i></sub>) 是一步转移概率矩阵。</p>
                </div>
                <div class="p1">
                    <p id="44"> (3) 隐藏状态的观测符号。所有状态可能观测到的符号集合记为V, 这里的V可以是离散集合, 也可以是区间集合, 取决于状态对应的观测符号的分布。一个观测序列可记为O= (<i>O</i><sub>1</sub>, <i>O</i><sub>2</sub>, …, <i>O</i><sub><i>N</i></sub>) , <i>N</i>为观测样本的个数。</p>
                </div>
                <div class="p1">
                    <p id="45"> (4) 观测符号的概率分布。记<i>b</i><sub><i>iv</i><sub><i>j</i></sub></sub>=<i>P</i> (<i>O</i><sub><i>n</i></sub>=<i>v</i><sub><i>j</i></sub>|<i>S</i><sub><i>n</i></sub>=<i>i</i>) 为<i>n</i>时刻状态为<i>i</i>的条件下观测符号<i>v</i><sub><i>j</i></sub>的概率, ∀ <i>i</i> ∈Ω, ∀ <i>v</i><sub><i>j</i></sub>∈V, 并记B= (<i>b</i><sub><i>iv</i><sub><i>j</i></sub></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="46">综上, 隐马尔可夫模型的参数组可记为<i>λ</i>= (<i>π</i>, A, B) 。</p>
                </div>
                <div class="p1">
                    <p id="47">在本文所讨论的模型中, 状态转移概率和观测概率分布属于先验信息, 往往从历史样本数据中或者已知的规则中获知。</p>
                </div>
                <div class="p1">
                    <p id="48">对于一条具有多个可见状态的隐马尔可夫链来说, 总可以将链上的状态区间分成三种情况:①状态<i>S</i><sub>1</sub>可见, 其后面状态全不可见, 从<i>S</i><sub>1</sub>向后估计状态路径;②状态<i>S</i><sub><i>n</i></sub>可见, 其前面状态都不可见, 从<i>S</i><sub><i>n</i></sub>向前估计状态路径;③状态<i>S</i><sub>1</sub>和状态<i>S</i><sub><i>n</i></sub>可见, 中间状态不可见, 估计<i>S</i><sub>1</sub>和<i>S</i><sub><i>n</i></sub>之间的状态路径。第二种情况实质上是第一种情况的逆序递推, 计算方法和步骤完全一样, 只需要改变下标号, 故只需讨论第一种和第三种情况。</p>
                </div>
                <h3 id="49" name="49" class="anchor-tag">三、已知初始状态的状态估计</h3>
                <div class="p1">
                    <p id="50">隐马尔可夫模型的参数<i>λ</i>和观测符号序列为已知条件。分析第一种情况, 即从一个可见状态出发, 向后估计单个时刻状态和整条状态路径。为不失一般性, 假设初始<i>S</i><sub>1</sub>可见, 估计从<i>S</i><sub>1</sub>到<i>S</i><sub><i>n</i></sub>各个时刻的最可能状态, 此时 (<i>O</i><sub>1</sub>, …, <i>O</i><sub><i>n</i></sub>) = (<i>v</i><sub>1</sub>, …, <i>v</i><sub><i>n</i></sub>) 。令<i>S</i><sub>1</sub><sup>0</sup>=<i>S</i><sub>1</sub>=<i>i</i><sub>1</sub>∈Ω, 状态<i>S</i><sub>2</sub>的概率由观测值<i>O</i><sub>2</sub>和<i>S</i><sub>1</sub>的状态转移概率共同决定。由贝叶斯公式可知:</p>
                </div>
                <div class="p1">
                    <p id="51" class="code-formula">
                        <mathml id="51"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">|</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">|</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="52">当观测符号为离散型变量时, 可以得到:</p>
                </div>
                <div class="p1">
                    <p id="53" class="code-formula">
                        <mathml id="53"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><mo stretchy="false"> (</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">|</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="54">当观测符号为连续型变量时, 设<i>f</i> (<i>O</i><sub>2</sub>=<i>v</i><sub>2</sub>| <i>S</i><sub>2</sub>=<i>i</i>) 为其条件概率密度, 同样可得:</p>
                </div>
                <div class="p1">
                    <p id="55" class="code-formula">
                        <mathml id="55"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><mrow><munder><mo>∫</mo><mrow><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>∈</mo><mtext>Ω</mtext></mrow></munder><mi>f</mi></mrow></mstyle><mo stretchy="false"> (</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">|</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo><mi>d</mi><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="56">为了与上文的算法进行比较, 根据式 (1) 和式 (3) , 列出离散观测符号下<i>S</i><sub>2</sub>的后验概率估计公式如下:</p>
                </div>
                <div class="p1">
                    <p id="57" class="code-formula">
                        <mathml id="57"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">|</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="58">这样就得到了观测符号<i>O</i><sub>2</sub>=<i>v</i><sub>2</sub>对应的每个状态的概率, 记其概率分布为<i>P</i><sub>2</sub> (<i>i</i>) =<i>P</i> (<i>S</i><sub>2</sub>=<i>i</i>) , ∀<i>i</i>∈Ω。令<i>S</i><mathml id="59"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mn>0</mn></msubsup></mrow></math></mathml>=<i>S</i><sub>2</sub>=<i>i</i><sub>2</sub>, 其中<i>i</i><sub>2</sub>=arg max{<i>P</i> (<i>S</i><sub>2</sub>=<i>i</i>|<i>O</i><sub>2</sub>=<i>v</i><sub>2</sub>) |<i>i</i>∈Ω}。</p>
                </div>
                <div class="p1">
                    <p id="60">显然, 式 (4) 满足概率的规范性, 即有:</p>
                </div>
                <div class="p1">
                    <p id="61" class="code-formula">
                        <mathml id="61"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">|</mo><mi>Ο</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow></mfrac></mrow></mstyle><mo>=</mo><mn>1</mn></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="62">由于第一个状态为可见状态, 故从第二个状态的概率分布开始, 状态序列估计才具有递推性。记<i>m</i>时刻各个状态的概率分布为<i>P</i><sub><i>m</i></sub> (<i>i</i>) =<i>P</i> (<i>S</i><sub><i>m</i></sub>=<i>i</i>) , 2≤<i>m</i>&lt;<i>n</i>, 则有递推公式:</p>
                </div>
                <div class="p1">
                    <p id="63" class="code-formula">
                        <mathml id="63"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mo stretchy="false">|</mo><mi>Ο</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>5</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="64">由于<i>P</i><sub>2</sub> (<i>i</i>) 满足概率的规范性, 通过数学归纳法不难证明, 在式 (5) 的定义下, 后面所有时刻状态的概率都满足规范性, 即其和为1:</p>
                </div>
                <div class="p1">
                    <p id="65" class="code-formula">
                        <mathml id="65"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle></mrow></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mfrac><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo>=</mo><mn>1</mn></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="66">通过初始条件<i>P</i><sub>2</sub> (<i>i</i>) =<i>P</i> (<i>S</i><sub>2</sub>=<i>i</i>) 和递推公式 (5) , 不难得到每个时刻的最大概率状态<i>P</i><sup>*</sup><sub><i>m</i></sub> (<i>i</i>) , 令<i>S</i><mathml id="67"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>0</mn></msubsup></mrow></math></mathml>=S<sub>r</sub>=i<sub>r</sub>, 其中<i>i</i><sub><i>r</i></sub>=arg max{<i>P</i><sub><i>r</i></sub> (<i>i</i>) |<i>i</i>∈Ω}, 2≤<i>r</i>≤<i>n</i>。</p>
                </div>
                <div class="p1">
                    <p id="68">接下来分析状态路径的估计。与单个时刻状态估计类似, 由于初始状态为可见的, 即从第二个状态开始递推, 以某条路径发生的最大概率为指标函数, 逐步寻找指标函数最大的状态路径。初始条件<i>P</i><sup>*</sup> (<i>S</i><sub>2</sub>=<i>i</i>) 为第二个状态为<i>i</i>时的指标函数, 根据分步进行的事件概率相乘的原理, 得到递推公式如下:</p>
                </div>
                <div class="p1">
                    <p id="69"><i>P</i><sup>*</sup> (<i>S</i><sub><i>m</i>+1</sub>=<i>j</i>) =max{<i>P</i><sup>*</sup> (<i>S</i><sub><i>m</i></sub>=<i>i</i>) <i>P</i> (<i>S</i><sub><sub><i>m</i>+1</sub></sub>=<i>j</i>|<i>O</i><sub><sub><i>m</i>+1</sub></sub>=<i>v</i><sub><sub><i>m</i>+1</sub></sub>) |<i>i</i>∈Ω}      (6) </p>
                </div>
                <div class="p1">
                    <p id="70">结合式 (5) , 可以得到递推公式的可计算形式:</p>
                </div>
                <div class="p1">
                    <p id="71" class="code-formula">
                        <mathml id="71"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mo stretchy="false">) </mo><mo>=</mo><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mi>m</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mo>, </mo><mi>j</mi><mo>∈</mo><mtext>Ω</mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>7</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="72">显然, 当<i>j</i>在Ω中任意取值时指标函数<i>P</i><sup>*</sup> (<i>S</i><sub><i>m</i></sub><sub>+1</sub>=<i>j</i>) 有<i>k</i>个表达式。同时, 还可以得到相应的状态点的轨迹:</p>
                </div>
                <div class="p1">
                    <p id="73" class="code-formula">
                        <mathml id="73"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><msubsup><mrow></mrow><mi>r</mi><mo>*</mo></msubsup><mo>=</mo><mi>i</mi><msub><mrow></mrow><mi>r</mi></msub><mo>=</mo><mrow><mi>arg</mi></mrow><mspace width="0.25em" /><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mi>r</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mo>, </mo><mspace width="0.25em" /><mi>j</mi><mo>∈</mo><mtext>Ω</mtext><mo>, </mo><mn>2</mn><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi><mo>-</mo><mn>1</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>8</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="74">以及最后一个轨迹点<i>S</i><sub><i>n</i></sub><sup>*</sup>:</p>
                </div>
                <div class="p1">
                    <p id="75" class="code-formula">
                        <mathml id="75"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><msubsup><mrow></mrow><mi>n</mi><mo>*</mo></msubsup><mo>=</mo><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub><mo>=</mo><mi>j</mi><msup><mrow></mrow><mo>*</mo></msup><mo>=</mo><mrow><mi>arg</mi></mrow><mspace width="0.25em" /><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></msub></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext><mo>, </mo><mspace width="0.25em" /><mi>j</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>9</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="76">根据上述步骤, 可以得到基于第一个状态可见且观测序列已知的概率最大的状态路径 (<i>S</i><sup>*</sup><sub>1</sub>, …, <i>S</i><sup>*</sup><sub><i>n</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="77">已知最后一个状态, 向前递推的过程也类似, 且可以得到类似的结果。设<i>n</i>时刻状态<i>S</i><sub><i>n</i></sub>=<i>i</i><sub><i>n</i></sub>, 则第<i>n</i>-1时刻状态为<i>i</i>的概率为:</p>
                </div>
                <div class="p1">
                    <p id="78" class="code-formula">
                        <mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">|</mo><mi>Ο</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="79">记<i>m</i>时刻各个状态的概率分布为<i>P</i><sub><i>m</i></sub> (<i>i</i>) =<i>P</i> (<i>S</i><sub><i>m</i></sub>=<i>i</i>) , 2&lt;<i>m</i>≤<i>n</i>-1, 则有向前递推公式:</p>
                </div>
                <div class="p1">
                    <p id="80" class="code-formula">
                        <mathml id="80"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>Ρ</mi><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mo stretchy="false">|</mo><mi>Ο</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="81">设初始条件<i>P</i><sup>*</sup> (<i>S</i><sub><i>n</i></sub><sub>-1</sub>=<i>i</i>) 为倒数第二个状态为<i>i</i>时的指标函数, 有状态路径的向前递推公式:</p>
                </div>
                <div class="p1">
                    <p id="82" class="code-formula">
                        <mathml id="82"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mi>m</mi></msub><mo>=</mo><mi>j</mi><mo stretchy="false">) </mo><mo>=</mo><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="83">得到相应的状态点的轨迹:</p>
                </div>
                <div class="p1">
                    <p id="84" class="code-formula">
                        <mathml id="84"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><msubsup><mrow></mrow><mi>r</mi><mo>*</mo></msubsup><mo>=</mo><mi>i</mi><msub><mrow></mrow><mi>r</mi></msub><mo>=</mo><mrow><mi>arg</mi></mrow><mspace width="0.25em" /><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mi>r</mi></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mi>r</mi></msub></mrow></msub></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mo>, </mo><mspace width="0.25em" /><mi>j</mi><mo>∈</mo><mtext>Ω</mtext><mo>, </mo><mn>2</mn><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi><mo>-</mo><mn>1</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="85">以及第一个状态点的最优估计<i>S</i><sup>*</sup><sub>1</sub>:</p>
                </div>
                <div class="p1">
                    <p id="86" class="code-formula">
                        <mathml id="86"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><msubsup><mrow></mrow><mn>1</mn><mo>*</mo></msubsup><mo>=</mo><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mi>j</mi><msup><mrow></mrow><mo>*</mo></msup><mo>=</mo><mrow><mi>arg</mi></mrow><mspace width="0.25em" /><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></msub></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext><mo>, </mo><mi>j</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="87">上述估计最可能状态路径的算法是基于动态规划设计的, 因此对于一条<i>n</i>个状态的隐马尔可夫链来说, 经过<i>n</i>-1的递推即可得到最可能状态路径。</p>
                </div>
                <h3 id="88" name="88" class="anchor-tag">四、已知首末状态的状态估计</h3>
                <div class="p1">
                    <p id="89">接下来分析第三种情况, 即前后两个状态可见, 估计中间的单个时刻状态和整条状态路径。首先考虑单个时刻状态的估计, 从前往后估计和从后往前估计可以得到每个时刻每个状态的两个估计概率, 两种估计的已知条件相同, 因此可以认为是等价的。设<i>P</i><sup>+</sup><sub><i>m</i></sub> (<i>i</i>) 为从前往后递推得到的第<i>m</i>时刻状态为<i>i</i>的概率, <i>P</i><sup>-</sup><sub><i>m</i></sub> (<i>i</i>) 为从后往前递推得到的第<i>m</i>时刻状态为<i>i</i>的概率, 本文给出的规则如下:</p>
                </div>
                <div class="p1">
                    <p id="90"><i>P</i><sub><i>m</i></sub> (<i>i</i>) =0, <i>if</i>min{<i>P</i><sub><i>m</i></sub><sup>+</sup> (<i>i</i>) , <i>P</i><sup>-</sup><sub><i>m</i></sub> (<i>i</i>) }=0, ∀<i>i</i>∈Ω      (15) </p>
                </div>
                <div class="p1">
                    <p id="91"><i>P</i><sub><i>m</i></sub> (<i>i</i>) =1, <i>if</i>max{<i>P</i><sub><i>m</i></sub><sup>+</sup> (<i>i</i>) , <i>P</i><sup>-</sup><sub><i>m</i></sub> (<i>i</i>) }=1, ∀<i>i</i>∈Ω      (16) </p>
                </div>
                <div class="p1">
                    <p id="92">对于其他介于0和1之间的估计值, 可以取:</p>
                </div>
                <div class="p1">
                    <p id="93" class="code-formula">
                        <mathml id="93"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>Ρ</mi><msubsup><mrow></mrow><mi>m</mi><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo>+</mo><mi>Ρ</mi><msubsup><mrow></mrow><mi>m</mi><mo>-</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mn>2</mn></mfrac><mo>, </mo><mo>∀</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>7</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="94">对式 (15) ～ (17) 的结果规范化处理, 最终得到估计值<i>P</i><sup>*</sup><sub><i>m</i></sub> (<i>i</i>) :</p>
                </div>
                <div class="p1">
                    <p id="95" class="code-formula">
                        <mathml id="95"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msubsup><mrow></mrow><mi>m</mi><mo>*</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>Ρ</mi><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>8</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="96">下面对处理规则的合理性做出说明。首先, 在马尔可夫链连通的情况下, 当从前往后递推得到某时刻某状态的概率为0或1时, 显然不需要考虑从后往前递推的结果, 其赋值必为0或1, 从后往前也一样。其次, 由于两种递推是等价的, 因此式 (17) 取均值也较为合理。式 (18) 的给出, 是为了保证每个时刻各状态概率之和为1。</p>
                </div>
                <div class="p1">
                    <p id="97">再来分析状态路径的估计。该问题等价于已知初始状态和最终状态, 寻找最优路径的动态规划问题。根据动态规划的最优性原理, 顺序递推和逆序递推得到的结果应该是相同的, 但本文中同一条路径, 顺着走和逆着走两种方式发生的概率并不相等。举例来说, 在状态数为<i>k</i>的HMM中, 当观测值<i>O</i><sub><i>m</i></sub>=<i>v</i><sub><i>m</i></sub>、<i>O</i><sub><i>m</i>+1</sub>=<i>v</i><sub><i>m</i>+1</sub>时, 对状态<i>i</i>来说下一时刻转移到状态<i>j</i>的概率为<i>P</i><sub><i>ij</i></sub>, 对状态<i>j</i>来说上一时刻状态为<i>i</i>的概率为<i>P</i>′<sub><i>ij</i></sub>, 即有:</p>
                </div>
                <div class="p1">
                    <p id="98" class="code-formula">
                        <mathml id="98"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mo>, </mo><msup><mi>Ρ</mi><mo>′</mo></msup><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub></mrow></mfrac></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="99">也就是说, <i>P</i><sub><i>ij</i></sub>=<i>P</i><sup>/</sup><sub><i>ij</i></sub>并不总是成立的。尽管如此, 仍然可以得到以下结论:对首末状态可见的HMM, 顺序递推可行的状态路径, 逆序递推必然可行。证明如下:设初始状态为<i>i</i><sub>1</sub>, 最终状态为<i>i</i><sub><i>n</i></sub>, 观测序列<i>v</i>= (<i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>, …, <i>v</i><sub><i>n</i></sub>) , 对路径 (<i>i</i><sub>1</sub>, <i>i</i><sub>2</sub>, …, <i>i</i><sub><i>n</i></sub>) 的正向概率<i>P</i><sup>+</sup>和逆向概率<i>P</i><sup>-</sup>, 有:</p>
                </div>
                <div class="p1">
                    <p id="100" class="code-formula">
                        <mathml id="100"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mi>Ρ</mi><msup><mrow></mrow><mo>+</mo></msup><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mrow><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mi>i</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>3</mn></msub><mi>v</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mrow><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub></mrow></mfrac><mo>×</mo><mo>⋯</mo><mo>×</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mrow><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mo>×</mo><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></msub><mo>&gt;</mo><mn>0</mn></mtd></mtr><mtr><mtd><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>Ρ</mi><msup><mrow></mrow><mo>-</mo></msup><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mrow><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mrow><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub></mrow></msub></mrow></mfrac><mo>×</mo><mo>⋯</mo><mo>×</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mi>i</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mrow><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow></mfrac><mo>×</mo><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub><mo>&gt;</mo><mn>0</mn></mtd></mtr></mtable><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>9</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="101">从充要条件 (19) 中不难发现, <i>P</i><sup>+</sup>和<i>P</i><sup>-</sup>分子的乘积相等, 因此有上述结论。</p>
                </div>
                <div class="p1">
                    <p id="102">类比单个时刻状态估计, 很自然会联想到计算状态路径正向和逆向概率, 求平均或做乘积。然而这样做的前提是穷举法求出链路中所有可能的正向和逆向状态路径, 计算量极大。为了能够比较路径发生的概率值从而找出最大可能路径, 本文给出在避免穷举路径的条件下, 每条状态路径概率值唯一的规则。</p>
                </div>
                <div class="p1">
                    <p id="103">充要条件 (19) 提供了一种思路, 即每条路径正向概率和逆向概率的分子相等, 只需要令其对应乘式的分母相等, 则概率值唯一。设对状态<i>i</i>来说下一时刻转移到状态<i>j</i>的概率为<i>P</i><sub><i>ij</i></sub>, 定义如下:</p>
                </div>
                <div class="p1">
                    <p id="104" class="code-formula">
                        <mathml id="104"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub></mrow><mrow><mi>max</mi><mrow><mo>{</mo><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub></mrow><mo>}</mo></mrow></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="105">显然, 式 (20) 保证了在观测序列<i>v</i>= (<i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>, …, <i>v</i><sub><i>n</i></sub>) 下的任意路径 (<i>i</i><sub>1</sub>, <i>i</i><sub>2</sub>, …, <i>i</i><sub><i>n</i></sub>) 的正向概率和逆向概率相等, 即<i>P</i><sup>+</sup>=<i>P</i><sup>-</sup>。在式 (20) 中, 分母的实际意义为:状态为<i>i</i>下看到下一时刻观测符号为<i>v</i><sub><i>m</i></sub><sub>+1</sub>的概率和状态为<i>j</i>下看到上一时刻观测符号为<i>v</i><sub><i>m</i></sub>的概率中较大的一个。这里采用了max-min准则, 即一步状态路径概率取小条件下, 找到整条状态路径概率最大的路径。这样只需要求出相邻时刻所有可能状态下观测符号的发生概率, 就可以运用上文提出的动态规划方法进行递推, 得到最大可能状态路径。由式 (20) 可知, 对第一阶段和最后阶段的所有状态的转移概率<i>P</i><sub><i>ij</i></sub>来说, 分母都为1。</p>
                </div>
                <div class="p1">
                    <p id="106">根据式 (7) 、式 (12) 和式 (20) , 得到了首尾状态已知下, 寻找最优路径的递推公式:</p>
                </div>
                <div class="p1">
                    <p id="107" class="code-formula">
                        <mathml id="107"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>j</mi><mo stretchy="false">) </mo><mo>=</mo><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mi>m</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mi>max</mi><mrow><mo>{</mo><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub></mrow><mo>}</mo></mrow></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="108">根据式 (21) , 即可找到概率最大的状态路径中状态点的轨迹:</p>
                </div>
                <div class="p1">
                    <p id="109" class="code-formula">
                        <mathml id="109"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><msubsup><mrow></mrow><mi>r</mi><mo>*</mo></msubsup><mo>=</mo><mi>j</mi><msub><mrow></mrow><mi>r</mi></msub><mo>=</mo><mrow><mi>arg</mi></mrow><mspace width="0.25em" /><mrow><mi>max</mi></mrow><mrow><mo>{</mo><mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mi>r</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mi>max</mi><mrow><mo>{</mo><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mi>r</mi></msub></mrow></msub></mrow><mo>}</mo></mrow></mrow></mfrac><mo stretchy="false">|</mo><mi>i</mi><mo>∈</mo><mtext>Ω</mtext></mrow><mo>}</mo></mrow><mo>, </mo><mspace width="0.25em" /><mn>2</mn><mo>≤</mo><mi>r</mi><mo>≤</mo><mi>n</mi><mo>-</mo><mn>1</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="110">类似地, 对一条已知首末状态的隐马尔可夫链, 只需经过<i>n</i>-2步递推, 就可以得到最可能状态路径, 只不过每一步递推的运算量比只已知一个状态的最可能路径估计的运算量大。</p>
                </div>
                <h3 id="111" name="111" class="anchor-tag">五、应用分析</h3>
                <div class="p1">
                    <p id="112">本文将部分状态可见的隐马尔可夫模型状态序列的估计方法应用到工业系统的故障识别中, 系统开始和结束作业时的状况可见, 而运行中的状况往往无法获知。为了进一步了解系统运行中的状况, 需要对其进行估计。</p>
                </div>
                <div class="p1">
                    <p id="113">分别记正常模态, 故障1, 故障2和故障3为1, 2, 3和4, 即状态空间为Ω={1, 2, 3, 4}。不同状态下观测到样本的概率分布也有所不同, 给出状态转移概率矩阵A= (<i>a</i><sub><i>ij</i></sub>) 和观测符号概率分布矩阵B= (<i>b</i><sub><i>iv</i><sub><i>j</i></sub></sub>) 如下:</p>
                </div>
                <div class="p1">
                    <p id="114" class="code-formula">
                        <mathml id="114"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>A</mtext><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd><mn>0</mn></mtd><mtd><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd></mtr><mtr><mtd><mfrac><mn>1</mn><mn>4</mn></mfrac></mtd><mtd><mn>0</mn></mtd><mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd><mtd><mfrac><mn>1</mn><mn>4</mn></mfrac></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mfrac><mn>2</mn><mn>3</mn></mfrac></mtd><mtd><mn>0</mn></mtd><mtd><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd></mtr><mtr><mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd><mtd><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mo>, </mo><mspace width="0.25em" /><mtext>B</mtext><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd columnalign="left"><mfrac><mn>1</mn><mn>4</mn></mfrac></mtd><mtd columnalign="left"><mfrac><mn>1</mn><mn>2</mn></mfrac></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mfrac><mn>1</mn><mn>4</mn></mfrac></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd columnalign="left"><mfrac><mn>2</mn><mn>3</mn></mfrac></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd columnalign="left"><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd></mtr><mtr><mtd columnalign="left"><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd columnalign="left"><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd columnalign="left"><mfrac><mn>1</mn><mn>3</mn></mfrac></mtd><mtd columnalign="left"><mn>0</mn></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="115">一次运行中, 观测到样本序列O= (<i>O</i><sub>1</sub>, <i>O</i><sub>2</sub>, <i>O</i><sub>3</sub>, <i>O</i><sub>4</sub>) = (<i>v</i><sub>4</sub>, <i>v</i><sub>3</sub>, <i>v</i><sub>2</sub>, <i>v</i><sub>1</sub>) , 已知系统初始状态为正常模态, 结束状态为故障2, 即<i>S</i><sub>1</sub>=1, <i>S</i><sub>4</sub>=3, 估计运行过程中每个阶段的最可能状态和整条最可能状态路径。</p>
                </div>
                <div class="p1">
                    <p id="116">首先以<i>S</i><sub>1</sub>为起点, 从前往后递推每个阶段各状态的概率。由式 (4) 得:</p>
                </div>
                <div class="p1">
                    <p id="117" class="code-formula">
                        <mathml id="117"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msubsup><mrow></mrow><mn>2</mn><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mn>1</mn><mn>1</mn></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mn>1</mn><mi>v</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mn>1</mn><mi>i</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub></mrow></mfrac><mo>=</mo><mn>0</mn></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="118">同样可以得到<i>P</i><sub>2</sub><sup>+</sup> (2) =2/3, <i>P</i><sub>2</sub><sup>+</sup> (3) =0, <i>P</i><sub>2</sub><sup>+</sup> (4) =1/3。接下来可以进行递推, 运用式 (5) , 可以得到:</p>
                </div>
                <div class="p1">
                    <p id="119" class="code-formula">
                        <mathml id="119"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msubsup><mrow></mrow><mn>3</mn><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></munderover><mi>Ρ</mi></mstyle><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mn>3</mn><mn>5</mn></mfrac></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="120">同样可以得到<i>P</i><sup>+</sup><sub>3</sub> (2) =2/15, <i>P</i><sup>+</sup><sub>3</sub> (3) =0, <i>P</i><sup>+</sup><sub>3</sub> (4) =4/15。</p>
                </div>
                <div class="p1">
                    <p id="121">然后以<i>S</i><sub>4</sub>为起点, 运用式 (10) 和式 (11) 从后往前递推每个阶段每个状态的概率。不难得到, <i>P</i><sup>-</sup><sub>3</sub> (1) =0, <i>P</i><sup>-</sup><sub>3</sub> (2) =1, <i>P</i><sup>-</sup><sub>3</sub> (3) =0, <i>P</i><sup>-</sup><sub>3</sub> (4) =0;<i>P</i><sup>-</sup><sub>2</sub> (1) =0, <i>P</i><sup>-</sup><sub>2</sub> (2) =0, <i>P</i><sup>-</sup><sub>2</sub> (3) =4/7, <i>P</i><sup>-</sup><sub>2</sub> (4) =3/7。</p>
                </div>
                <div class="p1">
                    <p id="122">运用式 (15) ～ (18) , 得到<i>P</i><sup>*</sup><sub>2</sub> (1) =0, <i>P</i><sup>*</sup><sub>2</sub> (2) =0, <i>P</i><sup>*</sup><sub>2</sub> (3) =0, <i>P</i><sup>*</sup><sub>2</sub> (4) =1;<i>P</i><sup>*</sup><sub>3</sub> (1) =0, <i>P</i><sup>*</sup><sub>3</sub> (2) =1, <i>P</i><sup>*</sup><sub>3</sub> (3) =0, <i>P</i><sup>*</sup><sub>3</sub> (4) =0。从而得到中间各阶段状态序列的估计 (事实上也是准确值) <i>S</i><sub>2</sub>=4, <i>S</i><sub>3</sub>=2。</p>
                </div>
                <div class="p1">
                    <p id="123">算例的结果除了验证算法的可行性外, 还可以得到另外一个结论, 即增加一个可见状态, 往往能极大地提高估计的准确性。</p>
                </div>
                <div class="p1">
                    <p id="124">接下来根据式 (20) ～ (22) 寻找该算例的最大可能状态路径。由式 (20) 、式 (21) 可得到:</p>
                </div>
                <div class="p1">
                    <p id="125" class="code-formula">
                        <mathml id="125"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mtext>S</mtext><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mn>1</mn><mo stretchy="false">) </mo><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mn>1</mn><mn>1</mn></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mn>1</mn><mi>v</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub></mrow><mrow><mi>max</mi><mo stretchy="false">{</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mn>1</mn><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mn>3</mn></msub></mrow></msub><mo>, </mo><mn>1</mn><mo stretchy="false">}</mo></mrow></mfrac><mo>=</mo><mn>0</mn></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="126">同理可得到<i>P</i><sup>*</sup> (<i>S</i><sub>2</sub>=2) =2/9, <i>P</i><sup>*</sup> (<i>S</i><sub>2</sub>=3) =0, <i>P</i><sup>*</sup> (<i>S</i><sub>2</sub>=4) =1/9。再根据式 (21) 和式 (22) 递推并记录状态点轨迹1-2-1:</p>
                </div>
                <div class="p1">
                    <p id="127" class="code-formula">
                        <mathml id="127"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>3</mn></msub><mo>=</mo><mn>1</mn><mo stretchy="false">) </mo><mo>=</mo><mrow><mi>max</mi></mrow><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mi>m</mi></msub><mo>=</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mi>max</mi><mo stretchy="false">{</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></msub><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub><mo stretchy="false">}</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>a</mi><msub><mrow></mrow><mrow><mn>2</mn><mn>1</mn></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mn>1</mn><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub><mi>Ρ</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>S</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mn>2</mn><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mn>1</mn></mrow></msub><mi>b</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mn>5</mn></mrow></mfrac></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="128">同样得到<i>P</i><sup>*</sup> (<i>S</i><sub>3</sub>=2) =2/45, 记录轨迹1-4-2;<i>P</i><sup>*</sup> (<i>S</i><sub>3</sub>=3) =0;<i>P</i><sup>*</sup> (<i>S</i><sub>3</sub>=4) =2/27, 记录轨迹1-2-4。<i>P</i><sup>*</sup> (<i>S</i><sub>4</sub>=3) =1/45, 记录状态轨迹1-4-2-3, 也即系统运行中各故障发生的顺序。</p>
                </div>
                <div class="p1">
                    <p id="129">本例中最大可能路径与单个时刻状态估计的结果相符。当然许多情况下, 单个时刻与整条路径的估计结果在各个时刻的状态未必吻合, 因为整条路径的估计考虑的是这条路径上的状态同时发生的概率最大。</p>
                </div>
                <h3 id="130" name="130" class="anchor-tag">六、结论</h3>
                <div class="p1">
                    <p id="131">本文对参数已知的隐马尔可夫模型的状态序列估计问题进行了研究, 指出部分状态可见的隐马尔可夫模型的普遍性, 分析和比较了已有的估计方法, 并指出该类模型状态序列估计的缺陷。通过分析先验与后验信息, 本文给出了一种基于贝叶斯分析和动态规划的估计方法, 并证明了其在解决部分可见状态隐马尔可夫模型单个时刻状态估计和整条状态路径估计上的合理性。文章最后给出一个系统故障识别的应用例子, 验证了方法的可行性。</p>
                </div>
                <div class="p1">
                    <p id="132">本文设计的算法在估计首末状态已知的状态路径时, 由于需要对一步状态路径概率的分母进行比较取大, 增加了计算量。另外, 为了使问题的研究较为凝练, 本文仅考虑了齐次隐马尔可夫模型, 且模型参数都是已知的。在实际的应用中, 或许需要做一些其他的改进。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="163">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJST&amp;filename=SJST14120500890573&amp;v=MTY3NzRud1plWnRGaW5sVXJuSUoxNFhhaEk9TmlmWWVySzhIOVBNcW85RmJPSVBDWHM2b0JNVDZUNFBRSC9pclJkR2VycVFUTQ==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b>Lember J, Koloydenko A.The adjusted Viterbi training for hidden Markov models [J].Bernoulli, 2008, 14:180-206.
                            </a>
                        </p>
                        <p id="165">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Error bounds for convolutional codes and an asymptotically optimum decoding algorithm">

                                <b>[2]</b>Viterbi A J.Error bounds for convolutional codes and an asymptotically optimum decoding algorithm [J].IEEE Transactions on Information Theory, 1967, 13:260-269.
                            </a>
                        </p>
                        <p id="167">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A Hidden MarkovModel-Based Isolated and Meaningful Hand Gesture Recognition">

                                <b>[3]</b>Elmezain M, Al-Hamadi A, Appenrodt J.A hidden Markov model-based isolated and meaningful hand gesture recognition [J].International Journal of Electrical, 2009, 3:156-163.
                            </a>
                        </p>
                        <p id="169">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=SWGC201901006&amp;v=MTU2NjhIOWpNcm85RllvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVab0Z5L2xVTC9JTmpyTWJiRzQ=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b>覃龙, 高琳, 张权.人类交互行为的隐马尔可夫模型[J].生物医学工程学杂志, 2019 (1) :40-49.
                            </a>
                        </p>
                        <p id="171">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012100144501&amp;v=Mjg1MDNPcm85RlplOExDWHc0b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcm5JSjE0WGFoST1OaWZPZmJLN0h0RA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b>Boutros T, Liang M.Detection and diagnosis of bearing and cutting tool faults using hidden Markov models [J].Mechanical Systems and Signal Processing, 2011, 25:2102-2124.
                            </a>
                        </p>
                        <p id="173">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=BJHK201703025&amp;v=MDc4MzR6cXFCdEdGckNVUjdxZlp1Wm9GeS9sVUwvSUp5ZkRaYkc0SDliTXJJOUhZWVFLREg4NHZSNFQ2ajU0TzM=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b>冯超, 景小宁, 李秋妮等.基于隐马尔可夫模型的空战决策点理论研究[J].北京航空航天大学学报, 2017 (3) :615-626.
                            </a>
                        </p>
                        <p id="175">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=STJD&amp;filename=STJD13062800007231&amp;v=MjQ2MzNPc0lEbjg0b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadEZpbmxVcm5JSjE0WGFoST1Oam5CYXJLN0h0Zk9wNDlGWg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b>Scott S L.Bayesian methods for hidden Markov models [J].Journal of the American Statistical Association, 2002, 97:337-351.
                            </a>
                        </p>
                        <p id="177">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An Introduction to Hidden Markov Models and Bayesian Networks">

                                <b>[8]</b>Zoubin G.An introduction to hidden Markov models and Bayesian networks [J].International Journal of Pattern Recognition and Artificial Intelligence, 2001, 15 (1) , 9-42.
                            </a>
                        </p>
                        <p id="179">
                            <a id="bibliography_9" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TJYJ201712011&amp;v=MDMwMjlqNTRPM3pxcUJ0R0ZyQ1VSN3FmWnVab0Z5L2xVTC9JTVNmU1pMRzRIOWJOclk5RVpZUUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[9]</b>刘鹤飞, 王坤, 蒋成飞.隐状态个数未知的隐马尔可夫多元正态分布的贝叶斯推断[J].统计研究, 2017 (12) , 119-125.
                            </a>
                        </p>
                        <p id="181">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XTLL201603014&amp;v=MjM0MzMzenFxQnRHRnJDVVI3cWZadVpvRnkvbFVML0lQVG5IWXJHNEg5Zk1ySTlFWUlRS0RIODR2UjRUNmo1NE8=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b>万稚慧, 刘金山.基于隐马尔可夫模型的array-CGH数据贝叶斯分析[J].系统工程理论与实践, 2016 (3) :684-693.
                            </a>
                        </p>
                        <p id="183">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Human-computer dialogue simulation using hidden Markov models">

                                <b>[11]</b>Cuayahuitl H, Renals S, Lemon O.Human-computer dialogue simulation using hidden Markov models [J].IEEE Workshop on Automatic Speech Recognition &amp; Understanding, 2005, 290-295.
                            </a>
                        </p>
                        <p id="185">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Deep Neural Networks for Acoustic Modeling in Speech Recognition">

                                <b>[12]</b>Hinton G, Deng L, Dong Y.Deep neural networks for acoustic modeling in speech recognition:the shared views of four research groups [J].IEEE Signal Processing Magazine, 2012, 29:82-97.
                            </a>
                        </p>
                        <p id="187">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Phone recognition using restricted Boltzmann machines">

                                <b>[13]</b>Mohamed A, Hinton G.Phone recognition using restricted Boltzmann machines [J].IEEE International Conference on Acoustics Speech &amp; Signal Processing, 2010, 23:4354-4357.
                            </a>
                        </p>
                        <p id="189">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Understanding human intentions via hidden Markov models in autonomous mobile robots">

                                <b>[14]</b>Kelley R, Tavakkoli A, King C.Understanding human intentions via hidden Markov models in autonomous mobile robots [J].ACM/IEEE International Conference on Human-robot Interaction, 2008, 367-374.
                            </a>
                        </p>
                        <p id="191">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An efficient forward-backward algorithm for an explicit-duration hidden Markov model">

                                <b>[15]</b>Yu S Z, Kobayashi H.An efficient forward-backward algorithm for an explicit-duration hidden Markov model [J].IEEE Signal Processing Letters, 2003, 10 (1) :11-14.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="TJYJ201906009" />
        <input id="dpi" type="hidden" value="200" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TJYJ201906009&amp;v=MDA1MTE0TzN6cXFCdEdGckNVUjdxZlp1Wm9GeS9sVUwvSU1TZlNaTEc0SDlqTXFZOUZiWVFLREg4NHZSNFQ2ajU=&amp;uid=WEEvREcwSlJHSldRa1FhcTdnTnhXM3ZNczVuMWxvWHh6aDZ1UFp4Z2NVUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=842_VlRz_g1CMCLi-M0twVw-4EOFG_noWyi_OsMnrAg1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>


    <link href="/kxreader/Content/css/LeftDetail?v=vAscMyvIPP9NePnbGPkqJ0A5tHOvnzl65tGuRDsf9xg1" rel="stylesheet"/>

</body>
</html>

