

<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>

</head>

<body>

    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637127163111238750%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201909020%26RESULT%3d1%26SIGN%3d84%252fZAEQ9GiXgHOMK%252bathWmTP9PI%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201909020&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201909020&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>


    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201909020&amp;v=MjgzNzVnVjcvSUx5dlNkTEc0SDlqTXBvOUhaSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#108" data-title="&lt;b&gt;1 研究背景和动机&lt;/b&gt; "><b>1 研究背景和动机</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#109" data-title="&lt;b&gt;1.1 云存储中编码研究现状&lt;/b&gt;"><b>1.1 云存储中编码研究现状</b></a></li>
                                                <li><a href="#117" data-title="&lt;b&gt;1.2 云存储中磁盘故障预测研究现状&lt;/b&gt;"><b>1.2 云存储中磁盘故障预测研究现状</b></a></li>
                                                <li><a href="#125" data-title="&lt;b&gt;1.3 本文研究动机&lt;/b&gt;"><b>1.3 本文研究动机</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#130" data-title="&lt;b&gt;2 pLRC的设计&lt;/b&gt; "><b>2 pLRC的设计</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#132" data-title="&lt;b&gt;2.1 磁盘故障预测算法选择&lt;/b&gt;"><b>2.1 磁盘故障预测算法选择</b></a></li>
                                                <li><a href="#137" data-title="&lt;b&gt;2.2 pLRC编码算法设计&lt;/b&gt;"><b>2.2 pLRC编码算法设计</b></a></li>
                                                <li><a href="#159" data-title="&lt;b&gt;2.3 pLRC算法优化&lt;/b&gt;"><b>2.3 pLRC算法优化</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#168" data-title="&lt;b&gt;3 理论量化分析&lt;/b&gt; "><b>3 理论量化分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#170" data-title="&lt;b&gt;3.1 可靠性分析&lt;/b&gt;"><b>3.1 可靠性分析</b></a></li>
                                                <li><a href="#180" data-title="&lt;b&gt;3.2 修复带宽分析&lt;/b&gt;"><b>3.2 修复带宽分析</b></a></li>
                                                <li><a href="#192" data-title="&lt;b&gt;3.3 pLRC更新开销分析&lt;/b&gt;"><b>3.3 pLRC更新开销分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#204" data-title="&lt;b&gt;4 实验与结果&lt;/b&gt; "><b>4 实验与结果</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#206" data-title="&lt;b&gt;4.1 实验部署环境&lt;/b&gt;"><b>4.1 实验部署环境</b></a></li>
                                                <li><a href="#218" data-title="&lt;b&gt;4.2 实验配置与方法&lt;/b&gt;"><b>4.2 实验配置与方法</b></a></li>
                                                <li><a href="#222" data-title="&lt;b&gt;4.3 实验结果&lt;/b&gt;"><b>4.3 实验结果</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#230" data-title="&lt;b&gt;5 总  结&lt;/b&gt; "><b>5 总  结</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#116" data-title="图1 (6,2,2) LRC的示例图">图1 (6,2,2) LRC的示例图</a></li>
                                                <li><a href="#129" data-title="图2 (6,2,2) LRC 转换为pLRC的示例图">图2 (6,2,2) LRC 转换为pLRC的示例图</a></li>
                                                <li><a href="#134" data-title="&lt;b&gt;表1 所选的SMART属性&lt;/b&gt;"><b>表1 所选的SMART属性</b></a></li>
                                                <li><a href="#135" data-title="&lt;b&gt;表2 决策树和人工神经网络的性能比较&lt;/b&gt;"><b>表2 决策树和人工神经网络的性能比较</b></a></li>
                                                <li><a href="#158" data-title="图3 pLRC的算法示例图">图3 pLRC的算法示例图</a></li>
                                                <li><a href="#173" data-title="图4 马尔可夫可靠性模型">图4 马尔可夫可靠性模型</a></li>
                                                <li><a href="#178" data-title="&lt;b&gt;表3 不同带宽下LRC和pLRC的MTTDL&lt;/b&gt; a"><b>表3 不同带宽下LRC和pLRC的MTTDL</b> a</a></li>
                                                <li><a href="#185" data-title="图5 LRC和pLRC修复带宽的理论分析结果">图5 LRC和pLRC修复带宽的理论分析结果</a></li>
                                                <li><a href="#202" data-title="图6 算法1和算法2更新方式的传输开销">图6 算法1和算法2更新方式的传输开销</a></li>
                                                <li><a href="#213" data-title="图7 pLRC架构图">图7 pLRC架构图</a></li>
                                                <li><a href="#224" data-title="图8 LRC和pLRC的降级读性能">图8 LRC和pLRC的降级读性能</a></li>
                                                <li><a href="#228" data-title="图9 LRC和pLRC的节点修复性能">图9 LRC和pLRC的节点修复性能</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="404">


                                    <a id="bibliography_1" title="Sebastian M.Microsoft Azure suffers outage after cooling issue[OL].[2019-01-05]https://www.datacenterdynamics.com/news/microsoft-azure-suffers-outage-after-cooling-issue/" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Microsoft Azure suffers outage after cooling issue[OL]">
                                        <b>[1]</b>
                                        Sebastian M.Microsoft Azure suffers outage after cooling issue[OL].[2019-01-05]https://www.datacenterdynamics.com/news/microsoft-azure-suffers-outage-after-cooling-issue/
                                    </a>
                                </li>
                                <li id="406">


                                    <a id="bibliography_2" title="Reed I S,Solomon G.Polynomial codes over certain finite fields[J].Journal of the Society for Industrial and Applied Mathematics,1960,8(2):300- 304" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJST&amp;filename=SJST14120300998566&amp;v=MjkxMjhvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVVMM0lKMXNRYWhJPU5pZlllcks4SDlQTXJJOUZiZUlIQ1hvLw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                        Reed I S,Solomon G.Polynomial codes over certain finite fields[J].Journal of the Society for Industrial and Applied Mathematics,1960,8(2):300- 304
                                    </a>
                                </li>
                                <li id="408">


                                    <a id="bibliography_3" title="Weatherspoon H,Kubiatowicz J D.Erasure coding vs.replication:A quantitative comparison[C] //Proc of Int Workshop on Peer-to-Peer Systems (IPTPS&#39;02).Berlin:Springer,2002:328- 337" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Erasure coding vs. replication: A quantitativecomparison">
                                        <b>[3]</b>
                                        Weatherspoon H,Kubiatowicz J D.Erasure coding vs.replication:A quantitative comparison[C] //Proc of Int Workshop on Peer-to-Peer Systems (IPTPS&#39;02).Berlin:Springer,2002:328- 337
                                    </a>
                                </li>
                                <li id="410">


                                    <a id="bibliography_4" title="Huang Cheng,Simitci H,Xu Yikang,et al.Erasure coding in windows Azure storage[C] //Proc of the 2012 USENIX Conf on Annual Technical Conf (ATC&#39;12).Berkeley,CA:USENIX Association,2012:15- 26" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Erasure coding in windows azure storage">
                                        <b>[4]</b>
                                        Huang Cheng,Simitci H,Xu Yikang,et al.Erasure coding in windows Azure storage[C] //Proc of the 2012 USENIX Conf on Annual Technical Conf (ATC&#39;12).Berkeley,CA:USENIX Association,2012:15- 26
                                    </a>
                                </li>
                                <li id="412">


                                    <a id="bibliography_5" title="Sathiamoorthy M,Asteris M,Papailiopoulos D,et al.Xoring elephants:Novel erasure codes for big data[J].Proceedings of International Conf on Very Large Data Bases Endowment,2013,6(5):325- 336" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=XORing elephants:Novel erasure codes for big data">
                                        <b>[5]</b>
                                        Sathiamoorthy M,Asteris M,Papailiopoulos D,et al.Xoring elephants:Novel erasure codes for big data[J].Proceedings of International Conf on Very Large Data Bases Endowment,2013,6(5):325- 336
                                    </a>
                                </li>
                                <li id="414">


                                    <a id="bibliography_6" title="Papailiopoulos D,Dimakis A G.Locally repairable codes[J].IEEE Transactions on Information Theory,2014,60(10):5843- 5855" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Locally repairable codes">
                                        <b>[6]</b>
                                        Papailiopoulos D,Dimakis A G.Locally repairable codes[J].IEEE Transactions on Information Theory,2014,60(10):5843- 5855
                                    </a>
                                </li>
                                <li id="416">


                                    <a id="bibliography_7" title="Botezatu M M,Giurgiu I,Bogojeska J,et al.Predicting disk replacement towards reliable data centers[C] //Proc of the 22nd Int Conf on Knowledge Discovery and Data Mining (KDD&#39;16).New York:ACM,2016:39- 48" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Predicting disk replacement towards reliable data centers">
                                        <b>[7]</b>
                                        Botezatu M M,Giurgiu I,Bogojeska J,et al.Predicting disk replacement towards reliable data centers[C] //Proc of the 22nd Int Conf on Knowledge Discovery and Data Mining (KDD&#39;16).New York:ACM,2016:39- 48
                                    </a>
                                </li>
                                <li id="418">


                                    <a id="bibliography_8" title="Li Peng,Li Jing,Stones R J,et al.Procode:A proactive erasure coding scheme for cloud storage systems[C] //Proc of the 35th IEEE Symp on Reliable Distributed Systems (SRDS&#39;16).Piscataway,NJ:IEEE,2016:219- 228" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Procode:A proactive erasure coding scheme for cloud storage systems">
                                        <b>[8]</b>
                                        Li Peng,Li Jing,Stones R J,et al.Procode:A proactive erasure coding scheme for cloud storage systems[C] //Proc of the 35th IEEE Symp on Reliable Distributed Systems (SRDS&#39;16).Piscataway,NJ:IEEE,2016:219- 228
                                    </a>
                                </li>
                                <li id="420">


                                    <a id="bibliography_9" title="Schroeder B,Gibson G A.Disk failures in the real world:What does an mttf of 1 000 000 hours mean to you?[C] //Proc of the USENIX Conf on File and Storage Technologies (FAST&#39;07).Berkeley,CA:USENIX Association,2007:1- 16" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Disk failures in the real world:What does an MTTF of1,000,000hours mean to you-">
                                        <b>[9]</b>
                                        Schroeder B,Gibson G A.Disk failures in the real world:What does an mttf of 1 000 000 hours mean to you?[C] //Proc of the USENIX Conf on File and Storage Technologies (FAST&#39;07).Berkeley,CA:USENIX Association,2007:1- 16
                                    </a>
                                </li>
                                <li id="422">


                                    <a id="bibliography_10" title="Facebook.Facebook&#39;s Hadoop 20[OL].[2019-01-05].https://github.com/facebookarchive/hadoop-20" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Facebook&amp;#39;&amp;#39;s Hadoop 20[OL]">
                                        <b>[10]</b>
                                        Facebook.Facebook&#39;s Hadoop 20[OL].[2019-01-05].https://github.com/facebookarchive/hadoop-20
                                    </a>
                                </li>
                                <li id="424">


                                    <a id="bibliography_11" title="Amazon.Amazon elastic compute cloud (EC2)[OL].[2019-01-05].http://aws.amazon.com/ec2/" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Amazon elastic compute cloud (EC2)[OL]">
                                        <b>[11]</b>
                                        Amazon.Amazon elastic compute cloud (EC2)[OL].[2019-01-05].http://aws.amazon.com/ec2/
                                    </a>
                                </li>
                                <li id="426">


                                    <a id="bibliography_12" title="Muralidhar S,Lloyd W,Roy S,et al.f4:Facebook&#39;s warm blob storage system[C] //Proc of the 11th USENIX Conf on Operating Systems Design and Implementation.Berkeley,CA:USENIX Association,2014:383- 398" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=f4:Facebook&amp;#39;&amp;#39;s warm blob storage system">
                                        <b>[12]</b>
                                        Muralidhar S,Lloyd W,Roy S,et al.f4:Facebook&#39;s warm blob storage system[C] //Proc of the 11th USENIX Conf on Operating Systems Design and Implementation.Berkeley,CA:USENIX Association,2014:383- 398
                                    </a>
                                </li>
                                <li id="428">


                                    <a id="bibliography_13" title="IBM.IBM cloud[OL].[2019-01-05].https://www.ibm.com/cloud/object-storage" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=IBM cloud[OL]">
                                        <b>[13]</b>
                                        IBM.IBM cloud[OL].[2019-01-05].https://www.ibm.com/cloud/object-storage
                                    </a>
                                </li>
                                <li id="430">


                                    <a id="bibliography_14" title="Rashmi K V,Shah N B,Gu Dikang,et al.A hitchhiker&#39;s guide to fast and efficient data reconstruction in erasure-coded data centers[C] //Proc of the ACM Conf on Special Interest Group on Data Communication (SIGCOMM&#39;14).New York:ACM,2014:331- 342" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A hitchhiker&amp;#39;&amp;#39;s guide to fast and efficient data reconstruction in erasure-coded data centers">
                                        <b>[14]</b>
                                        Rashmi K V,Shah N B,Gu Dikang,et al.A hitchhiker&#39;s guide to fast and efficient data reconstruction in erasure-coded data centers[C] //Proc of the ACM Conf on Special Interest Group on Data Communication (SIGCOMM&#39;14).New York:ACM,2014:331- 342
                                    </a>
                                </li>
                                <li id="432">


                                    <a id="bibliography_15" title="Chen Yulin,Mu Shuai,Li Jinyang,et al.Giza:Erasure coding objects across global data centers[C] //Proc of the 2017 USENIX Conf on Annual Technical Conf (ATC&#39;17).Berkeley,CA:USENIX Association,2017:539- 551" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Giza:Erasure coding objects across global data centers">
                                        <b>[15]</b>
                                        Chen Yulin,Mu Shuai,Li Jinyang,et al.Giza:Erasure coding objects across global data centers[C] //Proc of the 2017 USENIX Conf on Annual Technical Conf (ATC&#39;17).Berkeley,CA:USENIX Association,2017:539- 551
                                    </a>
                                </li>
                                <li id="434">


                                    <a id="bibliography_16" title="Dobre D,Viotti P,Vukoli M.Hybris:Robust hybrid cloud storage[C] //Proc of the ACM Symp on Cloud Computing.New York:ACM,2014:1- 14" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Hybris: Robust Hybrid Cloud Storage">
                                        <b>[16]</b>
                                        Dobre D,Viotti P,Vukoli M.Hybris:Robust hybrid cloud storage[C] //Proc of the ACM Symp on Cloud Computing.New York:ACM,2014:1- 14
                                    </a>
                                </li>
                                <li id="436">


                                    <a id="bibliography_17" title="Qiniu Cloud.Qiniu Cloud[OL].[2019-01-05].http://www.pingwest.com/qiniu/" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Qiniu Cloud[OL]">
                                        <b>[17]</b>
                                        Qiniu Cloud.Qiniu Cloud[OL].[2019-01-05].http://www.pingwest.com/qiniu/
                                    </a>
                                </li>
                                <li id="438">


                                    <a id="bibliography_18" title="Luo Xianghong,Shu Jiwu.Summary of research for erasure code in storage system[J].Journal of Computer Research and Development,2012,49(1):1- 11 (in Chinese)(罗象宏,舒继武.存储系统中的纠删码研究综述[J].计算机研究与发展,2012,49(1):1- 11" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201201001&amp;v=MjQ2ODI4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS9nVjcvSUx5dlNkTEc0SDlQTXJvOUZaWVFLREg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[18]</b>
                                        Luo Xianghong,Shu Jiwu.Summary of research for erasure code in storage system[J].Journal of Computer Research and Development,2012,49(1):1- 11 (in Chinese)(罗象宏,舒继武.存储系统中的纠删码研究综述[J].计算机研究与发展,2012,49(1):1- 11
                                    </a>
                                </li>
                                <li id="440">


                                    <a id="bibliography_19" title="Dimakis A G,Godfrey P B,Wu Yunnan,et al.Network coding for distributed storage systems[J].IEEE Transactions on Information Theory,2010,56(9):4539- 4551" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Network Coding for Distributed Storage Systems">
                                        <b>[19]</b>
                                        Dimakis A G,Godfrey P B,Wu Yunnan,et al.Network coding for distributed storage systems[J].IEEE Transactions on Information Theory,2010,56(9):4539- 4551
                                    </a>
                                </li>
                                <li id="442">


                                    <a id="bibliography_20" title="Shah N B,Rashmi K V,Kumar P V,et al.Interference alignment in regenerating codes for distributed storage:Necessity and code constructions[J].IEEE Transactions on Information Theory,2012,58(4):2134- 2158" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Interference Alignment in Regenerating Codes for Distributed Storage: Necessity and Code Constructions">
                                        <b>[20]</b>
                                        Shah N B,Rashmi K V,Kumar P V,et al.Interference alignment in regenerating codes for distributed storage:Necessity and code constructions[J].IEEE Transactions on Information Theory,2012,58(4):2134- 2158
                                    </a>
                                </li>
                                <li id="444">


                                    <a id="bibliography_21" title="Li S Y R,Yeung R W,Cai Ning.Linear network coding[J].IEEE Transactions on Information Theory,2003,49(2):371- 381" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Linear network coding">
                                        <b>[21]</b>
                                        Li S Y R,Yeung R W,Cai Ning.Linear network coding[J].IEEE Transactions on Information Theory,2003,49(2):371- 381
                                    </a>
                                </li>
                                <li id="446">


                                    <a id="bibliography_22" title="Hu Yuchong,Lee P P C,Shum K W.Analysis and construction of functional regenerating codes with uncoded repair for distributed storage systems[C] //Proc of the IEEE Int Conf on Computer Communication (INFOCOM&#39;13).New York:IEEE Communications Society,2013:2355- 2363" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Analysis and construction of functional regenerating codes with uncoded repair for distributed storage systems">
                                        <b>[22]</b>
                                        Hu Yuchong,Lee P P C,Shum K W.Analysis and construction of functional regenerating codes with uncoded repair for distributed storage systems[C] //Proc of the IEEE Int Conf on Computer Communication (INFOCOM&#39;13).New York:IEEE Communications Society,2013:2355- 2363
                                    </a>
                                </li>
                                <li id="448">


                                    <a id="bibliography_23" title="Tamo I,Wang Zhiying,Bruck J.Zigzag codes:MDS array codes with optimal rebuilding[J].IEEE Transactions on Information Theory,2013,59(3):1597- 1616" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Zigzag Codes: MDS Array Codes With Optimal Rebuilding">
                                        <b>[23]</b>
                                        Tamo I,Wang Zhiying,Bruck J.Zigzag codes:MDS array codes with optimal rebuilding[J].IEEE Transactions on Information Theory,2013,59(3):1597- 1616
                                    </a>
                                </li>
                                <li id="450">


                                    <a id="bibliography_24" title="Cadambe V R,Jafar S A,Maleki H,et al.Asymptotic interference alignment for optimal repair of MDS codes in distributed storage[J].IEEE Transactions on Information Theory,2013,59(5):2974- 2987" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Asymptotic interference alignment for optimal repair of MDS codes in distributed storage">
                                        <b>[24]</b>
                                        Cadambe V R,Jafar S A,Maleki H,et al.Asymptotic interference alignment for optimal repair of MDS codes in distributed storage[J].IEEE Transactions on Information Theory,2013,59(5):2974- 2987
                                    </a>
                                </li>
                                <li id="452">


                                    <a id="bibliography_25" title="Hu Yuchong,Xu Yinlong,Wang Xiaozhao,et al.Cooperative recovery of distributed storage systems from multiple losses with network coding[J].IEEE Journal on Selected Areas in Communications,2010,28(2):68- 276" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Cooperative recovery of distributed storage systems from multiple losses with network coding">
                                        <b>[25]</b>
                                        Hu Yuchong,Xu Yinlong,Wang Xiaozhao,et al.Cooperative recovery of distributed storage systems from multiple losses with network coding[J].IEEE Journal on Selected Areas in Communications,2010,28(2):68- 276
                                    </a>
                                </li>
                                <li id="454">


                                    <a id="bibliography_26" title="Shum K W,Hu Yuchong.Cooperative regenerating codes[J].IEEE Transactions on Information Theory,2013,59(11):7229- 7258" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Cooperative Regenerating Codes">
                                        <b>[26]</b>
                                        Shum K W,Hu Yuchong.Cooperative regenerating codes[J].IEEE Transactions on Information Theory,2013,59(11):7229- 7258
                                    </a>
                                </li>
                                <li id="456">


                                    <a id="bibliography_27" title="Hu Yuchong,Li Xiaolu,Zhang Mi,et al.Optimal repair layering for erasure-coded data centers:From theory to practice[J].ACM Transactions on Storage,2017,13(4):No.33" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM1F115E91E58C8AA012FF3E03BB833229&amp;v=MjA5NDlCdUhZZk9HUWxmQ3BiUTM1TnBodzcyN3dLZz1OaWZJWTdMT0g5REoyb1pFRWU0SGYzUkl2aFlTNkVrTFN3cmlyMkJIY2JHWFI3aVdDT052RlNpV1dyN0pJRnBtYQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[27]</b>
                                        Hu Yuchong,Li Xiaolu,Zhang Mi,et al.Optimal repair layering for erasure-coded data centers:From theory to practice[J].ACM Transactions on Storage,2017,13(4):No.33
                                    </a>
                                </li>
                                <li id="458">


                                    <a id="bibliography_28" title="Suh C,Ramchandran K.Exact-repair MDS code construction using interference alignment[J].IEEE Transactions on Information Theory,2011,57(3):1425- 1442" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Exact-repair MDS code construction using interference alignment">
                                        <b>[28]</b>
                                        Suh C,Ramchandran K.Exact-repair MDS code construction using interference alignment[J].IEEE Transactions on Information Theory,2011,57(3):1425- 1442
                                    </a>
                                </li>
                                <li id="460">


                                    <a id="bibliography_29" title="Ceph.Ceph[OL].[2019-01-05].http://docs.ceph.com/docs/master/rados/operations/erasure-code-lrc/ highlight=locally" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Ceph[OL]">
                                        <b>[29]</b>
                                        Ceph.Ceph[OL].[2019-01-05].http://docs.ceph.com/docs/master/rados/operations/erasure-code-lrc/ highlight=locally
                                    </a>
                                </li>
                                <li id="462">


                                    <a id="bibliography_30" title="Weil S A,Brandt S A,Miller E L,et al.Ceph:A scalable,high-performance distributed file system[C] //Proc of the 7th Symp on Operating Systems Design and Implementation (OSDI&#39;06).Berkeley,CA:USENIX Association,2006:307- 320" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Ceph:A scalable,high-performance distributed file system">
                                        <b>[30]</b>
                                        Weil S A,Brandt S A,Miller E L,et al.Ceph:A scalable,high-performance distributed file system[C] //Proc of the 7th Symp on Operating Systems Design and Implementation (OSDI&#39;06).Berkeley,CA:USENIX Association,2006:307- 320
                                    </a>
                                </li>
                                <li id="464">


                                    <a id="bibliography_31" title="Emerson.Data center downtime costs[OL].[2019-01-05].http://www.emerson.com/en-us/News/Pages/Net-Power-Study-Data-Center.aspx" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Data center downtime costs[OL]">
                                        <b>[31]</b>
                                        Emerson.Data center downtime costs[OL].[2019-01-05].http://www.emerson.com/en-us/News/Pages/Net-Power-Study-Data-Center.aspx
                                    </a>
                                </li>
                                <li id="466">


                                    <a id="bibliography_32" title="Li Jing,Wang Gang,Liu Xiaoguang,et al.Review of reliability prediction for storage system[J].Journal of Frontiers of Computer Science and Technology,2017,11(3):341- 354 (in Chinese)(李静,王刚,刘晓光,等.存储系统可靠性预测综述[J].计算机科学与探索,2017,11(3):341- 354)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=KXTS201703002&amp;v=MDY4MDI4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS9nVjcvSUxqWGZmYkc0SDliTXJJOUZab1FLREg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[32]</b>
                                        Li Jing,Wang Gang,Liu Xiaoguang,et al.Review of reliability prediction for storage system[J].Journal of Frontiers of Computer Science and Technology,2017,11(3):341- 354 (in Chinese)(李静,王刚,刘晓光,等.存储系统可靠性预测综述[J].计算机科学与探索,2017,11(3):341- 354)
                                    </a>
                                </li>
                                <li id="468">


                                    <a id="bibliography_33" title="Murray J F,Hughes G F,Kreutz-Delgado K.Machine learning methods for predicting failures in hard drives:A multiple-instance application[J].Journal of Machine Learning Research,2005,6(5):783- 816" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Machine learning methods for predicting failures in hard drives: a multiple-instance application">
                                        <b>[33]</b>
                                        Murray J F,Hughes G F,Kreutz-Delgado K.Machine learning methods for predicting failures in hard drives:A multiple-instance application[J].Journal of Machine Learning Research,2005,6(5):783- 816
                                    </a>
                                </li>
                                <li id="470">


                                    <a id="bibliography_34" title="Zhu Bingpeng,Wang Gang,Liu Xiaoguang,et al.Proactive drive failure prediction for large scale storage systems[C] //Proc of the 29th IEEE Symp on Mass Storage Systems and Technologies (MSST&#39;13).Piscataway,NJ:IEEE,2013:1- 5" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Proactive drive failure prediction for large scale storage systems">
                                        <b>[34]</b>
                                        Zhu Bingpeng,Wang Gang,Liu Xiaoguang,et al.Proactive drive failure prediction for large scale storage systems[C] //Proc of the 29th IEEE Symp on Mass Storage Systems and Technologies (MSST&#39;13).Piscataway,NJ:IEEE,2013:1- 5
                                    </a>
                                </li>
                                <li id="472">


                                    <a id="bibliography_35" title="Hamerly G,Elkan C.Bayesian approaches to failure prediction for disk drives[C] //Proc of the 18th Int Conf on Machine Learning (ICML&#39;01).San Francisco,CA:Morgan Kaufmann,2001:202- 209" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Bayesian approaches to failure prediction for disk drives">
                                        <b>[35]</b>
                                        Hamerly G,Elkan C.Bayesian approaches to failure prediction for disk drives[C] //Proc of the 18th Int Conf on Machine Learning (ICML&#39;01).San Francisco,CA:Morgan Kaufmann,2001:202- 209
                                    </a>
                                </li>
                                <li id="474">


                                    <a id="bibliography_36" title="Hughes G F,Murray J F,Kreutz-Delgado K,et al.Improved disk-drive failure warnings[J].IEEE Transactions on Reliability,2002,51(3):350- 357" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Improved disk-drive failure warnings">
                                        <b>[36]</b>
                                        Hughes G F,Murray J F,Kreutz-Delgado K,et al.Improved disk-drive failure warnings[J].IEEE Transactions on Reliability,2002,51(3):350- 357
                                    </a>
                                </li>
                                <li id="476">


                                    <a id="bibliography_37" title="Li Jing,Ji Xinpu,Jia Yuhan,et al.Hard drive failure prediction using cassification and regression trees[C] //Proc of the 44th Annual IEEE/IFIP Int Conf on Dependable Systems and Networks (DSN&#39;14).Los Alamitos,CA:IEEE Computer Society,2014:383- 394" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Hard drive failure prediction using classification and regression trees">
                                        <b>[37]</b>
                                        Li Jing,Ji Xinpu,Jia Yuhan,et al.Hard drive failure prediction using cassification and regression trees[C] //Proc of the 44th Annual IEEE/IFIP Int Conf on Dependable Systems and Networks (DSN&#39;14).Los Alamitos,CA:IEEE Computer Society,2014:383- 394
                                    </a>
                                </li>
                                <li id="478">


                                    <a id="bibliography_38" title="Baidu.SMART dataset[OL].[2019-01-05].http://pan.baidu.com/share/link?shareid=189977&amp;amp;uk=4278294944" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=SMART dataset[OL]">
                                        <b>[38]</b>
                                        Baidu.SMART dataset[OL].[2019-01-05].http://pan.baidu.com/share/link?shareid=189977&amp;amp;uk=4278294944
                                    </a>
                                </li>
                                <li id="480">


                                    <a id="bibliography_39" title="Cidon A,Escriva R,Katti S,et al.Tiered replication:A cost-effective alternative to full cluster geo-replication[C] //Proc of the 2012 USENIX Conf on Annual Technical Conf (ATC&#39;15).Berkeley,CA:USENIX Association,2015:31- 43" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Tiered replication:A cost-effective alternative to full cluster geo-replication">
                                        <b>[39]</b>
                                        Cidon A,Escriva R,Katti S,et al.Tiered replication:A cost-effective alternative to full cluster geo-replication[C] //Proc of the 2012 USENIX Conf on Annual Technical Conf (ATC&#39;15).Berkeley,CA:USENIX Association,2015:31- 43
                                    </a>
                                </li>
                                <li id="482">


                                    <a id="bibliography_40" title="Ford D,Labelle F,Popovici F I,et al.Availability in globally distributed storage systems[C] //Proc of the 7th Symp on Operating Systems Design and Implementation (OSDI&#39;10).Berkeley,CA:USENIX Association,2010:1- 7" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Availability in globally distributed storage systems">
                                        <b>[40]</b>
                                        Ford D,Labelle F,Popovici F I,et al.Availability in globally distributed storage systems[C] //Proc of the 7th Symp on Operating Systems Design and Implementation (OSDI&#39;10).Berkeley,CA:USENIX Association,2010:1- 7
                                    </a>
                                </li>
                                <li id="484">


                                    <a id="bibliography_41" title="Silberstein M,Ganesh L,Wang Y,et al.Lazy means smart:Reducing repair bandwidth costs in erasure-coded distributed storage[C] //Proc of Int Conf on Systems and Storage (SYSTOR&#39;14).New York:ACM,2014:1- 7" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Lazy means smart:Reducing repair bandwidth costs in erasure-coded distributed storage">
                                        <b>[41]</b>
                                        Silberstein M,Ganesh L,Wang Y,et al.Lazy means smart:Reducing repair bandwidth costs in erasure-coded distributed storage[C] //Proc of Int Conf on Systems and Storage (SYSTOR&#39;14).New York:ACM,2014:1- 7
                                    </a>
                                </li>
                                <li id="486">


                                    <a id="bibliography_42" title="Mu Fei,Xue Wei,Shu Jiwu,et al.An analytical model for large-scale storage system with replicated data[J].Journal of Computer Research and Development,2009,46(5):756- 761 (in Chinese)(穆飞,薛巍,舒继武,等.一种面向大规模副本存储系统的可靠性模型[J].计算机研究与发展,2009,46(5):756- 761)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200905008&amp;v=MTA4OTVxcUJ0R0ZyQ1VSTE9lWmVSc0Z5L2dWNy9JTHl2U2RMRzRIdGpNcW85RmJJUUtESDg0dlI0VDZqNTRPM3o=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[42]</b>
                                        Mu Fei,Xue Wei,Shu Jiwu,et al.An analytical model for large-scale storage system with replicated data[J].Journal of Computer Research and Development,2009,46(5):756- 761 (in Chinese)(穆飞,薛巍,舒继武,等.一种面向大规模副本存储系统的可靠性模型[J].计算机研究与发展,2009,46(5):756- 761)
                                    </a>
                                </li>
                                <li id="488">


                                    <a id="bibliography_43" title="Greenan K M,Plank J S,Wylie J J.Mean time to meaningless:MTTDL,Markov models,and storage system reliability[C] //Proc of the 2nd USENIX Conf on Hot Topics in Storage and File Systems (HotStorage&#39;10).Berkeley,CA:USENIX Association,2010:1- 5" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Mean time to meaningless:MTTDL,Markov models,and storage system reliability">
                                        <b>[43]</b>
                                        Greenan K M,Plank J S,Wylie J J.Mean time to meaningless:MTTDL,Markov models,and storage system reliability[C] //Proc of the 2nd USENIX Conf on Hot Topics in Storage and File Systems (HotStorage&#39;10).Berkeley,CA:USENIX Association,2010:1- 5
                                    </a>
                                </li>
                                <li id="490">


                                    <a id="bibliography_44" title="Apache.HDFS RAID[OL].[2019-01-05].http://wiki.apache.org/hadoop/HDFS-RAID" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=HDFS RAID[OL]">
                                        <b>[44]</b>
                                        Apache.HDFS RAID[OL].[2019-01-05].http://wiki.apache.org/hadoop/HDFS-RAID
                                    </a>
                                </li>
                                <li id="492">


                                    <a id="bibliography_45" title="Shvachko K,Kuang H,Radia S,et al.The Hadoop distributed file system[C] //Proc of the 26th IEEE Symp Mass Storage Systems and Technologies (MSST&#39;10).Piscataway,NJ:IEEE,2010:1- 10" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The Hadoop Distributed File System">
                                        <b>[45]</b>
                                        Shvachko K,Kuang H,Radia S,et al.The Hadoop distributed file system[C] //Proc of the 26th IEEE Symp Mass Storage Systems and Technologies (MSST&#39;10).Piscataway,NJ:IEEE,2010:1- 10
                                    </a>
                                </li>
                                <li id="494">


                                    <a id="bibliography_46" title="Dean J,Ghemawat S.MapReduce:Simplified data processing on large clusters[J].Communications of the ACM,2008,51(1):107- 113" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000030554&amp;v=MTQ0NDJNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VTDNJSjFzUWFoST1OaWZJWTdLN0h0ak5yNDlGWk9nUENYazlvQg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[46]</b>
                                        Dean J,Ghemawat S.MapReduce:Simplified data processing on large clusters[J].Communications of the ACM,2008,51(1):107- 113
                                    </a>
                                </li>
                                <li id="496">


                                    <a id="bibliography_47" title="Intel.ISA-L[OL].[2019-01-05].https://github.com/01org/isa-l" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=ISA-L[OL]">
                                        <b>[47]</b>
                                        Intel.ISA-L[OL].[2019-01-05].https://github.com/01org/isa-l
                                    </a>
                                </li>
                                <li id="498">


                                    <a id="bibliography_48" title="Tamo I,Barg A.A family of optimal locally recoverable codes[J].IEEE Transactions on Information Theory,2014,60(8):4661- 4676" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A family of optimal locally recoverable codes">
                                        <b>[48]</b>
                                        Tamo I,Barg A.A family of optimal locally recoverable codes[J].IEEE Transactions on Information Theory,2014,60(8):4661- 4676
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(09),1988-2000 DOI:10.7544/issn1000-1239.2019.20190048            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>云存储系统中的预测式局部修复码</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BC%A0%E6%99%93%E9%98%B3&amp;code=34658889&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张晓阳</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%AE%B8%E4%BD%B3%E8%B1%AA&amp;code=42840464&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">许佳豪</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%83%A1%E7%87%8F%E7%BF%80&amp;code=34658886&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">胡燏翀</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%8D%8E%E4%B8%AD%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2&amp;code=0045381&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">华中科技大学计算机科学与技术学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B7%B1%E5%9C%B3%E5%8D%8E%E4%B8%AD%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%A0%94%E7%A9%B6%E9%99%A2&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">深圳华中科技大学研究院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>为了保证客户访问数据的高可用性,一些云存储系统开始采用一类新型编码,即局部修复编码(locally repairable codes, LRC).例如Windows Azure和Facebook的HDFS RAID.与Reed-Solomon码相比,LRC修复效率高,因为它将每个条带的数据块分成多个组,每个组内额外生成一个校验块,因而组内就可以对单个故障块进行修复.LRC假设每组大小相同,这意味着每个故障块的修复所产生的组内数据传输量是相同的.但是,对于那些更易出现故障的磁盘,它们所造成丢失的数据块理应被系统更有效地修复.借助基于决策树的磁盘故障预测方法来动态调整LRC中组的大小,从而构造一类预测式LRC(proactive LRC, pLRC),使得即将发生故障的磁盘存储的数据块所在的组的长度变小,以便这些数据块可以在更小的组内进行更快地修复,同时保持和传统LRC相同的存储开销和编码结构.不仅通过MTTDL建模分析pLRC的可靠性,还在Facebook的Hadoop HDFS平台中实现了pLRC并进行了性能测试.结果表明,比起LRC,pLRC的可靠性最多可提升113%,同时降级读和磁盘修复性能最多可提高46.8%和47.5%.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BA%91%E5%AD%98%E5%82%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">云存储;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B1%80%E9%83%A8%E4%BF%AE%E5%A4%8D%E7%A0%81&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">局部修复码;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A3%81%E7%9B%98%E6%95%85%E9%9A%9C&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">磁盘故障;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">机器学习;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%86%B3%E7%AD%96%E6%A0%91&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">决策树;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    *胡燏翀,yuchonghu@hust.edu.cn;
                                </span>
                                <span>
                                    张晓阳,xiaoyangzhang@hust.edu.cn;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2019-01-22</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目(61872414,61502191);</span>
                                <span>深圳市知识创新计划项目(JCYJ20170307172447622);</span>
                    </p>
            </div>
                    <h1><b>Proactive Locally Repairable Codes for Cloud Storage Systems</b></h1>
                    <h2>
                    <span>Zhang Xiaoyang</span>
                    <span>Xu Jiahao</span>
                    <span>Hu Yuchong</span>
            </h2>
                    <h2>
                    <span>School of Computer Science and Technology, Huazhong University of Science and Technology</span>
                    <span>Shenzhen Huazhong University of Science and Technology Research Institute</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Cloud storage systems, which provide customers the ability to access their data reliably, start to adopt a novel family of codes called locally reparable codes(LRC), e.g., Windows Azure Storage and Facebook' HDFS RAID. Compared with Reed-Solomon codes, LRC is efficiently repairable since it divides the data blocks of each stripe into groups, each of which has an additional local parity block such that a failed block can be repaired locally in one group. LRC assumes that each group is equal-size which implies that each failed block is repaired from the same amount of data of a group. However, the blocks in the disks which are more likely to fail should be repaired more efficiently. In this paper, we present a proactive LRC(pLRC) via predicting disk failures and resizing the groups such that the recent failed disks can be repaired faster while maintaining the same storage overhead and code construction relative to LRC. We analyze pLRC through the reliability modeling of mean-time-to-data-loss(MTTDL) and also implement pLRC in Facebook's HDFS. The results show that compared with LRC, pLRC's reliability can be improved by up to 113%, and its degraded read and disk repair performance can be improved by up to 46.8% and 47.5%, respectively.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=cloud%20storage&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">cloud storage;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=locally%20repairable%20codes(LRC)&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">locally repairable codes(LRC);</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=disk%20failures&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">disk failures;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=machine%20learning&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">machine learning;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=decision%20tree&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">decision tree;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Zhang Xiaoyang, born in 1993.PhD candidate at HUST.His main research interests include cloud storage,storage scaling,network coding and erasure coding.&lt;image id="397" type="formula" href="images/JFYZ201909020_39700.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Xu Jiahao,born in 1996.Master candidate. Her main  research  interests  include predicting disk failures,machine learning? deep learning.(m201873224@hust.edu. cn)&lt;image id="399" type="formula" href="images/JFYZ201909020_39900.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Hu Yuchong,born in 1983.PhD.Associate professor and PhD supervisor.His main research interests include cloud storage, heterogeneous storage,network coding, and erasure coding.&lt;image id="401" type="formula" href="images/JFYZ201909020_40100.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2019-01-22</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Natural Science Foundation of China(61872414,61502191);</span>
                                <span>Shenzhen Knowledge Innovation Program(JCYJ20170307172447622);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="99">近几年来,随着社会的发展,各行业和领域的数据量都在呈爆炸式增长,因而不断对存储系统提出挑战,云环境下的存储系统已逐步成为未来数据存储的发展趋势.云存储系统的一个重要目标就是无论系统发生什么样的故障,都必须保证数据的可用性,即云存储服务提供商总能够持续不断地向用户提供数据访问的服务,否则会直接影响上层应用给用户提供正常服务.2018年,Windows Azure云存储服务因故障中断时间超过24 小时,超过40个Azure 云应用服务因此而中断,造成不小的经济损失<citation id="500" type="reference"><link href="404" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>.因此,对云存储服务提供商和用户来说,数据可用性至关重要.</p>
                </div>
                <div class="p1">
                    <p id="100">为了提高云存储的数据可用性,系统一般额外存储大量的冗余数据.冗余有2个常见的实现方式:复制和纠删码.复制是最简单的冗余方案,即一个文件拥有多个副本;而纠删码(一般采用Reed-Solomon码<citation id="501" type="reference"><link href="406" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>)是将一个文件等分成多个数据块,这些数据块再编码生成同样大小的若干个校验块,使得从所有数据块和校验块中任意下载原始文件大小的数据就可以重建出原始文件.与复制相比,纠删码可以大大提高数据可用性<citation id="502" type="reference"><link href="408" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>.可是,纠删码面临的一大挑战是当发生数据块丢失时,修复该数据块所需要的带宽消耗过大,即一个数据块丢失的话,需要下载多个块去重建出原始文件才能对单个数据块进行修复.这会使得数据修复性能偏低,从而导致云存储上的用户数据访问延迟过高,影响数据可用性.</p>
                </div>
                <div class="p1">
                    <p id="101">为了降低纠删码的修复开销,不少云存储系统(Windows Azure<citation id="503" type="reference"><link href="410" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>, Facebook<citation id="504" type="reference"><link href="412" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>)开始使用一类新型的编码方法——局部修复码(locally repairable codes, LRC)<citation id="505" type="reference"><link href="414" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>.LRC设计特点是在Reed-Solomon码的基础上,将一个条带的所有数据块均分成若干个组,然后每个分组针对组内所有的数据块额外编码生成一个新的校验块,称之为该组的局部校验块.显然,任意一个数据块的丢失,都可以通过其组内的局部校验块和组内其他数据块来快速修复出来,而无须构建整个原始文件来对丢失的数据块进行修复.因此,比起Reed-Solomon码,LRC可以大大降低修复丢失的数据块所耗费的带宽,进而降低修复时间,从而优化云存储系统对于用户的访问延迟,提高数据的可用性.</p>
                </div>
                <div class="p1">
                    <p id="102">我们发现,LRC蕴含了一个较强的假设:所有分组的长度是相同的.由于LRC修复一个数据块需要下载它所在组的所有块,那么这个假设就意味着修复任意一个数据块均需要下载同样多的块,耗费同样多的带宽.因此在这个假设下,想要LRC的修复效率得到比较好的保障,显然只有每个块丢失的概率较为均匀才比较公平;否则,如果块和块之间的丢失概率不同,但修复代价却相同,那么这对整个系统的修复效率就会产生公平性的影响.</p>
                </div>
                <div class="p1">
                    <p id="103">但是,一些研究<citation id="507" type="reference"><link href="416" rel="bibliography" /><link href="418" rel="bibliography" /><sup>[<a class="sup">7</a>,<a class="sup">8</a>]</sup></citation>表明:在云存储系统中,一些数据块的丢失概率其实远远大于其他数据块,这是因为这些数据块所在的磁盘可被预测出来将在近期内发生故障.实际上,磁盘是当前云存储系统中最主要的故障来源,磁盘故障占所有设备故障的78%<citation id="506" type="reference"><link href="420" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>.而磁盘故障大部分是由于诸如磨损之类的缓慢过程所导致的,这些过程通常会持续数月或数年,因此可以通过对磁盘历史状况不断监测而对其近期是否发生故障进行预测.这样的话,我们可以通过机器学习等方法提前预测到某些磁盘故障的发生,即近期内这些磁盘的故障概率远远高于其他磁盘——这意味着这些磁盘上的数据块的丢失概率也远远高于其他数据块.而这个现象和LRC码当前结构所蕴含的假设——“所有分组的长度相同,所有数据块修复代价一样”——是不匹配的.</p>
                </div>
                <div class="p1">
                    <p id="104">因此,这启发我们将基于机器学习的磁盘故障预测技术运用到LRC中对其固定分组的假设进行改进,以进一步提高LRC的修复性能.需要注意的是,已有相关研究工作将磁盘故障预测技术应用到复制和纠删码技术中<citation id="508" type="reference"><link href="418" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>,但LRC拥有不同于复制和纠删码的“条带分组”的特点,因此需要我们专门针对该特点进行有效的设计.本文贡献有3个方面:</p>
                </div>
                <div class="p1">
                    <p id="105">1) 将磁盘故障预测技术的结果和LRC参数结合,构造了一类基于预测的LRC(proactive LRC, pLRC)方案.pLRC通过磁盘故障预测方法,区分不同数据块的丢失概率,从而动态调整系统中的LRC分组大小.我们尽可能地让近期可能丢失的数据块所在分组的长度缩小,从而使得修复这些块所需的带宽降低;同时,对于近期不会丢失的数据块所在分组的长度变长,以保证pLRC的存储开销和LRC保持一致.</p>
                </div>
                <div class="p1">
                    <p id="106">2) 理论上,我们利用MTTDL建模分析对比了LRC和pLRC,结果显示后者可以提高多达113%的可靠性.同时,我们还对pLRC的修复带宽进行了理论上的数值分析,结果显示后者修复带宽理论上可以降低48.1%.</p>
                </div>
                <div class="p1">
                    <p id="107">3) 系统上,我们在Facebook的Hadoop HDFS RAID<citation id="509" type="reference"><link href="422" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>平台中,通过修改HDFS RAID相关代码,实现了LRC和pLRC技术,并将其运行在真实云环境下(Amazon Web Sevice<citation id="510" type="reference"><link href="424" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>).实验结果显示,比起LRC,pLRC的降级读性能提高了46.8%,磁盘修复时间缩短了47.5%.</p>
                </div>
                <h3 id="108" name="108" class="anchor-tag"><b>1 研究背景和动机</b></h3>
                <h4 class="anchor-tag" id="109" name="109"><b>1.1 云存储中编码研究现状</b></h4>
                <div class="p1">
                    <p id="110">随着云业务大规模的落地实施,数据存储已脱离于单纯的存储介质,逐渐演变成一种云服务,即云存储.相比于传统的存储介质环境,云环境中数据量大、应用复杂,这使得云存储系统要满足海量的存储需求和动态的IO服务需求,因而必须提供高可用性的容错机制,即持续稳定的在线运行性能.对此,云存储系统通常采用数据冗余技术来进行保驾护航.传统的数据冗余技术主要包括副本、RAID等.副本,即存储同一份数据的多个相同拷贝;数据的副本越多、数据可靠性越高,但存储空间利用率也就越低.RAID,即把多块独立的存储磁盘按特定方式组合起来形成一个磁盘阵列;该技术提高了存储空间的利用率,但传统磁盘阵列存在着扩展性较差、弹性缺乏、容错数较低等缺陷.因此,副本和RAID较难满足云存储的海量存储和动态变化的服务需求.</p>
                </div>
                <div class="p1">
                    <p id="111">针对传统数据冗余技术的不足,云存储系统中出现了一种更高效的数据冗余技术——纠删码,其基本思想是将一份数据划分为<i>k</i>个原始数据块,基于<i>k</i>个数据块编码获得<i>r</i>个校验块.以上<i>k</i>+<i>r</i>个块(即<i>k</i>个数据块和<i>r</i>个校验块,通常称为一个条带)中任意<i>r</i>块出错时,系统均可重构出<i>k</i>个原始数据块.常用纠删码为Reed-Solomon编码,通常记为(<i>k</i>,<i>r</i>) RS.与副本相比,纠删码可以大大提高数据可用性<citation id="511" type="reference"><link href="408" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>;另外,不同于弹性缺乏、容错数较低的RAID,纠删码还具有参数配置灵活、任意容错的特点(比如可以通过调整参数<i>k</i>和<i>r</i>来改变冗余度和容错数),因而可以根据存储服务需求的动态变化,自适应地来构建纠删码.在学术界,已有不少工作研究基于纠删码的云存储系统.比如,私有云存储(即企业内部数据中心):Facebook的f4<citation id="512" type="reference"><link href="426" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>、IBM的Cleversafe<citation id="513" type="reference"><link href="428" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>、Hitchhiker<citation id="514" type="reference"><link href="430" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>、Giza<citation id="515" type="reference"><link href="432" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>等;公有云存储:Azure<citation id="516" type="reference"><link href="410" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>,Hybris<citation id="517" type="reference"><link href="434" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>等.在工业界,纠删码也逐渐成为云存储产品的标配之一,比如,国外云厂商Windows Azure采用(<i>k</i>,<i>r</i>)=(6,4)的纠删码<citation id="518" type="reference"><link href="410" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>,国内云厂商七牛云采用(<i>k</i>,<i>r</i>)=(28,4)的纠删码<citation id="519" type="reference"><link href="436" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>.</p>
                </div>
                <div class="p1">
                    <p id="112">可是当某个数据块丢失时,纠删码需要下载所有<i>k</i>个块去重建出原始文件才能对这个块进行修复,这导致数据修复通常需耗费大量带宽,而对于存储集群来说,加速恢复是非常重要的<citation id="520" type="reference"><link href="438" rel="bibliography" /><sup>[<a class="sup">18</a>]</sup></citation>.因此不少新型纠删码设计方案针对如何对修复带宽进行优化,主要分为再生码和局部修复码2类:</p>
                </div>
                <div class="p1">
                    <p id="113">1) 再生码(regenerating codes, RC).Dimakis等人首次提出了再生码<citation id="521" type="reference"><link href="440" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>,比起传统纠删码降低了单节点修复带宽(即修复单节点故障所需的传输数据量),并将再生码分成两大类,分别为MSR码(minimal storage regenerating codes)和MBR码(minimal bandwidth regenerating codes).文献<citation id="522" type="reference">[<a class="sup">20</a>]</citation>采用随机线性编码<citation id="523" type="reference"><link href="444" rel="bibliography" /><sup>[<a class="sup">21</a>]</sup></citation>保证了在编码有限域足够大的条件下,再生码的解码成功率无限趋近于100%.随后的研究工作可以分成3类:1)由于随机线性编码很难满足精确修复特性,即并不保证原始丢失数据的恢复,因此一些工作<citation id="524" type="reference"><link href="446" rel="bibliography" /><link href="448" rel="bibliography" /><link href="450" rel="bibliography" /><sup>[<a class="sup">22</a>,<a class="sup">23</a>,<a class="sup">24</a>]</sup></citation>针对精确修复的再生码进行了广泛的研究;2)由于再生码最初只针对单节点修复,后续工作致力于多节点修复的再生码设计<citation id="525" type="reference"><link href="452" rel="bibliography" /><link href="454" rel="bibliography" /><sup>[<a class="sup">25</a>,<a class="sup">26</a>]</sup></citation>;3)还有一些研究专注于确定性再生码的设计<citation id="526" type="reference"><link href="456" rel="bibliography" /><link href="458" rel="bibliography" /><sup>[<a class="sup">27</a>,<a class="sup">28</a>]</sup></citation>.</p>
                </div>
                <div class="p1">
                    <p id="114">2) 局部修复码(LRC).LRC<citation id="529" type="reference"><link href="410" rel="bibliography" /><link href="412" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>]</sup></citation>通过限制数据修复时所连接的节点数目,即将数据修复尽可能局限在较小的节点集合内,来大大降低数据传输和IO操作数.实际上,LRC引入了额外的存储消耗去达到局部修复的优点,即在理论上并没有做到存储效率的最优,但是由于其实现的简易性,不少云存储系统开始部署局部修复码,比如Azure<citation id="527" type="reference"><link href="410" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>,Facebook<citation id="528" type="reference"><link href="412" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>,Ceph<citation id="530" type="reference"><link href="460" rel="bibliography" /><link href="462" rel="bibliography" /><sup>[<a class="sup">29</a>,<a class="sup">30</a>]</sup></citation>等.LRC是在参数为(<i>k</i>,<i>r</i>)的Reed-Solomon码的基础上,将一个条带的所有<i>k</i>个数据块均分成<i>m</i>组,每组有<i>k</i>/<i>m</i>个数据块,然后每组将自己所有的<i>k</i>/<i>m</i>个数据块通过异或额外生成一个新的校验块,称之为该组的局部校验块.与之对应,已有的<i>r</i>个校验块称之为全局校验块.</p>
                </div>
                <div class="p1">
                    <p id="115">图1是(<i>k</i>,<i>m</i>,<i>r</i>) LRC的示例图,其中<i>k</i>=6,<i>m</i>=2,<i>r</i>=2.<i>D</i><sub>1</sub>～<i>D</i><sub>6</sub>是6个数据块,<i>P</i><sub>1</sub>和<i>P</i><sub>2</sub>是通过<i>D</i><sub>1</sub>～<i>D</i><sub>6</sub>编码生成的2个全局校验块.然后将所有数据块分为2组:<i>D</i><sub>1</sub>～<i>D</i><sub>3</sub>,<i>D</i><sub>4</sub>～<i>D</i><sub>6</sub>,每组异或编码生成一个新的局部校验块:<i>Q</i><sub>1</sub>和<i>Q</i><sub>2</sub>.我们可以发现,<i>D</i><sub>1</sub>～<i>D</i><sub>6</sub>中无论哪一个数据块丢失,都可以通过该块所在组的局部校验块快速修复出来.比如,假设数据块<i>D</i><sub>1</sub>丢失,如果是基于Reed-Solomon编码,则需要下载<i>D</i><sub>2</sub>～<i>D</i><sub>6</sub>以及<i>P</i><sub>1</sub>一共6个块将<i>D</i><sub>1</sub>修复;而如果基于LRC,则仅需要下载<i>D</i><sub>2</sub>,<i>D</i><sub>3</sub>以及<i>Q</i><sub>1</sub>一共3个块即可修复<i>D</i><sub>1</sub>.因此,比起Reed-Solomon码,LRC可以降低大大降低修复一个丢失块的所需时间,从而优化云存储系统对于用户的访问性能.</p>
                </div>
                <div class="area_img" id="116">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_116.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 (6,2,2) LRC的示例图" src="Detail/GetImg?filename=images/JFYZ201909020_116.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 (6,2,2) LRC的示例图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_116.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 An illustration of (6,2,2) LRC</p>

                </div>
                <h4 class="anchor-tag" id="117" name="117"><b>1.2 云存储中磁盘故障预测研究现状</b></h4>
                <div class="p1">
                    <p id="118">云存储系统发生服务中断的代价越来越高昂<citation id="531" type="reference"><link href="464" rel="bibliography" /><sup>[<a class="sup">31</a>]</sup></citation>,服务中断最大的一个原因是磁盘设备发生故障<citation id="532" type="reference"><link href="420" rel="bibliography" /><link href="466" rel="bibliography" /><sup>[<a class="sup">9</a>,<a class="sup">32</a>]</sup></citation>.硬盘的故障一般分为2种:不可预测的和可预测的.前者发生几率不高,通常不可预测,比如人为不当操作造成的机械撞击等;但后者比如像轴承磨损、磁介质性能下降等都可以在几天甚至几周前就发现苗头从而进行规避.</p>
                </div>
                <div class="p1">
                    <p id="119">基于此,1992年IBM在AS/400计算机的磁盘中使用了名为Predictive Failure Analysis(故障预警分析技术)的监控技术;不久,康柏、希捷、昆腾以及康纳共同提出了名为IntelliSafe的类似技术;1996年以上几家公司联合推出了一套硬盘状态检测与预警系统和规范,命名为S.M.A.R.T.(self-monitoring analysis and reporting technology), 即“自我检测分析与报告技术”,成为一种自动监控硬盘驱动器完好状况和报告潜在问题的技术标准.</p>
                </div>
                <div class="p1">
                    <p id="120">SMART 技术通过在硬盘硬件内的检测指令对硬盘的各个硬件如磁头、马达、电路、盘片的运行情况进行监控,并与厂商所预设的安全值进行比较,若监控情况将超出或已超出预设安全值的安全范围时发出警报.但该方法只能预测出不到10%的硬盘故障<citation id="533" type="reference"><link href="468" rel="bibliography" /><sup>[<a class="sup">33</a>]</sup></citation>.因此,有不少研究工作在SMART数据集上建立各种预测模型,以提高硬盘的故障率预测准确率.这些磁盘故障预测模型<citation id="534" type="reference"><link href="416" rel="bibliography" /><link href="470" rel="bibliography" /><link href="472" rel="bibliography" /><link href="474" rel="bibliography" /><link href="476" rel="bibliography" /><sup>[<a class="sup">7</a>,<a class="sup">34</a>,<a class="sup">35</a>,<a class="sup">36</a>,<a class="sup">37</a>]</sup></citation>通常有3个主要参数:</p>
                </div>
                <div class="p1">
                    <p id="121">1) 准确率(false discovery rate, <i>FDR</i>),即故障磁盘中可以被准确预测出的比例.</p>
                </div>
                <div class="p1">
                    <p id="122">2) 误报率(false alarm rate, <i>FAR</i>),即健康磁盘中被误报为故障磁盘的比例.</p>
                </div>
                <div class="p1">
                    <p id="123">3) 提前预测时间(time in advance, <i>TIA</i>),即提前多长时间预测磁盘故障.</p>
                </div>
                <div class="p1">
                    <p id="124">文献<citation id="535" type="reference">[<a class="sup">33</a>]</citation>提出了一种基于多实例学习框架和朴素贝叶斯分类器的故障预测算法,但仅使用了369个磁盘的SMART数据集.文献<citation id="536" type="reference">[<a class="sup">35</a>]</citation>采用贝叶斯方法对磁盘故障进行建模,数据集由1 936个磁盘组成,其中只有9个被标记为失败,同样也比较小.文献<citation id="537" type="reference">[<a class="sup">36</a>]</citation>利用统计检验相关方法(如多变量秩和检验)提高<i>FDR</i>和降低<i>FAR</i>,同样的数据集也相当小,只有347个磁盘器(其中36个故障).文献<citation id="539" type="reference">[<a class="sup">34</a>,<a class="sup">37</a>]</citation>采用人工神经网络和决策树等学习方法,数据集规模较大,包含来自企业级模型的总共23 395个磁盘(其中433个故障).该方法最好预测性能达到0.1%以下的<i>FAR</i>和95%以上的<i>FDR</i>,且<i>TIA</i>至少为一周以上,从而为故障处理预留了充足时间.文献<citation id="538" type="reference">[<a class="sup">7</a>]</citation>同样使用了一个包含超过20 000个磁盘的大型数据集,通过选择合适的SMART指标并调整预测模型,使得<i>FDR</i>高达98%.</p>
                </div>
                <h4 class="anchor-tag" id="125" name="125"><b>1.3 本文研究动机</b></h4>
                <div class="p1">
                    <p id="126">当前很少有工作将云存储系统中的编码技术和磁盘故障预测技术联系起来,文献<citation id="540" type="reference">[<a class="sup">8</a>]</citation>提出了一类基于磁盘故障预测技术的纠删码技术Procode.Procode的技术原理是把复制和纠删码结合起来,将预测的故障磁盘的数据块和校验块进行复制,使得这些块在丢失以后无须通过纠删码恢复,只用通过复制恢复即可,因此降低修复这些块所需要的时间.文献<citation id="541" type="reference">[<a class="sup">8</a>]</citation>的作者在其工作展望中希望有工作能将Procode的策略思想和新型的编码技术相结合起来.但是,如果直接将Procode对即将丢失的数据块进行简单复制的策略和新型编码技术LRC技术结合的话,那么将会破坏LRC的单一编码结构而造成副本一致性维护问题,并且还会引入额外的存储开销、增加磁盘个数而加大系统存储管理成本.</p>
                </div>
                <div class="p1">
                    <p id="127">因此,这启发我们在LRC的编码结构和存储开销不变的前提下,将磁盘故障预测技术结果和LRC编码结合起来,构造了一类基于预测的LRC编码.pLRC算法首先通过文献<citation id="542" type="reference">[<a class="sup">34</a>]</citation>提供的一类磁盘故障预测方法以及相应的大型SMART数据集,区分一周的即将故障的磁盘(称为“坏盘”)和其他健康磁盘(称之为“好盘”);然后仅仅调整坏盘和好盘所拥有的数据块所在分组的大小,使得坏盘的数据块所在分组的长度变短,而这些分组为了保持存储量不变,同时将分组内其他好盘的数据块所在分组变长,并同步更新组内的校验块.这样的话,pLRC的编码结构依然和LRC保持一致,只是部分条带的分组组长不同;同时pLRC的存储开销和LRC也保持了一致.更重要的是,pLRC会对一周内大概率坏掉的磁盘进行快速修复,从而提高数据块修复性能.</p>
                </div>
                <div class="p1">
                    <p id="128">图2是(6,2,2) LRC转变为pLRC的示例图.假设<i>D</i><sub>1</sub>是坏盘的数据块,和图1相比,<i>D</i><sub>1</sub>所在分组变短,其他分组变长,<i>Q</i><sub>1</sub>和<i>Q</i><sub>2</sub>因组长变化更新为<i>Q</i>′<sub>1</sub>和<i>Q</i>′<sub>2</sub>.我们可以发现pLRC中仅仅只用<i>D</i><sub>2</sub>和<i>Q</i>′<sub>1</sub>共2个块即可修复<i>D</i><sub>1</sub>.因此,比起图1中的LRC,pLRC存储开销保持不变的同时,降低修复带宽33%,从而缩短了修复坏盘数据块的所需时间,优化了云存储系统对于用户的数据在线访问性能.</p>
                </div>
                <div class="area_img" id="129">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_129.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 (6,2,2) LRC 转换为pLRC的示例图" src="Detail/GetImg?filename=images/JFYZ201909020_129.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 (6,2,2) LRC 转换为pLRC的示例图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_129.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 An illustration of pLRC from (6,2,2) LRC</p>

                </div>
                <h3 id="130" name="130" class="anchor-tag"><b>2 pLRC的设计</b></h3>
                <div class="p1">
                    <p id="131">在本节中,我们主要对pLRC的设计算法进行描述.</p>
                </div>
                <h4 class="anchor-tag" id="132" name="132"><b>2.1 磁盘故障预测算法选择</b></h4>
                <div class="p1">
                    <p id="133">当前有包括决策树、人工神经网络等机器学习算法可用于预测磁盘,我们的目标是在<i>FDR</i>和<i>FAR</i>之间找到一个较好的权衡.为了实现这一目标,我们对当前主流的2类分类算法:决策树<citation id="543" type="reference"><link href="476" rel="bibliography" /><sup>[<a class="sup">37</a>]</sup></citation>和人工神经网络<citation id="544" type="reference"><link href="470" rel="bibliography" /><sup>[<a class="sup">34</a>]</sup></citation>进行了比较.和文献<citation id="545" type="reference">[<a class="sup">34</a>]</citation>类似,我们在开源的SMART数据集<citation id="546" type="reference"><link href="478" rel="bibliography" /><sup>[<a class="sup">38</a>]</sup></citation>上针对12个特征(见表1)进行采样.SMART数据集包含23 395个磁盘(其中433个坏盘、22 962个好盘)在7天内的SMART记录,其中每个盘每小时都会生成一条SMART记录,因此每个好盘有168条记录,而坏盘记录到自己发生故障为止.然后,我们将采样数据集随机拆分为训练数据集(占总数据集的70%),并通过交叉验证测试数据集(占总数据集的30%).2个预测算法的性能如表2所示.</p>
                </div>
                <div class="area_img" id="134">
                    <p class="img_tit"><b>表1 所选的SMART属性</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 1 Selected SMART Attributes</b></p>
                    <p class="img_note"></p>
                    <table id="134" border="1"><tr><td><br />Attribute ID</td><td>Attribute</td></tr><tr><td><br />1</td><td>Current Pending Sector Count</td></tr><tr><td><br />2</td><td>Current Pending Sector Count (raw value)</td></tr><tr><td><br />3</td><td>Hardware ECC Recovered</td></tr><tr><td><br />4</td><td>High Fly Writes</td></tr><tr><td><br />5</td><td>Raw Read Error Rate</td></tr><tr><td><br />6</td><td>Reallocated Sectors Count</td></tr><tr><td><br />7</td><td>Reallocated Sectors Count (raw value)</td></tr><tr><td><br />8</td><td>Reported Uncorrectable Errors</td></tr><tr><td><br />9</td><td>Seek Error Rate</td></tr><tr><td><br />10</td><td>Spin up Time</td></tr><tr><td><br />11</td><td>Temperature Celsius</td></tr><tr><td><br />12</td><td>Power on Hours</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="135">
                    <p class="img_tit"><b>表2 决策树和人工神经网络的性能比较</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 2 Performance Comparison of Decision Tree and BP Neural Network</b></p>
                    <p class="img_note"></p>
                    <table id="135" border="1"><tr><td><br />Algorithm</td><td><i>FDR</i>/%</td><td><i>FAR</i>/%</td><td><i>TIA</i>/d</td></tr><tr><td><br />Decision Tree</td><td>93</td><td>0.48</td><td>7</td></tr><tr><td><br />BP Neural Network</td><td>95</td><td>2.87</td><td>7</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="136">从表2可以看出,决策树和人工神经网络都能达到良好的预测准确性;但人工神经网络的误报率较高,会导致pLRC错把不少的好盘上所保存的数据块也进行分组大小调整而耗费不小的带宽.因此,我们选择决策树作为我们的预测算法.</p>
                </div>
                <h4 class="anchor-tag" id="137" name="137"><b>2.2 pLRC编码算法设计</b></h4>
                <div class="p1">
                    <p id="138">pLRC编码算法有2个主要的设计目标:</p>
                </div>
                <div class="p1">
                    <p id="139">1) 和LRC保持同样的存储开销和磁盘个数;</p>
                </div>
                <div class="p1">
                    <p id="140">2) 比LRC拥有更低的数据块修复带宽.</p>
                </div>
                <div class="p1">
                    <p id="141">针对这2个设计目标,pLRC的设计思想是对所有数据块进行“好”“坏”标记;然后在磁盘故障预测算法运行后,坏盘上的数据块标记为“坏块”;最后针对每个坏块所在的条带,缩短该坏块所在分组的组长,变长其他分组的组长,使得该条带所造成的存储开销和所需磁盘个数保持不变,并且坏块的修复所造成的带宽消耗降低.算法细节如下:</p>
                </div>
                <div class="p1">
                    <p id="142"><b>算法1</b>. pLRC编码.</p>
                </div>
                <div class="p1">
                    <p id="143">假设:系统有<i>N</i>个磁盘,每个磁盘拥有<i>p</i>个数据块,每个条带最多只包含一个坏块.</p>
                </div>
                <div class="area_img" id="402">
                                <img alt="" src="Detail/GetImg?filename=images/JFYZ201909020_40200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="155">算法1在初始状态时,所有数据块都标记为“好块”,然后执行LRC编码(行①②).在决策树预测算法过后,预测为坏盘所保存的数据块标记为“坏块”,然后找到所有坏块所在的条带(行③～⑤).最后对所有这些<i>bp</i>个条带进行分组大小调整:含有坏块的分组长度缩短为3(即原分组缩小为仅包含2个数据块和1个校验块的分组),即该分组为简单的(2,1) RS编码;然后该分组的其他块随机转移到其他分组,最后更新分组的校验块.</p>
                </div>
                <div class="p1">
                    <p id="156">算法1的具体过程如图3所示,图3(a)是初始状态下的(12,3,2) LRC编码.图3(b)是预测算法后的(12,3,2) pLRC编码,<i>D</i><sup>*</sup><sub>1</sub>标记为坏块,然后<i>D</i><sup>*</sup><sub>1</sub>所在分组从4个数据块下降到2个数据块,其他2个数据<i>D</i><sub>3</sub>和<i>D</i><sub>4</sub>转移到另外分组,分组校验块</p>
                </div>
                <div class="p1">
                    <p id="157">随之更新为:<i>Q</i>′<sub>1</sub>,<i>Q</i>′<sub>2</sub>和<i>Q</i>′<sub>3</sub>.坏块<i>D</i><sup>*</sup><sub>1</sub>可以通过下载2个块就可以修复出来.</p>
                </div>
                <div class="area_img" id="158">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_158.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 pLRC的算法示例图" src="Detail/GetImg?filename=images/JFYZ201909020_158.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 pLRC的算法示例图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_158.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 Illustrations of pLRC</p>

                </div>
                <h4 class="anchor-tag" id="159" name="159"><b>2.3 pLRC算法优化</b></h4>
                <div class="p1">
                    <p id="160">当所有坏块被修复以后,pLRC应该回归LRC以等待下一次磁盘故障预测算法的执行.基于算法1的编码策略,我们可以发现需要对大量的局部校验块进行更新,将造成较大的传输开销.因此,我们对pLRC算法进行进一步的优化,优化思想是通过尽可能地减少局部校验块的更新个数来降低其更新所带来的开销.算法细节如下:</p>
                </div>
                <div class="p1">
                    <p id="161"><b>算法2</b>. pLRC编码(优化).</p>
                </div>
                <div class="area_img" id="403">
                                <img alt="" src="Detail/GetImg?filename=images/JFYZ201909020_40300.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="166">算法2将坏块所在分组需要转移的数据块全部放在另外一个分组内,使得需要更新的校验块永远只有2个.因此,在从pLRC回归到LRC时,只需要对2个校验块进行更新,这样可以将2个校验块的更新操作协同起来,从而降低传输开销.</p>
                </div>
                <div class="p1">
                    <p id="167">举例说明,当从图3(b)的pLRC向图3(a)的LRC回归时,<i>Q</i>′<sub>1</sub>所在节点需要下载<i>D</i><sub>3</sub>和<i>D</i><sub>4</sub>更新回到<i>Q</i><sub>1</sub>,<i>Q</i>′<sub>2</sub>所在节点需要下载<i>D</i><sub>3</sub>回到<i>Q</i><sub>2</sub>,<i>Q</i>′<sub>3</sub>所在节点需要下载<i>D</i><sub>4</sub>回到<i>Q</i><sub>3</sub>,即系统总共需要下载4个数据块.与之对应的是,图3(c)的pLRC仅生产2个局部校验块<i>Q</i>′<sub>1</sub>和<i>Q</i>′<sub>2</sub>,因此<i>Q</i>′<sub>1</sub>所在节点首先下载<i>D</i><sub>3</sub>和<i>D</i><sub>4</sub>回到<i>Q</i><sub>1</sub>之后,该节点可以额外生成一个<i>D</i><sub>3</sub>和<i>D</i><sub>4</sub>的异或块传输给<i>Q</i>′<sub>2</sub>协助其回到<i>Q</i><sub>2</sub>,从而系统总共只需要下载3个数据块.和算法1相比,算法2所造成的传输开销降低了25%.</p>
                </div>
                <h3 id="168" name="168" class="anchor-tag"><b>3 理论量化分析</b></h3>
                <div class="p1">
                    <p id="169">在本节中,我们主要在理论上对pLRC的可靠性以及修复过程中消耗的带宽进行分析,并与LRC进行比较.</p>
                </div>
                <h4 class="anchor-tag" id="170" name="170"><b>3.1 可靠性分析</b></h4>
                <div class="p1">
                    <p id="171">可靠性是分布式系统中最重要的性质之一,下面对pLRC的可靠性进行分析.与之前的很多工作类似<citation id="549" type="reference"><link href="410" rel="bibliography" /><link href="412" rel="bibliography" /><link href="480" rel="bibliography" /><link href="482" rel="bibliography" /><link href="484" rel="bibliography" /><link href="486" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">39</a>,<a class="sup">40</a>,<a class="sup">41</a>,<a class="sup">42</a>]</sup></citation>,我们使用马尔可夫模型来对平均无数据丢失时间(mean-time-to-data-loss, MTTDL)进行分析.与文献<citation id="547" type="reference">[<a class="sup">4</a>]</citation>相同,我们对一般化马尔可夫模型进行简单的扩展使其可以捕捉到LRC以及pLRC中的特殊状态变换.虽然基于马尔可夫的可靠性分析的有效性值得商榷<citation id="548" type="reference"><link href="488" rel="bibliography" /><sup>[<a class="sup">43</a>]</sup></citation>,但我们认为它足以为本工作提供可靠性的初步见解.</p>
                </div>
                <div class="p1">
                    <p id="172">1) 模型.将参数固定为<i>k</i>=6,<i>m</i>=2,<i>r</i>=2.图4为LRC和pLRC参数(<i>k</i>,<i>m</i>,<i>r</i>)=(6,2,2)的马尔可夫模型.假定我们将多个条带上的数据分布于<i>k</i>+<i>m</i>+<i>r</i>个节点上,每种状态代表可用节点的数量.比如状态10表示全部节点都是健康节点,而状态5则表示有数据丢失.在本文中,我们仅考虑独立故障,将单节点的故障率记为<i>λ</i>.因此,从状态<i>i</i>到状态<i>i</i>-1,1≤<i>i</i>≤<i>n</i>的状态转换率为<i>iλ</i>.</p>
                </div>
                <div class="area_img" id="173">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_173.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 马尔可夫可靠性模型" src="Detail/GetImg?filename=images/JFYZ201909020_173.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 马尔可夫可靠性模型  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_173.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 Markov reliability model</p>

                </div>
                <div class="p1">
                    <p id="174">马尔可夫模型中增加的扩展部分位于状态7,其可转换为2个拥有6个健康节点的状态.状态6代表了有4个可修复的故障,而状态6F则表示了有4个不可修复的故障.我们将在4个故障情形中可修复故障的比例记为<i>p</i><sub>d</sub>,则从状态7到状态6的转换率为7<i>λp</i><sub>d</sub>,而从状态7到状态6F的转换率为7<i>λ</i>(1-<i>p</i><sub>d</sub>).</p>
                </div>
                <div class="p1">
                    <p id="175">在反方向的修复模型上,我们将从状态<i>i</i>到状态<i>i</i>+1进行修复的修复率记为<i>μ</i>,其中在状态转换中使用LRC修复的修复率记为<i>μ</i><sub>1</sub>,而对于pLRC从状态9到状态10的过程中使用(2,1) RS码的修复率记为<i>μ</i><sub>2</sub>.在pLRC中,对于使用磁盘预测技术预测出的故障磁盘,我们将采用(2,1) RS码进行局部修复;对于未能预测出的故障磁盘,将仍使用LRC来进行修复.因此,pLRC中从状态9到状态10的修复率<i>μ</i>=(1-<i>FDR</i>)×<i>μ</i><sub>1</sub>+<i>FDR</i>×<i>μ</i><sub>2</sub>.</p>
                </div>
                <div class="p1">
                    <p id="176">我们可以按如下方式配置参数:对于<i>λ</i>,我们假定一个节点的平均无故障时间(mean-time-to-failure, MTTF)为4年<citation id="550" type="reference"><link href="412" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>(也就是说,1/<i>λ</i>=4年).我们把节点间的可用带宽记为<i>γ</i>,集群中的节点数为<i>M</i>,单节点上的存储量记为<i>S</i>,修复每一单元数据所需要的修复开销记为<i>C</i>.例如,在(<i>k</i>,<i>m</i>,<i>r</i>)=(6,2,2)时,对于LRC来说,<i>C</i>=(3×8+6×2)/10=18/5,<i>p</i><sub>d</sub>=86%<citation id="551" type="reference"><link href="410" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>,因此<i>μ</i><sub>1</sub>=<i>γ</i> (<i>M</i>-1)/(18<i>S</i>/5);而对于pLRC来说,<i>C</i>=(2×8+6×2)/10=14/5,因此<i>μ</i><sub>2</sub>=<i>γ</i>(<i>M</i>-1)/(14<i>S</i>/5).</p>
                </div>
                <div class="p1">
                    <p id="177">2) 分析.我们现在对LRC和pLRC策略下的MTTDL进行分析.采用2.1节所使用的SMART数据集,其中23 395个磁盘约30%作为测试集(<i>M</i>=7 019),使用一组经典的参数(<i>S</i>=16 TB,网络带宽利用率为0.1)<citation id="552" type="reference"><link href="412" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>来对不同网络带宽下的两者的可靠性进行计算.结果如表3所示:</p>
                </div>
                <div class="area_img" id="178">
                    <p class="img_tit"><b>表3 不同带宽下LRC和pLRC的MTTDL</b> a <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 3 MTTDLs of LRC and pLRC for Different Values of Bandwidth</b></p>
                    <p class="img_note"></p>
                    <table id="178" border="1"><tr><td><br />Bandwidth/Gbps</td><td>LRC</td><td>pLRC</td></tr><tr><td><br />1</td><td>3.02E+13</td><td>6.43E+13</td></tr><tr><td><br />2</td><td>2.42E+14</td><td>5.14E+14</td></tr><tr><td><br />3</td><td>8.16E+14</td><td>1.74E+15</td></tr><tr><td><br />4</td><td>1.94E+15</td><td>4.11E+15</td></tr><tr><td><br />5</td><td>3.78E+15</td><td>8.03E+15</td></tr><tr><td><br />6</td><td>6.53E+15</td><td>1.39E+16</td></tr><tr><td><br />7</td><td>1.04E+16</td><td>2.20E+16</td></tr><tr><td><br />8</td><td>1.55E+16</td><td>3.29E+16</td></tr><tr><td><br />9</td><td>2.20E+16</td><td>4.69E+16</td></tr><tr><td><br />10</td><td>3.02E+16</td><td>6.43E+16</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="179">从表3中数据我们得到,在不同的网络带宽下,pLRC的MTTDL最多比LRC提高113%.主要的原因是pLRC提前预测了磁盘故障,并使用修复效率较高的(2,1) RS码进行局部修复,提升了系统的可靠性.我们还能看到,网络带宽越高,两者的MTTDL均越高.这是由于网络带宽越高,其余参数不变的情况下,修复率<i>μ</i>也越高,从而提升了可靠性.</p>
                </div>
                <h4 class="anchor-tag" id="180" name="180"><b>3.2 修复带宽分析</b></h4>
                <div class="p1">
                    <p id="181">对于(<i>k</i>,<i>m</i>,<i>r</i>) LRC和(<i>k</i>,<i>m</i>,<i>r</i>) pLRC,我们将LRC中修复每一单元所需的修复带宽记为<i>C</i><sub>LRC</sub>,将pLRC中修复每一单元所需的修复带宽记为<i>C</i><sub>pLRC</sub>.我们假定每个条带中最多含有一个坏盘上的块,通过对LRC进行分析得到:</p>
                </div>
                <div class="p1">
                    <p id="182"><mathml id="232"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><msub><mrow></mrow><mrow><mtext>L</mtext><mtext>R</mtext><mtext>C</mtext></mrow></msub><mo>=</mo><mfrac><mrow><mi>k</mi><mo>+</mo><mi>m</mi></mrow><mrow><mi>k</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>×</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>+</mo><mfrac><mi>r</mi><mrow><mi>k</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>×</mo><mi>k</mi></mrow></math></mathml>.      (1)</p>
                </div>
                <div class="p1">
                    <p id="183">注意:pLRC将预测将要坏掉的数据块使用(2,1)RS进行恢复,而未被预测中的块则仍使用原来的(<i>k</i>,<i>m</i>,<i>r</i>) LRC进行修复.同时,坏盘中的全局编码块也仍使用(<i>k</i>,<i>m</i>,<i>r</i>) LRC进行修复.因此,我们得到:</p>
                </div>
                <div class="p1">
                    <p id="184" class="code-formula">
                        <mathml id="184"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>C</mi><msub><mrow></mrow><mrow><mtext>p</mtext><mtext>L</mtext><mtext>R</mtext><mtext>C</mtext></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>-</mo><mi>F</mi><mi>D</mi><mi>R</mi><mo stretchy="false">)</mo><mo>×</mo><mi>C</mi><msub><mrow></mrow><mrow><mtext>L</mtext><mtext>R</mtext><mtext>C</mtext></mrow></msub><mo>+</mo><mi>F</mi><mi>D</mi><mi>R</mi><mo>×</mo></mtd></mtr><mtr><mtd><mrow><mo>(</mo><mrow><mfrac><mrow><mi>k</mi><mo>+</mo><mi>m</mi></mrow><mrow><mi>k</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>×</mo><mn>2</mn><mo>+</mo><mfrac><mi>r</mi><mrow><mi>k</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>×</mo><mi>k</mi></mrow><mo>)</mo></mrow><mo>.</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="area_img" id="185">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_185.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 LRC和pLRC修复带宽的理论分析结果" src="Detail/GetImg?filename=images/JFYZ201909020_185.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 LRC和pLRC修复带宽的理论分析结果  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_185.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Numerical results of recovery bandwidth 
 for LRC and pLRC</p>

                </div>
                <div class="p1">
                    <p id="186">通过计算式(1)、式(2)两个等式的差可以得到pLRC相对于LRC减少的修复带宽:</p>
                </div>
                <div class="p1">
                    <p id="187"><mathml id="233"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><msub><mrow></mrow><mrow><mtext>L</mtext><mtext>R</mtext><mtext>C</mtext></mrow></msub><mo>-</mo><mi>C</mi><msub><mrow></mrow><mrow><mtext>p</mtext><mtext>L</mtext><mtext>R</mtext><mtext>C</mtext></mrow></msub><mo>=</mo><mi>F</mi><mi>D</mi><mi>R</mi><mo>×</mo><mfrac><mrow><mi>k</mi><mo>+</mo><mi>m</mi></mrow><mrow><mi>k</mi><mo>+</mo><mi>m</mi><mo>+</mo><mi>r</mi></mrow></mfrac><mo>×</mo><mrow><mo>(</mo><mrow><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>-</mo><mn>2</mn></mrow><mo>)</mo></mrow></mrow></math></mathml>.      (3)</p>
                </div>
                <div class="p1">
                    <p id="188">由式(3)可以得出,<i>k</i>/<i>m</i>越大以及<i>FDR</i>越大,则<i>C</i><sub>LRC</sub>-<i>C</i><sub>pLRC</sub>越大,也就是pLRC相对于LRC来说,修复带宽减少得越多,修复带宽越小.</p>
                </div>
                <div class="p1">
                    <p id="189">如2.1节所示,根据基于决策树的磁盘预测算法的结果<i>FDR</i>≈93%,我们对(6,2,2) pLRC和(12,2,2) pLRC的修复带宽分别进行计算,并和相应的LRC进行比较,具体结果如图5所示:</p>
                </div>
                <div class="p1">
                    <p id="190">从图5可以看出,对于(6,2,2) LRC和(6,2,2) pLRC,<i>C</i><sub>LRC</sub>=3.6,<i>C</i><sub>pLRC</sub>=2.86,且<i>C</i><sub>LRC</sub>-<i>C</i><sub>pLRC</sub>=0.74.也就是说,修复一个单元的数据,LRC需要3.6个单元的数据来进行修复,而pLRC仅需要2.86个单元即可修复,此时pLRC相对LRC的修复带宽下降了大约20.6%.同样地,在(<i>k</i>,<i>m</i>,<i>r</i>)=(12,2,2)时,pLRC相对LRC的修复带宽下降了大约48.1%.</p>
                </div>
                <div class="p1">
                    <p id="191">我们发现,(12,2,2) pLRC对(6,2,2)pLRC的修复开销下降得更多,这是因为在<i>FDR</i>相同的情况下,(12,2,2) pLRC的<i>k</i>/<i>m</i>=6大于(6,2,2) pLRC 的<i>k</i>/<i>m</i>=3,由式(3)可知,前者的修复带宽下降更多.这说明条带越长,我们的算法效果越好,这符合实际云存储厂商为了降低存储成本采用大条带的事实<citation id="553" type="reference"><link href="434" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>.</p>
                </div>
                <h4 class="anchor-tag" id="192" name="192"><b>3.3 pLRC更新开销分析</b></h4>
                <div class="p1">
                    <p id="193">pLRC的更新开销包括2个部分:LRC重组成pLRC和pLRC回归为LRC时,算法2与算法1更新操作所造成的传输.下面我们对(<i>k</i>,<i>m</i>,<i>r</i>) pLRC的这2个算法在重组与回归过程中的更新造成的传输开销进行分析.</p>
                </div>
                <div class="p1">
                    <p id="194">1) 对算法1的更新方式的传输开销进行分析.在重组过程中,其将一个分组中的<i>k</i>/<i>m</i>个块除去坏块以及任意一个块,也就是将剩余的<i>k</i>/<i>m</i>-2个块随机均匀转移到其余<i>m</i>-1组中去.算法1需要对这<i>m</i>-1个组中的编码块进行更新,同时也需要传输2个块(坏块以及任意一个块)来对第1个分组中的编码块进行更新,因而在重组过程中一共需要传输<i>k</i>/<i>m</i>个块.在回归过程中,算法1需要将之前重组出去的<i>k</i>/<i>m</i>-2个块收集至第1个分组中以对第1个分组的编码块进行更新,并且这<i>k</i>/<i>m</i>-2个块需要对重组过程中更新的<i>m</i>-1个组的编码块进行更新.在回归过程中一共需要传输2(<i>k</i>/<i>m</i>-2)个块.因此,我们可以得到算法1的更新方式的传输开销为</p>
                </div>
                <div class="p1">
                    <p id="195"><mathml id="234"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>+</mo><mn>2</mn><mo>×</mo><mrow><mo>(</mo><mrow><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>-</mo><mn>2</mn></mrow><mo>)</mo></mrow><mo>=</mo><mn>3</mn><mo>×</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>-</mo><mn>4</mn></mrow></math></mathml>.      (4)</p>
                </div>
                <div class="p1">
                    <p id="196">2) 对算法2的更新方式的传输开销进行分析.在重组过程中,其将一个分组中剩余的<i>k</i>/<i>m</i>-2个块均转移至第2个分组中,这样算法2可以先将2个块(坏块以及任意一个块)传至第1个分组中的编码块,以生成新的编码块.然后算法2利用第1个分组中旧的编码块与这2个块生成一个异或块,并将其传至第2个分组的编码块上对编码块进行更新.因而在重组过程中算法2一共需要传输3个块.在回归过程中,算法2需要将之前重组出去的<i>k</i>/<i>m</i>-2个块收集至第1个分组中以对第1个分组的编码块进行更新,同时,算法2利用收集的这<i>k</i>/<i>m</i>-2个块生成一个更新块.然后算法2将这个更新块传至第2个分组的编码块上以对其进行更新.这样,在回归过程中一共需要传输<i>k</i>/<i>m</i>-2+1=<i>k</i>/<i>m</i>-1个块.因此,我们可以得到算法2的更新方式的传输开销为</p>
                </div>
                <div class="p1">
                    <p id="197"><mathml id="235"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mn>3</mn><mo>+</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>-</mo><mn>1</mn><mo>=</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>+</mo><mn>2</mn></mrow></math></mathml>.      (5)</p>
                </div>
                <div class="p1">
                    <p id="198">现在通过计算式(4)、式(5)两个等式的差来得到算法2相对于算法1减少的传输开销:</p>
                </div>
                <div class="p1">
                    <p id="199"><mathml id="236"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><msub><mrow></mrow><mn>1</mn></msub><mo>-</mo><mi>C</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mn>2</mn><mo>×</mo><mfrac><mi>k</mi><mi>m</mi></mfrac><mo>-</mo><mn>6</mn></mrow></math></mathml>.      (6)</p>
                </div>
                <div class="p1">
                    <p id="200">在LRC的算法中,分组中至少有3个块(2个数据块、1个编码块),因此<i>k</i>/<i>m</i>≥3.通过式(6)我们发现算法2的更新方式的传输开销要小于等于算法1的开销,且<i>k</i>/<i>m</i>越大,算法2的传输开销相对于算法1来说越有优势.</p>
                </div>
                <div class="p1">
                    <p id="201">根据式(4)(5),我们计算出不同分组内块数量下的算法传输开销,如图6所示:</p>
                </div>
                <div class="area_img" id="202">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_202.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 算法1和算法2更新方式的传输开销" src="Detail/GetImg?filename=images/JFYZ201909020_202.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 算法1和算法2更新方式的传输开销  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_202.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 Transfer cost of algorithm 1 and algorithm 2</p>

                </div>
                <div class="p1">
                    <p id="203">从图6中我们可以看到,算法1的开销要大于算法2的开销,且2种算法的开销之差也随着分组内块的数量的增多而不断增加.</p>
                </div>
                <h3 id="204" name="204" class="anchor-tag"><b>4 实验与结果</b></h3>
                <div class="p1">
                    <p id="205">在本节中,我们在云上运行了实验,测试了pLRC的降级读性能以及修复性能,并将其与LRC进行对比.</p>
                </div>
                <h4 class="anchor-tag" id="206" name="206"><b>4.1 实验部署环境</b></h4>
                <div class="p1">
                    <p id="207">我们将pLRC部署在Facebook的HDFS<citation id="554" type="reference"><link href="422" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>中,其通过整合HDFS-RAID<citation id="555" type="reference"><link href="490" rel="bibliography" /><sup>[<a class="sup">44</a>]</sup></citation>以在Hadoop Distributed File System (HDFS)<citation id="556" type="reference"><link href="492" rel="bibliography" /><sup>[<a class="sup">45</a>]</sup></citation>中支持纠删码.下面我们先对HDFS如何实现纠删码进行概述,然后介绍我们如何在HDFS中部署pLRC.</p>
                </div>
                <h4 class="anchor-tag" id="208" name="208">4.1.1 HDFS简概</h4>
                <div class="p1">
                    <p id="209">HDFS是学术界和工业界部署应用最为广泛的分布式存储系统之一.它由2种类型的节点组成:一个执行管理操作并包含各种元数据的NameNode,以及多个包含数据的DataNode.HDFS将数据分为固定大小的块,这些块作为基本单元来进行读、写以及编码等操作.</p>
                </div>
                <div class="p1">
                    <p id="210">HDFS-RAID引入了一个RaidNode来处理纠删码的相关操作如编码、修复等.RaidNode首先将数据存储为多个副本,并将这些副本分布在不同节点上.一段时间后,RaidNode通过使用MapReduce<citation id="557" type="reference"><link href="494" rel="bibliography" /><sup>[<a class="sup">46</a>]</sup></citation>来将这些块转换为编码过的块.具体来说,为了构建参数为(<i>k</i>,<i>r</i>)的纠删码,MapReduce作业中的map任务从不同的DataNode上收集<i>k</i>个编码块,然后将它们编码为<i>r</i>个校验块,并将这<i>k</i>+<i>r</i>个块分布至<i>k</i>+<i>r</i>个DataNode上.此外,RaidNode还会定期检查是否存在故障块,并触发修复操作来修复故障块.</p>
                </div>
                <h4 class="anchor-tag" id="211" name="211">4.1.2 pLRC部署</h4>
                <div class="p1">
                    <p id="212">下面我们将解释如何扩展Facebook的HDFS以对pLRC进行支持.具体架构如图7所示:</p>
                </div>
                <div class="area_img" id="213">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_213.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 pLRC架构图" src="Detail/GetImg?filename=images/JFYZ201909020_213.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 pLRC架构图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_213.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 Architecture of pLRC</p>

                </div>
                <div class="p1">
                    <p id="214">1) LRC和pLRC编码模块.我们在HDFS上增加了LRC编码,并实现了在预测到磁盘将要发生故障时将LRC编码转变为pLRC编码的相关模块.我们主要实现了LRC以及pLRC这2种编码的编解码以及修复操作.对于LRC,我们主要是增加了分组,计算出分组内的局部校验块,并通过Placement Manager模块指定其所有块的放置位置. LRC的分组信息、分组内局部校验块的信息以及块放置信息均存储于RaidNode上,以备修复过程及转换至pLRC时使用.对于pLRC, 我们首先在模块中增加getPredictingInfo API,通过此API从磁盘故障预测算法中获取预测的结果即坏盘;然后从NameNode获取坏盘中所有坏块相关的条带信息,从RaidNode获取分组、校验块信息以及块放置信息;最后通过传输块对分组校验块进行更新,使得坏块所在的条带从LRC编码转变为pLRC编码.</p>
                </div>
                <div class="p1">
                    <p id="215">对于修复操作,我们主要关注单节点的故障修复.现在支持2类修复操作:①节点修复.指的是某个节点发生故障时,对其上所有丢失的数据块进行修复.由于每个丢失的数据块位于不同的条带中,因此利用条带中的其余数据对其进行修复.当RaidNode检测到节点故障时,RaidNode会调用pLRC的修复函数来进行节点修复,其先从NameNode获取相关所有条带信息.对每一个条带,pLRC从RaidNode上获取相关的分组信息及放置信息,然后利用这些信息调用相关的DataNode传输修复所需的块至新节点上以进行修复操作.②降级读.指的是修复某个当前不可用的数据块.我们对文件系统客户端进行了修改,当客户端读取数据发现不能获取某个块时,会触发块丢失故障异常.此时客户端将调用RaidNode上的pLRC从相关DataNode上读取分组中的相关块来对丢失块进行修复,并将修复出的块传给客户端,从而完成降级读操作.</p>
                </div>
                <div class="p1">
                    <p id="216">2) ISA-L计算模块.以上的2种编码我们均通过使用Intel的ISA-L<citation id="558" type="reference"><link href="496" rel="bibliography" /><sup>[<a class="sup">47</a>]</sup></citation>硬件加速库来实现快速编解码.我们通过Java Native Interface (JNI)来将具体的编解码操作与Hadoop连接起来,从而极大地加速了编解码操作.我们主要使用2个ISA-L的API:用来指定编码系数的<i>ec</i>_<i>init</i>_<i>tables</i>以及用来具体执行编解码操作的<i>ec</i>_<i>encode</i>_<i>data</i>.这些ISA_L的API将基于硬件配置来自动对计算过程进行优化.</p>
                </div>
                <div class="p1">
                    <p id="217">3) 数据布局.LRC及pLRC编码在编解码完成后需要考虑将数据块如何在集群中进行放置.因此我们将数据布局增添到HDFS中,通过对RaidNode中的数据布局管理模块进行更改,以此来指定条带中的数据具体是如何放置的.即如何把编码后的同一条带中的数据块与编码块随机地放置到集群中的不同节点上或是将解码后的数据块放置到特定的节点上.</p>
                </div>
                <h4 class="anchor-tag" id="218" name="218"><b>4.2 实验配置与方法</b></h4>
                <div class="p1">
                    <p id="219">1) 实验环境配置.我们的实验部署在Amazon EC2<citation id="559" type="reference"><link href="424" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>上.使用位于美国东部(弗吉尼亚北部)区域的17个m4.4xlarge实例来进行实验,其中有1个实例用作管理节点NameNode及编解码节点RaidNode,其余16个实例用作数据节点DataNode.这些实例均基于Ubuntu 14.04的Linux平台,具体硬件配置为16核CPU、64 GB内存、2 TB SSD.</p>
                </div>
                <div class="p1">
                    <p id="220">2) 实验方法.我们测试了4种不同参数下pLRC的降级读延迟以及单节点修复时间,并与LRC进行对比.这4组参数分别是:微软Azure<citation id="560" type="reference"><link href="410" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>中采用的(6,2,2),(12,2,2),Faceook集群<citation id="561" type="reference"><link href="412" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>中采用的(10,2,4),以及理论最优LRC<citation id="562" type="reference"><link href="498" rel="bibliography" /><sup>[<a class="sup">48</a>]</sup></citation>中采用的(6,2,3).</p>
                </div>
                <div class="p1">
                    <p id="221">对于(6,2,2) pLRC,我们使用了总量为6 TB的数据来进行编码,生成4 TB的编码数据; 对于(12,2,2) pLRC我们使用了总量为12 TB的数据来进行编码,生成4 TB的编码数据; 对于(10,2,4) pLRC我们使用了总量为10 TB的数据来进行编码,生成6 TB的编码数据; 对于(6,2,3) pLRC我们使用了总量为6 TB的数据来进行编码,生成5 TB的编码数据.我们将这些数据分别均匀分布在10,16,16及11个数据节点上,每个数据节点存放1 T数据,取每个实验的5次平均运行结果.</p>
                </div>
                <h4 class="anchor-tag" id="222" name="222"><b>4.3 实验结果</b></h4>
                <div class="p1">
                    <p id="223">1) 数据块降级读性能.我们测试了当文件系统客户端读取一个不可用数据块的降级读性能.在系统中随机擦除掉一个数据块,然后让文件系统客户端通过降级读的方式来获取该数据块.降级读性能的测试结果如图8所示:</p>
                </div>
                <div class="area_img" id="224">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_224.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 LRC和pLRC的降级读性能" src="Detail/GetImg?filename=images/JFYZ201909020_224.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图8 LRC和pLRC的降级读性能  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_224.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 8 Degraded read performance for LRC and pLRC</p>

                </div>
                <div class="p1">
                    <p id="225">在图8中可以看到,在(<i>k</i>,<i>m</i>,<i>r</i>)=(12,2,2) 时,LRC的降级读时延为42.25 ms,pLRC的降级读时延为22.49 ms.pLRC相对于LRC来说减少了降级读的时延,降级读性能提升了大约46.8%.这主要是由于pLRC通过对预测到的坏盘使用(2,1) RS编码,大大减少了降级读时的修复开销,从而使得降级读性能得以提升.</p>
                </div>
                <div class="p1">
                    <p id="226">我们还发现pLRC相对LRC来说,其在(<i>k</i>,<i>m</i>,<i>r</i>)=(12,2,2)情况下的降级读性能提升要比(<i>k</i>,<i>m</i>,<i>r</i>)=(6,2,2)大.和3.2节理论分析结果较为一致.</p>
                </div>
                <div class="p1">
                    <p id="227">2) 节点修复性能.我们还测试了节点修复性能,即当某个节点发生故障时,系统对该节点上的多个数据块进行修复所消耗的时间.随机选取一个节点,擦除掉上面的所有块,然后分别使用pLRC和LRC来修复该节点上被擦除的所有块.节点修复性能的测试结果如图9所示:</p>
                </div>
                <div class="area_img" id="228">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909020_228.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 LRC和pLRC的节点修复性能" src="Detail/GetImg?filename=images/JFYZ201909020_228.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图9 LRC和pLRC的节点修复性能  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909020_228.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 9 Node repair performance for LRC and pLRC</p>

                </div>
                <div class="p1">
                    <p id="229">在图9中我们可以看到,在(<i>k</i>,<i>m</i>,<i>r</i>)=(12,2,2) 时,pLRC的节点修复时间为1.99×10<sup>3</sup> s,LRC的节点修复时间为3.79×10<sup>3</sup> s.pLRC相对于LRC修复时间下降了大约47.5%.在其余参数下情况类似.我们注意到(<i>k</i>,<i>m</i>,<i>r</i>)=(10,2,4)时,pLRC的节点修复时间相对LRC下降较少,主要是由于这种情况有较多的全局编码块,需要使用大量数据块来进行修复.</p>
                </div>
                <h3 id="230" name="230" class="anchor-tag"><b>5 总  结</b></h3>
                <div class="p1">
                    <p id="231">本文通过将基于机器学习的磁盘故障预测技术运用到LRC中以对其固定分组大小的假设进行改进,提出了一类基于预测的LRC编码方案pLRC,该方案通过动态调整系统中LRC的分组大小从而降低了修复带宽,并提升了系统的可靠性.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="404">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Microsoft Azure suffers outage after cooling issue[OL]">

                                <b>[1]</b>Sebastian M.Microsoft Azure suffers outage after cooling issue[OL].[2019-01-05]https://www.datacenterdynamics.com/news/microsoft-azure-suffers-outage-after-cooling-issue/
                            </a>
                        </p>
                        <p id="406">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJST&amp;filename=SJST14120300998566&amp;v=MDgyMTF1SHlqbVVMM0lKMXNRYWhJPU5pZlllcks4SDlQTXJJOUZiZUlIQ1hvL29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b>Reed I S,Solomon G.Polynomial codes over certain finite fields[J].Journal of the Society for Industrial and Applied Mathematics,1960,8(2):300- 304
                            </a>
                        </p>
                        <p id="408">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Erasure coding vs. replication: A quantitativecomparison">

                                <b>[3]</b>Weatherspoon H,Kubiatowicz J D.Erasure coding vs.replication:A quantitative comparison[C] //Proc of Int Workshop on Peer-to-Peer Systems (IPTPS'02).Berlin:Springer,2002:328- 337
                            </a>
                        </p>
                        <p id="410">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Erasure coding in windows azure storage">

                                <b>[4]</b>Huang Cheng,Simitci H,Xu Yikang,et al.Erasure coding in windows Azure storage[C] //Proc of the 2012 USENIX Conf on Annual Technical Conf (ATC'12).Berkeley,CA:USENIX Association,2012:15- 26
                            </a>
                        </p>
                        <p id="412">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=XORing elephants:Novel erasure codes for big data">

                                <b>[5]</b>Sathiamoorthy M,Asteris M,Papailiopoulos D,et al.Xoring elephants:Novel erasure codes for big data[J].Proceedings of International Conf on Very Large Data Bases Endowment,2013,6(5):325- 336
                            </a>
                        </p>
                        <p id="414">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Locally repairable codes">

                                <b>[6]</b>Papailiopoulos D,Dimakis A G.Locally repairable codes[J].IEEE Transactions on Information Theory,2014,60(10):5843- 5855
                            </a>
                        </p>
                        <p id="416">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Predicting disk replacement towards reliable data centers">

                                <b>[7]</b>Botezatu M M,Giurgiu I,Bogojeska J,et al.Predicting disk replacement towards reliable data centers[C] //Proc of the 22nd Int Conf on Knowledge Discovery and Data Mining (KDD'16).New York:ACM,2016:39- 48
                            </a>
                        </p>
                        <p id="418">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Procode:A proactive erasure coding scheme for cloud storage systems">

                                <b>[8]</b>Li Peng,Li Jing,Stones R J,et al.Procode:A proactive erasure coding scheme for cloud storage systems[C] //Proc of the 35th IEEE Symp on Reliable Distributed Systems (SRDS'16).Piscataway,NJ:IEEE,2016:219- 228
                            </a>
                        </p>
                        <p id="420">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Disk failures in the real world:What does an MTTF of1,000,000hours mean to you-">

                                <b>[9]</b>Schroeder B,Gibson G A.Disk failures in the real world:What does an mttf of 1 000 000 hours mean to you?[C] //Proc of the USENIX Conf on File and Storage Technologies (FAST'07).Berkeley,CA:USENIX Association,2007:1- 16
                            </a>
                        </p>
                        <p id="422">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Facebook&amp;#39;&amp;#39;s Hadoop 20[OL]">

                                <b>[10]</b>Facebook.Facebook's Hadoop 20[OL].[2019-01-05].https://github.com/facebookarchive/hadoop-20
                            </a>
                        </p>
                        <p id="424">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Amazon elastic compute cloud (EC2)[OL]">

                                <b>[11]</b>Amazon.Amazon elastic compute cloud (EC2)[OL].[2019-01-05].http://aws.amazon.com/ec2/
                            </a>
                        </p>
                        <p id="426">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=f4:Facebook&amp;#39;&amp;#39;s warm blob storage system">

                                <b>[12]</b>Muralidhar S,Lloyd W,Roy S,et al.f4:Facebook's warm blob storage system[C] //Proc of the 11th USENIX Conf on Operating Systems Design and Implementation.Berkeley,CA:USENIX Association,2014:383- 398
                            </a>
                        </p>
                        <p id="428">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=IBM cloud[OL]">

                                <b>[13]</b>IBM.IBM cloud[OL].[2019-01-05].https://www.ibm.com/cloud/object-storage
                            </a>
                        </p>
                        <p id="430">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A hitchhiker&amp;#39;&amp;#39;s guide to fast and efficient data reconstruction in erasure-coded data centers">

                                <b>[14]</b>Rashmi K V,Shah N B,Gu Dikang,et al.A hitchhiker's guide to fast and efficient data reconstruction in erasure-coded data centers[C] //Proc of the ACM Conf on Special Interest Group on Data Communication (SIGCOMM'14).New York:ACM,2014:331- 342
                            </a>
                        </p>
                        <p id="432">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Giza:Erasure coding objects across global data centers">

                                <b>[15]</b>Chen Yulin,Mu Shuai,Li Jinyang,et al.Giza:Erasure coding objects across global data centers[C] //Proc of the 2017 USENIX Conf on Annual Technical Conf (ATC'17).Berkeley,CA:USENIX Association,2017:539- 551
                            </a>
                        </p>
                        <p id="434">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Hybris: Robust Hybrid Cloud Storage">

                                <b>[16]</b>Dobre D,Viotti P,Vukoli M.Hybris:Robust hybrid cloud storage[C] //Proc of the ACM Symp on Cloud Computing.New York:ACM,2014:1- 14
                            </a>
                        </p>
                        <p id="436">
                            <a id="bibliography_17" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Qiniu Cloud[OL]">

                                <b>[17]</b>Qiniu Cloud.Qiniu Cloud[OL].[2019-01-05].http://www.pingwest.com/qiniu/
                            </a>
                        </p>
                        <p id="438">
                            <a id="bibliography_18" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201201001&amp;v=MDU0NzQ5RlpZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSc0Z5L2dWNy9JTHl2U2RMRzRIOVBNcm8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[18]</b>Luo Xianghong,Shu Jiwu.Summary of research for erasure code in storage system[J].Journal of Computer Research and Development,2012,49(1):1- 11 (in Chinese)(罗象宏,舒继武.存储系统中的纠删码研究综述[J].计算机研究与发展,2012,49(1):1- 11
                            </a>
                        </p>
                        <p id="440">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Network Coding for Distributed Storage Systems">

                                <b>[19]</b>Dimakis A G,Godfrey P B,Wu Yunnan,et al.Network coding for distributed storage systems[J].IEEE Transactions on Information Theory,2010,56(9):4539- 4551
                            </a>
                        </p>
                        <p id="442">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Interference Alignment in Regenerating Codes for Distributed Storage: Necessity and Code Constructions">

                                <b>[20]</b>Shah N B,Rashmi K V,Kumar P V,et al.Interference alignment in regenerating codes for distributed storage:Necessity and code constructions[J].IEEE Transactions on Information Theory,2012,58(4):2134- 2158
                            </a>
                        </p>
                        <p id="444">
                            <a id="bibliography_21" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Linear network coding">

                                <b>[21]</b>Li S Y R,Yeung R W,Cai Ning.Linear network coding[J].IEEE Transactions on Information Theory,2003,49(2):371- 381
                            </a>
                        </p>
                        <p id="446">
                            <a id="bibliography_22" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Analysis and construction of functional regenerating codes with uncoded repair for distributed storage systems">

                                <b>[22]</b>Hu Yuchong,Lee P P C,Shum K W.Analysis and construction of functional regenerating codes with uncoded repair for distributed storage systems[C] //Proc of the IEEE Int Conf on Computer Communication (INFOCOM'13).New York:IEEE Communications Society,2013:2355- 2363
                            </a>
                        </p>
                        <p id="448">
                            <a id="bibliography_23" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Zigzag Codes: MDS Array Codes With Optimal Rebuilding">

                                <b>[23]</b>Tamo I,Wang Zhiying,Bruck J.Zigzag codes:MDS array codes with optimal rebuilding[J].IEEE Transactions on Information Theory,2013,59(3):1597- 1616
                            </a>
                        </p>
                        <p id="450">
                            <a id="bibliography_24" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Asymptotic interference alignment for optimal repair of MDS codes in distributed storage">

                                <b>[24]</b>Cadambe V R,Jafar S A,Maleki H,et al.Asymptotic interference alignment for optimal repair of MDS codes in distributed storage[J].IEEE Transactions on Information Theory,2013,59(5):2974- 2987
                            </a>
                        </p>
                        <p id="452">
                            <a id="bibliography_25" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Cooperative recovery of distributed storage systems from multiple losses with network coding">

                                <b>[25]</b>Hu Yuchong,Xu Yinlong,Wang Xiaozhao,et al.Cooperative recovery of distributed storage systems from multiple losses with network coding[J].IEEE Journal on Selected Areas in Communications,2010,28(2):68- 276
                            </a>
                        </p>
                        <p id="454">
                            <a id="bibliography_26" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Cooperative Regenerating Codes">

                                <b>[26]</b>Shum K W,Hu Yuchong.Cooperative regenerating codes[J].IEEE Transactions on Information Theory,2013,59(11):7229- 7258
                            </a>
                        </p>
                        <p id="456">
                            <a id="bibliography_27" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM1F115E91E58C8AA012FF3E03BB833229&amp;v=MjA2NzhPR1FsZkNwYlEzNU5waHc3Mjd3S2c9TmlmSVk3TE9IOURKMm9aRUVlNEhmM1JJdmhZUzZFa0xTd3JpcjJCSGNiR1hSN2lXQ09OdkZTaVdXcjdKSUZwbWFCdUhZZg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[27]</b>Hu Yuchong,Li Xiaolu,Zhang Mi,et al.Optimal repair layering for erasure-coded data centers:From theory to practice[J].ACM Transactions on Storage,2017,13(4):No.33
                            </a>
                        </p>
                        <p id="458">
                            <a id="bibliography_28" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Exact-repair MDS code construction using interference alignment">

                                <b>[28]</b>Suh C,Ramchandran K.Exact-repair MDS code construction using interference alignment[J].IEEE Transactions on Information Theory,2011,57(3):1425- 1442
                            </a>
                        </p>
                        <p id="460">
                            <a id="bibliography_29" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Ceph[OL]">

                                <b>[29]</b>Ceph.Ceph[OL].[2019-01-05].http://docs.ceph.com/docs/master/rados/operations/erasure-code-lrc/ highlight=locally
                            </a>
                        </p>
                        <p id="462">
                            <a id="bibliography_30" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Ceph:A scalable,high-performance distributed file system">

                                <b>[30]</b>Weil S A,Brandt S A,Miller E L,et al.Ceph:A scalable,high-performance distributed file system[C] //Proc of the 7th Symp on Operating Systems Design and Implementation (OSDI'06).Berkeley,CA:USENIX Association,2006:307- 320
                            </a>
                        </p>
                        <p id="464">
                            <a id="bibliography_31" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Data center downtime costs[OL]">

                                <b>[31]</b>Emerson.Data center downtime costs[OL].[2019-01-05].http://www.emerson.com/en-us/News/Pages/Net-Power-Study-Data-Center.aspx
                            </a>
                        </p>
                        <p id="466">
                            <a id="bibliography_32" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=KXTS201703002&amp;v=MTEyODZHNEg5Yk1ySTlGWm9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJzRnkvZ1Y3L0lMalhmZmI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[32]</b>Li Jing,Wang Gang,Liu Xiaoguang,et al.Review of reliability prediction for storage system[J].Journal of Frontiers of Computer Science and Technology,2017,11(3):341- 354 (in Chinese)(李静,王刚,刘晓光,等.存储系统可靠性预测综述[J].计算机科学与探索,2017,11(3):341- 354)
                            </a>
                        </p>
                        <p id="468">
                            <a id="bibliography_33" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Machine learning methods for predicting failures in hard drives: a multiple-instance application">

                                <b>[33]</b>Murray J F,Hughes G F,Kreutz-Delgado K.Machine learning methods for predicting failures in hard drives:A multiple-instance application[J].Journal of Machine Learning Research,2005,6(5):783- 816
                            </a>
                        </p>
                        <p id="470">
                            <a id="bibliography_34" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Proactive drive failure prediction for large scale storage systems">

                                <b>[34]</b>Zhu Bingpeng,Wang Gang,Liu Xiaoguang,et al.Proactive drive failure prediction for large scale storage systems[C] //Proc of the 29th IEEE Symp on Mass Storage Systems and Technologies (MSST'13).Piscataway,NJ:IEEE,2013:1- 5
                            </a>
                        </p>
                        <p id="472">
                            <a id="bibliography_35" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Bayesian approaches to failure prediction for disk drives">

                                <b>[35]</b>Hamerly G,Elkan C.Bayesian approaches to failure prediction for disk drives[C] //Proc of the 18th Int Conf on Machine Learning (ICML'01).San Francisco,CA:Morgan Kaufmann,2001:202- 209
                            </a>
                        </p>
                        <p id="474">
                            <a id="bibliography_36" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Improved disk-drive failure warnings">

                                <b>[36]</b>Hughes G F,Murray J F,Kreutz-Delgado K,et al.Improved disk-drive failure warnings[J].IEEE Transactions on Reliability,2002,51(3):350- 357
                            </a>
                        </p>
                        <p id="476">
                            <a id="bibliography_37" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Hard drive failure prediction using classification and regression trees">

                                <b>[37]</b>Li Jing,Ji Xinpu,Jia Yuhan,et al.Hard drive failure prediction using cassification and regression trees[C] //Proc of the 44th Annual IEEE/IFIP Int Conf on Dependable Systems and Networks (DSN'14).Los Alamitos,CA:IEEE Computer Society,2014:383- 394
                            </a>
                        </p>
                        <p id="478">
                            <a id="bibliography_38" target="_blank" href="http://scholar.cnki.net/result.aspx?q=SMART dataset[OL]">

                                <b>[38]</b>Baidu.SMART dataset[OL].[2019-01-05].http://pan.baidu.com/share/link?shareid=189977&amp;uk=4278294944
                            </a>
                        </p>
                        <p id="480">
                            <a id="bibliography_39" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Tiered replication:A cost-effective alternative to full cluster geo-replication">

                                <b>[39]</b>Cidon A,Escriva R,Katti S,et al.Tiered replication:A cost-effective alternative to full cluster geo-replication[C] //Proc of the 2012 USENIX Conf on Annual Technical Conf (ATC'15).Berkeley,CA:USENIX Association,2015:31- 43
                            </a>
                        </p>
                        <p id="482">
                            <a id="bibliography_40" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Availability in globally distributed storage systems">

                                <b>[40]</b>Ford D,Labelle F,Popovici F I,et al.Availability in globally distributed storage systems[C] //Proc of the 7th Symp on Operating Systems Design and Implementation (OSDI'10).Berkeley,CA:USENIX Association,2010:1- 7
                            </a>
                        </p>
                        <p id="484">
                            <a id="bibliography_41" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Lazy means smart:Reducing repair bandwidth costs in erasure-coded distributed storage">

                                <b>[41]</b>Silberstein M,Ganesh L,Wang Y,et al.Lazy means smart:Reducing repair bandwidth costs in erasure-coded distributed storage[C] //Proc of Int Conf on Systems and Storage (SYSTOR'14).New York:ACM,2014:1- 7
                            </a>
                        </p>
                        <p id="486">
                            <a id="bibliography_42" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200905008&amp;v=MDQ5NTh0R0ZyQ1VSTE9lWmVSc0Z5L2dWNy9JTHl2U2RMRzRIdGpNcW85RmJJUUtESDg0dlI0VDZqNTRPM3pxcUI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[42]</b>Mu Fei,Xue Wei,Shu Jiwu,et al.An analytical model for large-scale storage system with replicated data[J].Journal of Computer Research and Development,2009,46(5):756- 761 (in Chinese)(穆飞,薛巍,舒继武,等.一种面向大规模副本存储系统的可靠性模型[J].计算机研究与发展,2009,46(5):756- 761)
                            </a>
                        </p>
                        <p id="488">
                            <a id="bibliography_43" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Mean time to meaningless:MTTDL,Markov models,and storage system reliability">

                                <b>[43]</b>Greenan K M,Plank J S,Wylie J J.Mean time to meaningless:MTTDL,Markov models,and storage system reliability[C] //Proc of the 2nd USENIX Conf on Hot Topics in Storage and File Systems (HotStorage'10).Berkeley,CA:USENIX Association,2010:1- 5
                            </a>
                        </p>
                        <p id="490">
                            <a id="bibliography_44" target="_blank" href="http://scholar.cnki.net/result.aspx?q=HDFS RAID[OL]">

                                <b>[44]</b>Apache.HDFS RAID[OL].[2019-01-05].http://wiki.apache.org/hadoop/HDFS-RAID
                            </a>
                        </p>
                        <p id="492">
                            <a id="bibliography_45" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The Hadoop Distributed File System">

                                <b>[45]</b>Shvachko K,Kuang H,Radia S,et al.The Hadoop distributed file system[C] //Proc of the 26th IEEE Symp Mass Storage Systems and Technologies (MSST'10).Piscataway,NJ:IEEE,2010:1- 10
                            </a>
                        </p>
                        <p id="494">
                            <a id="bibliography_46" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000030554&amp;v=MTk2NTc3SzdIdGpOcjQ5RlpPZ1BDWGs5b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VTDNJSjFzUWFoST1OaWZJWQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[46]</b>Dean J,Ghemawat S.MapReduce:Simplified data processing on large clusters[J].Communications of the ACM,2008,51(1):107- 113
                            </a>
                        </p>
                        <p id="496">
                            <a id="bibliography_47" target="_blank" href="http://scholar.cnki.net/result.aspx?q=ISA-L[OL]">

                                <b>[47]</b>Intel.ISA-L[OL].[2019-01-05].https://github.com/01org/isa-l
                            </a>
                        </p>
                        <p id="498">
                            <a id="bibliography_48" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A family of optimal locally recoverable codes">

                                <b>[48]</b>Tamo I,Barg A.A family of optimal locally recoverable codes[J].IEEE Transactions on Information Theory,2014,60(8):4661- 4676
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201909020" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201909020&amp;v=MjgzNzVnVjcvSUx5dlNkTEc0SDlqTXBvOUhaSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdIUktCTHdLT3MxcUlJWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>


    <link href="/kxreader/Content/css/LeftDetail?v=NLcKG8I1SJUaVFrQ0iGpF2klAT0OsmHRaVSZ1rKb5xg1" rel="stylesheet"/>

</body>
</html>

