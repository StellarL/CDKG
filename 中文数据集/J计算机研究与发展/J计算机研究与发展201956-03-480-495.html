<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637133237580908750%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201903003%26RESULT%3d1%26SIGN%3do5Ot1O9FYR3gcNjygZ6SEZMbVYI%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903003&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903003&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903003&amp;v=MDYxNDM0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNy9PTHl2U2RMRzRIOWpNckk5Rlo0UUtESDg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#94" data-title="&lt;b&gt;1 背景知识&lt;/b&gt; "><b>1 背景知识</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#95" data-title="&lt;b&gt;1.1 IFDS数据流分析框架&lt;/b&gt;"><b>1.1 IFDS数据流分析框架</b></a></li>
                                                <li><a href="#99" data-title="&lt;b&gt;1.2 FlowDroid与别名分析&lt;/b&gt;"><b>1.2 FlowDroid与别名分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#104" data-title="&lt;b&gt;2 研究动机&lt;/b&gt; "><b>2 研究动机</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#121" data-title="&lt;b&gt;3 稀疏的IFDS框架&lt;/b&gt; "><b>3 稀疏的IFDS框架</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#123" data-title="&lt;b&gt;3.1 指令定义&lt;/b&gt;"><b>3.1 指令定义</b></a></li>
                                                <li><a href="#126" data-title="&lt;b&gt;3.2 变量使用点索引&lt;/b&gt;"><b>3.2 变量使用点索引</b></a></li>
                                                <li><a href="#130" data-title="&lt;b&gt;3.3 自治数据流图ADFG&lt;/b&gt;"><b>3.3 自治数据流图ADFG</b></a></li>
                                                <li><a href="#180" data-title="&lt;b&gt;3.4 变量使用点索引的计算&lt;/b&gt;"><b>3.4 变量使用点索引的计算</b></a></li>
                                                <li><a href="#190" data-title="&lt;b&gt;3.5 传播函数&lt;/b&gt;"><b>3.5 传播函数</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#201" data-title="&lt;b&gt;4 基于稀疏框架的污点分析&lt;/b&gt; "><b>4 基于稀疏框架的污点分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#202" data-title="&lt;b&gt;4.1 总体框架&lt;/b&gt;"><b>4.1 总体框架</b></a></li>
                                                <li><a href="#205" data-title="&lt;b&gt;4.2 污点传播中使用点的维护与剪枝&lt;/b&gt;"><b>4.2 污点传播中使用点的维护与剪枝</b></a></li>
                                                <li><a href="#226" data-title="&lt;b&gt;4.3 面向别名传播的变量使用点索引&lt;/b&gt;"><b>4.3 面向别名传播的变量使用点索引</b></a></li>
                                                <li><a href="#229" data-title="&lt;b&gt;4.4 流敏感的别名传播维护&lt;/b&gt;"><b>4.4 流敏感的别名传播维护</b></a></li>
                                                <li><a href="#238" data-title="&lt;b&gt;4.5 剪枝优化讨论&lt;/b&gt;"><b>4.5 剪枝优化讨论</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#244" data-title="&lt;b&gt;5 实现与实验&lt;/b&gt; "><b>5 实现与实验</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#248" data-title="&lt;b&gt;5.1 评测问题&lt;/b&gt;"><b>5.1 评测问题</b></a></li>
                                                <li><a href="#253" data-title="&lt;b&gt;5.2 问题1:精确度验证&lt;/b&gt;"><b>5.2 问题1:精确度验证</b></a></li>
                                                <li><a href="#255" data-title="&lt;b&gt;5.3 问题2:预处理和更新阶段开销&lt;/b&gt;"><b>5.3 问题2:预处理和更新阶段开销</b></a></li>
                                                <li><a href="#260" data-title="&lt;b&gt;5.4 问题3:性能提升效果&lt;/b&gt;"><b>5.4 问题3:性能提升效果</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#264" data-title="&lt;b&gt;6 相关工作对比&lt;/b&gt; "><b>6 相关工作对比</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#269" data-title="&lt;b&gt;7 总结与未来工作&lt;/b&gt; "><b>7 总结与未来工作</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#98" data-title="图1 使用IFDS算法求解污点分析示例">图1 使用IFDS算法求解污点分析示例</a></li>
                                                <li><a href="#102" data-title="图2 FlowDroid方式的别名间污点传播示例">图2 FlowDroid方式的别名间污点传播示例</a></li>
                                                <li><a href="#108" data-title="图3 无关联污点传播示例">图3 无关联污点传播示例</a></li>
                                                <li><a href="#117" data-title="&lt;b&gt;表1 评测用例基本信息&lt;/b&gt;"><b>表1 评测用例基本信息</b></a></li>
                                                <li><a href="#119" data-title="&lt;b&gt;表2 使用FlowDroid对数据集进行评测结果&lt;/b&gt;"><b>表2 使用FlowDroid对数据集进行评测结果</b></a></li>
                                                <li><a href="#125" data-title="&lt;b&gt;表3 指令规则&lt;/b&gt;"><b>表3 指令规则</b></a></li>
                                                <li><a href="#133" data-title="图4 自治数据流图 (基对象为&lt;i&gt;a&lt;/i&gt;) 示例">图4 自治数据流图 (基对象为<i>a</i>) 示例</a></li>
                                                <li><a href="#182" data-title="&lt;b&gt;表4 计算变量使用点索引的数据流转移方程&lt;/b&gt;"><b>表4 计算变量使用点索引的数据流转移方程</b></a></li>
                                                <li><a href="#183" data-title="图5 计算变量使用点索引示例">图5 计算变量使用点索引示例</a></li>
                                                <li><a href="#200" data-title="图6 稀疏的IFDS框架示例">图6 稀疏的IFDS框架示例</a></li>
                                                <li><a href="#204" data-title="图7 基于稀疏的污点分析总体框架">图7 基于稀疏的污点分析总体框架</a></li>
                                                <li><a href="#228" data-title="&lt;b&gt;表5 后向分析中计算变量使用点索引的数据流转移方程&lt;/b&gt;"><b>表5 后向分析中计算变量使用点索引的数据流转移方程</b></a></li>
                                                <li><a href="#233" data-title="图8 FlowDroid的激活点维护示例">图8 FlowDroid的激活点维护示例</a></li>
                                                <li><a href="#240" data-title="图9 FlowDroid的保守子域处理示例">图9 FlowDroid的保守子域处理示例</a></li>
                                                <li><a href="#257" data-title="&lt;b&gt;表6 FlowDroidSP评测数据&lt;/b&gt;"><b>表6 FlowDroidSP评测数据</b></a></li>
                                                <li><a href="#258" data-title="图10 FlowDroid和FlowDroidSP不同模式下的结果对比">图10 FlowDroid和FlowDroidSP不同模式下的结果对比</a></li>
                                                <li><a href="#259" data-title="图11 独立更新计算值占可激活值的比例图">图11 独立更新计算值占可激活值的比例图</a></li>
                                                <li><a href="#262" data-title="图12 具有裁剪标识的数据流占总数比例图">图12 具有裁剪标识的数据流占总数比例图</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="321">


                                    <a id="bibliography_1" title="Zhang Yuqing, Zhou Wei, Peng Anni. Survey of Internet of things security[J]. Journal of Computer Research and Development, 2017, 54 (10) : 2130- 2143 (in Chinese) (张玉清, 周威, 彭安妮. 物联网安全综述[J]. 计算机研究与发展, 2017, 54 (10) : 2130- 2143) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201710003&amp;v=MjgzMzQ5Rlo0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNy9PTHl2U2RMRzRIOWJOcjQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                        Zhang Yuqing, Zhou Wei, Peng Anni. Survey of Internet of things security[J]. Journal of Computer Research and Development, 2017, 54 (10) : 2130- 2143 (in Chinese) (张玉清, 周威, 彭安妮. 物联网安全综述[J]. 计算机研究与发展, 2017, 54 (10) : 2130- 2143) 
                                    </a>
                                </li>
                                <li id="323">


                                    <a id="bibliography_2" title="Livshits V, Lam M. Finding security vulnerabilities in Java applications with static analysis[C] //Proc of the 14th USENIX Security Symposium. Berkeley, CA: USENIX Association, 2006: 262- 266" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Finding security vulnerabilities in Java applications with static analysis">
                                        <b>[2]</b>
                                        Livshits V, Lam M. Finding security vulnerabilities in Java applications with static analysis[C] //Proc of the 14th USENIX Security Symposium. Berkeley, CA: USENIX Association, 2006: 262- 266
                                    </a>
                                </li>
                                <li id="325">


                                    <a id="bibliography_3" title="Sabelfeld A, Myers A C. Language-based information-flow security[J]. IEEE Journal on Selected Areas in Communi-cations, 2003, 21 (1) : 5- 19" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Language-based information-flow security">
                                        <b>[3]</b>
                                        Sabelfeld A, Myers A C. Language-based information-flow security[J]. IEEE Journal on Selected Areas in Communi-cations, 2003, 21 (1) : 5- 19
                                    </a>
                                </li>
                                <li id="327">


                                    <a id="bibliography_4" title="Li Li, Bissyand&#233; T F, Papadakis M, et al. Static analysis of android apps: A systematic literature review[J]. Information &amp;amp; Software Technology, 2017, 88: 67- 95" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJESDA696CBA4A6BE1FDBE45231AA6CD3CBA&amp;v=MDgxNTdGcG1hQnVIWWZPR1FsZkNwYlEzNWRsaHdydTN3SzQ9TmlmT2ZjZkpHTmpLM1AwMFlKb0pmZ2s0dVdKaG56dDRTbnpqM1dNekNzYVhOc2p1Q09OdkZTaVdXcjdKSQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                        Li Li, Bissyand&#233; T F, Papadakis M, et al. Static analysis of android apps: A systematic literature review[J]. Information &amp;amp; Software Technology, 2017, 88: 67- 95
                                    </a>
                                </li>
                                <li id="329">


                                    <a id="bibliography_5" title="Avdiienko V, Kuznetsov K, Gorla A, et al. Mining apps for abnormal usage of sensitive data[C] //Proc of the 37th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 426- 436" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Mining apps for abnormal usage of sensitive data">
                                        <b>[5]</b>
                                        Avdiienko V, Kuznetsov K, Gorla A, et al. Mining apps for abnormal usage of sensitive data[C] //Proc of the 37th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 426- 436
                                    </a>
                                </li>
                                <li id="331">


                                    <a id="bibliography_6" title="Arzt S, Rasthofer S, Fritz C, et al. FlowDroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps[C] //Proc of the 35th ACM SIGPLAN Conf on Programming Language Design and Implementation. New York: ACM, 2014: 259- 269" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Flowdroid:Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for android apps">
                                        <b>[6]</b>
                                        Arzt S, Rasthofer S, Fritz C, et al. FlowDroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps[C] //Proc of the 35th ACM SIGPLAN Conf on Programming Language Design and Implementation. New York: ACM, 2014: 259- 269
                                    </a>
                                </li>
                                <li id="333">


                                    <a id="bibliography_7" title="Lerch J, Hermann B, Bodden E, et al. FlowTwist: Efficient context-sensitive inside-out taint analysis for large codebases[C] //Proc of the 22nd ACM SIGSOFT Int Symp on Foundations of Software Engineering. New York: ACM, 2014: 98- 108" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=FlowTwist: Efficient context-sensitive inside-out taint analysis for large codebases">
                                        <b>[7]</b>
                                        Lerch J, Hermann B, Bodden E, et al. FlowTwist: Efficient context-sensitive inside-out taint analysis for large codebases[C] //Proc of the 22nd ACM SIGSOFT Int Symp on Foundations of Software Engineering. New York: ACM, 2014: 98- 108
                                    </a>
                                </li>
                                <li id="335">


                                    <a id="bibliography_8" title="Mirzaei O, Suarez-Tangil G, Tapiador J, et al. TriFlow: Triaging Android applications using speculative information flows[C] //Proc of the 2017 ACM on Asia Conf on Computer and Communications Security. New York: ACM, 2017: 640- 651" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=TriFlow: Triaging Android applications using speculative information flows">
                                        <b>[8]</b>
                                        Mirzaei O, Suarez-Tangil G, Tapiador J, et al. TriFlow: Triaging Android applications using speculative information flows[C] //Proc of the 2017 ACM on Asia Conf on Computer and Communications Security. New York: ACM, 2017: 640- 651
                                    </a>
                                </li>
                                <li id="337">


                                    <a id="bibliography_9" title="Yang Wei, Xiao Xusheng, Andow B, et al. AppContext: Differentiating malicious and benign mobile app behaviors using context[C] //Proc of the 37th IEEE/ACM Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 303- 313" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=AppContext: Differentiating malicious and benign mobile app behaviors using context">
                                        <b>[9]</b>
                                        Yang Wei, Xiao Xusheng, Andow B, et al. AppContext: Differentiating malicious and benign mobile app behaviors using context[C] //Proc of the 37th IEEE/ACM Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 303- 313
                                    </a>
                                </li>
                                <li id="339">


                                    <a id="bibliography_10" title="Hardekopf B, Lin C. Semi-sparse flow-sensitive pointer analysis[C] //Proc of the 36th ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 2009: 226- 238" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Semi-sparse flow-sensitive pointer analysis">
                                        <b>[10]</b>
                                        Hardekopf B, Lin C. Semi-sparse flow-sensitive pointer analysis[C] //Proc of the 36th ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 2009: 226- 238
                                    </a>
                                </li>
                                <li id="341">


                                    <a id="bibliography_11" title="Hardekopf B. Pointer Analysis: Building a Foundation for Effective Program Analysis[M]. Austin: The University of Texas, 2009" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Pointer Analysis: Building a Foundation for Effective Program Analysis">
                                        <b>[11]</b>
                                        Hardekopf B. Pointer Analysis: Building a Foundation for Effective Program Analysis[M]. Austin: The University of Texas, 2009
                                    </a>
                                </li>
                                <li id="343">


                                    <a id="bibliography_12" title="Hardekopf B, Lin C. Flow-sensitive pointer analysis for millions of lines of code[C] //Proc of the 9th Annual IEEE/ACM Int Symp on Code Generation and Optimization. Piscataway, NJ: IEEE, 2011: 289- 298" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Flow-sensitive Pointer Analysis for Millions of Lines of Code">
                                        <b>[12]</b>
                                        Hardekopf B, Lin C. Flow-sensitive pointer analysis for millions of lines of code[C] //Proc of the 9th Annual IEEE/ACM Int Symp on Code Generation and Optimization. Piscataway, NJ: IEEE, 2011: 289- 298
                                    </a>
                                </li>
                                <li id="345">


                                    <a id="bibliography_13" title="Chung K C A. Points-to analysis with efficient strong updates[C] //Proc of the 38th ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 2011: 3- 16" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Points-to analysis with efficient strong up-dates">
                                        <b>[13]</b>
                                        Chung K C A. Points-to analysis with efficient strong updates[C] //Proc of the 38th ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 2011: 3- 16
                                    </a>
                                </li>
                                <li id="347">


                                    <a id="bibliography_14" title="Li Lian, Cifuentes C, Keynes N. Boosting the performance of flow-sensitive points-to analysis using value flow[C] //Proc of the 6th Joint Meeting of the European Software Engineering Conf and the ACM SIGSOFT Int Symp on Foundations of Software Engineering. New York: ACM, 2011: 343- 353" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Boosting the performance of flow-sensitive points-to analysis using value flow">
                                        <b>[14]</b>
                                        Li Lian, Cifuentes C, Keynes N. Boosting the performance of flow-sensitive points-to analysis using value flow[C] //Proc of the 6th Joint Meeting of the European Software Engineering Conf and the ACM SIGSOFT Int Symp on Foundations of Software Engineering. New York: ACM, 2011: 343- 353
                                    </a>
                                </li>
                                <li id="349">


                                    <a id="bibliography_15" title="Oh H, Heo K, Lee W, et al. Design and implementation of sparse global analyses for C-like languages[J]. ACM SIGPLAN Notices, 2012, 47 (6) : 229- 238" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000010112&amp;v=MDQ5NDZadUh5am1VYjdJSmwwY2FoUT1OaWZJWTdLN0h0ak5yNDlGWk9vUERYMDdvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                        Oh H, Heo K, Lee W, et al. Design and implementation of sparse global analyses for C-like languages[J]. ACM SIGPLAN Notices, 2012, 47 (6) : 229- 238
                                    </a>
                                </li>
                                <li id="351">


                                    <a id="bibliography_16" title="Sui Yulei, Su Yu, Xue Jingling. Region-based selective flow-sensitive pointer analysis[C] //Proc of the 21st Int Static Analysis Symp. Berlin: Springer, 2014: 319- 336" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Region-Based Selective Flow-Sensitive Pointer Analysis">
                                        <b>[16]</b>
                                        Sui Yulei, Su Yu, Xue Jingling. Region-based selective flow-sensitive pointer analysis[C] //Proc of the 21st Int Static Analysis Symp. Berlin: Springer, 2014: 319- 336
                                    </a>
                                </li>
                                <li id="353">


                                    <a id="bibliography_17" title="Yu Hongtao, Xue Jingling, Huo Wei, et al. Level by level: Making flow- and context-sensitive pointer analysis scalable for millions of lines of code[C] //Proc of the 8th Annual IEEE/ACM Int Symp on Code Generation and Optimization. New York: ACM, 2010: 218- 229" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Level by level:Making flow-and context-sensitive pointer analysis scalable for millions of lines of code">
                                        <b>[17]</b>
                                        Yu Hongtao, Xue Jingling, Huo Wei, et al. Level by level: Making flow- and context-sensitive pointer analysis scalable for millions of lines of code[C] //Proc of the 8th Annual IEEE/ACM Int Symp on Code Generation and Optimization. New York: ACM, 2010: 218- 229
                                    </a>
                                </li>
                                <li id="355">


                                    <a id="bibliography_18" title="Sui Yulei, Di Peng, Xue Jingling. Sparse flow-sensitive pointer analysis for multithreaded programs[C] //Proc of the 14th Annual IEEE/ACM Int Symp on Code Generation and Optimization. New York: ACM, 2016: 160- 170" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Sparse flow-sensitive pointer analysis for multithreaded programs">
                                        <b>[18]</b>
                                        Sui Yulei, Di Peng, Xue Jingling. Sparse flow-sensitive pointer analysis for multithreaded programs[C] //Proc of the 14th Annual IEEE/ACM Int Symp on Code Generation and Optimization. New York: ACM, 2016: 160- 170
                                    </a>
                                </li>
                                <li id="357">


                                    <a id="bibliography_19" title="Aho A V, Sethi R, Ullman J D. Compilers, Principles, Techniques[M]. New York: Addison Wesley, 1986" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Compilers: Principles, Techniques, and Tools">
                                        <b>[19]</b>
                                        Aho A V, Sethi R, Ullman J D. Compilers, Principles, Techniques[M]. New York: Addison Wesley, 1986
                                    </a>
                                </li>
                                <li id="359">


                                    <a id="bibliography_20" title="Reps T, Horwitz S, Sagiv M. Precise interprocedural dataflow analysis via graph reachability[C] //Proc of the 23rd ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 1994: 49- 61" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Precise interprocedural dataflow analysis via graph reachability">
                                        <b>[20]</b>
                                        Reps T, Horwitz S, Sagiv M. Precise interprocedural dataflow analysis via graph reachability[C] //Proc of the 23rd ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 1994: 49- 61
                                    </a>
                                </li>
                                <li id="361">


                                    <a id="bibliography_21" title="Maluszyski J. Program analysis via graph reachability[C] //Proc of the 14th Int Symp on Logic Programming. Cambridge: MIT Press, 1998: 5- 19" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Program analysis via graph reachability">
                                        <b>[21]</b>
                                        Maluszyski J. Program analysis via graph reachability[C] //Proc of the 14th Int Symp on Logic Programming. Cambridge: MIT Press, 1998: 5- 19
                                    </a>
                                </li>
                                <li id="363">


                                    <a id="bibliography_22" title="Lam P, Bodden E, Lhot&#225;k O, et al. The Soot framework for Java program analysis: A retrospective[C] //Proc of Cetus Users and Compiler Infrastructure Workshop. New York: ACM, 2011" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The Soot framework for Java program analysis:A retrospective">
                                        <b>[22]</b>
                                        Lam P, Bodden E, Lhot&#225;k O, et al. The Soot framework for Java program analysis: A retrospective[C] //Proc of Cetus Users and Compiler Infrastructure Workshop. New York: ACM, 2011
                                    </a>
                                </li>
                                <li id="365">


                                    <a id="bibliography_23" >
                                        <b>[23]</b>
                                    Litianwuxian Network Technology Co., Ltd. Anzhi App Store[OL].[2017-10-01]. http://www.anzhi.com/applist.html (in Chinese) (北京力天无限网络技术有限公司. 安智网应用市场[OL].[2017-10-01]. http://www.anzhi.com/applist.html) </a>
                                </li>
                                <li id="367">


                                    <a id="bibliography_24" title="Naeem N A, Lhot&#225;k O, Rodriguez J. Practical extensions to the IFDS algorithm[C] //Proc of the 19th Annual Int Conf on Compiler Construction. Berlin: Springer, 2010: 124- 144" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Practical extensions to the ifds algorithm">
                                        <b>[24]</b>
                                        Naeem N A, Lhot&#225;k O, Rodriguez J. Practical extensions to the IFDS algorithm[C] //Proc of the 19th Annual Int Conf on Compiler Construction. Berlin: Springer, 2010: 124- 144
                                    </a>
                                </li>
                                <li id="369">


                                    <a id="bibliography_25" title="Bodden E. Inter-procedural data-flow analysis with IFDS/IDE and Soot[C] //Proc of the ACM SIGPLAN Int Workshop on State of the Art in Java Program analysis. New York: ACM, 2012: 3- 8" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Inter-procedural data-flow analysis with ifds/ide and soot">
                                        <b>[25]</b>
                                        Bodden E. Inter-procedural data-flow analysis with IFDS/IDE and Soot[C] //Proc of the ACM SIGPLAN Int Workshop on State of the Art in Java Program analysis. New York: ACM, 2012: 3- 8
                                    </a>
                                </li>
                                <li id="371">


                                    <a id="bibliography_26" title="Arzt S, Rasthofer S, Bodden E. The soot-based toolchain for analyzing android apps[C] //Proc of the 4th Int Conf on Mobile Software Engineering and Systems. Piscataway, NJ: IEEE, 2017: 13- 24" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The soot-based toolchain for analyzing Android apps">
                                        <b>[26]</b>
                                        Arzt S, Rasthofer S, Bodden E. The soot-based toolchain for analyzing android apps[C] //Proc of the 4th Int Conf on Mobile Software Engineering and Systems. Piscataway, NJ: IEEE, 2017: 13- 24
                                    </a>
                                </li>
                                <li id="373">


                                    <a id="bibliography_27" title="Rasthofer S, Arzt S, Bodden E. A Machine-learning approach for classifying and categorizing Android sources and sinks[C/OL] //Proc of the 21st Annual Network and Distributed System Security Symp. 2014 [2017-09-01]. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.432.7534" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A Machine-learning approach for classifying and categorizing Android sources and sinks[C/OL]">
                                        <b>[27]</b>
                                        Rasthofer S, Arzt S, Bodden E. A Machine-learning approach for classifying and categorizing Android sources and sinks[C/OL] //Proc of the 21st Annual Network and Distributed System Security Symp. 2014 [2017-09-01]. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.432.7534
                                    </a>
                                </li>
                                <li id="375">


                                    <a id="bibliography_28" title="Li Li, Bartel A, Klein J, et al. IccTA: Detecting inter-component privacy leaks in Android apps[C] //Proc of the 37th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 280- 291" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Iccta:Detecting inter-component privacy leaks in android apps">
                                        <b>[28]</b>
                                        Li Li, Bartel A, Klein J, et al. IccTA: Detecting inter-component privacy leaks in Android apps[C] //Proc of the 37th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 280- 291
                                    </a>
                                </li>
                                <li id="377">


                                    <a id="bibliography_29" title="Arzt S, Bodden E. StubDroid: Automatic inference of precise data-flow summaries for the android framework[C] //Proc of the 38th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2016: 725- 735" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=StubDroid: Automatic inference of precise data-flow summaries for the android framework">
                                        <b>[29]</b>
                                        Arzt S, Bodden E. StubDroid: Automatic inference of precise data-flow summaries for the android framework[C] //Proc of the 38th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2016: 725- 735
                                    </a>
                                </li>
                                <li id="379">


                                    <a id="bibliography_30" title="Rasthofer S, Arzt S, Miltenberger M, et al. Harvesting runtime values in Android applications that feature anti-analysis techniques[C/OL] //Proc of the 23rd Annual Network and Distributed System Security Symp. 2016 [2017-09-01]. http://www.bodden.de/pubs/ssme16harvesting.pdf" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Harvesting runtime values in Android applications that feature anti-analysis techniques[C/OL]">
                                        <b>[30]</b>
                                        Rasthofer S, Arzt S, Miltenberger M, et al. Harvesting runtime values in Android applications that feature anti-analysis techniques[C/OL] //Proc of the 23rd Annual Network and Distributed System Security Symp. 2016 [2017-09-01]. http://www.bodden.de/pubs/ssme16harvesting.pdf
                                    </a>
                                </li>
                                <li id="381">


                                    <a id="bibliography_31" title="Tripp O, Pistoia M, Cousot P, et al. Andromeda: Accurate and scalable security analysis of web applications[C] / /Proc of the 2013 Int Conf on Fundamental Approaches to Software Engineering. Berlin: Springer, 2013: 210- 225" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=ANDROMEDA:accurate and scalable security analysis of Web applications">
                                        <b>[31]</b>
                                        Tripp O, Pistoia M, Cousot P, et al. Andromeda: Accurate and scalable security analysis of web applications[C] / /Proc of the 2013 Int Conf on Fundamental Approaches to Software Engineering. Berlin: Springer, 2013: 210- 225
                                    </a>
                                </li>
                                <li id="383">


                                    <a id="bibliography_32" title="Sridharan M, Gopan D, Shan L. Demand-driven points-to analysis for Java[J]. ACM SIGPLAN Notices, 2005, 40 (10) : 59- 76" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000081354&amp;v=Mjg2MzU3SHRqTnI0OUZaT01PRDNrOW9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVWI3SUpsMGNhaFE9TmlmSVk3Sw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[32]</b>
                                        Sridharan M, Gopan D, Shan L. Demand-driven points-to analysis for Java[J]. ACM SIGPLAN Notices, 2005, 40 (10) : 59- 76
                                    </a>
                                </li>
                                <li id="385">


                                    <a id="bibliography_33" title="Sridharan M. Refinement-based context-sensitive points-to analysis for Java[J]. ACM SIGPLAN Notices, 2006, 41 (6) : 387- 400" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000081460&amp;v=MDQ1MzBxUVRNbndaZVp1SHlqbVViN0lKbDBjYWhRPU5pZklZN0s3SHRqTnI0OUZaT01PQ0hvNW9CTVQ2VDRQUUgvaXJSZEdlcg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[33]</b>
                                        Sridharan M. Refinement-based context-sensitive points-to analysis for Java[J]. ACM SIGPLAN Notices, 2006, 41 (6) : 387- 400
                                    </a>
                                </li>
                                <li id="387">


                                    <a id="bibliography_34" title="Sp&#228;th J, Do LN, Ali K, Bodden E. Boomerang: Demand-driven flow-and context-sensitive pointer analysis forJava[C] //Proc of the 30th European Conf on Object-Oriented Programming. Dagstuhl: Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2016: 22- 26" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Boomerang: Demand-driven flow-and context-sensitive pointer analysis forJava">
                                        <b>[34]</b>
                                        Sp&#228;th J, Do LN, Ali K, Bodden E. Boomerang: Demand-driven flow-and context-sensitive pointer analysis forJava[C] //Proc of the 30th European Conf on Object-Oriented Programming. Dagstuhl: Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2016: 22- 26
                                    </a>
                                </li>
                                <li id="389">


                                    <a id="bibliography_35" title="Crandall J R, Chong F T. Minos: Control data attack prevention orthogonal to memory model[C] //Proc of the 37th Annual IEEE/ACM Int Symp on Microarchitecture. New York: ACM, 2004: 221- 232" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Minos: Control Data Attack Prevention Orthogonal to Memory Model">
                                        <b>[35]</b>
                                        Crandall J R, Chong F T. Minos: Control data attack prevention orthogonal to memory model[C] //Proc of the 37th Annual IEEE/ACM Int Symp on Microarchitecture. New York: ACM, 2004: 221- 232
                                    </a>
                                </li>
                                <li id="391">


                                    <a id="bibliography_36" title="Tripp O, Pistoia M, Fink S J, et al. TAJ: Effective taint analysis of web applications[C] //Proc of the 30th ACM SIGPLAN Conf on Programming Language Design and Implementation. New York: ACM, 2009: 87- 97" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Taj: effective taint analysis of web applications">
                                        <b>[36]</b>
                                        Tripp O, Pistoia M, Fink S J, et al. TAJ: Effective taint analysis of web applications[C] //Proc of the 30th ACM SIGPLAN Conf on Programming Language Design and Implementation. New York: ACM, 2009: 87- 97
                                    </a>
                                </li>
                                <li id="393">


                                    <a id="bibliography_37" title="Enck W, Gilbert P, Chun B G, et al. TaintDroid: An information flow tracking system for real-time privacy monitoring on smartphones[J]. ACM Transactions on Computer Systems, 2010, 32 (2) : 1- 29" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM14090900001091&amp;v=MTI2MDlUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VYjdJSmwwY2FoUT1OaWZJWTdLOEh0ak1wbzlGWk9zT0RIVTRvQk1UNg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[37]</b>
                                        Enck W, Gilbert P, Chun B G, et al. TaintDroid: An information flow tracking system for real-time privacy monitoring on smartphones[J]. ACM Transactions on Computer Systems, 2010, 32 (2) : 1- 29
                                    </a>
                                </li>
                                <li id="395">


                                    <a id="bibliography_38" title="Lu Long, Li Zhichun, Wu Zhenyu, et al. CHEX: Statically vetting Android apps for component hijacking vulnerabilities[C] //Proc of the 19th ACM Conf on Computer and Communications Security. New York: ACM, 2012: 229- 240" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Chex:statically vetting android apps for component hijacking vulnerabilities">
                                        <b>[38]</b>
                                        Lu Long, Li Zhichun, Wu Zhenyu, et al. CHEX: Statically vetting Android apps for component hijacking vulnerabilities[C] //Proc of the 19th ACM Conf on Computer and Communications Security. New York: ACM, 2012: 229- 240
                                    </a>
                                </li>
                                <li id="397">


                                    <a id="bibliography_39" title="Gordon M I, Kim D, Perkins J, et al. Information-flow analysis of Android applications in DroidSafe[C/OL] //Proc of the 22nd Annual Network and Distributed System Security Symp. 2015 [2017-09-01]. https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/information-flow-analysis-android-applications-droidsafe" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Information Flow Analysis of Android Applications in DroidSafe">
                                        <b>[39]</b>
                                        Gordon M I, Kim D, Perkins J, et al. Information-flow analysis of Android applications in DroidSafe[C/OL] //Proc of the 22nd Annual Network and Distributed System Security Symp. 2015 [2017-09-01]. https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/information-flow-analysis-android-applications-droidsafe
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(03),480-495 DOI:10.7544/issn1000-1239.2019.20180071            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于稀疏框架的静态污点分析优化技术</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="javascript:;">王蕾</a>
                                <a href="javascript:;">何冬杰</a>
                                <a href="javascript:;">李炼</a>
                                <a href="javascript:;">冯晓兵</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4(%E4%B8%AD%E5%9B%BD%E7%A7%91%E5%AD%A6%E9%99%A2%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E6%89%80)&amp;code=0142480&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">计算机体系结构国家重点实验室(中国科学院计算技术研究所)</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%AD%E5%9B%BD%E7%A7%91%E5%AD%A6%E9%99%A2%E5%A4%A7%E5%AD%A6&amp;code=1698842&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">中国科学院大学</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>当前, 隐私数据保护是信息系统安全的重要研究挑战, 对应用程序进行隐私泄露检测是隐私泄露保护的有效方案.污点分析技术可以有效地对应用程序进行保密性和完整性的安全检测, 提前报告出潜在的隐私泄露风险.然而, 当前高敏感度的静态污点分析还存在开销过高的问题.通过对目前主流的污点分析工具FlowDroid进行深入分析, 发现其污点分析计算中大量无关联污点传播是导致开销过高的重要原因, 统计实验表明无关联传播占比高达85.2%.针对这一问题, 尝试利用近年来一种有效的程序分析优化手段——稀疏优化——的方法, 对静态污点分析中无关联的传播进行消除, 达到时间和空间的开销优化.创新地将经典的数据流分析框架扩展成稀疏的形式, 在此基础上提供了基于稀疏优化的污点分析方法.最后实现了工具FlowDroidSP, 实验表明:FlowDroidSP在非剪枝模式下相比原FlowDroid具有平均4.8倍的时间加速和61.5%的内存降低.在剪枝模式下, 具有平均18.1倍的时间加速和76.1%的内存降低.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%9A%90%E7%A7%81%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">隐私泄露检测;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">静态程序分析;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">污点分析;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">程序优化;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%AE%89%E5%8D%93&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">安卓;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    王蕾, wanglei2011@ict.ac.cn;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-01-31</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目 (61521092, 61432016);</span>
                                <span>国家重点研发计划项目 (2017YFB0202002);</span>
                    </p>
            </div>
                    <h1><b>Sparse Framework Based Static Taint Analysis Optimization</b></h1>
                    <h2>
                    <span>Wang Lei</span>
                    <span>He Dongjie</span>
                    <span>Li Lian</span>
                    <span>Feng Xiaobing</span>
            </h2>
                                    <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>At present, privacy preserving is an important research challenge of information system security. Privacy leak detection for applications is an effective solution for privacy preserving. Taint analysis can effectively protect the confidentiality and integrity of information in the system, and report the privacy leak risk of applications in advance. However, the existing static taint analysis tool still has the problem of high analysis overhead especially in high sensitive mode. This work first deeply analyzes that there exists a large number of unrelated propagation which leads to unnecessary expenses in current IFDS-based taint analysis, and statistical results show that the proportion of it is up to 85.5%. Aiming at this problem, this paper attempts to use an effective optimization method, sparse optimization in recent years, to eliminate the unrelated propagation in static taint analysis, and achieve the optimization of time and space cost. We have innovatively extended the classic data flow analysis framework (IFDS) into a sparse form, and provide a corresponding taint analysis algorithm. We implemented a tool called FlowDroidSP. Experimental results show that the tool has 4.8 times of time acceleration and 61.5% memory reduction compared with the original FlowDroid under the non-pruning mode. Under pruning mode, it has an average time of 18.1 times speedup and 76.1% memory reduction.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=privacy%20leakage%20detection&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">privacy leakage detection;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=static%20program%20analysis&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">static program analysis;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=taint%20analysis&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">taint analysis;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=program%20optimization&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">program optimization;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Android&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Android;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Wang Lei, born in 1989.PhD.His main research interests include program analysis, Android security.<image id="315" type="formula" href="images/JFYZ201903003_31500.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    He Dongjie, born in 1992.Master.His main research interests include program analysis, Android security.<image id="316" type="formula" href="images/JFYZ201903003_31600.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Li Lian, born in 1977.PhD, professor.PhD supervisor at the Institute of Computing Technology, Chinese Academy of Sciences.Member of CCF.His main research interests include program analysis, compiler, software security.<image id="318" type="formula" href="images/JFYZ201903003_31800.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Feng Xiaobing, born in 1969.PhD.Professor and PhD supervisor at the Institute of Computing Technology, Chinese Academy of Sciences.Member of CCF.His main research interests include compiler optimization, binary translation.<image id="320" type="formula" href="images/JFYZ201903003_32000.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2018-01-31</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Natural Science Foundation of China (61521092, 61432016);</span>
                                <span>the National Key Research and Development Program of China (2017YFB0202002);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="85">当前, 隐私数据保护是信息系统安全的重要研究挑战之一, 大量的互联网 (电子邮件、社交网络) 、移动应用 (移动支付、手机定位) 、物联网 (智能家居、智能医疗等) 相关数据需要存放在应用端, 如果应用程序因存在漏洞而被攻击者利用 (完整性违反) 或者第三方应用程序有意地窃取用户系统中本地的数据 (保密性违反) , 则会产生隐私泄露问题<citation id="399" type="reference"><link href="321" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>.对系统应用中潜在的隐私数据泄露风险检测是当前该领域的重要研究方向.污点分析技术<citation id="400" type="reference"><link href="323" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation> (taint analysis) 是信息流分析技术<citation id="401" type="reference"><link href="325" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation> (information-flow analysis) 的一种实践方法.该技术通过对系统中敏感数据进行标记, 继而跟踪标记数据在程序中的传播, 检测系统的保密性和完整性等安全问题.据调查分析<citation id="402" type="reference"><link href="327" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>, 在Android应用的静态安全检测中, 污点分析是最为流行的分析方案.</p>
                </div>
                <div class="p1">
                    <p id="86">污点分析又被分为静态污点分析和动态污点分析.静态污点分析是指在不运行代码的前提下通过分析程序变量间的数据依赖关系来进行污点分析.相比动态运行的污点分析, 静态污点分析无需对程序进行插桩而导致运行时出现额外开销, 并且不依赖于测试用例输入, 可以在程序发布之前对应用程序进行检测, 避免发布之后造成的安全问题.然而, 当前静态污点分析技术的分析性能仍然不能满足安全检测的需求.例如, MudFlow<citation id="403" type="reference"><link href="329" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>尝试使用静态污点分析工具FlowDroid<citation id="404" type="reference"><link href="331" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>对当前Android应用市场的应用进行安全漏洞检测, 它只能使用低敏感度的程序分析且在运行内存较大 (730 GB) 的环境下, 一些例子仍然出现检测超时.并且, 低敏感度的程序分析会报告出大量的误报, 这会给检测人员带来诸多不便, 同样降低了检测的效率, 类似的问题还存在其他工作中<citation id="405" type="reference"><link href="333" rel="bibliography" /><link href="335" rel="bibliography" /><link href="337" rel="bibliography" /><sup>[<a class="sup">7</a>,<a class="sup">8</a>,<a class="sup">9</a>]</sup></citation>.因此, 对高敏感度的静态污点分析进行空间和时间上的优化是一个值得研究的问题.</p>
                </div>
                <div class="p1">
                    <p id="87">最近, 在程序分析领域中, 大量的研究工作<citation id="407" type="reference"><link href="339" rel="bibliography" /><link href="341" rel="bibliography" /><link href="343" rel="bibliography" /><link href="345" rel="bibliography" /><link href="347" rel="bibliography" /><link href="349" rel="bibliography" /><link href="351" rel="bibliography" /><link href="353" rel="bibliography" /><link href="355" rel="bibliography" /><sup>[<a class="sup">10</a>,<a class="sup">11</a>,<a class="sup">12</a>,<a class="sup">13</a>,<a class="sup">14</a>,<a class="sup">15</a>,<a class="sup">16</a>,<a class="sup">17</a>,<a class="sup">18</a>]</sup></citation>尝试使用稀疏的方式对静态程序分析问题进行效率优化.所谓的稀疏程序优化是指数据流值 (data flow fact) 不再沿着控制流图 (control flow graph, CFG) 上进行传递, 而转移到利用DEF-USE链得到的相关数据结构上传递.例如文献<citation id="406" type="reference">[<a class="sup">10</a>]</citation>利用了半稀疏 (semi-sparse) 的方法对指针分析进行优化, 将指针数据流值从CFG上的传播转移到数据流图中进行传播.使用DEF-USE链代替CFG来传递数据流值可以消除不必要的传播计算从而达到优化的目的.</p>
                </div>
                <div class="p1">
                    <p id="88">由于污点分析只是分析污点能否从污点源 (source) 传播到汇聚点 (sink) , 是一种按需的分析方式, 当前的主流静态污点分析 (FlowDroid) 是基于IFDS框架的, 而目前的IFDS框架是没有对稀疏优化进行支持的.因此, 本文的工作内容正是尝试利用稀疏的优化方法对静态污点分析进行优化.</p>
                </div>
                <div class="p1">
                    <p id="89">本文的主要贡献包含4个方面:</p>
                </div>
                <div class="p1">
                    <p id="90">1) 发现并分析当前基于IFDS (interprocedural, finite, distributive, subset) 问题的静态污点工具FlowDroid计算中存在大量无关联传播, 并通过实验验证其比例平均高达85.2%.</p>
                </div>
                <div class="p1">
                    <p id="91">2) 为了支持稀疏的污点传播, 提出了一种稀疏的IFDS数据流分析框架, 提供面向流敏感和域敏感的变量使用点索引的计算方法.</p>
                </div>
                <div class="p1">
                    <p id="92">3) 设计了基于稀疏数据流分析框架的污点分析技术.</p>
                </div>
                <div class="p1">
                    <p id="93">4) 实现一个基于本文技术的原型系统Flow-DroidSP, 经过实验验证, 该工具在提升性能的同时没有带来精度上的损失.在非剪枝模式下, 相比原FlowDroid具有平均4.8倍的时间加速和61.5%的内存降低, 在剪枝模式下, 具有平均18.1倍的时间加速和76.1%的内存降低.</p>
                </div>
                <h3 id="94" name="94" class="anchor-tag"><b>1 背景知识</b></h3>
                <h4 class="anchor-tag" id="95" name="95"><b>1.1 IFDS数据流分析框架</b></h4>
                <div class="p1">
                    <p id="96">一般而言, 静态污点分析问题都是被转化为数据流分析问题<citation id="408" type="reference"><link href="357" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>进行求解:首先为每一个过程构建控制流图或者过程间的控制流图, 然后根据不同敏感度 (上下文敏感、流敏感等) 进行具体的数据流传播分析 (与指针/别名分析) .IFDS框架<citation id="409" type="reference"><link href="359" rel="bibliography" /><sup>[<a class="sup">20</a>]</sup></citation>是一个精确高效的上下文敏感和流敏感的数据流分析框架, 其全称是过程间 (interprocedural) 、有限的 (finite) 、满足分配率的 (distributive) 、子集合 (subset) 问题.该问题作用在有限的数据流域中且数据值对并 (或交) 的集合操作满足分配率.满足上述限定的问题都可以利用IFDS算法进行求解 (文献<citation id="410" type="reference">[<a class="sup">20</a>]</citation>中的Tabulation算法) , 而污点分析正是满足IFDS算法要求的一个问题.污点分析的数据流值是污点变量, 它表示有哪些污点变量可以到达当前程序点.</p>
                </div>
                <div class="p1">
                    <p id="97">IFDS问题求解算法的核心思想就是将程序分析问题转化为图可达问题<citation id="411" type="reference"><link href="361" rel="bibliography" /><sup>[<a class="sup">21</a>]</sup></citation>.算法的分析过程在一个按照具体问题所构造的超图 (exploded supergraph) 上进行 (如图1例子所示) .其中数据流值可以被表示成图中的节点, 算法扩展了一个特殊数据流值:0值, 用于表示空集合;程序分析中转移函数的计算, 即对数据流值的传递计算被转化为图中的边的求解.为了更好地进行描述, 算法根据程序的特性将分析分解成4种转移函数 (边) :1) Call-Flow, 即求解函数调用 (参数映射) 的转移函数.2) Return-Flow, 即求解函数返回语句返回值到调用点的转移函数.3) CallToReturn-Flow, 即函数调用到函数返回的转移函数.4) Normal-Flow, 是指除了上述3种函数处理范围之外的语句的转移函数.IFDS求解算法Tabulation是一种动态规划的算法, 即求解过的子问题的路径可以被重复地利用, 而由于其数据流值满足分配率, 因此可以在分支或函数调用将边进行合并.求解算法包括了2类路径的计算:路径边集 (path edges) 和摘要边集 (summary edges) .路径边集表示的是起点0值到当前计算点的可达路径, 使用传播函数propagate将计算完成的边继续沿CFG传播到其下一个节点;摘要边集表示的是函数调用到函数返回的边, 其主要特点是如果在不同调用点再次遇到同样的函数调用, 可以直接利用其摘要边集信息从而避免了函数内重复的路径边集的计算.</p>
                </div>
                <div class="area_img" id="98">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 使用IFDS算法求解污点分析示例" src="Detail/GetImg?filename=images/JFYZ201903003_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 使用IFDS算法求解污点分析示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 An example of taint analysis by using IFDS algorithm</p>

                </div>
                <h4 class="anchor-tag" id="99" name="99"><b>1.2 FlowDroid与别名分析</b></h4>
                <div class="p1">
                    <p id="100">FlowDroid<citation id="412" type="reference"><link href="331" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>是当前最为流行的面向Java, Android应用程序的开源静态污点分析工具, 被广泛应用于Android App的隐私泄露检测和Java程序相关安全漏洞挖掘.FlowDroid基于Java分析工具Soot<citation id="413" type="reference"><link href="363" rel="bibliography" /><sup>[<a class="sup">22</a>]</sup></citation>, 将待分析程序字节码转化成Soot中间表示Jimple, 随后在Jimple上进行静态的污点分析.其分析的结果是多个污点源到污点汇聚点 (source→sink) 的集合.在污点传播分析中, FlowDroid正是基于IFDS数据流分析框架.同时, FlowDroid使用访问路径 (access path, 即形如<i>v</i>.<i>f</i>.<i>g</i>) 来支持域敏感, 如果访问路径长度超过预定值时, FlowDroid将对其进行保守的裁剪 (例如裁剪成<i>v</i>.<i>f</i>.*的形式) , 在具体实现中访问路径的长度一般设置为5.因此, FlowDroid具有流敏感、上下文敏感、域敏感的高精确度.</p>
                </div>
                <div class="p1">
                    <p id="101">FlowDroid的另一贡献就是提供了一种按需的面向别名的污点传播方法, 该方法同样是基于IFDS框架的.具体来讲, FlowDroid在遇到一个堆变量 (heap object) 的域进行污点赋值时, 会启动一个后向的IFDS求解器求解其别名相关的污点值, 如果生成与该变量别名的污点变量, 则又启动一个前向的IFDS求解器进行前向传播该值.以图2中的伪代码为例, 程序的行④污点源 (函数<i>source</i> () 的返回值) 赋值到了一个堆对象的域<i>a</i>.<i>f</i>中, 此时将启动一个后向的分析来寻找与<i>a</i>.<i>f</i>别名的污点值 (过程1) , 当后向求解器分析到<i>a</i>使用点行②时, 将产生与<i>a</i>别名的对象<i>b</i>的对应污点值, 即<i>b</i>.<i>f</i> (过程2) , 同时启动一个前向分析, 继续找<i>b</i>.<i>f</i>的使用位置 (过程3) .同理, 过程4/5/6/7是对<i>b</i>.<i>f</i>和<i>c</i>.<i>f</i>的进一步传播.为了解决流敏感的分析, FlowDroid引入激活点的概念, 激活点的作用是保证未被激活的变量只有通过了激活点之后才是一个真正的污点值, 否则即便到达泄露点也不会触发泄露.例如在过程6中的<i>c</i>.<i>f</i>变量只有再次经过了行④的激活点到达行⑤触发了<i>sink</i>, 才是一个真正的泄露.而对于过程3中的<i>b</i>.<i>f</i>, 虽然也到达了函数<i>sink</i>, 但是它没有经过激活点, 因此行③的<i>sink</i>不能被触发.</p>
                </div>
                <div class="area_img" id="102">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_102.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 FlowDroid方式的别名间污点传播示例" src="Detail/GetImg?filename=images/JFYZ201903003_102.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 FlowDroid方式的别名间污点传播示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_102.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 An example of FlowDroid-style alias based taint analysis</p>

                </div>
                <div class="p1">
                    <p id="103">本文的工作正是基于FlowDroid进行扩展优化的, 目前FlowDroid中污点传播所使用的数据流分析无论是前向求解还是后向求解 (计算别名) 都是基于IFDS框架的.IFDS框架的计算规模直接影响了污点分析的开销.然而, 当前IFDS框架仍然是基于CFG或过程间CFG的, 这会导致数据流分析中存在无关联的传播.所谓的无关联传播是指数据流值传播到某语句, 但是该语句不会利用其生成其他数据流值或将其杀死, 例如图1中变量<i>a</i>在行①被使用之后还会继续传递到行②～④直到程序结束, 而行③～④中没有使用<i>a</i>产生其他数据流值, <i>a</i>在行③～④上的传播正是无关联传播.因此本文的目标正是利用稀疏的优化方法来消除这种无关联的传播, 从而达到效率优化的目的.</p>
                </div>
                <h3 id="104" name="104" class="anchor-tag"><b>2 研究动机</b></h3>
                <div class="p1">
                    <p id="105">在面向高精确 (流敏感和域敏感) 的污点分析的计算中, 无关联的数据流传播还将被扩大, 进而产生更大的性能开销.具体来讲:</p>
                </div>
                <div class="p1">
                    <p id="106">1) 现代编译器利用中间表示对程序进行分析或者优化, 基于3地址的中间表示被各大编译器采用 (如Soot的Jimple表示) .例如图3 (a) 程序为一段程序的源码, 图3 (b) 程序是其3地址表示, 这种转换过程必然会引入大量的临时变量, 对于行②中的<i>b</i>.<i>f</i>.<i>h</i>=<i>a</i>.<i>f</i>语句将被转化为程序图3 (b) 中的行②～④的程序, 其中利用了2个临时变量<i>tmp</i>1, <i>tmp</i>2.这种临时变量的使用会增加无关联传播的规模.</p>
                </div>
                <div class="area_img" id="107">
                                    <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_10700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <img alt="" src="Detail/GetImg?filename=images/JFYZ201903003_10700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                    </a>

                </div>
                <div class="area_img" id="108">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 无关联污点传播示例" src="Detail/GetImg?filename=images/JFYZ201903003_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 无关联污点传播示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 An example of unrelated taint propagation</p>

                </div>
                <div class="p1">
                    <p id="109">2) 为了支持域敏感的分析, FlowDroid使用访问路径来表示污点变量, 由于相同对象的不同域需要不同的区分, 这会导致同一份代码因不同域的使用而被执行多次、无关联传播将会被放大.例如, 图3 (c) 和图3 (d) 中程序都调用了函数<i>foo</i> () , 但是它们所传递的参数对应的域是不同的, 分别是<i>x</i>.<i>f</i>1和<i>x</i>.<i>f</i>2.对于同一个对象但访问不同参数的情况, IFDS认为它们是不同的变量而不会对其进行摘要优化.此时, 参数<i>p</i>.<i>f</i>1传递到<i>tmp</i>2.<i>h</i>等过程产生的变量, 如<i>tmp</i>1.<i>f</i>.<i>f</i>1和<i>tmp</i>2.<i>h</i>.<i>f</i>1等, 那么对于<i>p</i>.<i>f</i>2的计算, 也同样需要再次生成, 如变量<i>tmp</i>1.<i>f</i>.<i>f</i>2和<i>tmp</i>2.<i>h</i>.<i>f</i>2等, 可见无关联传播增加了1倍.</p>
                </div>
                <div class="p1">
                    <p id="110">3) 为了支持流敏感, FlowDroid使用了激活点的方法, 每一个未被激活的数据流都会存在一个激活点, 即使数据流值中的访问路径相同但因激活点不同, 数据流值仍然是不同的, 同理2) 这也同样导致摘要优化失效.不同激活点的数据流值通过相同的代码片段将会导致这种无关联传播的增加.</p>
                </div>
                <div class="p1">
                    <p id="111">为了验证上述无关联传播确实存在, 以及计算其规模和所占比例, 我们针对FlowDroid进行实验验证.</p>
                </div>
                <div class="p1">
                    <p id="112">具体的评测对象是最新版本的FlowDroid (2017年11月) , 针对其IFDS计算边进行插桩统计, 统计的规则有3项:</p>
                </div>
                <div class="p1">
                    <p id="113">1) 对于Normal Flow和CallToReturn Flow, 通过该函数生成了其他值或者被杀死, 那么置为有关联的, 否则视为无关联传播.</p>
                </div>
                <div class="p1">
                    <p id="114">2) 对于Call Flow, 如果存在被调用函数 (callee) 且当前数据流值可以通过被调用函数生成相关形参, 那么这个变量是有关联的传播.</p>
                </div>
                <div class="p1">
                    <p id="115">3) 对于Return Flow, 如果数据流值可以通过退出语句生成调用者 (caller) 的相关返回值, 那么将设置其为有关联的传播.</p>
                </div>
                <div class="p1">
                    <p id="116">评测的实验机器配置是:64核Intel<sup>®</sup> Xeon<sup>®</sup> CPU E7-4809 (2.0 GHz) 和128 GB RAM, 为每一个Java虚拟机分配32 GB的内存.配置选项选择打开流敏感性并且设置访问路径的长度为5.具体的评测用例是在安智网<citation id="414" type="reference"><link href="365" rel="bibliography" /><sup>[<a class="sup">23</a>]</sup></citation>随机下载的25个Android应用程序.由于某些软件是不存在恶意行为的且对计算规模较小的程序评测没有意义, 这里去除掉了没有产生泄露结果或分析结果过快 (小于10 s) 的6个应用和3个运行超出内存的应用, 最终评测用例集合包含16个应用程序, 它们的基本信息如表1所示, 本文后续评测用例所用标号是与该表标号一一对应的.随后使用FlowDroid对其运行3次检测, 提取结果并求平均值, 其最终的统计运行结果如表2所示.</p>
                </div>
                <div class="area_img" id="117">
                    <p class="img_tit"><b>表1 评测用例基本信息</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 1 The Information of Evaluation Dataset</b></p>
                    <p class="img_note"></p>
                    <table id="117" border="1"><tr><td><br />No.</td><td>Application Name</td><td>Version</td><td>App Size/MB</td></tr><tr><td><br />1</td><td>Alarm/Clock</td><td>5.3.7</td><td>2.3</td></tr><tr><td><br />2</td><td>NingBoBus</td><td>1.0.1</td><td>3.8</td></tr><tr><td><br />3</td><td>Voicechanger</td><td>9.8.0</td><td>8.5</td></tr><tr><td><br />4</td><td>WeiboContact</td><td>2.0.2</td><td>5.4</td></tr><tr><td><br />5</td><td>RootVerifier</td><td>1.0</td><td>0.2</td></tr><tr><td><br />6</td><td>APVPDFViewer</td><td>0.4.7</td><td>3.3</td></tr><tr><td><br />7</td><td>Dingshidaren</td><td>2.1.1</td><td>1.7</td></tr><tr><td><br />8</td><td>LCDDisplay</td><td>1.0</td><td>5.5</td></tr><tr><td><br />9</td><td>FeeQuery</td><td>1.0</td><td>0.7</td></tr><tr><td><br />10</td><td>HuozhongContacts</td><td>3.0.0</td><td>1.5</td></tr><tr><td><br />11</td><td>MyAccount</td><td>0.8.7</td><td>1.5</td></tr><tr><td><br />12</td><td>SuningLottery</td><td>1.9.0</td><td>2</td></tr><tr><td><br />13</td><td>YoushengAlbum</td><td>1.0</td><td>5.7</td></tr><tr><td><br />14</td><td>iWencai</td><td>2.42.01</td><td>4.1</td></tr><tr><td><br />15</td><td>Gushiheima</td><td>2.2</td><td>1.5</td></tr><tr><td><br />16</td><td>Caike</td><td>2.0.23</td><td>4</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="118">表2中第2列 (Running Time) 和第3列 (Memory Size) 是程序的运行时间和内存开销.其中编号11的程序, 尽管程序的规模只有1.5 MB, 但是程序运行时间却长达1 922 s, 这正是由于流敏感和上下文敏感的较高时间复杂度导致的.第5列 (#IFDS) 是总的IFDS计算边个数, 而第6列是无关联的IFDS计算边 (#UR-IFDS) 个数, 其中总IFDS计算边个数平均高达1.1×10<sup>7</sup>, 而无关联IFDS计算边个数平均为1.01×10<sup>7</sup>.可见无关联的计算边占总计算边的比例是很高的, 其中最低比例是79.1%, 最高比例为92.9%, 平均比例为85.2%, 这也充分验证了前面的分析.所以得出结论是:由于域敏感和流敏感的特性使得IFDS算法的摘要优化失效, 当前无关联的计算占总计算的比例较高且规模较大.本文的研究目标正是尝试将数据流值直接传递到其使用点的位置, 跨过这些无关联的传播 (稀疏的方式) , 来消除这种无关联的计算.</p>
                </div>
                <div class="area_img" id="119">
                    <p class="img_tit"><b>表2 使用FlowDroid对数据集进行评测结果</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 2 The Results on Evaluation of FlowDroid</b></p>
                    <p class="img_note"></p>
                    <table id="119" border="1"><tr><td>No.</td><td>Running <br />Time/s</td><td>Memory <br />Size/GB</td><td>#RES</td><td>#IFDS<br />/10<sup>6</sup></td><td>#UR-IFDS<br />/10<sup>6</sup></td><td>PP<br />/%</td></tr><tr><td>1</td><td>73.4</td><td>3.3</td><td>41</td><td>3.8</td><td>3.5</td><td>92.9</td></tr><tr><td><br />2</td><td>672</td><td>15.8</td><td>27</td><td>17.1</td><td>14.6</td><td>85.3</td></tr><tr><td><br />3</td><td>30.8</td><td>3.8</td><td>32</td><td>1.0</td><td>0.9</td><td>89.8</td></tr><tr><td><br />4</td><td>491.7</td><td>7.2</td><td>18</td><td>14.1</td><td>11.3</td><td>80.5</td></tr><tr><td><br />5</td><td>245</td><td>8.8</td><td>111</td><td>1.1</td><td>0.91</td><td>79.8</td></tr><tr><td><br />6</td><td>172</td><td>5.1</td><td>46</td><td>7.9</td><td>6.9</td><td>87.1</td></tr><tr><td><br />7</td><td>253</td><td>11.6</td><td>99</td><td>11.0</td><td>9.5</td><td>86.0</td></tr><tr><td><br />8</td><td>760</td><td>15.9</td><td>19</td><td>22.2</td><td>17.5</td><td>79.1</td></tr><tr><td><br />9</td><td>93.3</td><td>7.3</td><td>37</td><td>3.9</td><td>3.2</td><td>83.7</td></tr><tr><td><br />10</td><td>855</td><td>12.6</td><td>46</td><td>37.1</td><td>33.2</td><td>89.4</td></tr><tr><td><br />11</td><td>1 922</td><td>13.1</td><td>184</td><td>36.1</td><td>29.3</td><td>81.2</td></tr><tr><td><br />12</td><td>246</td><td>8.1</td><td>33</td><td>7.5</td><td>6.3</td><td>84.1</td></tr><tr><td><br />13</td><td>43.2</td><td>2.6</td><td>38</td><td>1.2</td><td>1.1</td><td>90.1</td></tr><tr><td><br />14</td><td>109</td><td>4.6</td><td>14</td><td>3.1</td><td>2.6</td><td>86.0</td></tr><tr><td><br />15</td><td>104</td><td>5.7</td><td>28</td><td>2.7</td><td>2.2</td><td>83.5</td></tr><tr><td><br />16</td><td>419</td><td>6.2</td><td>39</td><td>11.0</td><td>9.3</td><td>84.4</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="120">为了解决该问题, 本文的方法将DEF-USE链的思想引入到IFDS计算框架中, 在数据流传播时, 直接将数据流值从其产生的位置传递到其真正使用点.</p>
                </div>
                <h3 id="121" name="121" class="anchor-tag"><b>3 稀疏的IFDS框架</b></h3>
                <div class="p1">
                    <p id="122">提供稀疏的污点分析的前提正是提供稀疏的数据流分析框架.本节将介绍如何将经典的数据流分析框架IFDS扩展成稀疏的形式.本文的方法同样是尝试使用DEF-USE链来代替CFG进行数据流值传播.然而与传统方法不同的是:为了支持域敏感和流敏感, 本文使用了一种特殊的数据结构来存储变量的使用点, 并提供了快速的构建算法 (3.3节和3.4节介绍) , 最后我们在3.5节修改了原IFDS的传播函数, 将得到的数据流值直接传播到其使用点.</p>
                </div>
                <h4 class="anchor-tag" id="123" name="123"><b>3.1 指令定义</b></h4>
                <div class="p1">
                    <p id="124">首先定义本框架中用到的指令规则, 将程序中所有语句转化为3地址的形式 (Jimple中间表示形式) , 保证程序中只存在6种与数据流传播相关的指令.为了方便后续规则的表示, 这里将赋值语句[COPY]根据目标为左值或者右值的情况分成[READ]和[WRITE]形式.对于堆变量的域访问, 如形如<i>v</i>.<i>f</i>变量的访问, 我们命名其堆所在对象为基对象 (base) , 即变量<i>v</i>, <i>f</i>则是基对象中的域 (field) .对堆对象域的读和写被定义为[LOAD]和[STORE]规则.如表3所示为所有的6种指令规则.</p>
                </div>
                <div class="area_img" id="125">
                    <p class="img_tit"><b>表3 指令规则</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 3 The Rules of the Instruction</b></p>
                    <p class="img_note"></p>
                    <table id="125" border="1"><tr><td><br />Rule</td><td>Instruction</td></tr><tr><td><br />ALLOC</td><td><i>v</i>=new <i>V</i> () </td></tr><tr><td><br />READ</td><td><i>w</i>=<i>v</i></td></tr><tr><td><br />WRITE</td><td><i>v</i>=<i>w</i></td></tr><tr><td><br />LOAD</td><td><i>w</i>=<i>v</i>.<i>f</i></td></tr><tr><td><br />STORE</td><td><i>v</i>.<i>f</i>=<i>w</i></td></tr><tr><td><br />CALL</td><td><i>r</i>=<i>c</i>.<i>m</i> (<i>v</i>) </td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="126" name="126"><b>3.2 变量使用点索引</b></h4>
                <div class="p1">
                    <p id="127">为了维护域敏感和流敏感性, 这里使用一种特殊的数据结构来表示变量的DEF-USE关系.</p>
                </div>
                <div class="p1">
                    <p id="128"><b>定义1</b>. 变量使用点索引.变量使用点索引是一个表 (map) 结构, 它的键值 (key) 是变量的域, 它的值 (value) 是该变量对应域的所有使用点集合.</p>
                </div>
                <div class="p1">
                    <p id="129">这里使用一个特殊域null来表示变量中域为空的情况, 使用函数<i>setUses</i>[<i>f</i>]=[<i>stmt</i>]表示将语句[<i>stmt</i>]加入到变量的域<i>f</i>的使用点集合中, 使用<i>v</i>.<i>getUseStmts</i> (<i>f</i>) 来表示获得的<i>f</i>域对应的使用点集合, 使用<i>v</i>.<i>getUseStmts</i> (*) 表示获得<i>v</i>的索引表中所有域对应的使用点集合.</p>
                </div>
                <h4 class="anchor-tag" id="130" name="130"><b>3.3 自治数据流图ADFG</b></h4>
                <div class="p1">
                    <p id="131"><b>定义2</b>. 自治数据流图 (autonomous data flow graph, ADFG) .自治数据流图是一个有向图<i>G</i>=&lt;<i>N</i>, <i>E</i>&gt;, 其中节点<i>N</i>表示程序中的变量且所有变量的基对象相同, 边<i>E</i>为表示节点所在语句之间的控制流.</p>
                </div>
                <div class="p1">
                    <p id="132">如图4 (b) 正是基对象为<i>a</i>的自治数据流图, 对于基对象<i>a</i>的所有相关变量均在该图中, 且这些变量所在的语句 (图4 (b) 用行号表示) 之间的控制流是节点之间相连的边.ADFG的优势就是图中变量的基对象相同且保存了完整的控制流信息, 之后对每一个独立的变量计算其DEF-USE (变量使用点索引) 时, 即可在ADFG中进行, 这既提高了分析效率, 又保证了流敏感.</p>
                </div>
                <div class="area_img" id="133">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_133.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 自治数据流图 (基对象为a) 示例" src="Detail/GetImg?filename=images/JFYZ201903003_133.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 自治数据流图 (基对象为<i>a</i>) 示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_133.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 An example of ADFG</p>

                </div>
                <div class="p1">
                    <p id="134">基于ADFG的定义, 我们提供了一种快速的构建ADFG的算法.该算法将按照变量的基对象进行分区, 然后对于每一个分区中的变量分别计算其独立的数据流图.具体算法如算法1所示:</p>
                </div>
                <div class="p1">
                    <p id="135"><b>算法1</b>. 构建自治数据流图算法.</p>
                </div>
                <div class="p1">
                    <p id="136">输入:程序的<i>allCFGs</i>;</p>
                </div>
                <div class="p1">
                    <p id="137">输出:程序的<i>allADFGs</i>.</p>
                </div>
                <div class="p1">
                    <p id="138">① <i>collectVariables</i> (…) ;</p>
                </div>
                <div class="p1">
                    <p id="139">② <i>partitionByBasicBlock</i> (…) ;</p>
                </div>
                <div class="p1">
                    <p id="140">③ <i>buildADFG</i> (…) .</p>
                </div>
                <div class="p1">
                    <p id="141">子过程1.<i>collectVariables</i>.</p>
                </div>
                <div class="p1">
                    <p id="142">输入:程序的<i>allCFGs</i>.</p>
                </div>
                <div class="p1">
                    <p id="143">① for each <i>oneCFG</i> in <i>allCFGs</i> do</p>
                </div>
                <div class="p1">
                    <p id="144">/*对于每一个方法的CFG进行遍历*/</p>
                </div>
                <div class="p1">
                    <p id="145">② for each <i>var</i> in each <i>stmt</i> of <i>oneCFG</i> do</p>
                </div>
                <div class="p1">
                    <p id="146">③ <i>varInfoSetMap</i>[<i>base</i>]←[<i>var</i>, <i>bb</i>, <i>idx</i>];</p>
                </div>
                <div class="p1">
                    <p id="147">/*将程序中所有变量按照其基对象进行分区, 存储到<i>varInfoSetMap</i> Hash表中*/</p>
                </div>
                <div class="p1">
                    <p id="148">④ end for</p>
                </div>
                <div class="p1">
                    <p id="149">⑤ end for</p>
                </div>
                <div class="p1">
                    <p id="150">子过程2.<i>partitionByBasicBlock</i>.</p>
                </div>
                <div class="p1">
                    <p id="151">输入:<i>varInfoSetMap</i>.</p>
                </div>
                <div class="p1">
                    <p id="152">① for each <i>varInfoSet</i> in <i>varInfoSetMap</i> do</p>
                </div>
                <div class="p1">
                    <p id="153">② for each <i>var</i> in <i>varInfoSet</i> do</p>
                </div>
                <div class="p1">
                    <p id="154">③ <i>bb</i>=<i>var</i>.<i>getBasicBlock</i> () ;</p>
                </div>
                <div class="p1">
                    <p id="155">/*获取当前变量的基本块*/</p>
                </div>
                <div class="p1">
                    <p id="156">④ <i>bbToVarInfoMap</i>[<i>bb</i>]←<i>var</i>;</p>
                </div>
                <div class="p1">
                    <p id="157">/*将变量按照其基本块进行分区, 存储到<i>bbToVarInfoMap</i> Hash表中*/</p>
                </div>
                <div class="p1">
                    <p id="158">⑤ end for</p>
                </div>
                <div class="p1">
                    <p id="159">⑥ end for</p>
                </div>
                <div class="p1">
                    <p id="160">子过程3.<i>buildADFG</i>.</p>
                </div>
                <div class="p1">
                    <p id="161">输入:<i>bbToVarInfoMap</i>.</p>
                </div>
                <div class="p1">
                    <p id="162">① for each <i>bb</i> in <i>bbToVarInfoMap</i> do</p>
                </div>
                <div class="p1">
                    <p id="163">② <i>ret</i>=<i>innerBBSolver</i> (<i>bb</i>, <i>bb</i>.<i>varSet</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="164">/*<i>innerBBSolver</i>将构建基本块内部节点的控制流关系, 并返回其头尾节点&lt;<i>head</i>, <i>tail</i>&gt;*/</p>
                </div>
                <div class="p1">
                    <p id="165">③ varinfo <i>tail</i>=<i>ret</i>.<i>getTail</i>;</p>
                </div>
                <div class="p1">
                    <p id="166">④ for <i>next</i> in <i>bb</i>.<i>getSuccs</i> do</p>
                </div>
                <div class="p1">
                    <p id="167">⑤ <i>traverseEachBB</i> (<i>next</i>, <i>tail</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="168">⑥ end for</p>
                </div>
                <div class="p1">
                    <p id="169">⑦ end for</p>
                </div>
                <div class="p1">
                    <p id="170">子过程4.<i>traverseEachBB</i>.</p>
                </div>
                <div class="p1">
                    <p id="171">输入:后继基本块<i>next</i>, 和前驱基本块的尾节点<i>preTail</i>.</p>
                </div>
                <div class="p1">
                    <p id="172">① <i>ret</i>=<i>innerBBSolver</i> (<i>next</i>, <i>next</i>.<i>varSet</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="173">② <i>varinfo head</i>=<i>ret</i>.<i>getHead</i>;</p>
                </div>
                <div class="p1">
                    <p id="174">③ <i>preTail</i>.<i>setSucc</i> (<i>head</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="175">④ for <i>next</i> in <i>bb</i>.<i>getSuccs</i> do</p>
                </div>
                <div class="p1">
                    <p id="176">⑤ <i>traverseEachBB</i> (<i>next</i>, <i>ret</i>.<i>getTail</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="177">⑥ end for</p>
                </div>
                <div class="p1">
                    <p id="178">函数<i>collectVariables</i>将变量按照其基对象进行分区, 存储到Hash表<i>varInfoSetMap</i>中, 对于一个变量, 这里存储的信息包括变量的值<i>var</i>和其基本块信息<i>bb</i>以及其所在基本块内部的索引号<i>idx</i>.函数<i>partitionByBasicBlock</i>再通过它所在的基本块分区并存储到Hash表<i>bbToVarInfoMap</i>中.之后, 函数<i>buildADFG</i>对基对象相同的变量集合按每一个基本块进行遍历, 在基本块内部, <i>buildADFG</i>调用<i>innerBBSolver</i>方法顺序的将后继语句加入到前驱语句的后继集合中.在基本块之间, <i>buildADFG</i>通过<i>innerBBSolver</i>的返回值得到每一个基本块的头节点和尾节点, 为上一个基本块的尾节点设置下一个基本块的头节点为其后继.</p>
                </div>
                <div class="p1">
                    <p id="179">至此, ADFG上每一个变量都包含其控制流中的后继信息, 且不包含其他基对象的变量.函数<i>collectVariables</i>和<i>partitionByBasicBlock</i>线性地扫描程序中的变量, 所以其算法时间复杂度是线性的.而<i>buildADFG</i>将对每一个基本块进行遍历, 在基本块内部则顺序访问每一个变量, 所以<i>buildADFG</i>算法的时间复杂度也是线性的, 整个构建ADFG算法的时间复杂度是线性的.</p>
                </div>
                <h4 class="anchor-tag" id="180" name="180"><b>3.4 变量使用点索引的计算</b></h4>
                <div class="p1">
                    <p id="181">在ADFG上, 所有变量的基对象均相同且仍包含其控制流信息, 整个CFG按照基对象的不同被分成多个ADFG.分析器将分别遍历每一个ADFG, 使用数据流分析的方法计算其变量的使用位置, 将其存储到使用点索引中.如表4所示为计算使用点索引的数据流转移函数, 图5为对应示例.我们将在4.2节讨论如何使用该索引为污点分析的访问路径生成具体的使用点以及对使用点集合进行剪枝.该分析使用了传统的工作集 (worklist) 算法, 初始化集合是所有语句中的变量<i>v</i>/<i>v</i>.<i>f</i>与当前语句[<i>stmt</i>] (即变量的定义语句) 组成的对&lt;[<i>stmt</i>], <i>v</i>/<i>v</i>.<i>f</i>&gt;.</p>
                </div>
                <div class="area_img" id="182">
                                            <p class="img_tit">
                                                <b>表4 计算变量使用点索引的数据流转移方程</b>
                                                    <br />
                                                <b>Table 4 Data Flow Transfer Function for Computing Variable Using Map</b>
                                                &nbsp;&nbsp;
                                                <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_18200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a>
                                                <a class="table downimg" data-tablename="Detail/GetImg?filename=images/JFYZ201903003_18200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">下载原表</a>
                                            </p>
                                    <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_18200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <img alt="表4 计算变量使用点索引的数据流转移方程" src="Detail/GetImg?filename=images/JFYZ201903003_18200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                    </a>

                </div>
                <div class="area_img" id="183">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_183.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 计算变量使用点索引示例" src="Detail/GetImg?filename=images/JFYZ201903003_183.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 计算变量使用点索引示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_183.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Examples of variable using map computing</p>

                </div>
                <div class="p1">
                    <p id="184">表4中, 第3列定义值 (DEF value) 是转移函数的输入, 即变量的定义位置传递过来的数据流值, 转移函数的功能是决定是否将当前语句设置为该值的使用点.根据3.1节中的指令定义, 定义值只能为<i>v</i>或者<i>v</i>.<i>f</i>的形式, 例如图5中被方格括住的变量.第4列Set USE Rule表示对定义值设置使用点索引的规则.为了区分域敏感特性, 需要为不同的域存储不同的使用点.如3.2节定义, 使用<i>setUses</i>[<i>f</i>]=[Stmt]来表示将语句[<i>stmt</i>]加入到变量<i>v</i>的域<i>f</i>的使用点集合中, 而<i>setUses</i>[null]表示定义值域是空的情况.第5列IsKill列表示定义值是否被杀死 (True) 或者继续寻找其使用位置 (False) .</p>
                </div>
                <div class="p1">
                    <p id="185">对于[ALLOC]和[WRITE]规则, 如图5 (a) 中例子所示, 无论定义值是<i>v</i>还是<i>v</i>.<i>f</i>, 都会将对<i>v</i>变量进行重新赋值, 传来的定义值不再有效.因此设置IsKill为True且不会产生使用关系.</p>
                </div>
                <div class="p1">
                    <p id="186">对于[READ]规则, 如果定义值是<i>v</i>, 如图5 (b) 左侧程序, 说明任何的形如<i>v</i>.*的访问路径都会传递到使用点, 所以设置空域的使用点集合 (setUses[null]=[<i>stmt</i>]) .如果定义值是<i>v</i>.<i>f</i>, 如图5 (b) 右侧程序, 说明只有形如<i>v</i>.<i>f</i>.*的访问路径会传递到使用点, 则设置域<i>f</i>的使用点集合 (<i>setUses</i>[<i>f</i>]=[<i>stmt</i>]) .</p>
                </div>
                <div class="p1">
                    <p id="187">对于[LOAD]规则, 说明访问路径第1个域满足和<i>f</i>相等时才会被使用.所以无论访问路径是形如<i>v</i>.*或<i>v</i>.<i>f</i>.*的输入, 都将设置域<i>f</i>的使用点集合 (<i>setUses</i>[<i>f</i>]=[<i>stmt</i>]) .</p>
                </div>
                <div class="p1">
                    <p id="188">对于[STORE]规则, 如果定义值是<i>v</i>.<i>f</i>, 如图5 (d) 规则右侧程序, 同[WRITE]规则, 传来的定义值不再有效.如果定义值是<i>v</i>, 说明形如<i>v</i>.*的访问路径可能传播到该语句, 且需要杀死其中第1个域为<i>f</i>的值.由于当前访问路径是无法表示形如<i>v</i>.{*-<i>f</i>}的数据流值, 为了不丢失信息, 这里使用一种延迟处理的方法:首先将该语句加入到定义值空域的使用点集合中 (<i>setUses</i>[null]=[<i>stmt</i>]) , 然后保守地认为该定义值全部失效 (将其杀死) , 最后在初始化集合中增加一个虚拟的&lt;[<i>stmt</i>], <i>v</i>&gt;的定义值, 增加新的虚拟定义值的目的是为了继续传播除<i>f</i>域之外的值.以图5 (d) 左侧程序为例, 假设函数<i>foo</i>的返回值得到的访问路径是<i>v</i>.<i>f</i>2, <i>v</i>.<i>f</i>2根据空域的使用点可以传播到[<i>v</i>.<i>f</i>1=“…”;]处, 由于域不同, 分析规则不会杀死该值, 则会继续启动对<i>v</i>.<i>f</i>2使用点的查询, 此时将使用虚拟定义值<i>v</i>进行索引查询, 即可找到域<i>f</i>2的使用点[<i>w</i>=<i>v</i>.<i>f</i>2;].如果函数<i>foo</i>的返回值是<i>v</i>.<i>f</i>1的话, 该值传播到[<i>v</i>.<i>f</i>1=“…”]会根据分析规则被杀死.这种延迟处理的方式既不会损失精度又可以正确地进行更新.</p>
                </div>
                <div class="p1">
                    <p id="189">对于[CALL]规则, 如图5 (e) 所示规则.这里设置使用点的规则同[WRITE], 这是因为在IFDS框架中函数的参数是否能够通过函数调用继续向下传递是由Call和CallToReturn规则决定的, 所以这里直接将定义值置为失效, 待Call和CallToReturn产生其返回值再进一步查找与传播.</p>
                </div>
                <h4 class="anchor-tag" id="190" name="190"><b>3.5 传播函数</b></h4>
                <div class="p1">
                    <p id="191">框架还需修改原IFDS框架的传播函数 (文献<citation id="415" type="reference">[<a class="sup">20</a>]</citation>中算法行35的函数<i>propagate</i>) , 这里为传播函数增加一个包装函数<i>propagateWrapper</i>, 如算法2所示.</p>
                </div>
                <div class="p1">
                    <p id="192"><b>算法2</b>. 稀疏的IFDS传播函数<i>propagate</i>-<i>Wrapper</i>.</p>
                </div>
                <div class="p1">
                    <p id="193">输入:定义语句<i>src</i>、目标数据流值<i>dtarget</i>;</p>
                </div>
                <div class="p1">
                    <p id="194">输出:目标语句<i>use</i>、目标数据流值<i>dtarget</i>.</p>
                </div>
                <div class="p1">
                    <p id="195">① <i>useSet</i>=<i>defValue</i>.<i>getUseStmts</i> () ;</p>
                </div>
                <div class="p1">
                    <p id="196">② for each <i>useStmt</i> in <i>useSet</i> do:</p>
                </div>
                <div class="p1">
                    <p id="197">③ <i>propagate</i> (<i>useStmt</i>, <i>dtarget</i>) </p>
                </div>
                <div class="p1">
                    <p id="198">④ end for</p>
                </div>
                <div class="p1">
                    <p id="199">包装函数将通过当前变量及其使用点索引获得其使用点集合, 然后将数据流值直接传递到其使用点.本算法不会影响IDFS产生新的数据流值的计算, 而只是修改其传播的目的语句, 即达到稀疏传播而又不影响正确性.例如图6中<i>a</i>在行②处将仍然会产生<i>b</i>值, 但会将<i>b</i>值直接传播到其使用位置, 即行③.</p>
                </div>
                <div class="area_img" id="200">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 稀疏的IFDS框架示例" src="Detail/GetImg?filename=images/JFYZ201903003_200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 稀疏的IFDS框架示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 An example of sparse IFDS framework</p>

                </div>
                <h3 id="201" name="201" class="anchor-tag"><b>4 基于稀疏框架的污点分析</b></h3>
                <h4 class="anchor-tag" id="202" name="202"><b>4.1 总体框架</b></h4>
                <div class="p1">
                    <p id="203">基于第3节的稀疏框架, 本节设计实现了与其适配的污点分析技术, 图7所示为其整体框架.相对于传统的污点分析 (FlowDroid) , 该框架增加一个预先分析 (preAnalysis) 的过程, 即构建ADFG和计算变量使用点索引的过程.与FlowDroid一样, 分析的第1部分仍是待分析程序的ICFG (图7中Build ICFG过程) , 以此作为预先分析的输入.预先分析过程生成的使用点索引作为污点传播前向分析和后向分析 (别名分析) 的输入, 最后是输出结果部分.</p>
                </div>
                <div class="area_img" id="204">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_204.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 基于稀疏的污点分析总体框架" src="Detail/GetImg?filename=images/JFYZ201903003_204.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 基于稀疏的污点分析总体框架  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_204.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 The overview of the our taint analysis framework</p>

                </div>
                <h4 class="anchor-tag" id="205" name="205"><b>4.2 污点传播中使用点的维护与剪枝</b></h4>
                <div class="p1">
                    <p id="206">由于在3.4节中提供了面向域敏感和流敏感的变量使用点索引, 本节将根据具体的输入使用这些索引产生污点分析的使用点, 并达到对使用点集合剪枝的效果.与FlowDroid类似, 我们同样使用访问路径来表示数据流值.具体如算法3所示:</p>
                </div>
                <div class="p1">
                    <p id="207"><b>算法3</b>. 污点传播使用点集合剪枝算法.</p>
                </div>
                <div class="p1">
                    <p id="208">输入:当前语句点<i>stmt</i>、数据流值访问路径<i>apath</i>;</p>
                </div>
                <div class="p1">
                    <p id="209">输出:数据流值的使用点集合<i>useSet</i>.</p>
                </div>
                <div class="p1">
                    <p id="210">① if <i>apath</i>.<i>getFirstField</i>≠null do</p>
                </div>
                <div class="p1">
                    <p id="211">/*形如<i>v</i>.<i>f</i>.*的访问路径输入*/</p>
                </div>
                <div class="p1">
                    <p id="212">② <i>useSet</i>=∪<i>getUseStmts</i> (<i>apath</i>.</p>
                </div>
                <div class="p1">
                    <p id="213"><i>getFirstField</i>) +<i>getUseStmts</i> (null) ;</p>
                </div>
                <div class="p1">
                    <p id="214">③ else /*形如<i>v</i>.*的访问路径输入*/</p>
                </div>
                <div class="p1">
                    <p id="215">④ if <i>isStore</i> (<i>stmt</i>) do:</p>
                </div>
                <div class="p1">
                    <p id="216">/*形如<i>v</i>.<i>f</i>=“…”的语句*/</p>
                </div>
                <div class="p1">
                    <p id="217">⑤ <i>useSet</i>=∪ (<i>getUseStmts</i> (*) -</p>
                </div>
                <div class="p1">
                    <p id="218"><i>getUseStmts</i> (<i>f</i>) ) ;</p>
                </div>
                <div class="p1">
                    <p id="219">/*从索引中所有域的使用点集合中减去域<i>f</i>的使用点*/</p>
                </div>
                <div class="p1">
                    <p id="220">⑥ else</p>
                </div>
                <div class="p1">
                    <p id="221">⑦ <i>useSet</i>∪=<i>getUseStmts</i> (*) ;</p>
                </div>
                <div class="p1">
                    <p id="222">⑧ end if</p>
                </div>
                <div class="p1">
                    <p id="223">⑨ end if</p>
                </div>
                <div class="p1">
                    <p id="224">算法3的输入是当前语句<i>stmt</i>和产生的数据流值的访问路径, 这里用<i>apath</i>表示.如果当前<i>apath</i>是形如<i>v</i>.<i>f</i>.*的形式, 即访问路径的第一个域是<i>f</i>, 那么使用域null和<i>f</i>产生其使用点集合, 即算法3中行②.这种方法可以过滤掉和<i>f</i>域不同的且不为空的域的使用点.如果<i>apath</i>是形如<i>v</i>.*的形式, 说明当前<i>v</i>的子域不确定, 因此需要传播到其所有域的使用点, 即算法3的行⑦.一种特殊的情况, 如果语句是[STORE]形式, 根据表4的[STORE]规则, 当前存在一个<i>v</i>的虚拟定义变量的使用点索引, 那么查找并使用该索引:除了需要产生所有域的使用点之外, 还需要从中减去当前语句被赋值域的使用点, 即算法3中行⑤, 这是由于当前[STORE]已经将该域更新为其他值, 无需再为该域计算使用点.最终算法的输出是<i>useSet</i>, 即根据当前访问路径得到的使用点集合.</p>
                </div>
                <div class="p1">
                    <p id="225">本文的方法虽然没有改变算法的复杂度 (IFDS算法的时间复杂度为<i>O</i> (<i>ED</i><sup>3</sup>) , 空间复杂度为<i>O</i> (<i>ED</i><sup>2</sup>) , 其中<i>E</i>是当前控制流图中的边个数, <i>D</i>是数据流域的大小) .但是由于我们的方法对当前控制流图转化成稀疏的形式 (自治数据流图) , 所以<i>E</i>的值将会明显的缩小, 此外<i>D</i>的值也由于无关联传播被消除而变小, 这也是本文方法能够提高效率的原因.</p>
                </div>
                <h4 class="anchor-tag" id="226" name="226"><b>4.3 面向别名传播的变量使用点索引</b></h4>
                <div class="p1">
                    <p id="227">在反向的IFDS计算中, 后向的别名间污点传播使用的变量使用点索引与前向传播稍有不同:由于需要在使用点计算其别名的污点, 所以同样将语句加入其使用点集合中.表5是对应的转移函数, 其中与正向的转移函数不同的是:[ALLOC]和[WRITE]和[LOAD]规则, 即需要保留它们的使用点.</p>
                </div>
                <div class="area_img" id="228">
                    <p class="img_tit"><b>表5 后向分析中计算变量使用点索引的数据流转移方程</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 5 Data Flow Transfer Function for Computing Backwards Variable Using Map</b></p>
                    <p class="img_note"></p>
                    <table id="228" border="1"><tr><td>Rule</td><td>Instruction</td><td>DEF<br />Value</td><td>Set USE Rule</td><td>IsKill</td></tr><tr><td><br />ALLOC</td><td><i>v</i>=new <i>V</i> () </td><td><i>v</i><br /><i>v</i>.<i>f</i></td><td><i>setUses</i>[null]=[<i>stmt</i>]<br /><i>setUses</i>[<i>f</i>]=[<i>stmt</i>]</td><td>True<br />True</td></tr><tr><td><br />WRITE</td><td><i>v</i>=<i>v</i>′</td><td><i>v</i><br /><i>v</i>.<i>f</i></td><td><i>setUses</i>[null]=[<i>stmt</i>]<br /><i>setUses</i>[<i>f</i>]=[<i>stmt</i>]</td><td>True<br />True</td></tr><tr><td><br />READ</td><td><i>v</i>′=<i>v</i></td><td><i>v</i><br /><i>v</i>.<i>f</i></td><td><i>setUses</i>[null]=[<i>stmt</i>]<br /><i>setUses</i>[<i>f</i>]=[<i>stmt</i>]</td><td>False<br />False</td></tr><tr><td><br />LOAD</td><td><i>v</i>′=<i>v</i>.<i>f</i></td><td><i>v</i>/<i>v</i>.<i>f</i></td><td><i>setUses</i>[<i>f</i>]=[<i>stmt</i>]</td><td>False</td></tr><tr><td><br />STORE</td><td><i>v</i>.<i>f</i>=<i>v</i>′</td><td><i>v</i><br /><i>v</i>.<i>f</i></td><td><i>setUses</i>[null]=[<i>stmt</i>]<br /><i>setUses</i>[<i>f</i>]=[<i>stmt</i>]</td><td>True<br />True</td></tr><tr><td><br />CALL</td><td><i>v</i>.<i>m</i> (<i>v</i>′) /<br /><i>v</i>′.<i>m</i> (<i>v</i>) </td><td><i>v</i><br /><i>v</i>.<i>f</i></td><td><i>setUses</i>[null]=[<i>stmt</i>]<br /><i>setUses</i>[<i>f</i>]=[<i>stmt</i>]</td><td>True<br />True</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="229" name="229"><b>4.4 流敏感的别名传播维护</b></h4>
                <div class="p1">
                    <p id="230">为了维护流敏感的别名传播, 基于IFDS的污点分析引入了激活点的概念, 稀疏的方法同样需要考虑这个问题, 由于稀疏的方法不能沿着CFG上的每一条语句进行传播, 这给维护激活点带来了挑战.</p>
                </div>
                <div class="p1">
                    <p id="231">为了解决该问题, 我们利用了可能可达性的概念, 所谓的可能可达 (may reach) 是一种偏序关系|[<i>KG</i>-*2]→:如果程序语句<i>S</i><sub>1</sub>和<i>S</i><sub>2</sub>存在偏序关系<i>S</i><sub>1</sub>|[<i>KG</i>-*2]→<i>S</i><sub>2</sub>, 则说明可能存在一条执行路径使得变量从<i>S</i><sub>1</sub>到EXIT流经<i>S</i><sub>2</sub>.相反, 如果<i>S</i><sub>1</sub>|[<i>KG</i>-*2]→<i>S</i><sub>2</sub>不被满足, 则说明一定不存在一条执行路径从<i>S</i><sub>1</sub>到EXIT流经<i>S</i><sub>2</sub>.</p>
                </div>
                <div class="p1">
                    <p id="232">那么, 定义当前污点变量的定义点是<i>defStmt</i>, 污点变量的激活点是<i>activeStmt</i>, 污点变量的使用点是<i>useStmt</i>, 如图8中所示.则污点值被激活的必要条件是:</p>
                </div>
                <div class="area_img" id="233">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_233.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 FlowDroid的激活点维护示例" src="Detail/GetImg?filename=images/JFYZ201903003_233.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图8 FlowDroid的激活点维护示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_233.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 8 An example of active stmt maintenance</p>

                </div>
                <div class="p1">
                    <p id="234"><b>约束1</b>. <i>defStmt</i>|[<i>KG</i>-*2]→<i>activeStmt</i>且<i>activeStmt</i>|[<i>KG</i>-*2]→<i>useStmt</i>.</p>
                </div>
                <div class="p1">
                    <p id="235">证明. 必要性证明.如果<i>defStmt</i>|[<i>KG</i>-*2]→<i>activeStmt</i>不满足, 那么污点变量不会流经激活点, 污点一定不会被激活.如果<i>activeStmt</i>|[<i>KG</i>-*2]→<i>useStmt</i>不满足, 则说明到达<i>activeStmt</i>的值一定不会到达<i>useStmt</i>, 也就不会存在被激活的变量到达<i>useStmt</i>. 证毕.</p>
                </div>
                <div class="p1">
                    <p id="236">至于偏序关系|[<i>KG</i>-*2]→是可以在预处理阶段计算出的哈希映射进行查询的.比较过程内2点<i>S</i><sub>1</sub>和<i>S</i><sub>2</sub>的偏序关系|[<i>KG</i>-*2]→的方法:如果它们在一个基本块中且该基本块不在循环中, 那么直接比较其基本块内部索引号.否则比较基本块之间的可能可达关系.而基本块的可能可达关系可以在预处理中很快的得到一个Hash映射.所以整个偏序关系比较的时间复杂度是<i>O</i> (1) 的.</p>
                </div>
                <div class="p1">
                    <p id="237">不过满足约束1的情况并不是满足污点激活的充分条件, 这是因为会存在数据流值被杀死的情况.为了保证精度, 我们为满足约束1的数据流值再启动一个独立的更新 (update) 分析, 更新分析是沿着CFG进行的, 直接使用传统数据流方程求解 (与FlowDroid方法一致) .如果数据流值既满足约束1又不被更新阶段所杀死, 则说明是被激活的.</p>
                </div>
                <h4 class="anchor-tag" id="238" name="238"><b>4.5 剪枝优化讨论</b></h4>
                <div class="p1">
                    <p id="239">至此, 本文的算法既保证了稀疏性又保证相比原FlowDroid不会损失任何的精确度.在具体实现中, 基于变量使用点索引的剪枝算法还能够消除FlowDroid的误报, 提高检测的精度.具体分析:</p>
                </div>
                <div class="area_img" id="240">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_240.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 FlowDroid的保守子域处理示例" src="Detail/GetImg?filename=images/JFYZ201903003_240.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图9 FlowDroid的保守子域处理示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_240.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 9 An example of FlowDroid conservative sub-field process</p>

                </div>
                <div class="p1">
                    <p id="241">如果当前分析器不确定具体的访问路径的子域时, FlowDroid会用一种保守的方式为其所有的子域均进行污点标记, 即使用形如<i>v</i>.*的访问路径表示<i>v</i>以及<i>v</i>的所有子域均为污点标记.这里命名该处理方式为保守子域处理.保守子域处理方式虽然不会产生漏报, 但是显然是会产生误报的.除了分析器不知道具体是哪个子域被标记的之外, 还会存在分析器无法对子域进行正确更新的情况.如图9所示, 行①的<i>source</i>正是产生了<i>v</i>.*的数据流值, 是一种保守子域的处理.当<i>v</i>.*传播到行②时, 由于不能确定是哪个子域被更新的 (当前数据流值无法表示形如<i>v</i>.{*-<i>f</i>}) , 此时只能保守地不更新而继续传播<i>v</i>.*值.因此<i>v</i>.*到达行③时则会报告出泄露.而实际上行③的<i>v</i>.<i>f</i>1值已经在行②被设置成非敏感的数据, 所以该报告是误报.</p>
                </div>
                <div class="p1">
                    <p id="242">而这种误报是可以利用本文的方法进行消除的.具体分析:对于行②的左值<i>v</i>.<i>f</i>1, 根据3.4节算法计算得到的使用点索引是 (<i>setUses</i>[<i>f</i>1]=[<i>L</i>3]) , 而当数据流值<i>v</i>.*到达行②时, 分析器执行4.2节算法3的行⑤分支, 即使用规则[<i>useStmt</i>=∪<i>getUseStmt</i> (*) -<i>getUseStmt</i> (<i>f</i>) ]来计算其使用点集合.此时, Hash表中<i>f</i>1域对应的使用点将会从总使用集合中删除.因此, 此时使用点集合中只包含行④而不会包含行③, 继而误报被消除.</p>
                </div>
                <div class="p1">
                    <p id="243">另外, 据实验观察, 这种保守子域的处理方式存在的情况是比较多的, 这是因为不但直接引入的变量会产生保守子域处理, 如果访问路径的长度超过预先设置的值时, FlowDroid会将该访问路径进行裁剪 (cut off) , 裁剪后的变量也是一种保守子域处理的方式.例如预先设置的访问路径阈值为3时, 当生成的访问路径为<i>v</i>.<i>f</i>.<i>g</i>.<i>h</i>时, 则会保守地转化成<i>v</i>.<i>f</i>.<i>g</i>.*的情况.如果程序中存在循环的情况 (使得访问路径长度不断增加) , 这种裁剪而导致的保守子域处理的情况尤为突出, 我们在实验评测部分统计验证了经过裁剪的数据流值占总数据流值所占比例是较大的 (5.4节) .</p>
                </div>
                <h3 id="244" name="244" class="anchor-tag"><b>5 实现与实验</b></h3>
                <div class="p1">
                    <p id="245">基于本文方法, 我们在FlowDroid和Soot的基础上实现了原型系统FlowDroidSP, 其中重用了FlowDroid创建ICFG、访问路径、提取结果部分以及计算污点的转移函数 (4种IFDS转移函数) .为了保证函数调用和函数返回的过程能够找到参数和返回值对应的使用点, 这里在创建ADFG时, 为函数参数和返回值增加了虚拟的定义值.最后, 我们使用了100多个单元测试用例测试其健壮性.</p>
                </div>
                <div class="p1">
                    <p id="246">为了验证本文方法的精确度, FlowDroidSP实现了2种模式:剪枝模式和非剪枝模式.剪枝模式 (简称FlowDroidSP-P) 正是利用了具有域敏感和流敏感的变量使用点索引进行剪枝的实现版本.如在4.5节所讨论, 由于FlowDroid的保守子域处理, 导致剪枝的模式会对FlowDroid的精度进行提升, 然而这不利于验证其是否会损失精度.因此, 我们实现了非剪枝的模式 (简称FlowDroidSP-NP) 专用于验证精确度.在非剪枝模式的实现中, 我们将4.2节的算法3中所有分支都执行[<i>useSet</i>=∪<i>getUseStmt</i> (*) ;]规则, 即使用其所有域的使用点, 不进行剪枝处理.非剪枝算法理论上是和FlowDroid原算法精度完全一致的.</p>
                </div>
                <div class="p1">
                    <p id="247">所有实验所使用的机器的配置是:64核Intel<sup>®</sup> Xeon<sup>®</sup> CPU E7-4809 (2.0 GHz) 和128 GB RAM, 为每一个Java虚拟机分配32 GB的内存.同FlowDroid一样, 设置访问路径的长度为5.这里所使用的测试集合同第2节中的16个应用程序.使用FlowDroidSP对每一个测试用例独立运行3次, 提取结果并求平均值.</p>
                </div>
                <h4 class="anchor-tag" id="248" name="248"><b>5.1 评测问题</b></h4>
                <div class="p1">
                    <p id="249">本节我们将试图利用实验验证3个评测问题:</p>
                </div>
                <div class="p1">
                    <p id="250">1) 相比FlowDroid, 本文的方法是否会损失精度.</p>
                </div>
                <div class="p1">
                    <p id="251">2) 预处理阶段和独立更新算法的开销是多少.</p>
                </div>
                <div class="p1">
                    <p id="252">3) FlowDroidSP相比FlowDroid的性能提升效果是多少.</p>
                </div>
                <h4 class="anchor-tag" id="253" name="253"><b>5.2 问题1:精确度验证</b></h4>
                <div class="p1">
                    <p id="254">验证精确度需要使用非剪枝版本.这里的评价标准是产生的结果数目是相同的.表6是Flow-Droid和FlowDroidSP的对比运行结果.表中F-Res列为原FlowDroid产生的结果个数而NP-Res列为非剪枝模式FlowDroidSP产生的结果个数, 可见非剪枝版本的FlowDroidSP与FlowDroid产生的结果个数是完全一致的, 总共产生341个泄露结果.这进一步验证了本文的方法相比FlowDroid方法是没有精度损失的.</p>
                </div>
                <h4 class="anchor-tag" id="255" name="255"><b>5.3 问题2:预处理和更新阶段开销</b></h4>
                <div class="p1">
                    <p id="256">如表6所示, 表中PRE-T列是FlowDroidSP非剪枝模式下的预处理过程的运行时间, 其中标号16的程序最高为2.6 s, 标号9的程序最低为0.2 s, 平均为0.9 s.对于内存开销 (PRE-Mem列) , 其中标号16开销最高为429 MB, 标号9开销最低为11 MB, 平均为126 MB.预处理的平均消耗时间占平均总分析时间的百分比小于1%, 而内存消耗平均占比为4%.由此可见, 预处理的时间和空间开销是很低的.时间上, 相对于分析的平均时间91.1 s, 这种开销几乎可以忽略不计.预处理开销低的原因是由于线性复杂度的ADFG构建算法和在此基础上的过程内的DEF-USE分析.同样, 对于独立更新阶段的时间消耗 (表6中SP-T列) , 最高时间消耗是4.1 s, 最低是0.07 s, 平均时间消耗是1.3 s.可见, 虽然独立更新阶段算法不是线性复杂度的, 但是由于我们首先使用了约束1进行过滤, 导致需要独立更新的数据值已经很少了.为此, 本实验单独的统计了独立更新的值 (Active-SP) 与需要激活但不满足约束1的值 (Active) 之间所占百分比的对比, 结果如图11所示.可见, 独立更新部分所占比例是较小的 (平均4.2%) .</p>
                </div>
                <div class="area_img" id="257">
                    <p class="img_tit"><b>表6 FlowDroidSP评测数据</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 6 The Results on Evaluation of FlowDroidSP</b></p>
                    <p class="img_note"></p>
                    <table id="257" border="1"><tr><td><br />No.</td><td>F-Time<br />/s</td><td>F-Mem<br />/GB</td><td>F-Res</td><td>NP-Time<br />/s</td><td>NP-Mem<br />/GB</td><td>NP-Res</td><td>PRE-T<br />/s</td><td>PRE-Mem<br />/MB</td><td>SP-T<br />/s</td><td>P-Time<br />/s</td><td>P-Mem<br />/GB</td><td>P-Res</td></tr><tr><td><br />1</td><td>73.4</td><td>3.3</td><td>41</td><td>16</td><td>0.8</td><td>41</td><td>1.5</td><td>230</td><td>0.7</td><td>15</td><td>2.3</td><td>41</td></tr><tr><td><br />2</td><td>672</td><td>15.8</td><td>27</td><td>172</td><td>6.3</td><td>27</td><td>0.6</td><td>79</td><td>3.2</td><td>50</td><td>3.7</td><td>9</td></tr><tr><td><br />3</td><td>30.8</td><td>3.8</td><td>32</td><td>6.4</td><td>1.3</td><td>32</td><td>1</td><td>123</td><td>0.07</td><td>4.6</td><td>0.8</td><td>32</td></tr><tr><td><br />4</td><td>491.7</td><td>7.2</td><td>18</td><td>73.2</td><td>1.8</td><td>18</td><td>0.5</td><td>39</td><td>0.47</td><td>11.3</td><td>1.4</td><td>18</td></tr><tr><td><br />5</td><td>245</td><td>8.8</td><td>111</td><td>69.3</td><td>3.2</td><td>111</td><td>0.3</td><td>37</td><td>2</td><td>11</td><td>1</td><td>21</td></tr><tr><td><br />6</td><td>172</td><td>5.1</td><td>46</td><td>46</td><td>1.9</td><td>46</td><td>0.2</td><td>17</td><td>0.2</td><td>21</td><td>1.1</td><td>46</td></tr><tr><td><br />7</td><td>253</td><td>11.6</td><td>99</td><td>73</td><td>3.5</td><td>99</td><td>1.3</td><td>190</td><td>2</td><td>19</td><td>2.2</td><td>99</td></tr><tr><td><br />8</td><td>760</td><td>15.9</td><td>19</td><td>153</td><td>4.7</td><td>19</td><td>0.6</td><td>71</td><td>2.2</td><td>14</td><td>0.7</td><td>16</td></tr><tr><td><br />9</td><td>93.3</td><td>7.3</td><td>37</td><td>22</td><td>1.1</td><td>37</td><td>0.2</td><td>11</td><td>0.3</td><td>22</td><td>1</td><td>37</td></tr><tr><td><br />10</td><td>855</td><td>12.6</td><td>46</td><td>256</td><td>5.4</td><td>46</td><td>1</td><td>141</td><td>3</td><td>146</td><td>2.7</td><td>40</td></tr><tr><td><br />11</td><td>1 922</td><td>13.1</td><td>184</td><td>400</td><td>12</td><td>184</td><td>1.7</td><td>306</td><td>4</td><td>60</td><td>5.3</td><td>180</td></tr><tr><td><br />12</td><td>246</td><td>8.1</td><td>33</td><td>43</td><td>3.3</td><td>33</td><td>0.8</td><td>129</td><td>0.9</td><td>19</td><td>1</td><td>31</td></tr><tr><td><br />13</td><td>43.2</td><td>2.6</td><td>38</td><td>5</td><td>0.8</td><td>38</td><td>0.6</td><td>80</td><td>0.1</td><td>3.3</td><td>0.6</td><td>26</td></tr><tr><td><br />14</td><td>109</td><td>4.6</td><td>14</td><td>18.9</td><td>1.1</td><td>14</td><td>0.5</td><td>64</td><td>0.18</td><td>7.4</td><td>0.9</td><td>13</td></tr><tr><td><br />15</td><td>104</td><td>5.7</td><td>28</td><td>22.9</td><td>2.4</td><td>28</td><td>0.6</td><td>78</td><td>0.2</td><td>3.1</td><td>0.4</td><td>14</td></tr><tr><td><br />16</td><td>419</td><td>6.2</td><td>39</td><td>82</td><td>4.4</td><td>39</td><td>2.6</td><td>429</td><td>1.9</td><td>57</td><td>3.5</td><td>35</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="258">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_258.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图10 FlowDroid和FlowDroidSP不同模式下的结果对比" src="Detail/GetImg?filename=images/JFYZ201903003_258.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图10 FlowDroid和FlowDroidSP不同模式下的结果对比  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_258.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 10 Comparison on FlowDroid and FlowDoidSP beyond different mode</p>

                </div>
                <div class="area_img" id="259">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_259.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图11 独立更新计算值占可激活值的比例图" src="Detail/GetImg?filename=images/JFYZ201903003_259.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图11 独立更新计算值占可激活值的比例图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_259.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 11 Proportion diagram of independent updating</p>

                </div>
                <h4 class="anchor-tag" id="260" name="260"><b>5.4 问题3:性能提升效果</b></h4>
                <div class="p1">
                    <p id="261">本节将对打开剪枝优化进行评测, 如表6中列P-Time, P-Mem, P-Res为剪枝模式下FlowDroidSP的运行时间、内存消耗和产生泄露的结果数量.最终图10给出了3种评测模式 (原FlowDroid, 非剪枝模式, 剪枝模式的FlowDroidSP) 的在运行时间, 内存消耗和产生结果数量的对比柱状图.在运行时间上, 非剪枝版本平均加速比为4.8倍, 在剪枝版本中, 平均加速比为18.1倍.非剪枝版本的时间消耗加速比波动范围正常, 最低3.3倍, 最高8.6倍.而剪枝版本的加速比波动范围是非常大的, 最低提升4.2倍, 最高提升高达54倍, 这是一方面由于剪枝方法本质决定, 如果在程序传播初始阶段就能够有效地杀死不该传播的数据流值, 会避免后续污点大量的扩散, 另一方面我们猜测剪枝方法的加速比也和程序中保守子域的规模有关, 保守子域处理的情况越多, 可能剪枝的情况就会越多.为此, 我们统计了具有被裁剪标识 (当前访问路径被裁剪后会得到一个裁剪标识) 的数据流的数量, 如图12所示为该数目占当前所有数据流值的比例.对于编号1、编号9、编号13的例子, 其所占比例为25%, 12.9%, 20.9%.所以剪枝优化对其提升比例不高 (分别为4.8, 4.2, 13.9倍) .而对于其他例子中该规模是相对较高, 例如编号8的比例高达97.4%, 所以剪枝算法对其优化的加速比可以高达54倍.对于内存消耗上, 在非剪枝模式下, FlowDroidSP降低内存消耗平均为61.5%.在剪枝模式下, FlowDroidSP降低内存消耗平均为76.1%.另外对于产生泄露结果数目的影响, 在剪枝模式下, FlowDroidSP是有一定精确度提升的, 一共消减了154个误报结果, 占总数的17.7%.</p>
                </div>
                <div class="area_img" id="262">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903003_262.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图12 具有裁剪标识的数据流占总数比例图" src="Detail/GetImg?filename=images/JFYZ201903003_262.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图12 具有裁剪标识的数据流占总数比例图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903003_262.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 12 Proportion diagram of cutting off date flow facts</p>

                </div>
                <h3 id="264" name="264" class="anchor-tag"><b>6 相关工作对比</b></h3>
                <div class="p1">
                    <p id="265">数据流分析是静态程序分析的经典分析方法, IFDS框架<citation id="416" type="reference"><link href="359" rel="bibliography" /><sup>[<a class="sup">20</a>]</sup></citation>率先将流敏感和上下文敏感的分析问题转化成图可达问题进行求解, 提高了分析的效率, 该算法的最坏时间复杂度是<i>O</i> (<i>ED</i><sup>3</sup>) , 其中<i>E</i>是当前控制流图中的边个数, <i>D</i>是数据流域的大小.文献<citation id="417" type="reference">[<a class="sup">24</a>]</citation>在2010年对IFDS进行了效率提升, 它利用一种按需的方法对ICFG进行构建, 为调用函数和被调用函数建立一个映射关系, 当调用退出时只有存在于映射里面的调用者才会为其计算返回值.后来, 该方法被实现到开源工具Heros<citation id="418" type="reference"><link href="369" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>中, FlowDroid正是基于这个版本的IFDS进行实现的.FlowTwist<citation id="419" type="reference"><link href="333" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>利用了祖先和邻居的数据结构将数据值之间的传播关系进行连接, 以保证来自不同源的数据流值可以进行合并, 增加了分析的扩展性.然而, 当前没有工作探索对IFDS进行稀疏化的支持.同样, 本文的方法本质是修改IFDS的传播函数, 因此也适用于上述2个工作.</p>
                </div>
                <div class="p1">
                    <p id="266">针对FlowDroid进行利用以检测安全问题的工作有很多<citation id="420" type="reference"><link href="327" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>.例如, 达姆施塔特大学的安全软件工程实验室围绕了FlowDroid构建了一整套的安全检测生态系统<citation id="421" type="reference"><link href="371" rel="bibliography" /><sup>[<a class="sup">26</a>]</sup></citation>, 这包括使用Susi<citation id="422" type="reference"><link href="373" rel="bibliography" /><sup>[<a class="sup">27</a>]</sup></citation>来提供污点分析所使用的源和汇聚点;使用IccTA<citation id="423" type="reference"><link href="375" rel="bibliography" /><sup>[<a class="sup">28</a>]</sup></citation>提供敏感信息通过组件间进行泄露的检测方法;使用StubDroid<citation id="424" type="reference"><link href="377" rel="bibliography" /><sup>[<a class="sup">29</a>]</sup></citation>利用FlowDroid对库函数进行摘要提取;Harvester<citation id="425" type="reference"><link href="379" rel="bibliography" /><sup>[<a class="sup">30</a>]</sup></citation>利用FlowDroid提取关键路径信息, 然后动态的验证这些信息是否是泄露等工作;静态污点分析的另一大挑战就是流敏感的别名分析, FlowDroid的流敏感的别名分析最初思想来源于Andromeda<citation id="426" type="reference"><link href="381" rel="bibliography" /><sup>[<a class="sup">31</a>]</sup></citation>, 其本质是基于CFL-图可达问题的变体;Sridharan等人<citation id="427" type="reference"><link href="383" rel="bibliography" /><sup>[<a class="sup">32</a>]</sup></citation>尝试将对Java的别名分析转化为CFL-图可达问题;随后又在文献<citation id="428" type="reference">[<a class="sup">33</a>]</citation>中提出了基于精简 (refine-ment) 的优化, 然而, 基于CFL的Java指针分析都是流不敏感的.为了解决流敏感问题, FlowDroid引入了激活点的方法;Boomerang<citation id="429" type="reference"><link href="387" rel="bibliography" /><sup>[<a class="sup">34</a>]</sup></citation>是最近提出的一个面向Java的按需的别名分析工具, 它也是基于IFDS的, 可以支持流敏感和上下文敏感.同样Boomerang也会面临类似的效率问题, 我们认为本文的方法同样适用于Boomerang来提高其分析效率.</p>
                </div>
                <div class="p1">
                    <p id="267">稀疏程序优化方法是目前指针分析领域的重点优化方案.Hardekopf和Lin<citation id="430" type="reference"><link href="339" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>在2009年首次将流敏感的指针分析应用到百万行代码量的程序分析中, 提出了半稀疏的流敏感指针分析方法, 该方法利用部分SSA (partial SSA) 使得本地变量的分析转移到该表示中, 构建了SEG (sparse evaluation graph) 进行具体指针分析;随后Hardekopf<citation id="431" type="reference"><link href="341" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>又利用了流不敏感的分析做为预处理将其扩展成全稀疏的形式;Lhotak和Chung<citation id="432" type="reference"><link href="345" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>的SUPT同样利用全稀疏的SSA表示并提供了强更新 (strong update) 的支持;Li等人<citation id="433" type="reference"><link href="347" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>将图可达的思想引入到值流图 (value flow graph) 中进行按需的流敏感的指针分析优化.然而, 上述的工作都是针对于C/C++语言进行开展的且这些分析往往需要一定的预处理 (SSA或者流不敏感的分析支持) .</p>
                </div>
                <div class="p1">
                    <p id="268">污点分析技术是一类重要的程序分析技术, 如今大量的研究工作应用其解决计算机系统信息的保密性和完整性问题:Mino<citation id="434" type="reference"><link href="389" rel="bibliography" /><sup>[<a class="sup">35</a>]</sup></citation>在硬件级别上扩展了寄存器的标志位来实现污点分析用来进行一些基础漏洞挖掘, 如缓冲区溢出;TAJ<citation id="435" type="reference"><link href="391" rel="bibliography" /><sup>[<a class="sup">36</a>]</sup></citation>工具利用了混合切片的静态分析技术提供Java Web安全漏洞的检测;TaintDroid<citation id="436" type="reference"><link href="393" rel="bibliography" /><sup>[<a class="sup">37</a>]</sup></citation>是当前最流行的动态Android应用隐私泄露检测工具, 它使用的多层次的插桩来完成污点传播.然而, TaintDroid必须在运行时对APK文件进行检测, 这依赖于APK输入测试集合来触发敏感数据流, 且TaintDroid会对Android系统本身带来一定开销, 每次Android版本更新之后, Taint-Droid都需要重新进行定制.CHEX<citation id="437" type="reference"><link href="395" rel="bibliography" /><sup>[<a class="sup">38</a>]</sup></citation>尝试使用静态的污点分析方法检测智能手机组件劫持漏洞;DroidSafe<citation id="438" type="reference"><link href="397" rel="bibliography" /><sup>[<a class="sup">39</a>]</sup></citation>结合Android Open Source Project实现了与原Android接口语义等价的分析模型, 并使用精确分析存根 (accurate analysis stub) 将AOSP代码之外的函数加入到模型, 在此基础上进行污点分析.</p>
                </div>
                <h3 id="269" name="269" class="anchor-tag"><b>7 总结与未来工作</b></h3>
                <div class="p1">
                    <p id="270">本文针对检测移动应用隐私泄露问题的污点分析技术进行性能提升.基于稀疏优化的思想, 本文将传统数据流分析框架扩展成稀疏的形式, 即将数据流值直接传播到其使用点, 避免其在定义点和使用点之间的无关联传播.我们提出了一种特殊的数据结构-变量使用点索引来存储流敏感和域敏感的DEF-USE关系, 并提供快速的构建算法.以此结构为输入, 提供了对应的污点分析技术.另外, 本文还发现基于流敏感和域敏感的DEF-USE关系可以对污点分析中保守子域处理的情况进行有效的剪枝, 可以同时提升其效率和精度.</p>
                </div>
                <div class="p1">
                    <p id="271">最后本文实现了工具FlowDroidSP并进行评测.实验表明, FlowDroidSP在提升性能的同时没有带来精度上的损失.在非剪枝模式下, 可以带来时间加速比4.8倍, 内存消耗降低61.5%, 在剪枝模式下, 可以带来时间加速比18.1倍, 内存消耗降低76.1%, 并且消减了17.7%的误报结果.</p>
                </div>
                <div class="p1">
                    <p id="272">由于IFDS框架分配率的限制, 当前污点分析还不能支持别名之间的强更新, 后续我们将探索如何利用预处理信息提供别名间的强更新.此外, 根据5.4节的实验结果不难得出的结论是当前保守子域问题也是限制污点分析扩展性的瓶颈, 尽管稀疏框架可以对其进行优化剪枝, 但仍然不能完全消除其误报, 未来对保守子域的精确计算也是一个值得研究的方向.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="321">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201710003&amp;v=MDAyNjY0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNy9PTHl2U2RMRzRIOWJOcjQ5Rlo0UUtESDg0dlI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b>Zhang Yuqing, Zhou Wei, Peng Anni. Survey of Internet of things security[J]. Journal of Computer Research and Development, 2017, 54 (10) : 2130- 2143 (in Chinese) (张玉清, 周威, 彭安妮. 物联网安全综述[J]. 计算机研究与发展, 2017, 54 (10) : 2130- 2143) 
                            </a>
                        </p>
                        <p id="323">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Finding security vulnerabilities in Java applications with static analysis">

                                <b>[2]</b>Livshits V, Lam M. Finding security vulnerabilities in Java applications with static analysis[C] //Proc of the 14th USENIX Security Symposium. Berkeley, CA: USENIX Association, 2006: 262- 266
                            </a>
                        </p>
                        <p id="325">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Language-based information-flow security">

                                <b>[3]</b>Sabelfeld A, Myers A C. Language-based information-flow security[J]. IEEE Journal on Selected Areas in Communi-cations, 2003, 21 (1) : 5- 19
                            </a>
                        </p>
                        <p id="327">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJESDA696CBA4A6BE1FDBE45231AA6CD3CBA&amp;v=MDMzOTNkbGh3cnUzd0s0PU5pZk9mY2ZKR05qSzNQMDBZSm9KZmdrNHVXSmhuenQ0U256ajNXTXpDc2FYTnNqdUNPTnZGU2lXV3I3SklGcG1hQnVIWWZPR1FsZkNwYlEzNQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b>Li Li, Bissyandé T F, Papadakis M, et al. Static analysis of android apps: A systematic literature review[J]. Information &amp; Software Technology, 2017, 88: 67- 95
                            </a>
                        </p>
                        <p id="329">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Mining apps for abnormal usage of sensitive data">

                                <b>[5]</b>Avdiienko V, Kuznetsov K, Gorla A, et al. Mining apps for abnormal usage of sensitive data[C] //Proc of the 37th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 426- 436
                            </a>
                        </p>
                        <p id="331">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Flowdroid:Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for android apps">

                                <b>[6]</b>Arzt S, Rasthofer S, Fritz C, et al. FlowDroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps[C] //Proc of the 35th ACM SIGPLAN Conf on Programming Language Design and Implementation. New York: ACM, 2014: 259- 269
                            </a>
                        </p>
                        <p id="333">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=FlowTwist: Efficient context-sensitive inside-out taint analysis for large codebases">

                                <b>[7]</b>Lerch J, Hermann B, Bodden E, et al. FlowTwist: Efficient context-sensitive inside-out taint analysis for large codebases[C] //Proc of the 22nd ACM SIGSOFT Int Symp on Foundations of Software Engineering. New York: ACM, 2014: 98- 108
                            </a>
                        </p>
                        <p id="335">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=TriFlow: Triaging Android applications using speculative information flows">

                                <b>[8]</b>Mirzaei O, Suarez-Tangil G, Tapiador J, et al. TriFlow: Triaging Android applications using speculative information flows[C] //Proc of the 2017 ACM on Asia Conf on Computer and Communications Security. New York: ACM, 2017: 640- 651
                            </a>
                        </p>
                        <p id="337">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=AppContext: Differentiating malicious and benign mobile app behaviors using context">

                                <b>[9]</b>Yang Wei, Xiao Xusheng, Andow B, et al. AppContext: Differentiating malicious and benign mobile app behaviors using context[C] //Proc of the 37th IEEE/ACM Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 303- 313
                            </a>
                        </p>
                        <p id="339">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Semi-sparse flow-sensitive pointer analysis">

                                <b>[10]</b>Hardekopf B, Lin C. Semi-sparse flow-sensitive pointer analysis[C] //Proc of the 36th ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 2009: 226- 238
                            </a>
                        </p>
                        <p id="341">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Pointer Analysis: Building a Foundation for Effective Program Analysis">

                                <b>[11]</b>Hardekopf B. Pointer Analysis: Building a Foundation for Effective Program Analysis[M]. Austin: The University of Texas, 2009
                            </a>
                        </p>
                        <p id="343">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Flow-sensitive Pointer Analysis for Millions of Lines of Code">

                                <b>[12]</b>Hardekopf B, Lin C. Flow-sensitive pointer analysis for millions of lines of code[C] //Proc of the 9th Annual IEEE/ACM Int Symp on Code Generation and Optimization. Piscataway, NJ: IEEE, 2011: 289- 298
                            </a>
                        </p>
                        <p id="345">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Points-to analysis with efficient strong up-dates">

                                <b>[13]</b>Chung K C A. Points-to analysis with efficient strong updates[C] //Proc of the 38th ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 2011: 3- 16
                            </a>
                        </p>
                        <p id="347">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Boosting the performance of flow-sensitive points-to analysis using value flow">

                                <b>[14]</b>Li Lian, Cifuentes C, Keynes N. Boosting the performance of flow-sensitive points-to analysis using value flow[C] //Proc of the 6th Joint Meeting of the European Software Engineering Conf and the ACM SIGSOFT Int Symp on Foundations of Software Engineering. New York: ACM, 2011: 343- 353
                            </a>
                        </p>
                        <p id="349">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000010112&amp;v=MDg0NzNycVFUTW53WmVadUh5am1VYjdJSmwwY2FoUT1OaWZJWTdLN0h0ak5yNDlGWk9vUERYMDdvQk1UNlQ0UFFIL2lyUmRHZQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b>Oh H, Heo K, Lee W, et al. Design and implementation of sparse global analyses for C-like languages[J]. ACM SIGPLAN Notices, 2012, 47 (6) : 229- 238
                            </a>
                        </p>
                        <p id="351">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Region-Based Selective Flow-Sensitive Pointer Analysis">

                                <b>[16]</b>Sui Yulei, Su Yu, Xue Jingling. Region-based selective flow-sensitive pointer analysis[C] //Proc of the 21st Int Static Analysis Symp. Berlin: Springer, 2014: 319- 336
                            </a>
                        </p>
                        <p id="353">
                            <a id="bibliography_17" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Level by level:Making flow-and context-sensitive pointer analysis scalable for millions of lines of code">

                                <b>[17]</b>Yu Hongtao, Xue Jingling, Huo Wei, et al. Level by level: Making flow- and context-sensitive pointer analysis scalable for millions of lines of code[C] //Proc of the 8th Annual IEEE/ACM Int Symp on Code Generation and Optimization. New York: ACM, 2010: 218- 229
                            </a>
                        </p>
                        <p id="355">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Sparse flow-sensitive pointer analysis for multithreaded programs">

                                <b>[18]</b>Sui Yulei, Di Peng, Xue Jingling. Sparse flow-sensitive pointer analysis for multithreaded programs[C] //Proc of the 14th Annual IEEE/ACM Int Symp on Code Generation and Optimization. New York: ACM, 2016: 160- 170
                            </a>
                        </p>
                        <p id="357">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Compilers: Principles, Techniques, and Tools">

                                <b>[19]</b>Aho A V, Sethi R, Ullman J D. Compilers, Principles, Techniques[M]. New York: Addison Wesley, 1986
                            </a>
                        </p>
                        <p id="359">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Precise interprocedural dataflow analysis via graph reachability">

                                <b>[20]</b>Reps T, Horwitz S, Sagiv M. Precise interprocedural dataflow analysis via graph reachability[C] //Proc of the 23rd ACM SIGPLAN-SIGACT Symp on Principles of Programming Languages. New York: ACM, 1994: 49- 61
                            </a>
                        </p>
                        <p id="361">
                            <a id="bibliography_21" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Program analysis via graph reachability">

                                <b>[21]</b>Maluszyski J. Program analysis via graph reachability[C] //Proc of the 14th Int Symp on Logic Programming. Cambridge: MIT Press, 1998: 5- 19
                            </a>
                        </p>
                        <p id="363">
                            <a id="bibliography_22" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The Soot framework for Java program analysis:A retrospective">

                                <b>[22]</b>Lam P, Bodden E, Lhoták O, et al. The Soot framework for Java program analysis: A retrospective[C] //Proc of Cetus Users and Compiler Infrastructure Workshop. New York: ACM, 2011
                            </a>
                        </p>
                        <p id="365">
                            <a id="bibliography_23" >
                                    <b>[23]</b>
                                Litianwuxian Network Technology Co., Ltd. Anzhi App Store[OL].[2017-10-01]. http://www.anzhi.com/applist.html (in Chinese) (北京力天无限网络技术有限公司. 安智网应用市场[OL].[2017-10-01]. http://www.anzhi.com/applist.html) 
                            </a>
                        </p>
                        <p id="367">
                            <a id="bibliography_24" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Practical extensions to the ifds algorithm">

                                <b>[24]</b>Naeem N A, Lhoták O, Rodriguez J. Practical extensions to the IFDS algorithm[C] //Proc of the 19th Annual Int Conf on Compiler Construction. Berlin: Springer, 2010: 124- 144
                            </a>
                        </p>
                        <p id="369">
                            <a id="bibliography_25" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Inter-procedural data-flow analysis with ifds/ide and soot">

                                <b>[25]</b>Bodden E. Inter-procedural data-flow analysis with IFDS/IDE and Soot[C] //Proc of the ACM SIGPLAN Int Workshop on State of the Art in Java Program analysis. New York: ACM, 2012: 3- 8
                            </a>
                        </p>
                        <p id="371">
                            <a id="bibliography_26" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The soot-based toolchain for analyzing Android apps">

                                <b>[26]</b>Arzt S, Rasthofer S, Bodden E. The soot-based toolchain for analyzing android apps[C] //Proc of the 4th Int Conf on Mobile Software Engineering and Systems. Piscataway, NJ: IEEE, 2017: 13- 24
                            </a>
                        </p>
                        <p id="373">
                            <a id="bibliography_27" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A Machine-learning approach for classifying and categorizing Android sources and sinks[C/OL]">

                                <b>[27]</b>Rasthofer S, Arzt S, Bodden E. A Machine-learning approach for classifying and categorizing Android sources and sinks[C/OL] //Proc of the 21st Annual Network and Distributed System Security Symp. 2014 [2017-09-01]. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.432.7534
                            </a>
                        </p>
                        <p id="375">
                            <a id="bibliography_28" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Iccta:Detecting inter-component privacy leaks in android apps">

                                <b>[28]</b>Li Li, Bartel A, Klein J, et al. IccTA: Detecting inter-component privacy leaks in Android apps[C] //Proc of the 37th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2015: 280- 291
                            </a>
                        </p>
                        <p id="377">
                            <a id="bibliography_29" target="_blank" href="http://scholar.cnki.net/result.aspx?q=StubDroid: Automatic inference of precise data-flow summaries for the android framework">

                                <b>[29]</b>Arzt S, Bodden E. StubDroid: Automatic inference of precise data-flow summaries for the android framework[C] //Proc of the 38th Int Conf on Software Engineering. Piscataway, NJ: IEEE, 2016: 725- 735
                            </a>
                        </p>
                        <p id="379">
                            <a id="bibliography_30" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Harvesting runtime values in Android applications that feature anti-analysis techniques[C/OL]">

                                <b>[30]</b>Rasthofer S, Arzt S, Miltenberger M, et al. Harvesting runtime values in Android applications that feature anti-analysis techniques[C/OL] //Proc of the 23rd Annual Network and Distributed System Security Symp. 2016 [2017-09-01]. http://www.bodden.de/pubs/ssme16harvesting.pdf
                            </a>
                        </p>
                        <p id="381">
                            <a id="bibliography_31" target="_blank" href="http://scholar.cnki.net/result.aspx?q=ANDROMEDA:accurate and scalable security analysis of Web applications">

                                <b>[31]</b>Tripp O, Pistoia M, Cousot P, et al. Andromeda: Accurate and scalable security analysis of web applications[C] / /Proc of the 2013 Int Conf on Fundamental Approaches to Software Engineering. Berlin: Springer, 2013: 210- 225
                            </a>
                        </p>
                        <p id="383">
                            <a id="bibliography_32" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000081354&amp;v=MzEzNzBrOW9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVWI3SUpsMGNhaFE9TmlmSVk3SzdIdGpOcjQ5RlpPTU9EMw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[32]</b>Sridharan M, Gopan D, Shan L. Demand-driven points-to analysis for Java[J]. ACM SIGPLAN Notices, 2005, 40 (10) : 59- 76
                            </a>
                        </p>
                        <p id="385">
                            <a id="bibliography_33" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000081460&amp;v=MTMzMDd3WmVadUh5am1VYjdJSmwwY2FoUT1OaWZJWTdLN0h0ak5yNDlGWk9NT0NIbzVvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[33]</b>Sridharan M. Refinement-based context-sensitive points-to analysis for Java[J]. ACM SIGPLAN Notices, 2006, 41 (6) : 387- 400
                            </a>
                        </p>
                        <p id="387">
                            <a id="bibliography_34" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Boomerang: Demand-driven flow-and context-sensitive pointer analysis forJava">

                                <b>[34]</b>Späth J, Do LN, Ali K, Bodden E. Boomerang: Demand-driven flow-and context-sensitive pointer analysis forJava[C] //Proc of the 30th European Conf on Object-Oriented Programming. Dagstuhl: Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2016: 22- 26
                            </a>
                        </p>
                        <p id="389">
                            <a id="bibliography_35" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Minos: Control Data Attack Prevention Orthogonal to Memory Model">

                                <b>[35]</b>Crandall J R, Chong F T. Minos: Control data attack prevention orthogonal to memory model[C] //Proc of the 37th Annual IEEE/ACM Int Symp on Microarchitecture. New York: ACM, 2004: 221- 232
                            </a>
                        </p>
                        <p id="391">
                            <a id="bibliography_36" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Taj: effective taint analysis of web applications">

                                <b>[36]</b>Tripp O, Pistoia M, Fink S J, et al. TAJ: Effective taint analysis of web applications[C] //Proc of the 30th ACM SIGPLAN Conf on Programming Language Design and Implementation. New York: ACM, 2009: 87- 97
                            </a>
                        </p>
                        <p id="393">
                            <a id="bibliography_37" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM14090900001091&amp;v=MjY3MDBUTW53WmVadUh5am1VYjdJSmwwY2FoUT1OaWZJWTdLOEh0ak1wbzlGWk9zT0RIVTRvQk1UNlQ0UFFIL2lyUmRHZXJxUQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[37]</b>Enck W, Gilbert P, Chun B G, et al. TaintDroid: An information flow tracking system for real-time privacy monitoring on smartphones[J]. ACM Transactions on Computer Systems, 2010, 32 (2) : 1- 29
                            </a>
                        </p>
                        <p id="395">
                            <a id="bibliography_38" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Chex:statically vetting android apps for component hijacking vulnerabilities">

                                <b>[38]</b>Lu Long, Li Zhichun, Wu Zhenyu, et al. CHEX: Statically vetting Android apps for component hijacking vulnerabilities[C] //Proc of the 19th ACM Conf on Computer and Communications Security. New York: ACM, 2012: 229- 240
                            </a>
                        </p>
                        <p id="397">
                            <a id="bibliography_39" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Information Flow Analysis of Android Applications in DroidSafe">

                                <b>[39]</b>Gordon M I, Kim D, Perkins J, et al. Information-flow analysis of Android applications in DroidSafe[C/OL] //Proc of the 22nd Annual Network and Distributed System Security Symp. 2015 [2017-09-01]. https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/information-flow-analysis-android-applications-droidsafe
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201903003" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903003&amp;v=MDYxNDM0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNy9PTHl2U2RMRzRIOWpNckk5Rlo0UUtESDg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
