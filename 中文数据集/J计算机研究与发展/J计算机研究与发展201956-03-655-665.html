<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637133238279502500%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201903020%26RESULT%3d1%26SIGN%3dgPUbs5R%252fzrgSyuh7MSiE%252b9dp%252bmQ%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903020&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903020&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903020&amp;v=MTc3MTVIWklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVZ2Rnk3blVyek9MeXZTZExHNEg5ak1ySTk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#62" data-title="&lt;b&gt;1 相关概念&lt;/b&gt; "><b>1 相关概念</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#64" data-title="&lt;b&gt;1.1 基本定义&lt;/b&gt;"><b>1.1 基本定义</b></a></li>
                                                <li><a href="#81" data-title="&lt;b&gt;1.2 簇 集&lt;/b&gt;"><b>1.2 簇 集</b></a></li>
                                                <li><a href="#97" data-title="&lt;b&gt;1.3 关键边&lt;/b&gt;"><b>1.3 关键边</b></a></li>
                                                <li><a href="#114" data-title="&lt;b&gt;1.4 合理性证明&lt;/b&gt;"><b>1.4 合理性证明</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#136" data-title="&lt;b&gt;2 流模式下有向近似覆盖图算法&lt;/b&gt; "><b>2 流模式下有向近似覆盖图算法</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#138" data-title="&lt;b&gt;2.1 算法基本思想&lt;/b&gt;"><b>2.1 算法基本思想</b></a></li>
                                                <li><a href="#144" data-title="&lt;b&gt;2.2 算法描述&lt;/b&gt;"><b>2.2 算法描述</b></a></li>
                                                <li><a href="#246" data-title="&lt;b&gt;2.3 算法分析&lt;/b&gt;"><b>2.3 算法分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#253" data-title="&lt;b&gt;3 实验与分析&lt;/b&gt; "><b>3 实验与分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#254" data-title="&lt;b&gt;3.1 实验环境与方法&lt;/b&gt;"><b>3.1 实验环境与方法</b></a></li>
                                                <li><a href="#258" data-title="&lt;b&gt;3.2 实验结果&lt;/b&gt;"><b>3.2 实验结果</b></a></li>
                                                <li><a href="#273" data-title="&lt;b&gt;3.3 与无向图的对比分析&lt;/b&gt;"><b>3.3 与无向图的对比分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#278" data-title="&lt;b&gt;4 总 结&lt;/b&gt; "><b>4 总 结</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#92" data-title="图1 3类簇集">图1 3类簇集</a></li>
                                                <li><a href="#103" data-title="图2 上簇节点指向上簇节点的簇间边">图2 上簇节点指向上簇节点的簇间边</a></li>
                                                <li><a href="#105" data-title="图3 簇节点指向下簇节点的簇间边">图3 簇节点指向下簇节点的簇间边</a></li>
                                                <li><a href="#248" data-title="图4 ∇结构">图4 ∇结构</a></li>
                                                <li><a href="#264" data-title="图5 不同数据集上的覆盖比例">图5 不同数据集上的覆盖比例</a></li>
                                                <li><a href="#268" data-title="图6 不同数据集上的伸展率">图6 不同数据集上的伸展率</a></li>
                                                <li><a href="#270" data-title="图7 不同数据集上的运行时间">图7 不同数据集上的运行时间</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="303">


                                    <a id="bibliography_1" title="Dong Rongsheng, Zhang Xinkai, Liu Huadong, et al. Representation and operations research of k2-MDD in large-scale graph data[J]. Journal of Computer Research and Development, 2016, 52 (12) : 2783- 2792 (in Chinese) (董荣胜, 张新凯, 刘华东, 等. 大规模图数据的k2-MDD表示方法与操作研究[J]. 计算机研究与发展, 2016, 52 (12) : 2783- 2792) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201612009&amp;v=MDcxMDdUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVZ2Rnk3blVyek9MeXZTZExHNEg5Zk5yWTlGYllRS0RIODR2UjQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                        Dong Rongsheng, Zhang Xinkai, Liu Huadong, et al. Representation and operations research of k2-MDD in large-scale graph data[J]. Journal of Computer Research and Development, 2016, 52 (12) : 2783- 2792 (in Chinese) (董荣胜, 张新凯, 刘华东, 等. 大规模图数据的k2-MDD表示方法与操作研究[J]. 计算机研究与发展, 2016, 52 (12) : 2783- 2792) 
                                    </a>
                                </li>
                                <li id="305">


                                    <a id="bibliography_2" title="Baswana S, Kavitha T, Mehlhorn K, et al. New constructions of (α, β) -spanners and purely additive spanners[C] //Proc of the 16th ACM-SIAM Symp on Discrete Algorithms. Philadelphia: SIAM, 2005: 672- 681" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=New constructions of (α, β)-spanners and purely additive spanners">
                                        <b>[2]</b>
                                        Baswana S, Kavitha T, Mehlhorn K, et al. New constructions of (α, β) -spanners and purely additive spanners[C] //Proc of the 16th ACM-SIAM Symp on Discrete Algorithms. Philadelphia: SIAM, 2005: 672- 681
                                    </a>
                                </li>
                                <li id="307">


                                    <a id="bibliography_3" title="Baswana S, Sen S. A simple linear time algorithm for computing (2k-1) -spanner of O (n1+1/k) size for weighted graphs[C] //Proc of the 30th Int Conf on Automata, Languages and Programming. Berlin: Springer, 2003: 384- 396" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A simple linear time algorithm for computing (2k-1)-spanner of O(n1+1/k) size for weighted graphs">
                                        <b>[3]</b>
                                        Baswana S, Sen S. A simple linear time algorithm for computing (2k-1) -spanner of O (n1+1/k) size for weighted graphs[C] //Proc of the 30th Int Conf on Automata, Languages and Programming. Berlin: Springer, 2003: 384- 396
                                    </a>
                                </li>
                                <li id="309">


                                    <a id="bibliography_4" title="Roditty L, Thorup M, Zwick U. Deterministic constructions of approximate distance oracles and spanners [C] //Proc of the 32nd Int Conf on Automata, Languages and Programming. Berlin: Springer, 2005: 261- 272" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Deterministic constructions of approximate distance oracles and spanners">
                                        <b>[4]</b>
                                        Roditty L, Thorup M, Zwick U. Deterministic constructions of approximate distance oracles and spanners [C] //Proc of the 32nd Int Conf on Automata, Languages and Programming. Berlin: Springer, 2005: 261- 272
                                    </a>
                                </li>
                                <li id="311">


                                    <a id="bibliography_5" title="Ausiello G, Franciosa P G, Italiano G F. Small stretch spanners on dynamic graphs[J]. Journal of Graph Algorithms and Applications, 2005, 10 (2) : 365- 385" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Small stretch spanners on dynamic graphs">
                                        <b>[5]</b>
                                        Ausiello G, Franciosa P G, Italiano G F. Small stretch spanners on dynamic graphs[J]. Journal of Graph Algorithms and Applications, 2005, 10 (2) : 365- 385
                                    </a>
                                </li>
                                <li id="313">


                                    <a id="bibliography_6" title="Baswana S. Dynamic algorithms for graph spanners[C] //Proc of the 14th European Symp on Algorithms. Berlin: Springer, 2006: 76- 87" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Dynamic algorithms for graph spanners">
                                        <b>[6]</b>
                                        Baswana S. Dynamic algorithms for graph spanners[C] //Proc of the 14th European Symp on Algorithms. Berlin: Springer, 2006: 76- 87
                                    </a>
                                </li>
                                <li id="315">


                                    <a id="bibliography_7" title="Gottlieb L A, Roditty L. An optimal dynamic spanner for doubling metric spaces[C] //Proc of the 16th European Symp on Algorithms. Berlin: Springer, 2008: 478- 489" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An optimal dynamic spanner for doubling metric spaces">
                                        <b>[7]</b>
                                        Gottlieb L A, Roditty L. An optimal dynamic spanner for doubling metric spaces[C] //Proc of the 16th European Symp on Algorithms. Berlin: Springer, 2008: 478- 489
                                    </a>
                                </li>
                                <li id="317">


                                    <a id="bibliography_8" title="Feigenbaum J, Kannan S, Mcgregor A, et al. Graph distances in the streaming model: The value of space[C] //Proc of the 16th ACM-SIAM Symp on Discrete Algorithms. Philadelphia: SIAM, 2005: 745- 754" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Graph distances in the streaming model: The value of space">
                                        <b>[8]</b>
                                        Feigenbaum J, Kannan S, Mcgregor A, et al. Graph distances in the streaming model: The value of space[C] //Proc of the 16th ACM-SIAM Symp on Discrete Algorithms. Philadelphia: SIAM, 2005: 745- 754
                                    </a>
                                </li>
                                <li id="319">


                                    <a id="bibliography_9" title="Baswana S. Faster streaming algorithms for graph apanners [EB/OL]. [2017-09-10]. http://arxiv.org/abs/cs/0611023v1" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Faster streaming algorithms for graph apanners">
                                        <b>[9]</b>
                                        Baswana S. Faster streaming algorithms for graph apanners [EB/OL]. [2017-09-10]. http://arxiv.org/abs/cs/0611023v1
                                    </a>
                                </li>
                                <li id="321">


                                    <a id="bibliography_10" title="Ausiello G, Franciosa P G, Italiano G F. Small stretch (α, β) -spanners in the streaming model[J]. Theoretical Computer Science, 2009, 410 (36) : 3406- 3413" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012100980148&amp;v=MDI5NjlNbndaZVp1SHlqbVViN0lKbHdWYVJRPU5pZk9mYks3SHRET3JvOUZiZU1QRFhneG9CTVQ2VDRQUUgvaXJSZEdlcnFRVA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                        Ausiello G, Franciosa P G, Italiano G F. Small stretch (α, β) -spanners in the streaming model[J]. Theoretical Computer Science, 2009, 410 (36) : 3406- 3413
                                    </a>
                                </li>
                                <li id="323">


                                    <a id="bibliography_11" title="Wang Weifu, Balkcom D, Chakrabarti A. A fast streaming spanner algorithm for incrementally constructing sparse roadmaps[C] //Proc of the 25th IEEE/RSJ Int Conf on Intelligent Robots and Systems. Piscataway, NJ: IEEE, 2013: 1257- 1263" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A fast streaming spanner algorithm for incrementally constructing sparse roadmaps">
                                        <b>[11]</b>
                                        Wang Weifu, Balkcom D, Chakrabarti A. A fast streaming spanner algorithm for incrementally constructing sparse roadmaps[C] //Proc of the 25th IEEE/RSJ Int Conf on Intelligent Robots and Systems. Piscataway, NJ: IEEE, 2013: 1257- 1263
                                    </a>
                                </li>
                                <li id="325">


                                    <a id="bibliography_12" title="Liebchen C, W&#252;nsch G. The zoo of tree spanner problems[J]. Discrete Applied Mathematics, 2008, 156 (5) : 569- 587" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300574635&amp;v=MDEwMTR3VmFSUT1OaWZPZmJLN0h0RE9ySTlGWWV3TENuODhvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVViN0lKbA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[12]</b>
                                        Liebchen C, W&#252;nsch G. The zoo of tree spanner problems[J]. Discrete Applied Mathematics, 2008, 156 (5) : 569- 587
                                    </a>
                                </li>
                                <li id="327">


                                    <a id="bibliography_13" title="Dragan F F, Abu-Ata M. Collective additive tree spanners of bounded tree-breadth graphs with generalizations and consequences [J]. Theoretical Computer Science, 2014, 547 (27) : 1- 17" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES14110700233259&amp;v=MDcxNTVGWnVnTURua3dvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVViN0lKbHdWYVJRPU5pZk9mYks4SDlETXFJOQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                        Dragan F F, Abu-Ata M. Collective additive tree spanners of bounded tree-breadth graphs with generalizations and consequences [J]. Theoretical Computer Science, 2014, 547 (27) : 1- 17
                                    </a>
                                </li>
                                <li id="329">


                                    <a id="bibliography_14" title="Bil&#242; D, Colella F, Gual&#224; L, et al. A faster computation of all the best swap edges of a tree spanner[C] //Proc of the 22nd Int Colloquium on Structural Information and Communication Complexity. Berlin: Springer, 2015: 239- 253" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A faster computation of all the best swap edges of a tree spanner">
                                        <b>[14]</b>
                                        Bil&#242; D, Colella F, Gual&#224; L, et al. A faster computation of all the best swap edges of a tree spanner[C] //Proc of the 22nd Int Colloquium on Structural Information and Communication Complexity. Berlin: Springer, 2015: 239- 253
                                    </a>
                                </li>
                                <li id="331">


                                    <a id="bibliography_15" title="Roditty L, Thorup M, Zwick U. Roundtrip spanners and roundtrip routing in directed graphs[J]. ACM Transactions on Algorithms, 2008, 4 (3) : 29:1- 29:17" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000090693&amp;v=MDE3MTFOcjQ5RlpPSVBDblU2b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VYjdJSmx3VmFSUT1OaWZJWTdLN0h0ag==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                        Roditty L, Thorup M, Zwick U. Roundtrip spanners and roundtrip routing in directed graphs[J]. ACM Transactions on Algorithms, 2008, 4 (3) : 29:1- 29:17
                                    </a>
                                </li>
                                <li id="333">


                                    <a id="bibliography_16" title="Pachocki J, Roditty L, Sidford A, et al. Approximating cycles in directed graphs: Fast algorithms for girth and roundtrip spanners[C] //Proc of the 29th ACM-SIAM Symp on Discrete Algorithms. New York: ACM, 2018: 1374- 1392" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Approximating cycles in directed graphs: Fast algorithms for girth and roundtrip spanners">
                                        <b>[16]</b>
                                        Pachocki J, Roditty L, Sidford A, et al. Approximating cycles in directed graphs: Fast algorithms for girth and roundtrip spanners[C] //Proc of the 29th ACM-SIAM Symp on Discrete Algorithms. New York: ACM, 2018: 1374- 1392
                                    </a>
                                </li>
                                <li id="335">


                                    <a id="bibliography_17" title="Zhu Chunjiang, Lam K Y. Source-wise round-trip spanners[J]. Information Processing Letters, 2017, 124 (8) : 42- 45" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES786E1783E0F1AD9C542FA97EC0A0C0CF&amp;v=MTk2MDVLVE5xSWRHRWV0NURRMU54bVVXN2owTE9YYmwyV0UxQ0xMblJjbnBDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVkbGh3cnErdzY0PU5pZk9mYlN3Rw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                        Zhu Chunjiang, Lam K Y. Source-wise round-trip spanners[J]. Information Processing Letters, 2017, 124 (8) : 42- 45
                                    </a>
                                </li>
                                <li id="337">


                                    <a id="bibliography_18" title="Peleg D, Roditty L. Localized spanner construction for ad hoc networks with variable transmission range[J]. ACM Transactions on Sensor Networks, 2010, 7 (3) : 25:1- 25:14" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000103514&amp;v=MTk5NzF3WmVadUh5am1VYjdJSmx3VmFSUT1OaWZJWTdLN0h0ak5yNDlGWmVzTUNYMDlvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[18]</b>
                                        Peleg D, Roditty L. Localized spanner construction for ad hoc networks with variable transmission range[J]. ACM Transactions on Sensor Networks, 2010, 7 (3) : 25:1- 25:14
                                    </a>
                                </li>
                                <li id="339">


                                    <a id="bibliography_19" title="Kaplan H, Mulzer W, Roditty L, et al. Spanners and reachability oracles for directed transmission graphs[C] //Proc of the 31st Int Symp on Computational Geometry. Wadern, Saarland, Germany: Dagstuhl, 2015: 156- 170" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Spanners and reachability oracles for directed transmission graphs">
                                        <b>[19]</b>
                                        Kaplan H, Mulzer W, Roditty L, et al. Spanners and reachability oracles for directed transmission graphs[C] //Proc of the 31st Int Symp on Computational Geometry. Wadern, Saarland, Germany: Dagstuhl, 2015: 156- 170
                                    </a>
                                </li>
                                <li id="341">


                                    <a id="bibliography_20" title="Adamic L A, Huberman B A, Barab&#225;si A L, et al. Power-law distribution of the world wide web[J]. Science, 2000, 287 (5461) : 2115" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Power-Law Distribution of the World Wide Web">
                                        <b>[20]</b>
                                        Adamic L A, Huberman B A, Barab&#225;si A L, et al. Power-law distribution of the world wide web[J]. Science, 2000, 287 (5461) : 2115
                                    </a>
                                </li>
                                <li id="343">


                                    <a id="bibliography_21" title="Liu Dayou, Jin Di, He Xiaodong, et al. Community mining in complex network[J]. Journal of Computer Research and Development, 2013, 50 (10) : 2140- 2154 (in Chinese) (刘大有, 金弟, 何东晓, 等. 复杂网络社区挖掘综述[J]. 计算机研究与发展, 2013, 50 (10) : 2140- 2154) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201310012&amp;v=MjQ1ODVMT2VaZVZ2Rnk3blVyek9MeXZTZExHNEg5TE5yNDlFWm9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[21]</b>
                                        Liu Dayou, Jin Di, He Xiaodong, et al. Community mining in complex network[J]. Journal of Computer Research and Development, 2013, 50 (10) : 2140- 2154 (in Chinese) (刘大有, 金弟, 何东晓, 等. 复杂网络社区挖掘综述[J]. 计算机研究与发展, 2013, 50 (10) : 2140- 2154) 
                                    </a>
                                </li>
                                <li id="345">


                                    <a id="bibliography_22" title="Boccaletti S, Bianconi G, Criado R, et al. The structure and dynamics of multilayer networks[J]. Physics Reports, 2014, 544 (1) : 1- 122" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The structure and dynamics of multilayer networks">
                                        <b>[22]</b>
                                        Boccaletti S, Bianconi G, Criado R, et al. The structure and dynamics of multilayer networks[J]. Physics Reports, 2014, 544 (1) : 1- 122
                                    </a>
                                </li>
                                <li id="347">


                                    <a id="bibliography_23" title="Chakrabarti D, Zhan Yiping, Faloutsos C. R-MAT: A recursive model for graph mining[C] //Proc of the 4th SIAM Int Conf on Data Mining. Philadelphia: SIAM, 2004: 442- 446" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=R-mat:A recursive model for graph mining">
                                        <b>[23]</b>
                                        Chakrabarti D, Zhan Yiping, Faloutsos C. R-MAT: A recursive model for graph mining[C] //Proc of the 4th SIAM Int Conf on Data Mining. Philadelphia: SIAM, 2004: 442- 446
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(03),655-665 DOI:10.7544/issn1000-1239.2019.20170680            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>流模式下有向近似覆盖图算法研究</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BC%A0%E6%98%95&amp;code=24226109&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张昕</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9D%8E%E6%99%93%E5%85%89&amp;code=11026953&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">李晓光</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E8%BE%BD%E5%AE%81%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%99%A2&amp;code=0033169&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">辽宁大学信息学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>随着社交网络、交通网络、生物信息网等领域的分析需求快速增长, 大规模图数据的处理逐渐成为信息技术领域新的挑战.近似覆盖图技术可以通过选取原图的子图, 同时保证子图中任意节点间距离的增加在覆盖因子的约束范围内, 从而降低大规模图存储与计算开销.当前相关工作主要研究无向图的近似覆盖图技术, 针对于此, 提出一种有向近似覆盖图算法, 重新定义了簇集以及簇边、桥边、自由边3类关建边, 并理论分析基于3类关键边的 (3, 2) 近似覆盖图构建正确性.在此基础上, 给出图数据以流模式到达时的近似覆盖图计算算法.算法通过判断边端点的类型进行边的积累聚簇及更新, 进而得到全图近似覆盖结果, 算法空间复杂度为<i>O</i> (<image id="366" type="formula" href="images/JFYZ201903020_36600.jpg" display="inline" placement="inline"><alt></alt></image>) .最后以基于幂率模型的人工数据集为实验对象, 验证算法满足覆盖因子 (3, 2) 的有向近似覆盖图定义, 且空间与时间开销较小.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%9C%89%E5%90%91%E5%9B%BE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">有向图;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%BF%91%E4%BC%BC%E8%A6%86%E7%9B%96%E5%9B%BE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">近似覆盖图;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%A6%86%E7%9B%96%E5%9B%A0%E5%AD%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">覆盖因子;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%81%9A%E7%B0%87&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">聚簇;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%95%B0%E6%8D%AE%E6%B5%81&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">数据流;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    *李晓光, xgli@lnu.edu.cn;
                                </span>
                                <span>
                                    张昕, zhangxin1979@hotmail.com;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2017-09-15</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目 (U1811261, 61802160);</span>
                                <span>辽宁省公共舆情与网络安全大数据系统工程实验室基金项目 (2016-294);</span>
                    </p>
            </div>
                    <h1><b>Spanner Algorithm for Directed Graph Stream</b></h1>
                    <h2>
                    <span>Zhang Xin</span>
                    <span>Li Xiaoguang</span>
            </h2>
                    <h2>
                    <span>College of Information, Liaoning University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>With the rapid growth of analysis demand in many fields such as social network, transportation network, and bioinformatics network, the processing of large-scale graph data has become a new challenge of information technology. Graph spanner is a subgraph in which the distance between every pair of vertices falling into the given range defined by stretch factor. With the spanner, the storage and computational cost are reduced greatly for large-scale graph data processing. Most of existing research work focused on the spanner on undirected graph, and we propose an effective algorithm for directed graph spanner. Firstly, we re-define the concept of cluster set and three kinds of crucial edges including cluster edge, bridge edge and free edge, and analyze theoretically the correctness of (3, 2) -spanner construction based on the crucial edges. Moreover, we propose a spanner algorithm for graph data in streaming model in which the edges is clustered and updated according to the type of end-point of edge, and then a (3, 2) -spanner of full graph is constructed. Finally, we provide the theoretical analysis of space complexity <i>O</i> (<image id="297" type="formula" href="images/JFYZ201903020_29700.jpg" display="inline" placement="inline"><alt></alt></image>) , and present the experiments on the synthetic graph of power law model. Experiment results show our algorithm meet the definition of (3, 2) -spanner, and has low time and space overhead.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=directed%20graph&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">directed graph;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=spanner&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">spanner;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=stretch%20factor&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">stretch factor;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=cluster&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">cluster;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=data%20stream&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">data stream;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Zhang Xin, born in 1979.PhD, associate professor, member of CCF.His main research interests include data mining and complex network.<image id="300" type="formula" href="images/JFYZ201903020_30000.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Li Xiaoguang, born in 1973.PhD, professor, member of CCF.His main research interests include database theory, data mining, and machine learning.<image id="301" type="formula" href="images/JFYZ201903020_30100.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2017-09-15</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Natural Science Foundation of China (U1811261, 61802160);</span>
                                <span>the Project of Liaoning Provincial Engineering Laboratory of Big Data System of Public Opinion and Network Security (2016-294);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="53">图作为一种重要的数据结构, 一直有着广泛的应用, 特别是随着信息技术的发展, 在诸如通信网络中路由选择与资源优化、社交网络中用户关系与兴趣点分析、交通网络分析以及计算几何学与计算生物学等重要应用领域中, 大量的数据均以图结构作为抽象对象, 进而开展各种复杂的计算与分析研究<citation id="349" type="reference"><link href="303" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>.因此, 大规模图数据相关研究逐渐成为许多研究与应用领域的一项重要的基础性工作.但由于数据量的飞速增长, 以及图结构自身的复杂性, 大规模图数据的存储与计算代价通常较高, 很难高效地支撑后续的研究应用工作.</p>
                </div>
                <div class="p1">
                    <p id="54">针对这种情况, 研究人员进行了大量相关工作, 其中求解近似覆盖图是目前一种代表性的研究方法, 得到广泛的关注.该方法通过近似解代替精确解, 以此降低存储精度需求, 进而降低存储与计算代价.考虑到在许多应用中, 对图中节点间连接信息的需求精度不高, 可以在保持节点间连通性的前提下删除大量边, 仅保留节点间近似的路径长度, 形成对原图的一种近似覆盖.这种方法通常以2个参数<i>α</i>与<i>β</i>约束近似图与原图中节点间路径长度的变化程度, 称为原图的 (<i>α</i>, <i>β</i>) -覆盖.文献<citation id="350" type="reference">[<a class="sup">2</a>]</citation>提出一种确定性算法, 可以获得 (<i>k</i>, <i>k</i>-1) -覆盖, 该算法适用于无向无权图, 其时间复杂度为<i>O</i> (<i>m</i>+<i>n</i>) , 空间复杂度为<i>O</i> (<i>k</i>×<i>n</i><sup>1+1/<i>k</i></sup>) , 其中<i>n</i>与<i>m</i>分别为图数据中节点与边的数量.同时, 该文献还证明了对于无向图的 (1, 6) -覆盖, 在空间复杂度为<i>O</i> (<i>n</i><sup>4/3</sup>) 的情况下, 都能够在时间复杂度最高为<i>O</i> (<i>mn</i>) .文献<citation id="351" type="reference">[<a class="sup">3</a>]</citation>提出一种适用于加权无向图的随机性算法, 该算法可以获得 (2<i>k</i>-1, 0) -覆盖, 其时间复杂度为<i>O</i> (<i>m</i>+<i>n</i>) , 空间复杂度为<i>O</i> (<i>k</i>×<i>n</i><sup>1+1/<i>k</i></sup>) .文献<citation id="352" type="reference">[<a class="sup">4</a>]</citation>则提出了与文献<citation id="353" type="reference">[<a class="sup">3</a>]</citation>相同使用环境与目标的非随机性算法, 其时间复杂度也同样为<i>O</i> (<i>m</i>+<i>n</i>) .</p>
                </div>
                <div class="p1">
                    <p id="55">较早的研究工作多集中针对静态无向图, 考虑到数据的动态变化, 特别是边的插入与删除, 文献<citation id="354" type="reference">[<a class="sup">5</a>]</citation>提出的方法可以在<i>O</i> (<i>n</i>) 条边的插入与删除过程中, 获得 (3, 0) -覆盖与 (5, 0) -覆盖, 处理每次边变化的时间复杂度与原图最大度值呈线性关系, 算法所得到 (3, 0) -覆盖边数为<i>O</i> (<i>n</i><sup>3/2</sup>) , 而 (5, 0) -覆盖边数则为<i>O</i> (<i>n</i><sup>4/3</sup>) .文献<citation id="355" type="reference">[<a class="sup">6</a>]</citation>提出了一种可更加快速获得 (2<i>k</i>-1, 0) -覆盖的随机动态算法, 空间复杂度为<i>O</i> (<i>k</i>×<i>n</i><sup>1+1/<i>k</i></sup>) , 处理每次边变化的时间复杂度为<i>O</i> (<i>m</i>/<i>n</i><sup>1+1/<i>k</i></sup>) .文献<citation id="356" type="reference">[<a class="sup">7</a>]</citation>提出的方法能够动态构造 (1+<i>ε</i>) -覆盖, 其更新时间为<i>O</i> (log <i>n</i>) , 其中<i>ε</i>为常数参数.</p>
                </div>
                <div class="p1">
                    <p id="56">随着数据量级以及变化速度的不断增大, 流模式下近似覆盖图的计算逐渐成为研究热点.文献<citation id="357" type="reference">[<a class="sup">8</a>]</citation>提出了一种适用于无向无权图的随机算法, 该算法仅通过1次扫描可以获得 (2<i>k</i>+1, 0) -覆盖, 其空间大小为<i>O</i> (<i>k</i>×<i>n</i><sup>1+1/<i>k</i></sup>) , 平均处理1条边的时间为<i>O</i> (<i>k</i><sup>2</sup>×<i>n</i><sup>1/<i>k</i></sup>×log <i>n</i>) , 所需内存大小为<i>O</i> (<i>k</i><sup>2</sup>×<i>n</i><sup>1/<i>k</i></sup>×log <i>n</i>) 字节.文献<citation id="358" type="reference">[<a class="sup">9</a>]</citation>提出的方法可以通过1次扫描获得空间大小为<i>O</i> (<i>k</i>×<i>n</i><sup>1+1/<i>k</i></sup>) 的 (2<i>k</i>-1, 0) -覆盖, 其整体时间复杂度为<i>O</i> (<i>m</i>+<i>n</i>) , 所需内存大小为<i>O</i> (<i>k</i>×<i>n</i><sup>1+1/<i>k</i></sup>) .文献<citation id="359" type="reference">[<a class="sup">10</a>]</citation>提出了一种非严格流模式下的算法, 该算法假定数据传输以块的模式进行, 内存中保留与节点有关的信息, 算法所需的内存大小为<i>O</i> (<i>n</i>) , 所需外部存储块为<i>O</i> (<i>n</i><sup>4/3</sup>/<i>B</i>) , 其中<i>B</i>是外部存储块的大小.文献<citation id="360" type="reference">[<a class="sup">11</a>]</citation>提出基于采样的流模式近似覆盖图算法, 该算法对每条边的平均处理时间为<i>O</i> (max{<i>l</i>/log <i>n</i>, 1}) , 其中<i>l</i>为子图数量.</p>
                </div>
                <div class="p1">
                    <p id="57">近年来, 基于其他覆盖形式以及不同距离含义的研究也得到一定程度的关注, 例如图的近似树形覆盖<citation id="361" type="reference"><link href="325" rel="bibliography" /><link href="327" rel="bibliography" /><link href="329" rel="bibliography" /><sup>[<a class="sup">12</a>,<a class="sup">13</a>,<a class="sup">14</a>]</sup></citation>以及有向图环境下基于往返距离<citation id="362" type="reference"><link href="331" rel="bibliography" /><link href="333" rel="bibliography" /><link href="335" rel="bibliography" /><sup>[<a class="sup">15</a>,<a class="sup">16</a>,<a class="sup">17</a>]</sup></citation>与平面距离的近似覆盖图<citation id="363" type="reference"><link href="337" rel="bibliography" /><link href="339" rel="bibliography" /><sup>[<a class="sup">18</a>,<a class="sup">19</a>]</sup></citation>等.综合看来, 目前的研究工作大多集中于无向图环境, 有少量针对有向图的研究, 但其侧重点以及应用环境与传统方法相比差异较大.本文针对有向图环境, 研究基于传统距离含义的近似覆盖图计算, 定义相关概念, 进而给出具体算法, 并通过理论分析以及实验, 说明算法的有效性.</p>
                </div>
                <div class="p1">
                    <p id="58">本文的主要工作有3个方面:</p>
                </div>
                <div class="p1">
                    <p id="59">1) 针对有向图特点, 重新定义近似覆盖图的相关概念, 包括簇集以及簇边、桥边、自由边这3类关键边;</p>
                </div>
                <div class="p1">
                    <p id="60">2) 分析了求解近似覆盖图过程中, 簇集的形成、3类关键边的确定以及关键边类型可能发生的转化, 论证了3类关键边形成的子图满足覆盖因子为 (3, 2) 的近似覆盖图定义;</p>
                </div>
                <div class="p1">
                    <p id="61">3) 给出了在流模式下求解有向图近似覆盖的算法, 依据在模拟数据集上的实验结果, 对该算法进行了定量分析, 并与无向图近似覆盖算法进行了定性对比分析, 综合说明算法较佳的时空效率.</p>
                </div>
                <h3 id="62" name="62" class="anchor-tag"><b>1 相关概念</b></h3>
                <div class="p1">
                    <p id="63">本节给出有向图的近似覆盖图计算所需相关定义的形式化描述, 并论证其合理性.</p>
                </div>
                <h4 class="anchor-tag" id="64" name="64"><b>1.1 基本定义</b></h4>
                <div class="p1">
                    <p id="65">本文所需基础定义为图<i>G</i>= (<i>V</i>, <i>E</i>) , 其中, </p>
                </div>
                <div class="p1">
                    <p id="66"><i>V</i>:图中节点的集合;</p>
                </div>
                <div class="p1">
                    <p id="67"><i>E</i>:图中边 (节点对间的连接) 的集合;</p>
                </div>
                <div class="p1">
                    <p id="68">&lt;<i>e</i><sub>1</sub>, <i>e</i><sub>2</sub>&gt;∈<i>E</i>:有向图中节点<i>e</i><sub>1</sub>到节点<i>e</i><sub>2</sub>的有向边, <i>e</i><sub>1</sub>称为边的始点, <i>e</i><sub>2</sub>称为边的终点, <i>e</i><sub>1</sub>称为<i>e</i><sub>2</sub>的前趋节点, <i>e</i><sub>2</sub>称为<i>e</i><sub>1</sub>的后继节点;</p>
                </div>
                <div class="p1">
                    <p id="69"><i>deg</i> (<i>v</i>) :图中与节点<i>v</i> (<i>v</i>∈<i>V</i>) 连接的边数, 称为该节点的度;</p>
                </div>
                <div class="p1">
                    <p id="70"><i>deg</i>_<i>in</i> (<i>v</i>) :有向图中射入节点<i>v</i>的边数, 称为该节点的入度;</p>
                </div>
                <div class="p1">
                    <p id="71"><i>deg</i>_<i>out</i> (<i>v</i>) :有向图中由节点<i>v</i>射出的边数, 称为该节点的出度;</p>
                </div>
                <div class="p1">
                    <p id="72"><i>d</i> (<i>u</i>, <i>v</i>) :图中节点<i>u</i>到<i>v</i>经过最少的边数, 称为节点对 (<i>u</i>, <i>v</i>) 间的距离.若<i>u</i>到<i>v</i>之间不存在连通路径, 记距离<i>d</i> (<i>u</i>, <i>v</i>) 为正无穷.无向图中<i>d</i> (<i>u</i>, <i>v</i>) =<i>d</i> (<i>v</i>, <i>u</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="73"><i>Pre</i> (<i>x</i>) :节点<i>x</i>所有前趋节点的集合, 即对于任意的节点<i>a</i>, 若&lt;<i>a</i>, <i>x</i>&gt;∈<i>E</i>, 则<i>a</i>∈<i>Pre</i> (<i>x</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="74"><i>Next</i> (<i>x</i>) :节点<i>x</i>所有后继节点的集合, 即对于任意的节点<i>b</i>, 若&lt;<i>x</i>, <i>b</i>&gt;∈<i>E</i>, 则<i>b</i>∈<i>Next</i> (<i>x</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="75"><i>N</i> (<i>x</i>) :节点<i>x</i>的邻节点集合, 且包含<i>x</i>自身.</p>
                </div>
                <div class="p1">
                    <p id="76">图<i>G</i>的近似覆盖图是一个与图<i>G</i>拥有相同的节点集合的子图, 且该子图保存了图<i>G</i>中任意节点对之间距离的近似.</p>
                </div>
                <div class="p1">
                    <p id="77"><b>定义1</b>. 近似覆盖图.设图<i>G</i>= (<i>V</i>, <i>E</i>) , 给定参数<i>α</i>≥1, <i>β</i>≥0, 若对于<i>G</i>′= (<i>V</i>, <i>E</i>′) 中任意的节点对 (<i>u</i>, <i>v</i>) , 均满足:</p>
                </div>
                <div class="p1">
                    <p id="78"><i>d</i>′ (<i>u</i>, <i>v</i>) ≤<i>d</i> (<i>u</i>, <i>v</i>) ×<i>α</i>+<i>β</i>, (1) </p>
                </div>
                <div class="p1">
                    <p id="79">则称子图<i>G</i>′是图<i>G</i>的近似覆盖图, 记作 (<i>α</i>, <i>β</i>) -覆盖, 参数<i>α</i>与<i>β</i>称为覆盖因子.</p>
                </div>
                <div class="p1">
                    <p id="80">式 (1) 中<i>d</i>′ (<i>u</i>, <i>v</i>) 表示节点对 (<i>u</i>, <i>v</i>) 在<i>G</i>′中的距离.依参数<i>α</i>=1或参数<i>β</i>=0, 称对应的近似覆盖图为简单加性近似覆盖图或简单乘积近似覆盖图.若参数<i>α</i>与<i>β</i>取值过小, 则近似覆盖图与原图的差异不大, 降低存储计算开销的作用不明显, 而参数<i>α</i>与<i>β</i>取值过大的话, 则相对原图来说细节损失过多, 不适合进一步的计算分析.因此, 适当的参数选取才能够较为充分地发挥近似覆盖图的作用.参考现有研究工作的参数选择, 本文设定覆盖因子<i>α</i>=3, <i>β</i>=2, 即计算图<i>G</i>的 (3, 2) -覆盖.</p>
                </div>
                <h4 class="anchor-tag" id="81" name="81"><b>1.2 簇 集</b></h4>
                <div class="p1">
                    <p id="82">本文算法基本思路为获得原图的一个适当的聚簇结果, 有选择地删除簇内及簇间的部分边, 由此得到原图的一个近似覆盖.本节给出簇集以及相关定义如下.</p>
                </div>
                <div class="p1">
                    <p id="83"><b>定义2</b>. 簇集.令<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>k</i></sub>为节点集<i>V</i>中的若干节点, 取其中每个节点前驱集与后继集的不小于<i>l</i>的子集, 分别合并为<i>k</i>个集合, 即:</p>
                </div>
                <div class="p1">
                    <p id="84"><i>Up</i> (<i>x</i><sub><i>i</i></sub>) ⊆<i>Pre</i> (<i>x</i><sub><i>i</i></sub>) , |<i>Up</i> (<i>x</i><sub><i>i</i></sub>) |≥<i>l</i>, (2) </p>
                </div>
                <div class="p1">
                    <p id="85"><i>Down</i> (<i>x</i><sub><i>i</i></sub>) ⊆<i>Next</i> (<i>x</i><sub><i>i</i></sub>) , |<i>Down</i> (<i>x</i><sub><i>i</i></sub>) |≥<i>l</i>, (3) </p>
                </div>
                <div class="p1">
                    <p id="86"><i>Cl</i> (<i>x</i><sub><i>i</i></sub>) =<i>Up</i> (<i>x</i><sub><i>i</i></sub>) ∪<i>Down</i> (<i>x</i><sub><i>i</i></sub>) ∪{<i>x</i><sub><i>i</i></sub>}, (4) </p>
                </div>
                <div class="p1">
                    <p id="87">其中, <i>k</i>≥1, <i>l</i>≥1且1≤<i>i</i>≤<i>k</i>, 若满足:</p>
                </div>
                <div class="p1">
                    <p id="88"><mathml id="89"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∪</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>C</mi></mstyle><mi>l</mi><mo stretchy="false"> (</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∪</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>Ν</mi></mstyle><mo stretchy="false"> (</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></math></mathml>, (5) </p>
                </div>
                <div class="p1">
                    <p id="90">则称这些集合{<i>Cl</i> (<i>x</i><sub><i>i</i></sub>) }为图<i>G</i>的<i>l</i>类簇集.</p>
                </div>
                <div class="p1">
                    <p id="91">图<i>G</i>的<i>l</i>类簇集中, 称每个集合<i>Cl</i> (<i>x</i><sub><i>i</i></sub>) 为簇, 节点<i>x</i><sub><i>i</i></sub>为该簇的中心节点, 分别称集合<i>Up</i> (<i>x</i><sub><i>i</i></sub>) 与<i>Down</i> (<i>x</i><sub><i>i</i></sub>) 为该簇的上簇节点与下簇节点, 合称该簇的簇节点, 而不属于任何簇的节点则称为自由节点.由定义1可见, 簇之间可能存在重叠, 同时属于多个簇的节点, 其在各个簇中的角色也可能不同.对于簇节点<i>x</i>, 依据节点<i>x</i>为这些簇的上簇节点或下簇节点, 对应簇的中心节点集合分别表示为<i>center</i>_<i>up</i> (<i>x</i>) 或<i>center</i>_<i>down</i> (<i>x</i>) .图1为一个简单的3类簇集示意, 为清晰起见, 省略了簇节点之间包含在簇内的边.图1中节点<i>a</i>, <i>b</i>分别为簇<i>Cl</i> (<i>a</i>) , <i>Cl</i> (<i>b</i>) 的簇中心节点, 同时节点<i>a</i>在簇<i>Cl</i> (<i>b</i>) 中为簇节点, 节点<i>b</i>在簇<i>Cl</i> (<i>a</i>) 中也为簇节点.节点<i>c</i>同时属于2个簇, 且均为下簇节点, 因此集合<i>center</i>_<i>down</i> (<i>c</i>) ={<i>Cl</i> (<i>a</i>) , <i>Cl</i> (<i>b</i>) }.</p>
                </div>
                <div class="area_img" id="92">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903020_092.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 3类簇集" src="Detail/GetImg?filename=images/JFYZ201903020_092.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 3类簇集  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903020_092.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 3-clustering</p>

                </div>
                <div class="p1">
                    <p id="93"><b>定义3</b>. 自由邻节点集合.对于图<i>G</i>中的节点<i>v</i>, 其自由邻节点集合为</p>
                </div>
                <div class="p1">
                    <p id="94"><i>FN</i> (<i>v</i>) = (<i>Pre</i> (<i>v</i>) ∪<i>Next</i> (<i>v</i>) ) \ (<mathml id="95"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∪</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mrow></mrow></mstyle></mrow></math></mathml><i>Cl</i> (<i>x</i><sub><i>i</i></sub>) ) . (6) </p>
                </div>
                <div class="p1">
                    <p id="96">由定义2可以看出, 1个节点可以同时属于多个簇, 所以1个<i>l</i>类簇集最多可以有<i>n</i>个簇, 每个簇至少包含<i>l</i>个节点以及2<i>l</i>条有向边.结合定义3可知, 若给定1个<i>l</i>类簇集, 对于图中任意的节点<i>v</i>来说均有|<i>FN</i> (<i>v</i>) |&lt;2<i>l</i>成立, 则该<i>l</i>类簇集显然是最大化的.</p>
                </div>
                <h4 class="anchor-tag" id="97" name="97"><b>1.3 关键边</b></h4>
                <div class="p1">
                    <p id="98">对于图<i>G</i>中的任意边&lt;<i>u</i>, <i>v</i>&gt;是否保存在近似覆盖子图<i>G</i>′中, 本节分为簇边、桥边与自由边3类关键边讨论, 其中与簇中心节点相连的边均保存为该簇的簇边, 余下分3种情况讨论:</p>
                </div>
                <div class="p1">
                    <p id="99">1) 当节点<i>u</i>与<i>v</i>同属1个簇<i>Cl</i> (<i>x</i>) , 若<i>u</i>∈<i>Up</i> (<i>x</i>) , <i>v</i>∈<i>Down</i> (<i>x</i>) , 则边&lt;<i>u</i>, <i>v</i>&gt;不需要保存;除此之外, 则临时标记边&lt;<i>u</i>, <i>v</i>&gt;为自由边.显然, 边的始点与终点分别为同簇内的上簇节点与下簇节点时, 存在由簇中心点转接的长度为2的路径, 由原图中去除该边不影响节点间可达性, 且节点间距离仅增加1.</p>
                </div>
                <div class="p1">
                    <p id="100">2) 当节点<i>u</i>与<i>v</i>分属2个不同簇<i>Cl</i> (<i>x</i><sub>1</sub>) , <i>Cl</i> (<i>x</i><sub>2</sub>) 时, 进一步分3种情况来讨论:</p>
                </div>
                <div class="p1">
                    <p id="101">① 当<i>u</i>∈<i>Down</i> (<i>x</i><sub>1</sub>) , <i>v</i>∈<i>Up</i> (<i>x</i><sub>2</sub>) 时, 边&lt;<i>u</i>, <i>v</i>&gt;保存为连接簇<i>Cl</i> (<i>x</i><sub>1</sub>) 与<i>Cl</i> (<i>x</i><sub>2</sub>) 的桥边.</p>
                </div>
                <div class="p1">
                    <p id="102">② 当<i>u</i>∈<i>Up</i> (<i>x</i><sub>1</sub>) , <i>v</i>∈<i>Up</i> (<i>x</i><sub>2</sub>) 时, 若不存在以节点<i>v</i>为终点的桥边&lt;<i>a</i>, <i>v</i>&gt;, 则临时标记边&lt;<i>u</i>, <i>v</i>&gt;为自由边.如图2所示, 节点<i>x</i><sub>1</sub>与<i>x</i><sub>2</sub>为簇中心节点, 节点<i>u</i>与<i>v</i>分别为各簇的上簇节点, 图2中虚线边为簇间桥边, 若该桥边不存在, 则边&lt;<i>u</i>, <i>v</i>&gt;需保存于近似覆盖图中, 以保证节点<i>u</i>与<i>v</i>之间可达.</p>
                </div>
                <div class="area_img" id="103">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903020_103.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 上簇节点指向上簇节点的簇间边" src="Detail/GetImg?filename=images/JFYZ201903020_103.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 上簇节点指向上簇节点的簇间边  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903020_103.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 Edge between different cluster from Up-node to Up-node</p>

                </div>
                <div class="p1">
                    <p id="104">③ 当<i>u</i>∈<i>Cl</i> (<i>x</i><sub>1</sub>) , <i>v</i>∈<i>Down</i> (<i>x</i><sub>2</sub>) 时, 若簇对<i>Cl</i> (<i>x</i><sub>1</sub>) 与<i>Cl</i> (<i>x</i><sub>2</sub>) 之间不存在桥边, 则临时标记边&lt;<i>u</i>, <i>v</i>&gt;为自由边.如图3所示, 节点<i>x</i><sub>1</sub>与<i>x</i><sub>2</sub>为簇中心节点, 节点<i>u</i>为<i>Cl</i> (<i>x</i><sub>1</sub>) 中的簇节点, 节点<i>v</i>为<i>Cl</i> (<i>x</i><sub>2</sub>) 中的上簇节点, 图3中虚线边为簇间桥边, 若该桥边不存在, 则边&lt;<i>u</i>, <i>v</i>&gt;需保存于近似覆盖图中, 以保证节点<i>u</i>与<i>v</i>之间可达.</p>
                </div>
                <div class="area_img" id="105">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903020_105.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 簇节点指向下簇节点的簇间边" src="Detail/GetImg?filename=images/JFYZ201903020_105.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 簇节点指向下簇节点的簇间边  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903020_105.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 Edge between different cluster from  Cluster-node to Down-node</p>

                </div>
                <div class="p1">
                    <p id="106">3) 节点<i>u</i>与<i>v</i>中的任意一个节点为自由节点, 则临时标记边&lt;<i>u</i>, <i>v</i>&gt;为自由边.</p>
                </div>
                <div class="p1">
                    <p id="107">由于同一节点可能属于多个簇, 因此上述3种情况可能有所重叠, 所以明确不同类型边的保存规则有4项:</p>
                </div>
                <div class="p1">
                    <p id="108">① 簇边均需保存;</p>
                </div>
                <div class="p1">
                    <p id="109">② 至少满足1对簇间桥边定义, 需保存;</p>
                </div>
                <div class="p1">
                    <p id="110">③ 1个端点为自由节点的自由边需保存;</p>
                </div>
                <div class="p1">
                    <p id="111">④ 簇内自由边与簇间自由边, 若不存在包含边的2个端点, 且始点为上簇节点, 终点为下簇节点的簇, 则需保存.</p>
                </div>
                <div class="p1">
                    <p id="112">考虑聚簇过程如下:当临时自由边数量达到一定阈值时, 对其进行聚类形成新簇, 具体来说当以某节点<i>u</i>为始点及终点的临时自由边数量均超过阈值<i>l</i>时, 则形成新簇<i>Cl</i> (<i>u</i>) , 节点<i>u</i>为该簇中心节点, 节点<i>u</i>的所有临时自由前趋节点与自由后继节点分别为该簇的上簇节点与下簇节点.</p>
                </div>
                <div class="p1">
                    <p id="113">在聚簇过程中部分临时自由边会转为簇边或桥边保存, 而部分临时自由边可能转变为无需保存的冗余边从而被删除, 最终所得近似图覆盖子图中可能仍保存有未被删除的自由边, 因此近似图覆盖子图是由簇边、桥边以及自由边形成的集合.</p>
                </div>
                <h4 class="anchor-tag" id="114" name="114"><b>1.4 合理性证明</b></h4>
                <div class="p1">
                    <p id="115">由1.3节对簇边、桥边以及自由边的描述, 可以证明对于给定有向图<i>G</i>= (<i>V</i>, <i>E</i>) 及图上的1个<i>l</i>类簇集, 若子图<i>G</i>′= (<i>V</i>, <i>E</i>′) 是图<i>G</i>的 (3, 2) -覆盖, 即满足:</p>
                </div>
                <div class="p1">
                    <p id="116"><i>d</i>′ (<i>u</i>, <i>v</i>) ≤3<i>d</i> (<i>u</i>, <i>v</i>) +2, (7) </p>
                </div>
                <div class="p1">
                    <p id="117">则<i>E</i>′为这3类关键边的集合.为此, 观察图<i>G</i>中任意边&lt;<i>u</i>, <i>v</i>&gt;在子图<i>G</i>′中对应的以<i>u</i>为起点且<i>v</i>为终点的路径, 可分4种情况讨论.需要注意的是, 在聚簇过程中, 簇内自由边或簇间自由边可能转变为新簇内上簇节点指向下簇节点的冗余边, 从而被删除, 使得原来长度为1的自由边转变成了2条簇边形成的长度为2的路径:</p>
                </div>
                <div class="p1">
                    <p id="118">1) 当节点<i>u</i>, <i>v</i>中至少有1个节点是簇中心点时, 则边&lt;<i>u</i>, <i>v</i>&gt;为图<i>G</i>′中的1条簇边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =1.</p>
                </div>
                <div class="p1">
                    <p id="119">2) 当节点<i>u</i>, <i>v</i>中至少有1个节点是自由节点且没有簇中心节点时, 则&lt;<i>u</i>, <i>v</i>&gt;为图<i>G</i>′中的1条自由边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =1.</p>
                </div>
                <div class="p1">
                    <p id="120">3) 当节点<i>u</i>, <i>v</i>同属1个簇<i>Cl</i> (<i>x</i>) 时, 若<i>u</i>∈<i>Up</i> (<i>x</i>) , <i>v</i>∈<i>Down</i> (<i>x</i>) , 则边&lt;<i>u</i>, <i>x</i>&gt;, &lt;<i>x</i>, <i>v</i>&gt;为图<i>G</i>′中的簇边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =2.否则边&lt;<i>u</i>, <i>v</i>&gt;为图<i>G</i>′中的簇内自由边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =1或2.</p>
                </div>
                <div class="p1">
                    <p id="121">4) 当节点<i>u</i>, <i>v</i>分属2个不同簇<i>Cl</i> (<i>x</i><sub>1</sub>) , <i>Cl</i> (<i>x</i><sub>2</sub>) 时, 又细分为4种情况:</p>
                </div>
                <div class="p1">
                    <p id="122">① 当<i>u</i>∈<i>Down</i> (<i>x</i><sub>1</sub>) , <i>v</i>∈<i>Up</i> (<i>x</i><sub>2</sub>) 时, 则边&lt;<i>u</i>, <i>v</i>&gt;为图<i>G</i>′中的桥边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =1;</p>
                </div>
                <div class="p1">
                    <p id="123">② 当<i>u</i>∈<i>Down</i> (<i>x</i><sub>1</sub>) , <i>v</i>∈<i>Down</i> (<i>x</i><sub>2</sub>) 时, 若图<i>G</i>′中存在桥边&lt;<i>u</i>, <i>a</i>&gt;, 其中<i>a</i>∈<i>Up</i> (<i>x</i><sub>2</sub>) , 则该桥边与簇边&lt;<i>a</i>, <i>x</i><sub>2</sub>&gt;, &lt;<i>x</i><sub>2</sub>, <i>v</i>&gt;构成图<i>G</i>′中的1条路径, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =3.否则, &lt;<i>u</i>, <i>v</i>&gt;为图<i>G</i>′中的簇间自由边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =1或2;</p>
                </div>
                <div class="p1">
                    <p id="124">③ 当<i>u</i>∈<i>Up</i> (<i>x</i><sub>1</sub>) , <i>v</i>∈<i>Up</i> (<i>x</i><sub>2</sub>) 时, 若图<i>G</i>′中存在边&lt;<i>a</i>, <i>v</i>&gt;, 其中<i>a</i>∈<i>Down</i> (<i>x</i><sub>1</sub>) , 则簇边&lt;<i>u</i>, <i>x</i><sub>1</sub>&gt;, &lt;<i>x</i><sub>1</sub>, <i>a</i>&gt;与该边构成图<i>G</i>′中的1条路径, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =3.否则, &lt;<i>u</i>, <i>v</i>&gt;为图<i>G</i>′中的簇间自由边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =1或2;</p>
                </div>
                <div class="p1">
                    <p id="125">④ 当<i>u</i>∈<i>Up</i> (<i>x</i><sub>1</sub>) , <i>v</i>∈<i>Down</i> (<i>x</i><sub>2</sub>) 时, 若图<i>G</i>′中存在桥边&lt;<i>a</i>, <i>b</i>&gt;, 其中<i>a</i>∈<i>Down</i> (<i>x</i><sub>1</sub>) , <i>b</i>∈<i>Up</i> (<i>x</i><sub>2</sub>) , 则图<i>G</i>′中存在路径{&lt;<i>u</i>, <i>x</i><sub>1</sub>&gt;, &lt;<i>x</i><sub>1</sub>, <i>a</i>&gt;, &lt;<i>a</i>, <i>b</i>&gt;, &lt;<i>b</i>, <i>x</i><sub>2</sub>&gt;, &lt;<i>x</i><sub>2</sub>, <i>v</i>&gt;}, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =5.否则, &lt;<i>u</i>, <i>v</i>&gt;为图<i>G</i>′中的簇间自由边, 此时<i>d</i>′ (<i>u</i>, <i>v</i>) =1或2.</p>
                </div>
                <div class="p1">
                    <p id="126">由以上分析可以看出, 除最后1种情况外, 均满足<i>d</i>′ (<i>u</i>, <i>v</i>) ≤3<i>d</i> (<i>u</i>, <i>v</i>) .将观察范围扩展为图<i>G</i>中的路径<i>D</i>={&lt;<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>&gt;, &lt;<i>u</i><sub>2</sub>, <i>u</i><sub>3</sub>&gt;…&lt;<i>u</i><sub><i>i</i>-1</sub>, <i>v</i><sub><i>i</i></sub>&gt;}, 显然有:</p>
                </div>
                <div class="p1">
                    <p id="127" class="code-formula">
                        <mathml id="127"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><msup><mi>d</mi><mo>′</mo></msup><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></munderover><msup><mi>d</mi><mo>′</mo></msup></mstyle><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mi>j</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo>≤</mo></mtd></mtr><mtr><mtd><mn>3</mn><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></munderover><mi>d</mi></mstyle><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mi>j</mi></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo>=</mo><mn>3</mn><mi>d</mi><mo stretchy="false"> (</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>u</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo>.</mo><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>8</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="128">再观察前述最后1种情况 (同时也是最坏情况) , 即每个节点<i>u</i><sub><i>j</i></sub>分别属于簇<i>Cl</i> (<i>x</i><sub><i>j</i></sub>) , 其中1≤<i>j</i>≤<i>i</i>, 且图<i>G</i>中相邻节点在子图<i>G</i>′中需要经过始点所在簇中心节点以及桥边转接至相邻簇, 再经相邻簇中心节点连接至终点, 因这2部分子路径的长度分别为3和2, 则对于图<i>G</i>中边&lt;<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>&gt;来说, 有:</p>
                </div>
                <div class="p1">
                    <p id="129"><i>d</i>′ (<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>) =3<i>d</i> (<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>) +2. (9) </p>
                </div>
                <div class="p1">
                    <p id="130">式 (9) 中右部第1项为簇<i>Cl</i> (<i>x</i><sub>1</sub>) 中2次转接及1次桥边转接, 第2项为簇<i>Cl</i> (<i>x</i><sub>2</sub>) 中的2次转接.进一步考虑图<i>G</i>中路径<i>D</i>的下一条边&lt;<i>u</i><sub>2</sub>, <i>u</i><sub>3</sub>&gt;, 在子图<i>G</i>′中节点<i>u</i><sub>1</sub>到达<i>u</i><sub>3</sub>则需要多经过1个簇, 因此增加2次簇中转接及1次桥边转接, 即式 (10) 中右边第2项:</p>
                </div>
                <div class="p1">
                    <p id="131"><i>d</i>′ (<i>u</i><sub>1</sub>, <i>u</i><sub>3</sub>) =3<i>d</i> (<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>) +3<i>d</i> (<i>u</i><sub>2</sub>, <i>u</i><sub>3</sub>) +2. (10) </p>
                </div>
                <div class="p1">
                    <p id="132">以此类推, 可得:</p>
                </div>
                <div class="area_img" id="302">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JFYZ201903020_30200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="135">因此可得, 在所有情况下子图<i>G</i>′均是满足定义1覆盖因子为 (3, 2) 的近似覆盖图, 即图<i>G</i>的 (3, 2) -覆盖.</p>
                </div>
                <h3 id="136" name="136" class="anchor-tag"><b>2 流模式下有向近似覆盖图算法</b></h3>
                <div class="p1">
                    <p id="137">本节给出有向图中计算近似覆盖图算法的基本思想以及算法中需要保存的临时信息, 以伪代码的形式给出算法具体过程的描述, 并分析了算法空间效率.</p>
                </div>
                <h4 class="anchor-tag" id="138" name="138"><b>2.1 算法基本思想</b></h4>
                <div class="p1">
                    <p id="139">图数据以边的形式存储, 按边的端点排序后以流模式输入.算法或者建立上簇节点与下簇节点均至少为<i>l</i>个的新簇, 或者将输入边的端点添加至已存在的簇.在处理节点的同时, 输入边可能保存为簇边或桥边, 也可能被抛弃, 剩余边均标记为自由边, 临时保存在候选自由边集合中.当候选自由边集合大小超过阈值时, 将对其进行聚类形成新簇, 这样即使簇边&lt;<i>u</i>, <i>v</i>&gt;的起点<i>u</i>距离终点<i>v</i>较远, 使得边的输入位于数据流早期时, 仍然可以形成以<i>v</i>为中心节点的簇.</p>
                </div>
                <div class="p1">
                    <p id="140">具体算法中, 每个节点<i>x</i>存储2种信息:</p>
                </div>
                <div class="p1">
                    <p id="141">1) 标识节点<i>x</i>是簇节点、自由节点或簇中心点的状态标志.若节点<i>x</i>为簇节点, 还需存储包含<i>x</i>的所有簇的标志, 以及集合<i>center</i>_<i>up</i> (<i>x</i>) 与<i>center</i>_<i>down</i> (<i>x</i>) ;若节点<i>x</i>是某个簇的中心节点, 则需保存该簇的<i>Up</i> (<i>x</i>) 与<i>Down</i> (<i>x</i>) 集合.</p>
                </div>
                <div class="p1">
                    <p id="142">2) 临时自由边的集合<i>T</i><sub>pre</sub> (<i>x</i>) 与<i>T</i><sub>next</sub> (<i>x</i>) .其中<i>T</i><sub>pre</sub> (<i>x</i>) 包含了节点<i>x</i>的所有前趋自由边, <i>T</i><sub>next</sub> (<i>x</i>) 包含了节点<i>x</i>的所有后继自由边.随着算法的运行导致节点状态发生改变, 这2个集合中可能会包含一些非自由边, 将在自由边集聚类时删除.</p>
                </div>
                <div class="p1">
                    <p id="143">簇边保存在对应簇边集合中, 桥边存储在矩阵<b><i>Bridge</i></b>中, <i>Bridge</i>[<i>i</i>, <i>j</i>]存储连接簇<i>C</i><sub><i>i</i></sub>到簇<i>C</i><sub><i>j</i></sub>的桥边集合.若簇<i>C</i><sub><i>i</i></sub>与簇<i>C</i><sub><i>j</i></sub>之间不存在桥边, 则<i>Bridge</i>[<i>i</i>, <i>j</i>]显然为空.但反之未必成立, 即<i>Bridge</i>[<i>i</i>, <i>j</i>]为空时, 可能存在连接簇<i>C</i><sub><i>i</i></sub>与<i>C</i><sub><i>j</i></sub>的桥边, 保存在<i>T</i><sub>pre</sub> (<i>x</i>) 或<i>T</i><sub>next</sub> (<i>x</i>) 中.</p>
                </div>
                <h4 class="anchor-tag" id="144" name="144"><b>2.2 算法描述</b></h4>
                <div class="p1">
                    <p id="145">算法通过判断边端点类型来决定边是否需要保存以及保存为何种类型.若端点包含簇中心点则保存边为簇边, 否则先考虑是否满足桥边定义, 之后判断是否属于同簇内上簇节点指向下簇节点, 最后分3种情况考察是否为自由边.当节点自由边数量超过阈值时, 开始聚集新簇, 并删除新簇中可能的冗余边.</p>
                </div>
                <div class="p1">
                    <p id="146"><b>算法1</b>. 流模式下有向近似覆盖图的计算.</p>
                </div>
                <div class="p1">
                    <p id="147">输入:前一时刻有向图<i>G</i>、当前到达的边&lt;<i>x</i>, <i>y</i>&gt;;</p>
                </div>
                <div class="p1">
                    <p id="148">输出:当前时刻聚簇以及3类关键边.</p>
                </div>
                <div class="p1">
                    <p id="149">① if <i>x</i>或<i>y</i>为簇中心点</p>
                </div>
                <div class="p1">
                    <p id="150">② 保存&lt;<i>x</i>, <i>y</i>&gt;至簇边集合;</p>
                </div>
                <div class="p1">
                    <p id="151">③ if <i>y</i>为自由节点</p>
                </div>
                <div class="p1">
                    <p id="152">④ 添加<i>y</i>至<i>Down</i> (<i>x</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="153">⑤ 更新<i>y</i>标识为簇节点;</p>
                </div>
                <div class="p1">
                    <p id="154">⑥ end if</p>
                </div>
                <div class="p1">
                    <p id="155">⑦ if <i>x</i>为自由节点</p>
                </div>
                <div class="p1">
                    <p id="156">⑧ 添加<i>x</i>至<i>Up</i> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="157">⑨ 更新<i>x</i>标识为簇节点;</p>
                </div>
                <div class="p1">
                    <p id="158">⑩ end if</p>
                </div>
                <div class="p1">
                    <p id="159"> (11) end if</p>
                </div>
                <div class="p1">
                    <p id="160"> (12) if <i>x</i>和<i>y</i>均为簇节点</p>
                </div>
                <div class="p1">
                    <p id="161"> (13) if存在<i>cx</i>≠<i>cy</i></p>
                </div>
                <div class="p1">
                    <p id="162">/*<i>cx</i>, <i>cy</i>分别属于<i>center</i>_<i>down</i> (<i>x</i>) 与<i>center</i>_<i>up</i> (<i>y</i>) */</p>
                </div>
                <div class="p1">
                    <p id="163"> (14) 保存&lt;<i>x</i>, <i>y</i>&gt;至<i>Bridge</i>[<i>cx</i>, <i>cy</i>];</p>
                </div>
                <div class="p1">
                    <p id="164"> (15) else if <i>center</i>_<i>up</i> (<i>x</i>) ∩<i>center</i>_<i>down</i> (<i>y</i>) =∅</p>
                </div>
                <div class="p1">
                    <p id="165"> (16) if <i>center</i>_<i>down</i> (<i>y</i>) ≠∅</p>
                </div>
                <div class="p1">
                    <p id="166"> (17) for <i>cx</i>∈ (<i>center</i>_<i>up</i> (<i>x</i>) ∪<i>center</i>_<i>down</i> (<i>x</i>) ) </p>
                </div>
                <div class="p1">
                    <p id="167"> (18) if <i>Bridge</i>[<i>cx</i>, <i>cy</i>]≠∅</p>
                </div>
                <div class="p1">
                    <p id="168"> (19) 添加&lt;<i>x</i>, <i>y</i>&gt;至<i>T</i><sub>next</sub> (<i>x</i>) 与<i>T</i><sub>pre</sub> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="169"> (20) end if</p>
                </div>
                <div class="p1">
                    <p id="170"> (21) end for</p>
                </div>
                <div class="p1">
                    <p id="171"> (22) end if</p>
                </div>
                <div class="p1">
                    <p id="172"> (23) if存在<i>cx</i>≠<i>cy</i></p>
                </div>
                <div class="p1">
                    <p id="173">/*<i>cx</i>, <i>cy</i>分别属于<i>center</i>_<i>up</i> (<i>x</i>) 与<i>center</i>_<i>up</i> (<i>y</i>) */</p>
                </div>
                <div class="p1">
                    <p id="174"> (24) if <i>Bridge</i>[<i>cx</i>, <i>cy</i>]不存在以<i>y</i>为终点的边</p>
                </div>
                <div class="p1">
                    <p id="175"> (25) 添加&lt;<i>x</i>, <i>y</i>&gt;至<i>T</i><sub>next</sub> (<i>x</i>) 与<i>T</i><sub>pre</sub> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="176"> (26) end if</p>
                </div>
                <div class="p1">
                    <p id="177"> (27) end if</p>
                </div>
                <div class="p1">
                    <p id="178"> (28) if <i>x</i>和<i>y</i>属于同一个簇</p>
                </div>
                <div class="p1">
                    <p id="179"> (29) 添加&lt;<i>x</i>, <i>y</i>&gt;至<i>T</i><sub>next</sub> (<i>x</i>) 与<i>T</i><sub>pre</sub> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="180"> (30) end if</p>
                </div>
                <div class="p1">
                    <p id="181"> (31) end if</p>
                </div>
                <div class="p1">
                    <p id="182"> (32) end if</p>
                </div>
                <div class="p1">
                    <p id="183"> (33) if <i>y</i> 为自由节点</p>
                </div>
                <div class="p1">
                    <p id="184"> (34) 添加&lt;<i>x</i>, <i>y</i>&gt;至<i>T</i><sub>next</sub> (<i>x</i>) 与<i>T</i><sub>pre</sub> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="185"> (35) if |<i>T</i><sub>next</sub> (<i>x</i>) |&gt;2<i>n</i><sup>1/3</sup>且|<i>T</i><sub>pre</sub> (<i>x</i>) |&gt;2<i>n</i><sup>1/3</sup></p>
                </div>
                <div class="p1">
                    <p id="186"> (36) for <i>T</i><sub>next</sub> (<i>x</i>) 与<i>T</i><sub>pre</sub> (<i>x</i>) 中的每条边</p>
                </div>
                <div class="p1">
                    <p id="187"> (37) if边端点均为簇节点且其中之一是由自由节点更新为簇节点</p>
                </div>
                <div class="p1">
                    <p id="188"> (38) 执行步骤 (13) ～ (31) , 若边未保存为桥边或自由边, 由<i>T</i><sub>pre</sub> (<i>x</i>) 与<i>T</i><sub>next</sub> (<i>x</i>) 中删除;</p>
                </div>
                <div class="p1">
                    <p id="189"> (39) end if</p>
                </div>
                <div class="p1">
                    <p id="190"> (40) end for</p>
                </div>
                <div class="p1">
                    <p id="191"> (41) if |<i>T</i><sub>next</sub> (<i>x</i>) |&gt;<i>n</i><sup>1/3</sup> 且|<i>T</i><sub>pre</sub> (<i>x</i>) |&gt;<i>n</i><sup>1/3</sup></p>
                </div>
                <div class="p1">
                    <p id="192"> (42) <i>T</i><sub>pre</sub> (<i>x</i>) 与<i>T</i><sub>next</sub> (<i>x</i>) 中的边均保存为簇边;</p>
                </div>
                <div class="p1">
                    <p id="193"> (43) <i>T</i><sub>pre</sub> (<i>x</i>) 中节点保存为<i>Up</i> (<i>x</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="194"> (44) <i>T</i><sub>next</sub> (<i>x</i>) 中的节点保存为<i>Down</i> (<i>x</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="195"> (45) for <i>u</i>∈<i>Up</i> (<i>x</i>) </p>
                </div>
                <div class="p1">
                    <p id="196"> (46) for <i>v</i>∈<i>T</i><sub>next</sub> (<i>u</i>) </p>
                </div>
                <div class="p1">
                    <p id="197"> (47) if <i>v</i>∈<i>Down</i> (<i>x</i>) </p>
                </div>
                <div class="p1">
                    <p id="198"> (48) 由<i>T</i><sub>pre</sub> (<i>v</i>) 与<i>T</i><sub>next</sub> (<i>u</i>) 删除</p>
                </div>
                <div class="p1">
                    <p id="199">&lt;<i>u</i>, <i>v</i>&gt;;</p>
                </div>
                <div class="p1">
                    <p id="200"> (49) end if</p>
                </div>
                <div class="p1">
                    <p id="201"> (50) end for</p>
                </div>
                <div class="p1">
                    <p id="202"> (51) end for</p>
                </div>
                <div class="p1">
                    <p id="203"> (52) if <i>x</i> 为自由节点</p>
                </div>
                <div class="p1">
                    <p id="204"> (53) 添加<i>x</i>至簇<i>C</i>;</p>
                </div>
                <div class="p1">
                    <p id="205"> (54) 更新<i>x</i>标识为簇节点及簇中心点;</p>
                </div>
                <div class="p1">
                    <p id="206"> (55) else</p>
                </div>
                <div class="p1">
                    <p id="207"> (56) 增加<i>x</i>标识簇中心点;</p>
                </div>
                <div class="p1">
                    <p id="208"> (57) end if</p>
                </div>
                <div class="p1">
                    <p id="209"> (58) end if</p>
                </div>
                <div class="p1">
                    <p id="210"> (59) end if</p>
                </div>
                <div class="p1">
                    <p id="211"> (60) end if</p>
                </div>
                <div class="p1">
                    <p id="212"> (61) if <i>x</i>为自由节点</p>
                </div>
                <div class="p1">
                    <p id="213">/*与步骤 (33) ～ (60) 类似*/</p>
                </div>
                <div class="p1">
                    <p id="214"> (62) 添加〈<i>x</i>, <i>y</i>〉至<i>T</i><sub>next</sub> (<i>x</i>) 与<i>T</i><sub>pre</sub> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="215"> (63) if |<i>T</i><sub>next</sub> (<i>y</i>) |&gt;2<i>n</i><sup>1/3</sup> 且 |<i>T</i><sub>pre</sub> (<i>y</i>) |&gt;2<i>n</i><sup>1/3</sup></p>
                </div>
                <div class="p1">
                    <p id="216"> (64) for <i>T</i><sub>next</sub> (<i>y</i>) 与<i>T</i><sub>pre</sub> (<i>y</i>) 中的每条边</p>
                </div>
                <div class="p1">
                    <p id="217"> (65) if 边端点均为簇节点且其中之一是由自由节点更新为簇节点</p>
                </div>
                <div class="p1">
                    <p id="218"> (66) 执行步骤 (13) ～ (31) , 若边未保存为桥边或自由边, 由<i>T</i><sub>pre</sub> (<i>y</i>) 与<i>T</i><sub>next</sub> (<i>y</i>) 中删除;</p>
                </div>
                <div class="p1">
                    <p id="219"> (67) end if</p>
                </div>
                <div class="p1">
                    <p id="220"> (68) end for</p>
                </div>
                <div class="p1">
                    <p id="221"> (69) if |<i>T</i><sub>next</sub> (<i>y</i>) |&gt;<i>n</i><sup>1/3</sup>且|<i>T</i><sub>pre</sub> (<i>y</i>) |&gt;<i>n</i><sup>1/3</sup></p>
                </div>
                <div class="p1">
                    <p id="222"> (70) <i>T</i><sub>pre</sub> (<i>y</i>) 与<i>T</i><sub>next</sub> (<i>y</i>) 中的边均保存为簇边;</p>
                </div>
                <div class="p1">
                    <p id="223"> (71) <i>T</i><sub>pre</sub> (<i>y</i>) 中节点保存为<i>Up</i> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="224"> (72) <i>T</i><sub>next</sub> (<i>y</i>) 中的节点保存为<i>Down</i> (<i>y</i>) ;</p>
                </div>
                <div class="p1">
                    <p id="225"> (73) for <i>u</i>∈<i>Up</i> (<i>y</i>) </p>
                </div>
                <div class="p1">
                    <p id="226"> (74) for <i>v</i>∈<i>T</i><sub>next</sub> (<i>u</i>) </p>
                </div>
                <div class="p1">
                    <p id="227"> (75) if <i>v</i>∈<i>Down</i> (<i>y</i>) </p>
                </div>
                <div class="p1">
                    <p id="228"> (76) 由<i>T</i><sub>pre</sub> (<i>v</i>) 与<i>T</i><sub>next</sub> (<i>u</i>) 删除</p>
                </div>
                <div class="p1">
                    <p id="229">〈<i>u</i>, <i>v</i>〉;</p>
                </div>
                <div class="p1">
                    <p id="230"> (77) end if</p>
                </div>
                <div class="p1">
                    <p id="231"> (78) end for</p>
                </div>
                <div class="p1">
                    <p id="232"> (79) end for</p>
                </div>
                <div class="p1">
                    <p id="233"> (80) if <i>y</i>为自由节点</p>
                </div>
                <div class="p1">
                    <p id="234"> (81) 添加<i>y</i>至簇<i>C</i>;</p>
                </div>
                <div class="p1">
                    <p id="235"> (82) 更新<i>y</i>标识为簇节点及簇中心点;</p>
                </div>
                <div class="p1">
                    <p id="236"> (83) else</p>
                </div>
                <div class="p1">
                    <p id="237"> (84) 增加<i>y</i>标识簇中心点;</p>
                </div>
                <div class="p1">
                    <p id="238"> (85) end if</p>
                </div>
                <div class="p1">
                    <p id="239"> (86) end if</p>
                </div>
                <div class="p1">
                    <p id="240"> (87) end if</p>
                </div>
                <div class="p1">
                    <p id="241"> (88) end if</p>
                </div>
                <div class="p1">
                    <p id="242">算法1中步骤①～ (11) 处理到达边的端点存在簇中心点的情况, 此时将该边保存为簇边, 端点保存为相应的上簇节点集或下簇节点集.</p>
                </div>
                <div class="p1">
                    <p id="243">步骤 (12) ～ (32) 处理端点均为簇节点的情况.首先, 当到达边至少满足1对簇之间桥边定义时, 该边保存为桥边 (步骤 (13) ～ (14) ) .否则, 若属于同簇内上簇节点指向下簇节点的情况则忽略该边 (步骤 (15) 判断条件不为空的情况) , 对应步骤 (38) 则是删除该边.再者, 则根据1.3节所述几种情况, 判断是否保存该边为自由边, 因为这3种情况可能同时出现, 所以算法中设为并列条件, 其中步骤 (16) ～ (22) 为端点分属不同簇, 终点为下簇节点, 簇间没有桥边的情况;步骤 (23) ～ (27) 为端点分属不同簇且均为上簇节点, 簇间没有以到达边终点为终点的桥边的情况;步骤 (28) ～ (30) 为端点属于同簇但不是上簇节点指向下簇节点的情况, 若这些情况均不满足, 则忽略到达边或者删除该边 (对应步骤 (38) ) .</p>
                </div>
                <div class="p1">
                    <p id="244">步骤 (33) ～ (60) 为到达边始点为自由节点的情况.首先添加到达边至临时自由边集合, 然后判断前驱自由边与后继自由边数量是否超过阈值, 据此决定是否聚集新簇.随着数据流的到达, 节点类型发生变化, 自由边集合中可能存在冗余, 需要在聚簇前进行清理, 同时为了避免扫描自由边集合过于频繁, 将阈值设为给定值的2倍 (步骤 (35) ) .步骤 (36) ～ (40) 为扫描自由边集合的过程, 对于端点类型发生变化的边, 执行步骤 (13) ～ (31) 来判断其是否需要保存为桥边或继续保存为自由边, 否则将其删除.步骤 (41) 表示清理后的自由边数量超过聚簇阈值, 由步骤 (42) 开始进行聚簇, 对应边和节点分别保存为簇边以及上簇下簇节点 (步骤 (42) ～ (44) ) .新簇中可能存在上簇节点指向下簇节点的冗余边, 通过步骤 (45) ～ (51) 的处理来删除.若新簇中心节点为自由节点, 则将其添加进簇并更新其标识 (步骤 (52) ～ (54) ) , 否则仅更新其标识 (步骤 (55) ～ (57) ) .步骤 (61) ～ (88) 为到达边终点为自由节点的情况, 与步骤 (33) ～ (60) 类似, 不再赘述.</p>
                </div>
                <div class="p1">
                    <p id="245">算法1中, 簇边与桥边自初次保存后一直存在, 端点为自由节点的自由边在端点标识改变之前一直保存, 之后可能随着聚集新簇成为簇边, 或成为桥边, 或继续保存为自由边, 还可能任意一个保存条件都不再满足从而删除.显然, 算法满足2.3节给出的不同类型边的保存规则.</p>
                </div>
                <h4 class="anchor-tag" id="246" name="246"><b>2.3 算法分析</b></h4>
                <div class="p1">
                    <p id="247">依据2.2节给出的算法描述, 本节分析该算法在有向图中求得的近似图覆盖子图边集的大小.由图4所示, 有向图中的节点可看作上下2部分, 图4中的边均由上半部分中指向下半部分.这种情况下, 若删除其中的任意1条边, 则某2个节点之间不再连通, 称这种结构为∇结构.</p>
                </div>
                <div class="area_img" id="248">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903020_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 ∇结构" src="Detail/GetImg?filename=images/JFYZ201903020_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 ∇结构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903020_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 ∇ structure</p>

                </div>
                <div class="p1">
                    <p id="249">考虑图<i>G</i>的节点<i>v</i>, 若满足<i>deg</i>_<i>in</i> (<i>v</i>) ≥<i>n</i><sup>1/3</sup>且<i>deg</i>_<i>out</i> (<i>v</i>) ≥<i>n</i><sup>1/3</sup>, 则进行聚类操作形成簇<i>Cl</i> (<i>v</i>) .设簇总数为<i>k</i>, 则最坏情况下簇边的数量为 (<i>n</i>-<i>k</i>) ×<i>k</i>, 当<i>k</i>=<i>n</i>/2时达到最大值, 即簇边的数量不超过<i>O</i> (<i>n</i><sup>2</sup>/4) .</p>
                </div>
                <div class="p1">
                    <p id="250">考虑与簇<i>Cl</i> (<i>v</i>) 相连的节点<i>u</i>, 以节点<i>u</i>为始点连接簇<i>Cl</i> (<i>v</i>) 的边集合&lt;<i>u</i>, <i>X</i>&gt;, 则满足<i>X</i>⊆<i>Up</i> (<i>v</i>) 或者<i>X</i>⊆<i>Down</i> (<i>v</i>) , 但2者不会同时满足.因此聚类操作得到2部分结果:或是聚类成簇, 则除了簇边以外的桥边及自由边形成∇结构;或是部分节点的出度或入度之一小于<i>n</i><sup>1/3</sup>, 不足以形成新簇, 保存为自由边.其中∇结构显然可以判断出边的数量不超过<i>O</i> (<i>n</i><sup>2</sup>/4) .</p>
                </div>
                <div class="p1">
                    <p id="251">对于满足<i>deg</i>_<i>in</i> (<i>v</i>) &lt;<i>n</i><sup>1/3</sup>或<i>deg</i>_<i>out</i> (<i>v</i>) &lt;<i>n</i><sup>1/3</sup>的节点<i>v</i>, 可以不失一般性的假设<i>deg</i>_<i>in</i> (<i>v</i>) &lt;<i>n</i><sup>1/3</sup>.设这部分节点共<i>k</i>个, 记为集合<i>X</i>, 其余 (<i>n</i>-<i>k</i>) 个节点记为集合<i>Y</i>, 则以<i>X</i>中节点为始点的边, 分别以集合<i>X</i>及<i>Y</i>中的节点为终点, 其中以集合<i>X</i>中节点为终点的部分, 始点的平均出度不超过<i>n</i><sup>1/3</sup>, 而以集合<i>Y</i>中节点为终点的部分, 始点的平均出度不超过 (<i>n</i>-<i>k</i>) .因此这部分自由边数量为<i>k</i>× (<i>n</i>-<i>k</i>+<i>l</i>) , 由于<i>l</i>远远小于<i>n</i>, 所以最大值为<i>n</i><sup>2</sup>/4.</p>
                </div>
                <div class="p1">
                    <p id="252">由此可得, 图<i>G</i>′= (<i>V</i>, <i>E</i>′) 为关联到<i>n</i><sup>1/3</sup>类最大化簇集的 (3, 2) -覆盖, 则<i>G</i>′包含<i>O</i> (<i>n</i><sup>2</sup>/4) 条边.</p>
                </div>
                <h3 id="253" name="253" class="anchor-tag"><b>3 实验与分析</b></h3>
                <h4 class="anchor-tag" id="254" name="254"><b>3.1 实验环境与方法</b></h4>
                <div class="p1">
                    <p id="255">实验运行的硬件环境为英特尔酷睿双核处理器, 主频2.2 GHz、内存8 GB、软件环境为Linux操作系统, 算法由C语言编写实现, 使用gcc进行编译.实验数据使用幂率模型生成的人工数据集, 此类图中节点的度分布呈现幂率分布, 与互联网、社交网、交通网以及蛋白质生物网络等现实世界中的大规模图数据类似, 普遍具有小世界与无标度等宏观拓扑特性<citation id="365" type="reference"><link href="341" rel="bibliography" /><link href="343" rel="bibliography" /><link href="345" rel="bibliography" /><sup>[<a class="sup">20</a>,<a class="sup">21</a>,<a class="sup">22</a>]</sup></citation>, 是图分析领域广泛选用的实验数据集, 适用于本文的算法实验分析.本文具体采用基于递归矩阵 (R-MAT) 的网络模型<citation id="364" type="reference"><link href="347" rel="bibliography" /><sup>[<a class="sup">23</a>]</sup></citation>, 生成节点数量为8 000, 平均度分别为50, 200, 800, 3 200的4个人工图数据集, 对比算法在不同数据集上的运行效果.</p>
                </div>
                <div class="p1">
                    <p id="256">算法的具体实现中, 使用散列表存储节点所需的信息, 为每个节点保存1个32 b的标签作为散列表键值.当1条有向边以流的形式到达时, 首先判断该边的2个端点是否首次出现.若是首次出现的新节点, 则创建1个与该节点对应的散列表项, 否则根据节点的标签检索到对应的散列表项并根据需要进行更新.</p>
                </div>
                <div class="p1">
                    <p id="257">对于非对称的桥边集矩阵<b><i>Bridge</i></b>, 也使用散列表来保存桥边列表, 并采用64 b的散列键值.当1条有向边判定为桥边, 需要保存至列表中时, 将该边的2个端点各自的32 b标签值连接为1个64 b键值, 这样由标签值的连接次序就可以区别同一对节点对应的2条有向边.桥边的存储按其64 b键值将该边插入到桥边列表的相应位置, 而当检索某2个簇间的桥边是否存在时, 则同样按其64 b键值在散列表中进行查找.</p>
                </div>
                <h4 class="anchor-tag" id="258" name="258"><b>3.2 实验结果</b></h4>
                <div class="p1">
                    <p id="259">本文实验中主要考察3项指标:</p>
                </div>
                <div class="p1">
                    <p id="260">1) 平均伸展率是指图中所有节点对 (<i>x</i>, <i>y</i>) 在近似覆盖图与原图中距离之比<i>d</i>′ (<i>x</i>, <i>y</i>) /<i>d</i> (<i>x</i>, <i>y</i>) 的平均值.实际计算中普遍使用采样估算值, 即随机选取一定比例的节点对进行计算, 在大幅减少计算量的同时, 结果的精度也有一定的保证.依据定义所得理论上限值通常称为最大伸展率, 由覆盖因子决定, 而在实际上近似覆盖图中的节点对并不都处于理论上的极限情况, 因此平均伸展率比最大伸展率要小.</p>
                </div>
                <div class="p1">
                    <p id="261">2) 近似图覆盖比例是指近似图覆盖中边的数量与原图中边的数量之比, 体现算法的空间效率.</p>
                </div>
                <div class="p1">
                    <p id="262">3) 运行时间即算法在数据集上运行的时间, 体现其时间效率.</p>
                </div>
                <div class="p1">
                    <p id="263">图5所示是近似图覆盖比例随着聚簇阈值的改变表现出的不同情况, 图5中4条折线分别表示本文算法在4个不同人工图数据集上运行的结果.由图中可以看出, 随着图数据集的密度增大, 即边的数量增加, 近似图覆盖比例逐渐下降.这是由于在高密度的图数据集中, 节点对之间的路径较多, 其中满足最大伸缩因子的路径数量也较多, 因此大量的边均不需保存在近似覆盖子图中, 使得覆盖图与原图的边数量比较低.</p>
                </div>
                <div class="area_img" id="264">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903020_264.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 不同数据集上的覆盖比例" src="Detail/GetImg?filename=images/JFYZ201903020_264.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 不同数据集上的覆盖比例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903020_264.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Coverage ratio on different dataset</p>

                </div>
                <div class="p1">
                    <p id="265">同时由图5中还可以看出, 近似图覆盖比例随着聚簇阈值的增大呈U型变化.当聚簇阈值较小时, 簇的数量较大, 则需保存大量的簇间桥边, 同时由于单个簇中节点较少, 节点间的簇内连接 (包括簇边和自由边) 保留比例较高, 使得整体覆盖比例较高.当聚簇阈值较大时, 大量节点由于无法聚簇而成为自由节点, 导致大量的自由边需要保存在近似图覆盖子图中, 使得近似图覆盖比例较高.特别是在低密度图数据集中, 当聚簇阈值较大, 甚至大于图中节点平均度时, 只能形成数量极少的簇, 此时近似图覆盖比例极高.</p>
                </div>
                <div class="p1">
                    <p id="266">现有无向图近似覆盖的研究成果中, 最佳聚簇阈值大多设为<i>n</i><sup>1/3</sup>, 对应本文实验中图数据集的节点数量, 则最佳阈值为20.由实验结果可以看到, 4个数据集在聚簇阈值为20左右时表现一致, 所得近似图覆盖比例均为最低 (不同数据集约为 0.001～0.01左右) , 验证了本文的理论分析, 即近似覆盖图中边的数量主要与节点数量相关, 这与相关无向图的研究结果也是一致.同时较低的最优覆盖比例也符合真实大规模图的拓扑统计特性, 即图中节点平均度不高的同时, 节点间的最短路径仍然较短, 即所谓的小世界特性.特别是近似覆盖图的节点间路径长度约束较原图更宽, 所需边的数量更少, 因此所得最优近似图覆盖比例极低, 极大的降低了图数据存储的空间开销.</p>
                </div>
                <div class="p1">
                    <p id="267">图6所示是平均伸展率随着聚簇阈值的改变表现出的不同情况, 图6中4条折线分别表示本文算法在4个不同人工图数据集上运行的结果, 其中平均伸展率是采用随机选取10 000对节点计算所得的采样估算值.由图6中可以看出平均伸展率随着聚簇阈值的增大基本呈倒U型变化, 与图5中的近似图覆盖比例变化相对应, 即近似图中保存的边比例越高, 节点间路径越接近原图, 平均伸展率越小.当聚簇阈值较小时, 较多的簇内与簇间连接使得节点间的路径与原图相比变化较小, 因此平均伸展率较小.当聚簇阈值较大时, 形成少量的簇与大量自由节点, 原图中许多节点间的路径由大量的自由边维持下来, 使得平均伸展因子趋近于1.当聚簇阈值为20左右时, 近似图覆盖比例最低, 而此时平均伸展率较大.由于删除了原图中大量的边, 因此很多相邻节点不再保持有直接的邻居关系, 而是需要由始点经过若干次转接间接到达终点.图6中实验结果显示, 平均伸展因子峰值为3.08, 接近定义1给出的理论上限3<i>x</i>+2.</p>
                </div>
                <div class="area_img" id="268">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903020_268.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 不同数据集上的伸展率" src="Detail/GetImg?filename=images/JFYZ201903020_268.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 不同数据集上的伸展率  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903020_268.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 Stretch ratio on different dataset</p>

                </div>
                <div class="p1">
                    <p id="269">4个数据集的数据曲线趋势基本一致, 且随着数据集节点平均度的增加, 平均伸展率有所增大.这显然是由于低密度图的近似覆盖比例较高, 近似图中保留的边相对更多, 使得节点间路径变化更小, 这同样与图5所示相对应.</p>
                </div>
                <div class="area_img" id="270">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903020_270.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 不同数据集上的运行时间" src="Detail/GetImg?filename=images/JFYZ201903020_270.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 不同数据集上的运行时间  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903020_270.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 Runtime on different dataset</p>

                </div>
                <div class="p1">
                    <p id="271">图7所示是算法运行时间随着聚簇阈值的改变表现出的不同情况, 图7中4条折线分别表示本文算法在4个不同人工图数据集上运行的结果.由图7中可以明显看出, 算法在节点平均度较低的图数据集上运行时间较短, 这是因为同样聚簇阈值下, 算法在稀疏的图数据集中需要处理的边的数量较少.</p>
                </div>
                <div class="p1">
                    <p id="272">同时由图7中还可以看出算法运行时间随着聚簇阈值的增大呈下降趋势.由算法描述可知, 较大的时间开销一部分在于<i>T</i><sub>pre</sub> (<i>x</i>) 与<i>T</i><sub>next</sub> (<i>x</i>) 这2个集合中边信息的处理, 并且需要遍历节点<i>x</i>邻接点所属簇, 另一部分在于边端点均为簇节点时, 需要判断其所属的多个簇之间的重叠情况, 因此簇的数量极大的影响算法时间效率.当聚簇阈值较小时, 运行时间较长, 随着聚簇阈值增大, 簇的数量显著减少, 算法运行时间也随之明显缩短, 但当聚簇阈值继续增大时, 由于所保存边的数量达到最小值后开始增加, 运行时间缩短的趋势开始平缓.</p>
                </div>
                <h4 class="anchor-tag" id="273" name="273"><b>3.3 与无向图的对比分析</b></h4>
                <div class="p1">
                    <p id="274">本文算法适用于计算有向图的近似覆盖图, 而相关研究工作多针对无向图环境, 且少有的针对有向图环境的研究, 其距离的定义较为特殊, 不具有普遍意义, 因此算法效率之间直接的定量对比没有明确的意义.直观看来, 与相同规模 (节点与边的数量相同) 的无向图相比, 有向图的近似覆盖图中保留的边显然更多, 存储开销更大, 算法的时间复杂度也更高.本节定性的分析本文算法与同为聚簇方法的无向图环境下近似覆盖图算法相比, 空间与时间开销存在差异的原因.</p>
                </div>
                <div class="p1">
                    <p id="275">本文算法存储空间的额外需求主要是自由边的增加.为保证同簇内上簇节点之间、下簇节点之间以及下簇节点到上簇节点的连通, 在近似覆盖图中保留了许多簇内自由边, 这类边在无向图环境下是不需要保存的.尽管随着数据流的到达, 在逐步聚簇的过程中删除了其中的冗余, 但仍有一部分保留至最终的近似覆盖图, 增加了存储开销.类似地为保证簇间节点的连通性, 当边的2个端点分别为不同簇的上簇节点, 若当前桥边不满足端点间连通的需求, 则需要保留簇间自由边, 或者当边终点为与始点不同簇的下簇节点时, 若当前没有桥边, 则也需要保留簇间自由边.簇间自由边类似于额外的桥边, 这类边在无向图环境下是也不需要保存的.</p>
                </div>
                <div class="p1">
                    <p id="276">时间开销方面, 当边到达时, 本文算法需要考虑的情况比无向图环境下更为复杂.当边端点均为簇节点时, 本文算法需要判断该边是否应保留为簇内自由边、簇间自由边或者桥边, 因此要进行多次集合的交与并操作, 而无向图仅需判断2个端点是否同簇.当自由边数量超过阈值时从而需要删除其中冗余时, 本文算法需要再次判断这些边是否应保留为簇内自由边、簇间自由边或者桥边, 而无向图仅需判断端点是否仍是自由节点.聚簇过程中, 对于新簇内可能出现的簇内自由边冗余, 本文算法需要通过遍历相关上簇节点与下簇节点集删除这部分冗余, 而无向图中并不存在簇内自由边, 因此不需要进行这部分处理.</p>
                </div>
                <div class="p1">
                    <p id="277">由以上分析可以看出, 本文算法相比无向图环境下的算法, 时空开销均有所增加, 但其原因是由于保证有向图节点间连通所带来的复杂性的增加.相对于有向图与无向图之间复杂度的差异, 本文算法复杂度的增加十分有限, 可以认为其时空效率较佳.</p>
                </div>
                <h3 id="278" name="278" class="anchor-tag"><b>4 总 结</b></h3>
                <div class="p1">
                    <p id="279">本文以有向图为研究对象, 重新定义了近似覆盖图计算过程中所需的相关概念, 包括簇集与簇边、桥边、自由边3类关键边, 以及由有向图簇衍生出的上簇节点与下簇节点等不同类型的节点.通过理论分析的方式, 证明了这3类边的集合满足覆盖因子为 (3, 2) 的有向近似覆盖图的定义.针对图数据以流模式到达的情况, 本文给出依次处理每条到达边的具体算法.算法通过判断边端点的类型, 据此将到达边抛弃或保存适合类型, 并在满足聚簇阈值时形成新簇, 最终得到包含簇边、簇间桥边以及自由边的近似覆盖图.算法空间开销的理论分析结果表明, 对于包含<i>n</i>个节点的有向图<i>G</i>, 其最大化簇集的 (3, 2) -覆盖包含<i>O</i> (<i>n</i><sup>2</sup>/4) 条边.最后, 考虑幂指数特性是现实大规模图数据的普遍规律, 本文实验数据选取以幂指数模型为基础的人工图数据, 通过对比节点平均度不同的图数据, 观察随聚簇阈值变化时, 算法的空间时间效率等方面的变化.实验结果表明:本文算法在满足覆盖因子约束的前提下, 时空效率均较好.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="303">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201612009&amp;v=MzA3MTN5N25VcnpPTHl2U2RMRzRIOWZOclk5RmJZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkY=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b>Dong Rongsheng, Zhang Xinkai, Liu Huadong, et al. Representation and operations research of k2-MDD in large-scale graph data[J]. Journal of Computer Research and Development, 2016, 52 (12) : 2783- 2792 (in Chinese) (董荣胜, 张新凯, 刘华东, 等. 大规模图数据的k2-MDD表示方法与操作研究[J]. 计算机研究与发展, 2016, 52 (12) : 2783- 2792) 
                            </a>
                        </p>
                        <p id="305">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=New constructions of (α, β)-spanners and purely additive spanners">

                                <b>[2]</b>Baswana S, Kavitha T, Mehlhorn K, et al. New constructions of (α, β) -spanners and purely additive spanners[C] //Proc of the 16th ACM-SIAM Symp on Discrete Algorithms. Philadelphia: SIAM, 2005: 672- 681
                            </a>
                        </p>
                        <p id="307">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A simple linear time algorithm for computing (2k-1)-spanner of O(n1+1/k) size for weighted graphs">

                                <b>[3]</b>Baswana S, Sen S. A simple linear time algorithm for computing (2k-1) -spanner of O (n1+1/k) size for weighted graphs[C] //Proc of the 30th Int Conf on Automata, Languages and Programming. Berlin: Springer, 2003: 384- 396
                            </a>
                        </p>
                        <p id="309">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Deterministic constructions of approximate distance oracles and spanners">

                                <b>[4]</b>Roditty L, Thorup M, Zwick U. Deterministic constructions of approximate distance oracles and spanners [C] //Proc of the 32nd Int Conf on Automata, Languages and Programming. Berlin: Springer, 2005: 261- 272
                            </a>
                        </p>
                        <p id="311">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Small stretch spanners on dynamic graphs">

                                <b>[5]</b>Ausiello G, Franciosa P G, Italiano G F. Small stretch spanners on dynamic graphs[J]. Journal of Graph Algorithms and Applications, 2005, 10 (2) : 365- 385
                            </a>
                        </p>
                        <p id="313">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Dynamic algorithms for graph spanners">

                                <b>[6]</b>Baswana S. Dynamic algorithms for graph spanners[C] //Proc of the 14th European Symp on Algorithms. Berlin: Springer, 2006: 76- 87
                            </a>
                        </p>
                        <p id="315">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An optimal dynamic spanner for doubling metric spaces">

                                <b>[7]</b>Gottlieb L A, Roditty L. An optimal dynamic spanner for doubling metric spaces[C] //Proc of the 16th European Symp on Algorithms. Berlin: Springer, 2008: 478- 489
                            </a>
                        </p>
                        <p id="317">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Graph distances in the streaming model: The value of space">

                                <b>[8]</b>Feigenbaum J, Kannan S, Mcgregor A, et al. Graph distances in the streaming model: The value of space[C] //Proc of the 16th ACM-SIAM Symp on Discrete Algorithms. Philadelphia: SIAM, 2005: 745- 754
                            </a>
                        </p>
                        <p id="319">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Faster streaming algorithms for graph apanners">

                                <b>[9]</b>Baswana S. Faster streaming algorithms for graph apanners [EB/OL]. [2017-09-10]. http://arxiv.org/abs/cs/0611023v1
                            </a>
                        </p>
                        <p id="321">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012100980148&amp;v=MjEzMzBud1plWnVIeWptVWI3SUpsd1ZhUlE9TmlmT2ZiSzdIdERPcm85RmJlTVBEWGd4b0JNVDZUNFBRSC9pclJkR2VycVFUTQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b>Ausiello G, Franciosa P G, Italiano G F. Small stretch (α, β) -spanners in the streaming model[J]. Theoretical Computer Science, 2009, 410 (36) : 3406- 3413
                            </a>
                        </p>
                        <p id="323">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A fast streaming spanner algorithm for incrementally constructing sparse roadmaps">

                                <b>[11]</b>Wang Weifu, Balkcom D, Chakrabarti A. A fast streaming spanner algorithm for incrementally constructing sparse roadmaps[C] //Proc of the 25th IEEE/RSJ Int Conf on Intelligent Robots and Systems. Piscataway, NJ: IEEE, 2013: 1257- 1263
                            </a>
                        </p>
                        <p id="325">
                            <a id="bibliography_12" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300574635&amp;v=Mjg3MjVUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VYjdJSmx3VmFSUT1OaWZPZmJLN0h0RE9ySTlGWWV3TENuODhvQk1UNg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[12]</b>Liebchen C, Wünsch G. The zoo of tree spanner problems[J]. Discrete Applied Mathematics, 2008, 156 (5) : 569- 587
                            </a>
                        </p>
                        <p id="327">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES14110700233259&amp;v=MDA4ODROaWZPZmJLOEg5RE1xSTlGWnVnTURua3dvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVViN0lKbHdWYVJRPQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b>Dragan F F, Abu-Ata M. Collective additive tree spanners of bounded tree-breadth graphs with generalizations and consequences [J]. Theoretical Computer Science, 2014, 547 (27) : 1- 17
                            </a>
                        </p>
                        <p id="329">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A faster computation of all the best swap edges of a tree spanner">

                                <b>[14]</b>Bilò D, Colella F, Gualà L, et al. A faster computation of all the best swap edges of a tree spanner[C] //Proc of the 22nd Int Colloquium on Structural Information and Communication Complexity. Berlin: Springer, 2015: 239- 253
                            </a>
                        </p>
                        <p id="331">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000090693&amp;v=MjY2MTJvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVViN0lKbHdWYVJRPU5pZklZN0s3SHRqTnI0OUZaT0lQQ25VNg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b>Roditty L, Thorup M, Zwick U. Roundtrip spanners and roundtrip routing in directed graphs[J]. ACM Transactions on Algorithms, 2008, 4 (3) : 29:1- 29:17
                            </a>
                        </p>
                        <p id="333">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Approximating cycles in directed graphs: Fast algorithms for girth and roundtrip spanners">

                                <b>[16]</b>Pachocki J, Roditty L, Sidford A, et al. Approximating cycles in directed graphs: Fast algorithms for girth and roundtrip spanners[C] //Proc of the 29th ACM-SIAM Symp on Discrete Algorithms. New York: ACM, 2018: 1374- 1392
                            </a>
                        </p>
                        <p id="335">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES786E1783E0F1AD9C542FA97EC0A0C0CF&amp;v=MDMwNTFHRWV0NURRMU54bVVXN2owTE9YYmwyV0UxQ0xMblJjbnBDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVkbGh3cnErdzY0PU5pZk9mYlN3R0tUTnFJZA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b>Zhu Chunjiang, Lam K Y. Source-wise round-trip spanners[J]. Information Processing Letters, 2017, 124 (8) : 42- 45
                            </a>
                        </p>
                        <p id="337">
                            <a id="bibliography_18" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000103514&amp;v=MjYzODJRPU5pZklZN0s3SHRqTnI0OUZaZXNNQ1gwOW9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVWI3SUpsd1ZhUg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[18]</b>Peleg D, Roditty L. Localized spanner construction for ad hoc networks with variable transmission range[J]. ACM Transactions on Sensor Networks, 2010, 7 (3) : 25:1- 25:14
                            </a>
                        </p>
                        <p id="339">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Spanners and reachability oracles for directed transmission graphs">

                                <b>[19]</b>Kaplan H, Mulzer W, Roditty L, et al. Spanners and reachability oracles for directed transmission graphs[C] //Proc of the 31st Int Symp on Computational Geometry. Wadern, Saarland, Germany: Dagstuhl, 2015: 156- 170
                            </a>
                        </p>
                        <p id="341">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Power-Law Distribution of the World Wide Web">

                                <b>[20]</b>Adamic L A, Huberman B A, Barabási A L, et al. Power-law distribution of the world wide web[J]. Science, 2000, 287 (5461) : 2115
                            </a>
                        </p>
                        <p id="343">
                            <a id="bibliography_21" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201310012&amp;v=MDM2NDZPZVplVnZGeTduVXJ6T0x5dlNkTEc0SDlMTnI0OUVab1FLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkw=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[21]</b>Liu Dayou, Jin Di, He Xiaodong, et al. Community mining in complex network[J]. Journal of Computer Research and Development, 2013, 50 (10) : 2140- 2154 (in Chinese) (刘大有, 金弟, 何东晓, 等. 复杂网络社区挖掘综述[J]. 计算机研究与发展, 2013, 50 (10) : 2140- 2154) 
                            </a>
                        </p>
                        <p id="345">
                            <a id="bibliography_22" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The structure and dynamics of multilayer networks">

                                <b>[22]</b>Boccaletti S, Bianconi G, Criado R, et al. The structure and dynamics of multilayer networks[J]. Physics Reports, 2014, 544 (1) : 1- 122
                            </a>
                        </p>
                        <p id="347">
                            <a id="bibliography_23" target="_blank" href="http://scholar.cnki.net/result.aspx?q=R-mat:A recursive model for graph mining">

                                <b>[23]</b>Chakrabarti D, Zhan Yiping, Faloutsos C. R-MAT: A recursive model for graph mining[C] //Proc of the 4th SIAM Int Conf on Data Mining. Philadelphia: SIAM, 2004: 442- 446
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201903020" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903020&amp;v=MTc3MTVIWklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVZ2Rnk3blVyek9MeXZTZExHNEg5ak1ySTk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
