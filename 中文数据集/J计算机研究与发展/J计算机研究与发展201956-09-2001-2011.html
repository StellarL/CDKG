

<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>

</head>

<body>

    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637127163620770000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201909021%26RESULT%3d1%26SIGN%3dcafkqBHnnWadweUunLVHtPU4Mjc%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201909021&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201909021&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>


    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201909021&amp;v=MDAxMDNVUkxPZVplUnNGeS9nVkw3TEx5dlNkTEc0SDlqTXBvOUhaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#44" data-title="&lt;b&gt;1 基于指令解释的映射模型&lt;/b&gt; "><b>1 基于指令解释的映射模型</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#46" data-title="&lt;b&gt;1.1 机器模拟的形式化描述&lt;/b&gt;"><b>1.1 机器模拟的形式化描述</b></a></li>
                                                <li><a href="#50" data-title="&lt;b&gt;1.2 机器模拟的性质&lt;/b&gt;"><b>1.2 机器模拟的性质</b></a></li>
                                                <li><a href="#57" data-title="&lt;b&gt;1.3 现有模型存在的不足&lt;/b&gt;"><b>1.3 现有模型存在的不足</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#66" data-title="&lt;b&gt;2 二进制翻译过程的抽象及其形式化&lt;/b&gt; "><b>2 二进制翻译过程的抽象及其形式化</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#69" data-title="&lt;b&gt;2.1 机器的抽象描述&lt;/b&gt;"><b>2.1 机器的抽象描述</b></a></li>
                                                <li><a href="#84" data-title="&lt;b&gt;2.2 程序执行的抽象&lt;/b&gt;"><b>2.2 程序执行的抽象</b></a></li>
                                                <li><a href="#95" data-title="&lt;b&gt;2.3 模拟行为的抽象&lt;/b&gt;"><b>2.3 模拟行为的抽象</b></a></li>
                                                <li><a href="#104" data-title="&lt;b&gt;2.4 二进制翻译过程的抽象&lt;/b&gt;"><b>2.4 二进制翻译过程的抽象</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#107" data-title="&lt;b&gt;3 二进制翻译的正确性&lt;/b&gt; "><b>3 二进制翻译的正确性</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#109" data-title="&lt;b&gt;3.1 等价的一般性描述&lt;/b&gt;"><b>3.1 等价的一般性描述</b></a></li>
                                                <li><a href="#116" data-title="&lt;b&gt;3.2 状态映射函数的性质&lt;/b&gt;"><b>3.2 状态映射函数的性质</b></a></li>
                                                <li><a href="#123" data-title="&lt;b&gt;3.3 状态转移函数的表达形式&lt;/b&gt;"><b>3.3 状态转移函数的表达形式</b></a></li>
                                                <li><a href="#136" data-title="&lt;b&gt;3.4 指称语义等价状态序列的构建&lt;/b&gt;"><b>3.4 指称语义等价状态序列的构建</b></a></li>
                                                <li><a href="#146" data-title="&lt;b&gt;3.5 状态转移函数构建的正确性验证&lt;/b&gt;"><b>3.5 状态转移函数构建的正确性验证</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#150" data-title="&lt;b&gt;4 优化过程的形式化描述&lt;/b&gt; "><b>4 优化过程的形式化描述</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#153" data-title="&lt;b&gt;4.1 状态转移函数表述形式对效率的影响&lt;/b&gt;"><b>4.1 状态转移函数表述形式对效率的影响</b></a></li>
                                                <li><a href="#172" data-title="&lt;b&gt;4.2 状态转移函数在宿主机器状态序列的实现&lt;/b&gt;"><b>4.2 状态转移函数在宿主机器状态序列的实现</b></a></li>
                                                <li><a href="#176" data-title="&lt;b&gt;4.3 状态转移函数的修改&lt;/b&gt;"><b>4.3 状态转移函数的修改</b></a></li>
                                                <li><a href="#180" data-title="&lt;b&gt;4.4 复合优化翻译模式&lt;/b&gt;"><b>4.4 复合优化翻译模式</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#195" data-title="&lt;b&gt;5 总  结&lt;/b&gt; "><b>5 总  结</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#52" data-title="图1 机器模拟中的映射关系">图1 机器模拟中的映射关系</a></li>
                                                <li><a href="#138" data-title="图2 基于子函数描述的状态转移函数构建">图2 基于子函数描述的状态转移函数构建</a></li>
                                                <li><a href="#141" data-title="图3 基于连通子图描述的状态转移函数构建">图3 基于连通子图描述的状态转移函数构建</a></li>
                                                <li><a href="#144" data-title="图4 二进制翻译的形式化模型">图4 二进制翻译的形式化模型</a></li>
                                                <li><a href="#169" data-title="图5 后继状态计算过程(1)">图5 后继状态计算过程(1)</a></li>
                                                <li><a href="#178" data-title="图6 二进制翻译双映射过程">图6 二进制翻译双映射过程</a></li>
                                                <li><a href="#187" data-title="图7 后继状态计算过程(2)">图7 后继状态计算过程(2)</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title="Tan Yusong,Wu Qingbo.A study of virtualization and operating system technologies [J].Computer Engineering &amp;amp; Science,2011,33(4):62- 68 (in Chinese)(谭郁松,吴庆波.虚拟化与操作系统辨析[J].计算机工程与科学,2011,33(4):62- 68)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJK201104014&amp;v=MTgxNDdUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJzRnkvZ1ZMN0tMejdCWmJHNEg5RE1xNDlFWUlRS0RIODR2UjQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                        Tan Yusong,Wu Qingbo.A study of virtualization and operating system technologies [J].Computer Engineering &amp;amp; Science,2011,33(4):62- 68 (in Chinese)(谭郁松,吴庆波.虚拟化与操作系统辨析[J].计算机工程与科学,2011,33(4):62- 68)
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title="Tang Feng,Wu Chenggang,Zhang Zhaoqing,et al.Exception handling in application level binary translation [J].Journal of Computer Research and Development,2006,43(12):2166- 2173 (in Chinese)(唐锋,武成岗,张兆庆,等.二进制翻译应用级异常处理[J].计算机研究与发展,2006,43(12):2166- 2173)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200612026&amp;v=MTgyNDVMRzRIdGZOclk5SFlvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSc0Z5L2dWTDdLTHl2U2Q=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                        Tang Feng,Wu Chenggang,Zhang Zhaoqing,et al.Exception handling in application level binary translation [J].Journal of Computer Research and Development,2006,43(12):2166- 2173 (in Chinese)(唐锋,武成岗,张兆庆,等.二进制翻译应用级异常处理[J].计算机研究与发展,2006,43(12):2166- 2173)
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title="Yang Hao,Tang Feng,Xie Haibin,et al.Library function disposing approach in binary translation [J].Journal of Computer Research and Development,2006,43(12):2174- 2179 (in Chinese)(杨浩,唐锋,谢海斌,等.二进制翻译中的库函数处理[J].计算机研究与发展,2006,43(12):2174- 2179)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200612027&amp;v=MDgyMDVMT2VaZVJzRnkvZ1ZMN0tMeXZTZExHNEh0Zk5yWTlIWTRRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                        Yang Hao,Tang Feng,Xie Haibin,et al.Library function disposing approach in binary translation [J].Journal of Computer Research and Development,2006,43(12):2174- 2179 (in Chinese)(杨浩,唐锋,谢海斌,等.二进制翻译中的库函数处理[J].计算机研究与发展,2006,43(12):2174- 2179)
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title="Zhao Tianlei,Tang Yuxing,Fu Guitao,et al.Accelerating program behavior analysis with dynamic binary translation [J].Journal of Computer Research and Development,2012,49(1):35- 43 (in Chinese)(赵天磊,唐遇星,付桂涛,等.利用动态二进制翻译加速应用程序行为特征分析[J].计算机研究与发展,2012,49(1):35- 43)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201201005&amp;v=MTgzMzZxQnRHRnJDVVJMT2VaZVJzRnkvZ1ZMN0tMeXZTZExHNEg5UE1ybzlGWVlRS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                        Zhao Tianlei,Tang Yuxing,Fu Guitao,et al.Accelerating program behavior analysis with dynamic binary translation [J].Journal of Computer Research and Development,2012,49(1):35- 43 (in Chinese)(赵天磊,唐遇星,付桂涛,等.利用动态二进制翻译加速应用程序行为特征分析[J].计算机研究与发展,2012,49(1):35- 43)
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title="Nakamura T,Miki S,Oikawa S.Automatic vectorization by runtime binary translation [C] //Proc of the 2nd Int Conf on Networking and Computing.Washington:IEEE Computer Society,2011:87- 94" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Automatic vectorization by runtime binary translation">
                                        <b>[5]</b>
                                        Nakamura T,Miki S,Oikawa S.Automatic vectorization by runtime binary translation [C] //Proc of the 2nd Int Conf on Networking and Computing.Washington:IEEE Computer Society,2011:87- 94
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title="Chen Jiuye,Yang Wu,Shen Boye,et al.Automatic validation for binary translation[J].Computer Languages Systems &amp;amp; Structures,2015,43(C):96- 115" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Automatic validation for binary translation">
                                        <b>[6]</b>
                                        Chen Jiuye,Yang Wu,Shen Boye,et al.Automatic validation for binary translation[J].Computer Languages Systems &amp;amp; Structures,2015,43(C):96- 115
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title="William Y J,Bauman M A,Kao Fengjung,et al.Operand and limits optimization for binary translation system:America,US9021454[P].2015-04-28" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Operand and limits optimization for binary translation system">
                                        <b>[7]</b>
                                        William Y J,Bauman M A,Kao Fengjung,et al.Operand and limits optimization for binary translation system:America,US9021454[P].2015-04-28
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title="Tr&#246;ger J.Specification-driven dynamic binary translation [D].Brisbane,Australia:Queensland University of Technology,2005" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Specification-driven dynamic binary translation">
                                        <b>[8]</b>
                                        Tr&#246;ger J.Specification-driven dynamic binary translation [D].Brisbane,Australia:Queensland University of Technology,2005
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title="Rabin M O.Computable algebra,general theory and theory of computable fields [J].Transactions of the American Mathematical Society,1960,95(2):341- 360" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJAM&amp;filename=SJAM120524012713&amp;v=MTUzODBEeE04enhVU21EZDlTSDduM3hFOWZidm5LcmlmWnU5dUZDdm5VN2pOSjE4V05pZktZN0s2SHRUT3E0OUVadXdP&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[9]</b>
                                        Rabin M O.Computable algebra,general theory and theory of computable fields [J].Transactions of the American Mathematical Society,1960,95(2):341- 360
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title="Chen Wei,Xu Weixia,Wang Zhiying,et al.A formalization of an emulation based co-designed virtual machine[C] //Proc of the 5th Int Conf on Innovative Mobile and Internet Services in Ubiquitous Computing.Washington:IEEE Computer Society,2011:164- 168" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A formalization of an emulation based co-designed virtual machine">
                                        <b>[10]</b>
                                        Chen Wei,Xu Weixia,Wang Zhiying,et al.A formalization of an emulation based co-designed virtual machine[C] //Proc of the 5th Int Conf on Innovative Mobile and Internet Services in Ubiquitous Computing.Washington:IEEE Computer Society,2011:164- 168
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title="Liao Yin.Dynamic binary translation modeling and parallelization research [D].Hefei:University of Science and Technology of China,2013 (in Chinese)(廖银.动态二进制翻译建模及其并行化研究[D].合肥:中国科学技术大学,2013)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1013228534.nh&amp;v=MjMxMzR6cXFCdEdGckNVUkxPZVplUnNGeS9nVkw3S1ZGMjZIYkc2RnRUUHE1RWJQSVFLREg4NHZSNFQ2ajU0TzM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                        Liao Yin.Dynamic binary translation modeling and parallelization research [D].Hefei:University of Science and Technology of China,2013 (in Chinese)(廖银.动态二进制翻译建模及其并行化研究[D].合肥:中国科学技术大学,2013)
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" title="Winskel G.The Formal Semantics of Programming Languages [M].Cambridge,MA:MIT Press,2004" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The Formal Semantics of Programming Languages">
                                        <b>[12]</b>
                                        Winskel G.The Formal Semantics of Programming Languages [M].Cambridge,MA:MIT Press,2004
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title="Song Fangmin.Proof of equivalence of programs [J].Journal of Computer Research and Development,1989,26(4):34- 38 (in Chinese)(宋方敏.程序的等价性证明[J].计算机研究与发展,1989,26(4):34- 38)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ198904007&amp;v=MDUzNzJPM3pxcUJ0R0ZyQ1VSTE9lWmVSc0Z5L2dWTDdLTHl2U2RMS3hGdGpNcTQ5Rlk0UUtESDg0dlI0VDZqNTQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                        Song Fangmin.Proof of equivalence of programs [J].Journal of Computer Research and Development,1989,26(4):34- 38 (in Chinese)(宋方敏.程序的等价性证明[J].计算机研究与发展,1989,26(4):34- 38)
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_14" title="David M.Model Theory:An Introduction [M].Berlin:Springer,2007" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Model Theory:An Introduction">
                                        <b>[14]</b>
                                        David M.Model Theory:An Introduction [M].Berlin:Springer,2007
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_15" title="Shen Yuming,Ma Yue,Cao Cungen,et al.Faithful and full translations between logics [J].Journal of Software,2013,24(7):1626- 1637 (in Chinese)(申宇铭,马越,曹存根,等.逻辑之间的语义忠实语义满翻译[J].软件学报,2013,24(7):1626- 1637)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201307017&amp;v=MTkzMDBGckNVUkxPZVplUnNGeS9nVkw3S055ZlRiTEc0SDlMTXFJOUVZNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEc=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                        Shen Yuming,Ma Yue,Cao Cungen,et al.Faithful and full translations between logics [J].Journal of Software,2013,24(7):1626- 1637 (in Chinese)(申宇铭,马越,曹存根,等.逻辑之间的语义忠实语义满翻译[J].软件学报,2013,24(7):1626- 1637)
                                    </a>
                                </li>
                                <li id="33">


                                    <a id="bibliography_16" title="Tao Qiuming,Zhao Chen,Guo Liang.Proving soundness of program transformations in optimizing compilation based on temporal logic [J].Journal of Software,2009,20(8):2074- 2086 (in Chinese)(陶秋铭,赵琛,郭亮,等.基于时序逻辑证明编译优化程序变换的保义性[J].软件学报,2009,20(8):2074- 2086)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB200908009&amp;v=MTY3MjNVUkxPZVplUnNGeS9nVkw3S055ZlRiTEc0SHRqTXA0OUZiWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                        Tao Qiuming,Zhao Chen,Guo Liang.Proving soundness of program transformations in optimizing compilation based on temporal logic [J].Journal of Software,2009,20(8):2074- 2086 (in Chinese)(陶秋铭,赵琛,郭亮,等.基于时序逻辑证明编译优化程序变换的保义性[J].软件学报,2009,20(8):2074- 2086)
                                    </a>
                                </li>
                                <li id="35">


                                    <a id="bibliography_17" title="Dai Tao,Shan Zheng,Lu Shuaibing,et al.Register allocation algorithm of dynamic binary translation based on priority [J].Journal of Zhejiang University:Engineering Science,2016,50(7):1338- 1346 (in Chinese)(戴涛,单征,卢帅兵,等.基于优先级动态二进制翻译寄存器分配算法[J].浙江大学学报:工学版,2016,50(7):1338- 1346)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=ZDZC201607016&amp;v=Mjg3MzFzRnkvZ1ZMN0tQeW5SYmJHNEg5Zk1xSTlFWW9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                        Dai Tao,Shan Zheng,Lu Shuaibing,et al.Register allocation algorithm of dynamic binary translation based on priority [J].Journal of Zhejiang University:Engineering Science,2016,50(7):1338- 1346 (in Chinese)(戴涛,单征,卢帅兵,等.基于优先级动态二进制翻译寄存器分配算法[J].浙江大学学报:工学版,2016,50(7):1338- 1346)
                                    </a>
                                </li>
                                <li id="37">


                                    <a id="bibliography_18" >
                                        <b>[18]</b>
                                    Wen Yanhua,Tang Daguo,Qi Fengbin.Register mapping and register function cutting out implementation in binary translation [J].Journal of Software,2009,20(Supplement):1- 7 (in Chinese)(文延华,唐大国,漆锋滨.二进制翻译中的寄存器映射与剪裁的实现[J].软件学报,2009,20(增刊):1- 7)</a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(09),2001-2011 DOI:10.7544/issn1000-1239.2019.20180513            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>二进制翻译正确性及优化方法的形式化模型</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%82%85%E7%AB%8B%E5%9B%BD&amp;code=39936564&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">傅立国</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BA%9E%E5%BB%BA%E6%B0%91&amp;code=39547374&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">庞建民</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%8B%E5%86%9B&amp;code=39976037&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">王军</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BC%A0%E5%AE%B6%E8%B1%AA&amp;code=41491892&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张家豪</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%B2%B3%E5%B3%B0&amp;code=41491891&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">岳峰</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%95%B0%E5%AD%A6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%85%88%E8%BF%9B%E8%AE%A1%E7%AE%97%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4(%E6%88%98%E7%95%A5%E6%94%AF%E6%8F%B4%E9%83%A8%E9%98%9F%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E5%A4%A7%E5%AD%A6)&amp;code=1702647&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">数学工程与先进计算国家重点实验室(战略支援部队信息工程大学)</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>二进制翻译在体系结构设计、程序性能优化、安全性分析以及软件移植等领域的研究中备受关注.不同应用场景对二进制翻译的需求各不相同,却总聚焦于翻译的正确性和翻译的效率2个方面.翻译的正确性用于评判翻译前后程序在逻辑功能上是否具有等价性,而等价的证明依赖于适当的形式化模型.为了满足研究二进制翻译正确性以及翻译优化方法对理论模型的需求,对已有理论模型进行了深入的剖析,并进一步构建了新的基于后继关系的映射模型.该模型既能够形式化地描述正确翻译的二进制翻译过程所具备的性质和构造方法,也可以在翻译过程形式化描述的基础上对翻译过程优化方法的特征和性质进行描述.通过构建翻译正确性及翻译过程优化方法的形式化模型,为二进制翻译技术中关于翻译过程的实现以及优化方法的策略组合等进一步研究提供了更强的理论支撑.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BF%BB%E8%AF%91&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">二进制翻译;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%BF%BB%E8%AF%91%E6%AD%A3%E7%A1%AE%E6%80%A7&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">翻译正确性;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%95%88%E7%8E%87&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">效率;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%BF%BB%E8%AF%91%E4%BC%98%E5%8C%96&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">翻译优化;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">形式化模型;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    *庞建民,jianmin_pang@126.com;
                                </span>
                                <span>
                                    傅立国,flg_njlg@163.com;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-07-17</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目(61472447);</span>
                    </p>
            </div>
                    <h1><b>Formal Model of Correctness and Optimization on Binary Translation</b></h1>
                    <h2>
                    <span>Fu Liguo</span>
                    <span>Pang Jianmin</span>
                    <span>Wang Jun</span>
                    <span>Zhang Jiahao</span>
                    <span>Yue Feng</span>
            </h2>
                    <h2>
                    <span>State Key Laboratory of Mathematical Engineering and Advanced Computing (Strategic Support Force Information Engineering University)</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Binary translation has attracted more and more attention in the fields of architecture optimization, program performance optimization, security analysis, software transplantation and so on. Although there are totally different requirements on the application of binary translation techniques in these various fields, the researchers are always focusing their attention on two aspects: the correctness of translation and the efficiency of translation. The correctness of translation refers to the equivalent logical functions between the program before and after the translation, so an appropriate formal model for the translation needs to be built at first. According to the current research needs on correctness and optimization of binary translation technique, twice mapping model based on subsequent relations could have been constructed firstly; then the properties and construction methods of a correct process on translation should have been described formally; based on the formal description, the optimization methods of translation would be classified and analyzed on their diverse characteristics and various properties finally. This paper provides a more powerful theoretical support for the further research on the strategy pattern combination of translation methods and optimization methods in the binary translation technology by constructing a formal model of binary translation based on correctness and optimization.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=binary%20translation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">binary translation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=translation%20correctness&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">translation correctness;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=efficiency&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">efficiency;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=translation%20optimization&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">translation optimization;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=formal%20model&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">formal model;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Fu Liguo,born in 1989.PhD.His main research interests include advanced compi-lation and high performance computing.&lt;image id="237" type="formula" href="images/JFYZ201909021_23700.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Pang Jianmin, born in 1964. PhD, professor,PhD supervisor.Senior member of CCF. His main research interests include computer architecture,information security and high performance computing.&lt;image id="239" type="formula" href="images/JFYZ201909021_23900.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Wang Jun,born in 1992.PhD candidate. His  main  research  interests  include computer architecture and high performance computing.&lt;image id="241" type="formula" href="images/JFYZ201909021_24100.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Zhang Jiahao,born in 1991.Master.His main research interests include computer architecture and high performance computing.&lt;image id="243" type="formula" href="images/JFYZ201909021_24300.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Yue Feng,born in 1985.PhD.Member of CCF.His main research interests include advanced compilation and high performance computing.&lt;image id="245" type="formula" href="images/JFYZ201909021_24500.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2018-07-17</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Natural Science Foundation of China(61472447);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="39">传统意义上的二进制翻译是指将源平台指令集的指令序列翻译成其他平台指令集的指令序列的过程.随着虚拟化技术应用的兴起,二进制翻译技术作为跨指令集架构虚拟化实现的核心技术被广泛关注<citation id="217" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>.二进制翻译中的动态翻译方式既能够在程序运行期间动态地解释代码片段,也能够结合程序运行的时空局部性特征实现性能调优,亦可以再现程序在源平台复杂的运行时行为,从而成为体系结构设计、程序性能优化、安全性分析以及软件移植的研究热点.</p>
                </div>
                <div class="p1">
                    <p id="40">为实现二进制程序到其他平台的有效移植,需要确保二进制翻译过程的正确性和有效性.正确性要求源平台二进制程序的逻辑功能在宿主平台上被予以等价的实现;有效性关注的是源平台代码在宿主平台上运行时的效率.因此,二进制翻译技术在应用研究中的问题总是可以归结为翻译的正确性问题和翻译的效率问题.</p>
                </div>
                <div class="p1">
                    <p id="41">现有相关问题的研究大多是对限定翻译系统工程实现的探讨,局限于具体翻译系统缺陷的修复.以选定的翻译器或者翻译框架为条件,不利于深入研究二进制翻译的正确性和运行效率.如用于精确处理中断、精确处理异常还原的二进制翻译器,则更关注其翻译的正确性;而用于软件无源移植的翻译器则更关注其运行效率<sup></sup><citation id="218" type="reference"><link href="5" rel="bibliography" /><link href="7" rel="bibliography" /><sup>[<a class="sup">2</a>,<a class="sup">3</a>]</sup></citation>.</p>
                </div>
                <div class="p1">
                    <p id="42">在设计二进制翻译器时,将翻译过程的正确性和效率作为整体进行研究,能够预见和避免类似限定框架下存在的种种问题.例如,在新型体系架构研发的研究中,为了解决传统的通过功能模拟的方法收集典型行为特征速度很慢的问题,使用了动态二进制翻译技术来加快程序行为分析.然而该方法却也引入了分析误差,可见追求翻译的有效性时翻译的正确性会受到影响<citation id="219" type="reference"><link href="9" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>.因此,翻译正确性和翻译效率以及两者之间关联性的研究对于二进制翻译系统框架的设计具有重要意义,特别是在对一些优化方法的正确性进行理论验证的过程中.</p>
                </div>
                <div class="p1">
                    <p id="43">在现有的二进制翻译正确性验证相关的研究中,采用自动化形式化的验证方法已经比较普遍.如文献<citation id="220" type="reference">[<a class="sup">5</a>]</citation>于2011年提出了对动态翻译过程中SIMD指令的翻译进行运行时验证的方法;文献<citation id="221" type="reference">[<a class="sup">6</a>]</citation>于2015年提出同时支持动态翻译和静态翻译的验证方法,却局限于仅对部分制定翻译结果的验证;文献<citation id="222" type="reference">[<a class="sup">7</a>]</citation>于同年提出了使用形式化的方法讨论操作数和操作数约束的优化过程,然而该模型对于二进制优化方法的描述不具备通用性.因此为了能够对翻译的正确性和优化方法的有效性进行一致性的研究,本文对翻译过程及其优化方法构建适当的形式化模型.</p>
                </div>
                <h3 id="44" name="44" class="anchor-tag"><b>1 基于指令解释的映射模型</b></h3>
                <div class="p1">
                    <p id="45">文献<citation id="223" type="reference">[<a class="sup">8</a>]</citation>借鉴文献<citation id="224" type="reference">[<a class="sup">9</a>]</citation>中可计算代数系统中同构的性质,构建了机器模拟过程和动态二进制翻译过程的形式化模型.该模型将机器模拟的过程定义为由源机器状态和指令解释函数组成的有序对到由宿主机器状态和指令解释函数组成的有序对的映射;继而在此基础上,将动态二进制翻译过程归约为机器模拟过程的动态优化方法,从而描述了动态二进制翻译过程相较于机器模拟过程所优化的对象和方法.</p>
                </div>
                <h4 class="anchor-tag" id="46" name="46"><b>1.1 机器模拟的形式化描述</b></h4>
                <div class="p1">
                    <p id="47"><b>定义1</b>. 机器描述1.机器为<i>M</i>=(<i>S</i>,<i>I</i>,<i>γ</i>).其中,<i>S</i>表示机器的状态集;<i>I</i>表示机器的指令集;<i>γ</i>:<i>I</i>×<i>S</i>→<i>S</i>表示机器指令在指定机器状态下的解释函数.</p>
                </div>
                <div class="p1">
                    <p id="48">当指令<i>i</i>∈<i>I</i>作用于状态<i>s</i>∈<i>S</i>,其后继状态<i>s</i>′可表示为<i>s</i>′=<i>γ</i>(<i>i</i>,<i>s</i>).</p>
                </div>
                <div class="p1">
                    <p id="49"><b>定义2</b>. 解释函数.指令路径<i>i</i><sup>*</sup>=&lt;<i>i</i><sub>0</sub>,<i>i</i><sub>1</sub>,…,<i>i</i><sub><i>m</i></sub><sub>-1</sub>&gt;∈<i>I</i><sup>*</sup>的解释函数为<i>γ</i><sup>*</sup>:<i>I</i><sup>*</sup>×<i>S</i>→<i>S</i>,表示进行<i>m</i>次<i>γ</i>的迭代操作,即<i>γ</i>(<i>i</i><sub><i>m</i></sub><sub>-1</sub>,…,<i>γ</i>(<i>i</i><sub>2</sub>,<i>γ</i>(<i>i</i><sub>1</sub>,<i>γ</i>(<i>i</i><sub>0</sub>,<i>s</i><sub>0</sub>)))…)=<i>γ</i><sup>*</sup>(<i>i</i><sup>*</sup>,<i>s</i><sub>0</sub>).</p>
                </div>
                <h4 class="anchor-tag" id="50" name="50"><b>1.2 机器模拟的性质</b></h4>
                <div class="p1">
                    <p id="51">在宿主机器模拟源机器,即对源机器的指令执行行为进行模拟.因此,源机器的组成要素需要在宿主机器上一一实现.用<i>M</i><sub>R</sub>=(<i>S</i><sub>R</sub>,<i>I</i><sub>R</sub>,<i>γ</i><sub>R</sub>)表示源机器,用<i>M</i><sub>H</sub>=(<i>S</i><sub>H</sub>,<i>I</i><sub>H</sub>,<i>γ</i><sub>H</sub>)表示宿主机器,设<i>φ</i><sub><i>S</i></sub>:<i>S</i><sub>R</sub>→<i>S</i><sub>H</sub>为源机器状态集合到宿主机器状态集合的映射.设<i>φ</i><sub><i>I</i></sub>:<i>I</i><sup>*</sup><sub>R</sub>→<i>I</i><sup>*</sup><sub>H</sub>为源机器指令路径集合到宿主机器指令路径集合的映射.机器模拟中源机器和宿主机器关于状态和指令路径的映射关系如图1所示.</p>
                </div>
                <div class="area_img" id="52">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909021_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 机器模拟中的映射关系" src="Detail/GetImg?filename=images/JFYZ201909021_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 机器模拟中的映射关系  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909021_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 The mapping relation in machine simulation</p>

                </div>
                <div class="p1">
                    <p id="53">源机器<i>M</i><sub>R</sub>执行指令序列<i>i</i><sup>*</sup><sub>R</sub>由状态<i>s</i><sub>R</sub>到达状态<i>γ</i><sup>*</sup><sub>R</sub>(<i>i</i><sup>*</sup><sub>R</sub>,<i>s</i><sub>R</sub>), <i>γ</i><sup>*</sup><sub>R</sub>为指令序列<i>i</i><sup>*</sup><sub>R</sub>的解释函数.宿主机器<i>M</i><sub>H</sub>对<i>M</i><sub>R</sub>的模拟行为表现在2个方面:1)对状态<i>s</i><sub>R</sub>和<i>γ</i><sup>*</sup><sub>R</sub>(<i>i</i><sup>*</sup><sub>R</sub>,<i>s</i><sub>R</sub>)有相对应的状态<i>φ</i><sub><i>S</i></sub>(<i>s</i><sub>R</sub>)和<i>φ</i><sub><i>S</i></sub>(<i>γ</i><sup>*</sup><sub>R</sub>(<i>i</i><sup>*</sup><sub>R</sub>,<i>s</i><sub>R</sub>));2)对指令序列<i>i</i><sup>*</sup><sub>R</sub>有映射得到的本地指令序列<i>φ</i><sub><i>I</i></sub>(<i>i</i><sup>*</sup><sub>R</sub>),该序列的解释函数为<i>γ</i><sup>*</sup><sub>H</sub>.有效的模拟过程中,机器状态、指令序列及其解释函数应满足</p>
                </div>
                <div class="p1">
                    <p id="54"><i>φ</i><sub><i>S</i></sub>(<i>γ</i><sup>*</sup><sub>R</sub>(<i>i</i><sup>*</sup><sub>R</sub>,<i>s</i><sub>R</sub>))=<i>γ</i><sup>*</sup><sub>H</sub>(<i>φ</i><sub><i>I</i></sub>(<i>i</i><sup>*</sup><sub>R</sub>),<i>φ</i><sub><i>S</i></sub>(<i>s</i><sub>R</sub>)).(1)</p>
                </div>
                <div class="p1">
                    <p id="55">源机器<i>M</i><sub>R</sub>从状态<i>s</i><sub>R</sub>经过指令序列<i>i</i><sup>*</sup><sub>R</sub>得到状态<i>γ</i><sup>*</sup><sub>R</sub>(<i>i</i><sup>*</sup><sub>R</sub>,<i>s</i><sub>R</sub>)的过程,被宿主机器<i>M</i><sub>H</sub>从状态<i>φ</i><sub><i>S</i></sub>(<i>s</i><sub>R</sub>)经过指令序列<i>φ</i><sub><i>I</i></sub>(<i>i</i><sup>*</sup><sub>R</sub>)到状态<i>γ</i><sup>*</sup><sub>H</sub>(<i>φ</i><sub><i>I</i></sub>(<i>i</i><sup>*</sup><sub>R</sub>),<i>φ</i><sub><i>S</i></sub>(<i>s</i><sub>R</sub>))的过程所模拟.</p>
                </div>
                <div class="p1">
                    <p id="56">文献<citation id="225" type="reference">[<a class="sup">8</a>]</citation>将动态二进制翻译归为机器模拟过程的动态优化技术,指出其实质是源机器平台上执行路径在宿主机器上的再次编译,并参照式(1)给出了动态二进制翻译的一般性质.</p>
                </div>
                <h4 class="anchor-tag" id="57" name="57"><b>1.3 现有模型存在的不足</b></h4>
                <div class="p1">
                    <p id="58">基于指令解释的映射模型通过式(1)描述了机器模拟过程和动态二进制翻译过程的一般性质.文献<citation id="226" type="reference">[<a class="sup">10</a>]</citation>在协同设计虚拟机的模拟研究中使用文献<citation id="227" type="reference">[<a class="sup">8</a>]</citation>中的模型对模拟过程中的一些性质给予了形式化的论证,文献<citation id="228" type="reference">[<a class="sup">5</a>,<a class="sup">6</a>,<a class="sup">7</a>]</citation>在使用这种描述方法的同时也暴露了该模型存在的一些不足.</p>
                </div>
                <h4 class="anchor-tag" id="59" name="59">1.3.1 确定的指令路径</h4>
                <div class="p1">
                    <p id="60">在该模型中,宿主机器对源机器的模拟和翻译默认源机器执行前的初始状态以及之后执行的指令序列是确定的.而在实际翻译过程中,仅加载待翻译可执行文件后的初始状态以及机器指令执行行为的相关解释是已知的.在无法确定具体指令执行路径时,便无法通过映射得到宿主机的指令执行路径.</p>
                </div>
                <h4 class="anchor-tag" id="61" name="61">1.3.2 指令路径的映射</h4>
                <div class="p1">
                    <p id="62">假设源机器执行的指令路径是确定的.通过映射得到宿主机器的指令路径,执行该指令路径使得宿主机器从初始状态得到满足条件的结束状态.然而对于模拟和翻译过程,具体执行的指令路径只是一个实现.以指令和固定的指令序列作为映射元素的翻译方式,破坏了指令序列更高层次等价翻译的可能性,这对于构建更高形式优化方法的描述是不利的.</p>
                </div>
                <h4 class="anchor-tag" id="63" name="63">1.3.3 指令路径的执行效率</h4>
                <div class="p1">
                    <p id="64">该模型主要用于描述模拟和翻译过程的正确性.仅使用状态映射函数及其优化函数描述本地指令路径的执行效率,不足以深入讨论翻译方法的优化问题.将翻译过程表示为指令路径间的映射过于抽象,无法刻画动态翻译过程的开销.该模型的翻译过程与源机器具体的指令路径相关,优化也是基于具体指令路径的.不同的指令或者指令路径其指令解释函数可能是相同的,然而这些等价的指令(序列)若按照指令为单位的翻译方式,其在宿主机器翻译得到的指令(序列)之间执行开销的差距可能极其大.翻译过程的优化也包括求解更为有效的本地实现.然而在指令映射的方法不足以描述生成的本地指令路径的效率.</p>
                </div>
                <div class="p1">
                    <p id="65">综上所述,在分析翻译效率时,该模型中的状态映射函数及其优化函数并不能涵盖翻译过程中所有重要的因素.能够对翻译过程正确性和优化方法有效性进行分析的形式化模型,需要对影响翻译正确性和翻译效率的所有因素的概念加以定义,然后结合这些因素对二进制翻译的正确性和翻译中优化方法的定义和性质进行讨论.</p>
                </div>
                <h3 id="66" name="66" class="anchor-tag"><b>2 二进制翻译过程的抽象及其形式化</b></h3>
                <div class="p1">
                    <p id="67">二进制翻译过程需要源机器架构特征描述和二进制可执行文件一同作为输入.由于宿主机器只能执行本地指令序列,待翻译的程序在宿主机器可以有2种存在形式:1)完整的宿主平台可执行文件;2)需要其他程序配合的零散的指令序列片段.然而不论是以哪种形式,本地存储的指令序列在执行时都是宿主机器对二进制程序在源机器上执行过程的模仿.</p>
                </div>
                <div class="p1">
                    <p id="68">系统性地讨论翻译过程的正确性和翻译过程的优化,需要对二进制翻译过程进行抽象.对二进制翻译过程的抽象即对源机器程序的执行过程以及对该过程模仿过程的抽象,且两者在本质上都是机器的指令执行过程.所以抽象机器上指令执行的过程是刻画二进制翻译过程的基础.</p>
                </div>
                <h4 class="anchor-tag" id="69" name="69"><b>2.1 机器的抽象描述</b></h4>
                <div class="p1">
                    <p id="70">基于指令解释的映射模型本质上是利用指令的操作语义描述指令执行过程中机器状态的变化过程,以算数表达式的形式用指令解释函数定义了指令执行的过程.机器<i>M</i>=(<i>S</i>,<i>I</i>,<i>γ</i>)从状态<i>s</i>∈<i>S</i>执行指令<i>i</i>到达状态<i>s</i>′∈<i>S</i>的过程,指令解释函数的操作语义可描述为</p>
                </div>
                <div class="p1">
                    <p id="71">&lt;<i>i</i>,<i>s</i>&gt;→<i>s</i>′.(2)</p>
                </div>
                <div class="p1">
                    <p id="72">然而,基于这种描述的指令解释函数在描述指令序列的解释函数时,在对每条指令的解释函数进行复合操作的时候需要明确每条指令的解释函数,这需要满足以下2点:一是指令序列是已知的;二是每条指令的解释函数是可表示的.为了弱化指令路径对指令迭代执行过程描述的限制,需要对指令执行过程进一步抽象.</p>
                </div>
                <div class="p1">
                    <p id="73">文献<citation id="229" type="reference">[<a class="sup">11</a>]</citation>将动态二进制翻译过程概括为查找、翻译和执行3个过程的迭代.该描述与处理器从存储器取指、译指(取值)和执行(返值)的执行过程相符.因此,指令执行的路径是和机器状态密切相关的,每个机器状态的后继状态是通过执行从该状态中获得的指令而得到的.因此机器指令的执行过程可以描述为<i>γ</i>(<i>i</i>,<i>s</i>)=<i>γ</i>(<i>f</i>(<i>s</i>),<i>s</i>)=<i>s</i>′.其中<i>f</i>表示从执行前的状态<i>s</i>获取指令<i>i</i>的过程.在状态解释函数<i>γ</i>中,2个参数都是状态<i>s</i>的函数,可将其缩略为</p>
                </div>
                <div class="p1">
                    <p id="74"><i>γ</i>(<i>s</i>)=<i>s</i>′.(3)</p>
                </div>
                <div class="p1">
                    <p id="75">如此,函数<i>γ</i>定义了一个机器状态间的映射关系,描述了机器状态在指令执行中的状态迁移过程.这种描述是对机器执行指令的行为加以抽象,而并非对具体指令的执行效果进行描述.此时<i>γ</i>不再是机器指令解释函数,而是机器指令执行的指称函数.</p>
                </div>
                <div class="p1">
                    <p id="76">使用状态转移函数可以表示任意指令和指令序列的执行.根据指称语义及其操作语义的一致性<citation id="230" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>,结合式(2)可将指令<i>i</i>∈<i>I</i>的状态转移函数表述成</p>
                </div>
                <div class="p1">
                    <p id="77"><i>γ</i>(<i>i</i>)={(<i>s</i>,<i>s</i>′)|&lt;<i>i</i>,<i>s</i>&gt;→<i>s</i>′}.(4)</p>
                </div>
                <div class="p1">
                    <p id="78">式(4)中使用函数<i>γ</i>描述了指令<i>i</i>的指称语义,称为指令<i>i</i>的指称.当讨论范围扩大为整个指令集<i>I</i>时,可以将指令集<i>I</i>的指称语义以函数的形式表述为</p>
                </div>
                <div class="p1">
                    <p id="79"><mathml id="200"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>γ</mi><mo>=</mo><mi>γ</mi><mo stretchy="false">(</mo><mi>Ι</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∪</mo><mrow><mi>i</mi><mo>∈</mo><mi>Ι</mi></mrow></munder><mo stretchy="false">{</mo></mstyle><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><msup><mi>s</mi><mo>′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">|</mo><mo>&lt;</mo><mi>i</mi><mo>,</mo><mi>s</mi><mo>&gt;</mo><mo>→</mo><msup><mi>s</mi><mo>′</mo></msup><mo stretchy="false">}</mo></mrow></math></mathml>.(5)</p>
                </div>
                <div class="p1">
                    <p id="80">此时,函数<i>γ</i>作为指令集<i>I</i>的指称定义了一个关系集合<mathml id="201"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∪</mo><mrow><mi>i</mi><mo>∈</mo><mi>Ι</mi></mrow></munder><mo stretchy="false">{</mo></mstyle><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><msup><mi>s</mi><mo>′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">|</mo><mo>&lt;</mo><mi>i</mi><mo>,</mo><mi>s</mi><mo>&gt;</mo><mo>→</mo><msup><mi>s</mi><mo>′</mo></msup><mo stretchy="false">}</mo></mrow></math></mathml>,这与式(3)所构建的状态元素关系是一致的.通过指称语义的抽象,可以归纳具有相同功能的指令和指令序列,从而刻画机器指令和指令序列执行过程的本质而不必考虑指令和指令序列的具体形式.</p>
                </div>
                <div class="p1">
                    <p id="81">综合以上分析,对机器定义如下:</p>
                </div>
                <div class="p1">
                    <p id="82"><b>定义3</b>. 机器描述2.机器为<i>M</i>=(<i>S</i>,<i>γ</i>).其中,<i>S</i>表示机器的状态集;<i>γ</i>:<i>S</i>→<i>S</i>表示机器指令集的指称函数.</p>
                </div>
                <div class="p1">
                    <p id="83">指称函数<i>γ</i>定义了状态集<i>S</i>上的一个二元关系,表示指令执行前后状态的变换关系,故也可以将其称作状态迁移函数.</p>
                </div>
                <h4 class="anchor-tag" id="84" name="84"><b>2.2 程序执行的抽象</b></h4>
                <div class="p1">
                    <p id="85">重新定义机器描述后,程序执行的过程也可以得到进一步的抽象.设加载完可执行文件后的机器状态为<i>s</i><sub>0</sub>∈<i>S</i>,程序执行的过程可以用机器指令的迭代执行过程表示,而程序执行过程状态和程序执行结果的求解问题则被归约为状态<i>s</i><sub>0</sub>后继状态的求解过程.</p>
                </div>
                <div class="p1">
                    <p id="86">状态<i>s</i><sub>0</sub>及其后续状态可以表述为有序集合{<i>γ</i><sup>0</sup>(<i>s</i><sub>0</sub>),<i>γ</i><sup>1</sup>(<i>s</i><sub>0</sub>),<i>γ</i><sup>2</sup>(<i>s</i><sub>0</sub>),…,<i>γ</i><sup><i>n</i></sup>(<i>s</i><sub>0</sub>),…}.<i>s</i><sub>0</sub>∈<i>S</i>,<i>n</i>∈N,其中<i>γ</i><sup>0</sup>(<i>s</i><sub>0</sub>)=<i>s</i><sub>0</sub>.为了深入刻画程序执行的性质,需要对该集合中元素间的关系进一步讨论.</p>
                </div>
                <div class="p1">
                    <p id="87"><b>定义4</b>. 状态间的二元关系.在机器状态集合上存在二元关系≤,对于状态<i>a</i>和状态<i>b</i>,如果<i>b</i>∈<i>γ</i><sup>*</sup>(<i>a</i>),记作<i>a</i>≤<i>b</i>.</p>
                </div>
                <div class="p1">
                    <p id="88"><b>性质1</b>. 当集合<i>γ</i><sup>*</sup>(<i>s</i><sub>0</sub>)中不存在2个相等的元素时,集合<i>γ</i><sup>*</sup>(<i>s</i><sub>0</sub>)上的二元关系≤为全序关系.</p>
                </div>
                <div class="p1">
                    <p id="89">证明.</p>
                </div>
                <div class="p1">
                    <p id="90">1) 对于任意状态<i>s</i>=<i>γ</i><sup>0</sup>(<i>s</i>)∈<i>γ</i><sup>*</sup>(<i>s</i>),因此有<i>s</i>≤<i>s</i>,自反性可证.</p>
                </div>
                <div class="p1">
                    <p id="91">2) 设有状态<i>a</i>和状态<i>b</i>使得(<i>a</i>≤<i>b</i>)∧(<i>b</i>≤<i>a</i>).根据二元关系≤的定义可知<i>b</i>∈<i>γ</i><sup>*</sup>(<i>a</i>)和<i>a</i>∈<i>γ</i><sup>*</sup>(<i>b</i>)同时成立.当<i>b</i>∈<i>γ</i><sup>*</sup>(<i>a</i>)成立,由函数<i>γ</i><sup>*</sup>的定义,不妨设<i>b</i>=<i>γ</i><sup><i>i</i></sup>(<i>a</i>),<i>i</i>≥0,带入前提条件<i>a</i>∈<i>γ</i><sup>*</sup>(<i>b</i>)有<i>a</i>∈{<i>γ</i><sup><i>i</i></sup><sup>+0</sup>(<i>a</i>),<i>γ</i><sup><i>i</i></sup><sup>+1</sup>(<i>a</i>),<i>γ</i><sup><i>i</i></sup><sup>+2</sup>(<i>a</i>),…,<i>γ</i><sup><i>i</i></sup><sup>+</sup><sup><i>n</i></sup>(<i>a</i>),…},<i>i</i>≥0,因为<i>a</i>=<i>γ</i><sup>0</sup>(<i>a</i>),所以仅当<i>i</i>=0时(<i>a</i>≤<i>b</i>)∧(<i>b</i>≤<i>a</i>)满足.此时<i>b</i>=<i>γ</i><sup>0</sup>(<i>a</i>)=<i>a</i>,反对称性可证.</p>
                </div>
                <div class="p1">
                    <p id="92">3) 设集合<i>γ</i><sup>*</sup>(<i>s</i><sub>0</sub>)中有状态<i>a</i>,<i>b</i>,<i>c</i>满足<i>a</i>≤<i>b</i>且<i>b</i>≤<i>c</i>,设<i>a</i>=<i>γ</i><sup><i>i</i></sup>(<i>s</i><sub>0</sub>),<i>b</i>=<i>γ</i><sup><i>j</i></sup>(<i>s</i><sub>0</sub>),<i>c</i>=<i>γ</i><sup><i>k</i></sup>(<i>s</i><sub>0</sub>).<i>i</i>,<i>j</i>,<i>k</i>∈N,根据二元关系≤的定义可知,<i>i</i>≤<i>j</i>,<i>j</i>≤<i>k</i>即<i>i</i>≤<i>k</i>,可得<i>a</i>≤<i>c</i>,传递性可证.综上,二元关系≤为偏序关系可证.</p>
                </div>
                <div class="p1">
                    <p id="93">4) 集合<i>γ</i><sup>*</sup>(<i>s</i><sub>0</sub>)中的任意元素均存在<i>γ</i><sup><i>i</i></sup>(<i>s</i><sub>0</sub>),<i>i</i>≥0的表达形式,因此任意2个元素总是可比较的.  证毕.</p>
                </div>
                <div class="p1">
                    <p id="94">状态迁移函数定义了指令执行前后机器状态的一个二元关系.因此程序在机器上的执行过程可以用全序集{<i>γ</i><sup>*</sup>(<i>s</i><sub>0</sub>),≤}来表示,其中<i>s</i><sub>0</sub>为程序加载完后的机器初始状态.</p>
                </div>
                <h4 class="anchor-tag" id="95" name="95"><b>2.3 模拟行为的抽象</b></h4>
                <div class="p1">
                    <p id="96">模拟是二级制翻译的核心本质,抽象描述程序执行过程后,就可以对模拟的概念加以阐述.</p>
                </div>
                <div class="p1">
                    <p id="97">设源机器<i>M</i><sub>R</sub>=(<i>S</i><sub>R</sub>,<i>γ</i><sub>R</sub>)在初始状态<i>s</i><sub>0</sub>∈<i>S</i><sub>R</sub>执行程序<i>p</i>得到状态有序集合</p>
                </div>
                <div class="p1">
                    <p id="98"><i>S</i><sup><i>p</i></sup><sub>R</sub>={<i>γ</i><sup>0</sup><sub>R</sub>(<i>s</i><sub>0</sub>),<i>γ</i><sup>1</sup><sub>R</sub>(<i>s</i><sub>0</sub>),<i>γ</i><sup>2</sup><sub>R</sub>(<i>s</i><sub>0</sub>),…,</p>
                </div>
                <div class="p1">
                    <p id="99"><i>γ</i><sup><i>m</i></sup><sub>R</sub>(<i>s</i><sub>0</sub>),…},<i>m</i>∈N.</p>
                </div>
                <div class="p1">
                    <p id="100">设宿主机器<i>M</i><sub>H</sub>=(<i>S</i><sub>H</sub>,<i>γ</i><sub>H</sub>)在初始状态<i>s</i>′<sub>0</sub>∈<i>S</i><sub>H</sub>执行程序<i>q</i>得到状态有序集合</p>
                </div>
                <div class="p1">
                    <p id="101"><i>S</i><sup><i>q</i></sup><sub>H</sub>={<i>γ</i><sup>0</sup><sub>H</sub>(<i>s</i>′<sub>0</sub>),<i>γ</i><sup>1</sup><sub>H</sub>(<i>s</i>′<sub>0</sub>),<i>γ</i><sup>2</sup><sub>H</sub>(<i>s</i>′<sub>0</sub>),…,</p>
                </div>
                <div class="p1">
                    <p id="102"><i>γ</i><sup><i>n</i></sup><sub>H</sub>(<i>s</i>′<sub>0</sub>),…},<i>n</i>∈N.</p>
                </div>
                <div class="p1">
                    <p id="103"><b>定义5</b>. 指令序列的模拟.若满足2个条件:1)存在映射<i>φ</i><sub><i>S</i></sub>使得集合<i>S</i><sup><i>p</i></sup><sub>R</sub>中的任意元素在集合<i>S</i><sup><i>q</i></sup><sub>H</sub>中有相对应的像;2)若集合<i>S</i><sup><i>p</i></sup><sub>R</sub>中有状态<i>a</i>,<i>b</i>满足(<i>a</i>≤<i>b</i>)∧(<i>a</i>≠<i>b</i>),且有<i>a</i>′∈<i>φ</i><sub><i>S</i></sub>(<i>a</i>),<i>b</i>′∈<i>φ</i><sub><i>S</i></sub>(<i>b</i>),那么集合<i>S</i><sup><i>q</i></sup><sub>H</sub>中的状态<i>a</i>′,<i>b</i>′满足(<i>a</i>′≤<i>b</i>′)∧(<i>a</i>′≠<i>b</i>′).此时,则称在宿主机器<i>M</i><sub>H</sub>上的程序<i>q</i>是对源机器<i>M</i><sub>R</sub>上程序<i>p</i>的一个模拟.</p>
                </div>
                <h4 class="anchor-tag" id="104" name="104"><b>2.4 二进制翻译过程的抽象</b></h4>
                <div class="p1">
                    <p id="105">二进制翻译最终实现了指令序列到指令序列的映射.根据宿主机器对源机器上程序模拟执行的定义,可以定义二进制翻译:</p>
                </div>
                <div class="p1">
                    <p id="106"><b>定义6</b>. 指令序列的翻译.设(<i>a</i>≤<i>b</i>)∧(<i>a</i>≠<i>b</i>),<i>a</i>,<i>b</i>∈<i>S</i><sup><i>p</i></sup><sub>R</sub>,映射<i>φ</i><sub><i>S</i></sub>使得状态<i>a</i>在宿主机器<i>M</i><sub>H</sub>上的像中存在<i>a</i>′∈<i>φ</i><sub><i>S</i></sub>(<i>a</i>)满足(<i>γ</i><sup>*</sup>(<i>a</i>′)∩<i>φ</i><sub><i>S</i></sub>(<i>b</i>))≠∅.宿主机器<i>M</i><sub>H</sub>上存在状态序列{<i>a</i>′,<i>γ</i><sup>1</sup>(<i>a</i>′),<i>γ</i><sup>2</sup>(<i>a</i>′),…,<i>γ</i><sup><i>n</i></sup><sup>-1</sup>(<i>a</i>′),<i>b</i>′},<i>γ</i><sup><i>i</i></sup>(<i>a</i>′)∉<i>φ</i><sub><i>S</i></sub>(<i>b</i>),称状态<i>a</i>′到状态<i>b</i>′所执行的指令序列为源机器<i>M</i><sub>R</sub>上状态<i>a</i>到状态<i>b</i>所执行的指令序列的一个翻译.而生成宿主机器上这段指令序列的过程称为对源机器上对应指令序列的翻译过程.</p>
                </div>
                <h3 id="107" name="107" class="anchor-tag"><b>3 二进制翻译的正确性</b></h3>
                <div class="p1">
                    <p id="108">翻译源机器平台上的程序,是为了在宿主机器平台上得到具有相同逻辑功能的程序.因此翻译得到程序的逻辑功能相同与否决定了翻译的正确性.然而当讨论翻译正确性的时候,需要先统一描述程序的功能,继而给出关于逻辑功能等价的定义,最终探讨正确的二进制翻译过程具有的一般性质.</p>
                </div>
                <h4 class="anchor-tag" id="109" name="109"><b>3.1 等价的一般性描述</b></h4>
                <div class="p1">
                    <p id="110">程序逻辑功能的等价可以通过相同逻辑功能的正确性证明<citation id="231" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>.即通过证明不同程序满足相同逻辑功能的正确性,从而证明程序间在某种程度上具有等价性.</p>
                </div>
                <div class="p1">
                    <p id="111">证明程序<i>a</i>,<i>b</i>等价,需要证明对于任意前置条件<i>P</i>和后置条件<i>Q</i>,{<i>P</i>}<i>a</i>{<i>Q</i>}可证当且仅当{<i>P</i>}<i>b</i>{<i>Q</i>}可证.该描述方法借用了程序功能验证描述的一般形式——霍尔三元组,将程序的功能等价定义为功能相同.然而此处定义的前置条件和后置条件是不加限制的.因此,当讨论对象限制在源机器和宿主机器之间的指令序列执行其指称语义的等价,有效的二进制翻译具有如下性质.</p>
                </div>
                <div class="p1">
                    <p id="112"><b>性质2</b>. 设机器<i>M</i><sub>R</sub>到机器<i>M</i><sub>H</sub>的正确翻译是指对于<i>M</i><sub>R</sub>上任意满足关系(<i>p</i>≤<i>q</i>)∧(<i>p</i>≠<i>q</i>)的状态<i>p</i>,<i>q</i>,在<i>S</i><sub>H</sub>上总存在状态满足关系(<i>p</i>′≤<i>q</i>′)∧(<i>p</i>′≠<i>q</i>′)的状态<i>p</i>′,<i>q</i>′与之相对应,可表示为</p>
                </div>
                <div class="p1">
                    <p id="113"><i>trans</i>(<i>M</i><sub>R</sub>,<i>M</i><sub>H</sub>)⇔(∀<i>p</i>,<i>q</i>∈<i>S</i><sub>R</sub>.(<i>p</i>≤<i>q</i>)∧(<i>p</i>≠<i>q</i>)⇒∃<i>p</i>′,<i>q</i>′∈<i>S</i><sub>H</sub>.(<i>p</i>′≤<i>q</i>′)∧(<i>p</i>′≠<i>q</i>′)).(6)</p>
                </div>
                <div class="p1">
                    <p id="115">式(6)中,限制状态<i>p</i>,<i>q</i>不相等,因为对于不改变机器状态的指令进行翻译是没有意义的.性质2和式(6)是对具体程序在不同机器上翻译、模拟性质的推广.因而在此不予证明.通过将源机器和宿主机器抽象为2个偏序集合 {<i>S</i><sub>R</sub>,≤}和{<i>S</i><sub>H</sub>,≤},翻译过程和程序模拟执行过程被有效区分,有利于二进制翻译正确性的深入分析.</p>
                </div>
                <h4 class="anchor-tag" id="116" name="116"><b>3.2 状态映射函数的性质</b></h4>
                <div class="p1">
                    <p id="117">在给出二进制翻译正确性的一般性质之后,我们需要对翻译过程所具有的性质进行分析.即为了实现源机器上程序的模拟执行,如何在宿主机器上构建与之相对应的状态序列.</p>
                </div>
                <div class="p1">
                    <p id="118">根据性质2和式(6)的描述,当成功地翻译并模拟执行了一个程序时,即映射<i>φ</i><sub><i>S</i></sub>将偏序集{<i>S</i><sub>R</sub>,≤}上的任意全序集{<i>γ</i><sup>*</sup><sub>R</sub>(<i>s</i><sub>0</sub>),≤},<i>s</i><sub>0</sub>∈<i>S</i><sub>R</sub>映射到偏序集{<i>S</i><sub>H</sub>,≤}上的全序集{<i>γ</i><sup>*</sup><sub>H</sub>(<i>s</i>′<sub>0</sub>),≤},<i>s</i>′<sub>0</sub>∈<i>S</i><sub>H</sub>.对于状态<i>a</i>,<i>b</i>∈<i>γ</i><sup>*</sup><sub>R</sub>(<i>s</i><sub>0</sub>)以及状态映射函数<i>φ</i><sub><i>S</i></sub>,总有状态<i>a</i>′∈(<i>φ</i><sub><i>S</i></sub>(<i>a</i>)∩<i>γ</i><sup>*</sup><sub>H</sub>(<i>s</i>′<sub>0</sub>))和状态<i>b</i>′∈(<i>φ</i><sub><i>S</i></sub>(<i>b</i>)∩<i>γ</i><sup>*</sup><sub>H</sub>(<i>s</i>′<sub>0</sub>))且<i>a</i>≤<i>b</i>⇒<i>a</i>′≤<i>b</i>′总为真.因此,映射<i>φ</i><sub><i>S</i></sub>总是可以将偏序集{<i>S</i><sub>R</sub>,≤}上的任意全序映射为偏序集{<i>S</i><sub>H</sub>,≤}上的一个全序.根据保序映射的定义,此时偏序集{<i>S</i><sub>R</sub>,≤}到偏序集{<i>S</i><sub>H</sub>,≤}的映射<i>φ</i><sub><i>S</i></sub>是保序映射.</p>
                </div>
                <div class="p1">
                    <p id="119">然而在具体到任意代表程序执行的全序集到全序集的映射时,根据函数单调性的定义,可知机器状态的映射函数<i>φ</i><sub><i>S</i></sub>是单调的.根据单调的性质可知,映射函数<i>φ</i><sub><i>S</i></sub>的反函数<mathml id="202"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mrow><mi>φ</mi><msub><mrow></mrow><mi>S</mi></msub></mrow><mo stretchy="true">¯</mo></mover></mrow></math></mathml>必然存在.</p>
                </div>
                <div class="p1">
                    <p id="120"><b>性质3</b>. 态映射函数<i>φ</i><sub><i>S</i></sub>是保序映射,单调且存在反函数.</p>
                </div>
                <div class="p1">
                    <p id="121">尽管状态映射函数<i>φ</i><sub><i>S</i></sub>作用的对象是源机器的机器状态,然而其本质是对源机器状态集合中的后继关系到宿主机器状态集合中的后记关系的再现.</p>
                </div>
                <div class="p1">
                    <p id="122">因此,翻译的正确性体现在状态映射函数<i>φ</i><sub><i>S</i></sub>能否构建一个满足模拟源机器程序执行的状态集在本地的一个模拟实现.</p>
                </div>
                <h4 class="anchor-tag" id="123" name="123"><b>3.3 状态转移函数的表达形式</b></h4>
                <div class="p1">
                    <p id="124">综合3.2节所述,映射<i>φ</i><sub><i>S</i></sub>描述了状态转移函数<i>γ</i><sub>R</sub>和<i>γ</i><sub>H</sub>执行前后状态之间的关系.</p>
                </div>
                <div class="p1">
                    <p id="125">根据式(6)可知,满足正确性的翻译过程中所实现的二元关系的映射,是从<i>γ</i><sub>R</sub>到<i>γ</i><sub>H</sub>的映射,即从已知源平台的指令序列到不确定的宿主平台指令序列的映射.此时可以用描述机器状态序列所蕴含的指令序列指称语义的函数来描述二进制翻译中映射关系的保持.</p>
                </div>
                <div class="p1">
                    <p id="126">状态转移函数<i>γ</i><sub>H</sub>所描述的前后继关系显然是受 <i>γ</i><sub>R</sub>的描述约束的.根据紧致性定理,若对状态转移函数<i>γ</i><sub>R</sub>作用域中每个子函数均有对应的状态转移函数满足有效翻译间的映射关系,那么每个子函数映射得到函数的集合所构建得到状态转移函数<i>γ</i><sub>H</sub>是满足翻译的有效性的.</p>
                </div>
                <div class="p1">
                    <p id="127">因此,复杂机器指令的指称语义函数可以使用其子函数指称语义函数集合的形式描述<citation id="232" type="reference"><link href="29" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>.描述翻译过程需要明确状态转移函数的表示形式.根据工程实践中待翻译指令的可确定性,本文将状态转移函数的描述划分为基于子函数的描述和基于连通图的描述2种.</p>
                </div>
                <h4 class="anchor-tag" id="128" name="128">3.3.1 基于子函数的描述</h4>
                <div class="p1">
                    <p id="129"><i>γ</i>={<i>f</i><sub><i>i</i></sub>(<i>s</i>)},<i>s</i>∈<i>A</i><sub><i>i</i></sub>给出了符合机器指令功能描述的状态转移函数表示形式.根据状态转移过程中所执行的指令进行分类,将状态转移函数划分为若干个描述不同指令功能的子函数.其中,{<i>A</i><sub><i>i</i></sub>|<i>i</i>∈<i>I</i>}表示对状态转移函数<i>γ</i>在状态集合<i>S</i>上的1个划分.当划分所得的子集数目有限时,根据紧致性定理,如果对于机器状态集<i>S</i>划分的每个子集,状态转移函数<i>γ</i>都有1个有效的子函数,那么状态转移函数<i>γ</i>对于机器状态集<i>S</i>的状态转移关系定义是有效的.</p>
                </div>
                <div class="p1">
                    <p id="130">然而这种划分需要对作用的状态先进行关于定义域划分的归类,因此在使用状态函数计算时需要先进行归类计算.</p>
                </div>
                <h4 class="anchor-tag" id="131" name="131">3.3.2 基于连通子图的描述</h4>
                <div class="p1">
                    <p id="132">使用基于子函数的描述方式通常能够较为完备地描述状态转移函数.然而当研究范围局限于部分机器状态时,基于子函数的描述方式会构建大量冗余的关系定义.并且当需要对状态转移函数进行修改且状态后继关系不确定的时候,使用子函数进行描述所定义的状态转移函数更加复杂.</p>
                </div>
                <div class="p1">
                    <p id="133"><i>γ</i>={{[<i>γ</i><sup><i>n</i></sup>(<i>s</i><sub><i>i</i></sub>),<i>γ</i><sup><i>n</i></sup><sup>+1</sup>(<i>s</i><sub><i>i</i></sub>)]}},<i>s</i><sub><i>i</i></sub>∈<i>A</i><sub><i>i</i></sub>给出了符合特定指令执行序列描述的状态转移函数表示形式,其中{[<i>γ</i><sup><i>n</i></sup>(<i>s</i>),<i>γ</i><sup><i>n</i></sup>(<i>s</i>)]},<i>n</i>∈N表示状态<i>s</i>及其所有后继状态作为状态转移函数定义集所定义的后继形成的集合.其现实意义即每个初始状态对应机器执行过程中一个特定的执行序列.</p>
                </div>
                <div class="p1">
                    <p id="134">此时可以使用有向图来描述二元后继关系.对满足(<i>a</i>≤<i>b</i>)∧(<i>a</i>≠<i>b</i>)的机器状态<i>a</i>,<i>b</i>,以<i>a</i>为起点、<i>b</i>为终点作有向图.因此,当给定任意状态<i>s</i>时,求解<i>s</i>所定义状态转移图中所有的连通关系,通过求解以<i>s</i>为起点,依次求解每个后继节点的后继,得到1个后继关系图,该图是状态转移状态图的1个连通子图.这种描述则是将机器状态根据后继关系划分成了若干个连通子图.</p>
                </div>
                <div class="p1">
                    <p id="135">状态转移函数适合描述待翻译指令具有不确定性的动态翻译过程,因为待翻译指令不确定,机器状态序列间的前后继关系较为复杂,使用子函数能够较好地描述这种复杂的前后继关系;而在可以静态翻译的程序中,分析得到确定的指令序列片段,因此每个指令序列执行前后机器状态的变化较为简单,使用状态连同图描述较为便捷,可以简化新构建的状态转移函数.</p>
                </div>
                <h4 class="anchor-tag" id="136" name="136"><b>3.4 指称语义等价状态序列的构建</b></h4>
                <div class="p1">
                    <p id="137">在定义了状态转移函数的描述形式之后,在宿主机器构建满足翻译正确性的状态序列可以通过构建具有语义等价的指称函数实现<citation id="233" type="reference"><link href="31" rel="bibliography" /><link href="33" rel="bibliography" /><sup>[<a class="sup">15</a>,<a class="sup">16</a>]</sup></citation>.设<i>γ</i><sub>RH</sub>⊂<i>γ</i><sup>*</sup><sub>H</sub>为满足<i>γ</i><sub>R</sub>在机器<i>M</i><sub>H</sub>翻译正确性的指称函数,若<i>γ</i><sub>R</sub>是基于子函数的表达形式,<i>γ</i><sub>RH</sub>的构建过程如图2所示:</p>
                </div>
                <div class="area_img" id="138">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909021_138.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 基于子函数描述的状态转移函数构建" src="Detail/GetImg?filename=images/JFYZ201909021_138.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 基于子函数描述的状态转移函数构建  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909021_138.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 Construction of state transition function 
 based on subfunction description</p>

                </div>
                <div class="p1">
                    <p id="139">通过这种描述,将状态转移函数<i>γ</i><sub>RH</sub>的构建问题细化为对状态转移函数<i>γ</i><sub>R</sub>中子函数<i>f</i><sub>R</sub><sub><i>i</i></sub>(<i>s</i>),<i>s</i>∈<i>A</i><sub><i>i</i></sub>对应的状态转移函数<i>f</i><sub>RH</sub><sub><i>i</i></sub>(<i>s</i>),<i>s</i>∈<i>φ</i><sub><i>S</i></sub>(<i>A</i><sub><i>i</i></sub>)的构建.因为状态转移函数<i>γ</i><sub>R</sub>的作用域<i>S</i><sub>R</sub>为有限域,其上的划分{<i>A</i><sub><i>i</i></sub>|<i>i</i>∈<i>I</i>}也是有限的,选择的划分方式决定了<i>i</i>的值,从而决定了构建状态转移函数<i>γ</i><sub>RH</sub>的复杂程度.</p>
                </div>
                <div class="p1">
                    <p id="140">这种描述的现实意义即按照机器状态转移的方式进行分类,从而可以对不同指令的处理过程进行分类讨论.如果<i>γ</i><sub>R</sub>是基于连通子图描述的,<i>γ</i><sub>RH</sub>的构建如图3所示:</p>
                </div>
                <div class="area_img" id="141">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909021_141.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 基于连通子图描述的状态转移函数构建" src="Detail/GetImg?filename=images/JFYZ201909021_141.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 基于连通子图描述的状态转移函数构建  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909021_141.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 Construction of state transition function 
 based on connected subgraph description</p>

                </div>
                <div class="p1">
                    <p id="142">基于连通子图描述的状态转移函数构建过程如图3所示.其中,<i>s</i><sub><i>i</i></sub>∈<i>A</i><sub><i>i</i></sub>,0&lt;<i>i</i>&lt;<i>n</i>,{<i>A</i><sub><i>i</i></sub>|<i>i</i>∈<i>I</i>}是<i>γ</i><sub>R</sub>定义域的一个划分.此时状态转移关系<i>γ</i><sub>RH</sub>的构建被归约为2个连通子图之间关系的构建.</p>
                </div>
                <div class="p1">
                    <p id="143">当在宿主机上构建具有语义等价的指称函数之后,便可以使用代表宿主机指令指称函数的状态转移函数<i>γ</i><sub>H</sub>去实现构建的<i>γ</i><sub>RH</sub>,通过<i>γ</i><sub>H</sub>实现<i>γ</i><sub>RH</sub>所构建的状态序列若满足和源机器序列语义等价,则满足翻译正确性<citation id="234" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>.至此,二进制翻译的形式化模型可以描述如图4所示:</p>
                </div>
                <div class="area_img" id="144">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909021_144.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 二进制翻译的形式化模型" src="Detail/GetImg?filename=images/JFYZ201909021_144.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 二进制翻译的形式化模型  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909021_144.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 Formal model of binary translation</p>

                </div>
                <div class="p1">
                    <p id="145">图4中明确表示出翻译过程即将源机器<i>M</i><sub>R</sub>定义的偏序集{<i>S</i><sub>R</sub>,<i>γ</i><sub>R</sub>}映射到宿主机器偏序集<i>M</i><sub>H</sub>定义的偏序集{<i>S</i><sub>H</sub>,<i>γ</i><sub>H</sub>}的过程,其映射所得的偏序集合{<i>φ</i><sub><i>S</i></sub>(<i>S</i><sub>R</sub>),<i>γ</i><sub>RH</sub>}满足<i>φ</i><sub><i>S</i></sub>(<i>S</i><sub>R</sub>)⊂<i>S</i><sub>H</sub>,<i>γ</i><sub>RH</sub>⊂<i>γ</i><sup>*</sup><sub>H</sub>.</p>
                </div>
                <h4 class="anchor-tag" id="146" name="146"><b>3.5 状态转移函数构建的正确性验证</b></h4>
                <div class="p1">
                    <p id="147">图4构建了二进制翻译统一的形式化模型,然而在工程实现中,宿主机器状态转移函数构建的正确性验证与翻译器使用的翻译方式是相关的.</p>
                </div>
                <div class="p1">
                    <p id="148">动态二进制翻译中代码发现过程与翻译过程是交叉执行的,因此可以处理执行路径较为复杂和不确定的指令序列.处理这种指令序列,使用基于子函数的形式描述源机器指令执行前后机器状态的变化是较为合适的.如翻译器QEMU自带的正确性验证程序test-i386,即通过x86处理器指令的翻译测试验证翻译系统的正确性.</p>
                </div>
                <div class="p1">
                    <p id="149">静态二进制翻译中代码发现过程相对于翻译过程是独立的,可以构建待翻译程序的执行路径流图.此时,使用基于联通子图的状态转移函数描述源机器上一段确定指令序列的状态转移函数是较为合适的.静态二进制翻译通常以指令段为基本单位,在翻译的过程中结合语义分析进行优化,最终翻译得到的结果很难使用基于指令翻译正确性的验证方法去验证翻译的正确性.因此,静态二进制翻译通常以翻译后指令最终执行结果作为正确性测试的结果.常用的测试集包括nbench,spec2006等.</p>
                </div>
                <h3 id="150" name="150" class="anchor-tag"><b>4 优化过程的形式化描述</b></h3>
                <div class="p1">
                    <p id="151">设机器<i>M</i><sub>R</sub>,有∀<i>p</i>∈<i>S</i><sub>R</sub>,<i>q</i>∈<i>γ</i><sup>*</sup><sub>R</sub>(<i>p</i>),为了获取指令序列<i>q</i>在初始状态<i>p</i>下的执行结果,可以通过正确的翻译,将该求解过程归约为宿主机器<i>M</i><sub>H</sub>上指令序列<i>φ</i>(<i>q</i>)=<i>γ</i><sup>*</sup><sub>H</sub>(<i>φ</i>(<i>p</i>))的执行.然而在使用基于<i>γ</i><sub>H</sub>定义的状态序列描述<i>γ</i><sub>RH</sub>所表述的指称函数时,其解并非唯一,即满足同一指称语义的指令序列可以有多个.此时为了获取状态序列中后续状态到达最快,也就是求解<i>γ</i><sup>*</sup><sub>H</sub>(<i>φ</i><sub><i>S</i></sub>(<i>p</i>))速度最快的状态序列,需要对使用指令序列的指称函数计算后继状态的过程进行分析,从而确定翻译过程中影响翻译结果效率的各种因素.</p>
                </div>
                <div class="p1">
                    <p id="152">本节从状态转移函数不同表述形式的使用、状态转移函数在宿主机器状态序列的实现以及状态转移函数的修改3个方面,阐述各种实现方法对翻译得到的状态序列效率的影响.</p>
                </div>
                <h4 class="anchor-tag" id="153" name="153"><b>4.1 状态转移函数表述形式对效率的影响</b></h4>
                <div class="p1">
                    <p id="154">翻译后得到的宿主机状态序列,其目标后继状态的计算过程越快,计算执行的速度越好.即生成的指称函数<i>γ</i><sub>RH</sub>在使用基于<i>γ</i><sub>H</sub>定义的子函数实现时,其实现的复杂程度越低越好.状态转移函数<i>γ</i>同时也是指令序列的指称函数,具有2种描述形式.因此后续状态的计算形式也有2种.</p>
                </div>
                <div class="p1">
                    <p id="155">首先给出使用基于子函数描述的状态转移函数计算后继状态的计算过程.</p>
                </div>
                <div class="p1">
                    <p id="156">设<i>γ</i>={<i>f</i><sub><i>i</i></sub>(<i>s</i>),<i>s</i>∈<i>A</i><sub><i>i</i></sub>},0&lt;<i>i</i>&lt;<i>n</i>,计算状态<i>γ</i><sup><i>i</i></sup><sup>-1</sup>(<i>s</i>)的后继状态<i>γ</i><sup><i>i</i></sup>(<i>s</i>)=<i>γ</i>(<i>γ</i><sup><i>i</i></sup><sup>-1</sup>(<i>s</i>))时,需要首先根据状态过转移函数<i>γ</i>的定义域对状态<i>γ</i><sup><i>i</i></sup><sup>-1</sup>(<i>s</i>)进行归类,然后再选择对应的状态转移子函数进行计算.该过程与式(3)中表示从当前状态获取执行指令的过程相一致.此时后继状态的计算过程可以表述为</p>
                </div>
                <div class="p1">
                    <p id="157"><i>γ</i><sup><i>i</i></sup>(<i>s</i>)=<i>f</i><sub><i>m</i></sub>(<i>γ</i><sup><i>i</i></sup><sup>-1</sup>(<i>s</i>)),<i>γ</i><sup><i>i</i></sup><sup>-1</sup>(<i>s</i>)∈<i>A</i><sub><i>m</i></sub>.</p>
                </div>
                <div class="p1">
                    <p id="158">若将对当前状态归类的过程看作一个函数,该函数以当前状态为参数,查询当前状态在状态转移函数定义域中所属的子域,以该子域对应的子函数为返回值.设<i>δ</i>为状态归类函数,<i>δ</i>(<i>s</i>)=<i>f</i><sub><i>i</i></sub>,<i>s</i>∈<i>A</i><sub><i>i</i></sub>,则基于子函数表示的状态转移函数<i>γ</i>计算后继状态<i>γ</i>(<i>s</i>)的计算过程可表示为</p>
                </div>
                <div class="p1">
                    <p id="159" class="code-formula">
                        <mathml id="159"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mrow><mo>{</mo><mtable columnalign="left"><mtr><mtd><mi>δ</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><msub><mrow></mrow><mi>i</mi></msub><mo>,</mo><mi>s</mi><mo>∈</mo><mi>A</mi><msub><mrow></mrow><mi>i</mi></msub></mtd></mtr><mtr><mtd><mi>γ</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false">(</mo><mi>γ</mi><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>,</mo><mi>γ</mi><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>A</mi><msub><mrow></mrow><mi>m</mi></msub></mtd></mtr></mtable></mrow><mo>⇒</mo></mtd></mtr><mtr><mtd><mi>γ</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>γ</mi><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>γ</mi><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="160">式(7)中状态归类函数<i>δ</i>是一个关于<i>γ</i><sup><i>i</i></sup><sup>-1</sup>(<i>s</i>)的二阶函数.该函数抽象描述了基于子函数表示的状态转移函数做后继状态计算的过程,忽略了状态转移函数的表示形式,可以将任意起始状态<i>s</i><sub>0</sub>的后继状态的计算递归地表示为</p>
                </div>
                <div class="p1">
                    <p id="161" class="code-formula">
                        <mathml id="161"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mtable columnalign="left"><mtr><mtd><mi>γ</mi><msup><mrow></mrow><mn>0</mn></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><msub><mrow></mrow><mn>0</mn></msub><mo>,</mo></mtd></mtr><mtr><mtd><mi>γ</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>γ</mi><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>γ</mi><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo></mtd></mtr></mtable></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="162">用<i>δ</i><sub><i>i</i></sub>=<i>δ</i>(<i>γ</i><sup><i>i</i></sup><sup>-1</sup>(<i>s</i>))表示第<i>i</i>次后继状态计算的状态转移函数,则后继递归计算递归地表示为</p>
                </div>
                <div class="p1">
                    <p id="163" class="code-formula">
                        <mathml id="163"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mtable columnalign="left"><mtr><mtd><mi>γ</mi><msup><mrow></mrow><mn>0</mn></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>s</mi><msub><mrow></mrow><mn>0</mn></msub><mo>,</mo></mtd></mtr><mtr><mtd><mi>γ</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>δ</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">(</mo><mi>δ</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>⋯</mo><mo stretchy="false">(</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>s</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo></mtd></mtr></mtable></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="164">此时状态转移函数定义了由若干状态子集划分的后继关系集合<i>γ</i>={<i>δ</i><sup><i>S</i></sup><sub><sup><i>i</i></sup></sub>,<i>δ</i><sup><i>S</i></sup><sub><sup><i>j</i></sup></sub>,…},其中状态集合<i>S</i><sub><i>i</i></sub>,<i>S</i><sub><i>j</i></sub>是状态全集<i>S</i>的1个有效划分中的不同元素.</p>
                </div>
                <div class="p1">
                    <p id="165">由此可见,在针对部分指定状态的后继计算过程中,使用基于子函数表示的状态转移函数与使用基于连通子图表示的状态转移函数具有一致性.</p>
                </div>
                <div class="p1">
                    <p id="166"><b>性质4</b>. 设有状态集合<i>S</i><sub><i>i</i></sub>,如果其在源机器状态转移函数中有基于连通子图的定义,那么,在宿主机上构建状态转移函数时,针对状态集<i>S</i><sub><i>i</i></sub>的映射状态<i>φ</i><sub><i>S</i></sub>(<i>S</i><sub><i>i</i></sub>) 构建的状态转移函数,基于连通子图构建的状态转移函数效率会比基于子函数构建的状态映射函数效率高.</p>
                </div>
                <div class="p1">
                    <p id="167">性质4的证明需要通过分析图5中使用2种不同状态转移函数计算后继状态的复杂程度.</p>
                </div>
                <div class="p1">
                    <p id="168">假设源机器<i>M</i><sub><i>S</i></sub>上的状态集<i>S</i><sub><i>i</i></sub>有状态转移函数<i>γ</i><sub>R</sub>=<i>δ</i><sup><i>S</i></sup><sub><sup><i>i</i></sup></sub>,在计算后继状态<i>γ</i><sup><i>t</i></sup><sub>R</sub>(<i>S</i><sub><i>i</i></sub>)时,若使用基于子函数表示的状态转移函数会先对状态集<i>S</i><sub><i>i</i></sub>进行归类计算求取状态转移子函数<i>f</i><sub><i>m</i></sub>,然后再求取后继状态,如图5中虚线箭头所示;而基于同构图描述的状态转移函数,可以直接通过转移函数求解后继状态,如图5中实线箭头所示.因此,每次求得的<i>f</i><sub><i>m</i></sub>和对应的<i>δ</i><mathml id="203"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>n</mi><mrow><mi>S</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msubsup></mrow></math></mathml>是等价的,基于同构图的状态转移函数蕴含有对应的状态转移函数信息,因此省略了选择或者生成对应转移函数的过程,性质4可证.</p>
                </div>
                <div class="area_img" id="169">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909021_169.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 后继状态计算过程(1)" src="Detail/GetImg?filename=images/JFYZ201909021_169.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 后继状态计算过程(1)  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909021_169.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Subsequent state calculation progress (1)</p>

                </div>
                <div class="p1">
                    <p id="170">在实际应用中,动态翻译在运行时翻译和维护代码的过程实现了模拟状态转移指令序列的生成,但从功能上并没有实现模拟源平台状态的转移,所以执行效率低于静态翻译.与此同时,也显示出了静态翻译的局限性,因为需要预测源机器执行的状态序列.</p>
                </div>
                <div class="p1">
                    <p id="171">将指令及其解释函数抽象为状态转移函数,能够对二进制翻译过程进行更系统的刻画,主要是可以对机器模拟、动态翻译和静态翻译进行统一描述.而这种形式化的统一描述对于构建动静结合的二进制翻译模式是至关重要的.</p>
                </div>
                <h4 class="anchor-tag" id="172" name="172"><b>4.2 状态转移函数在宿主机器状态序列的实现</b></h4>
                <div class="p1">
                    <p id="173">在二进制翻译模型中,基于偏序集{<i>S</i><sub>H</sub>,<i>γ</i><sub>H</sub>}翻译得到了偏序集合{<i>φ</i><sub><i>S</i></sub>(<i>S</i><sub>R</sub>),<i>γ</i><sub>RH</sub>}.因此在实现<i>γ</i><sub>RH</sub>时,所使用的状态序列是需要满足<i>γ</i><sub>H</sub>所定义的后继关系限制的.这种限制体现在宿主机器体系结构特征对二进制翻译结果的限制.</p>
                </div>
                <div class="p1">
                    <p id="174">这种限制形式化描述为:若<i>γ</i><sub>H</sub>={<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>},那么<i>γ</i><sub>RH</sub>=<i>f</i><sub>…</sub>(…<i>f</i><sub><i>j</i></sub>(<i>f</i><sub><i>i</i></sub>(<i>s</i>))…),<i>s</i>∈<i>S</i><sub>H</sub>.</p>
                </div>
                <div class="p1">
                    <p id="175">现实中,任何机器平台最终只能执行该平台所能识别的指令和操作.基于子函数描述的状态转移函数<i>γ</i><sub>H</sub>抽象了宿主机器的体系架构,定义了一系列的功能(指令).由此可见,不同指令序列所对应的状态序列会影响<i>γ</i><sub>RH</sub>中后继状态计算的效率.这种影响和具体的机器架构相关,不做过多讨论.这种优化方式在应用中主要体现为寄存器映射一类的优化方法中,将源平台上使用频繁的存储单元(通常为寄存器)映射到宿主平台的寄存器上.因为使用频繁,节省了映射在内存中反复读写而占用的时间<citation id="235" type="reference"><link href="35" rel="bibliography" /><link href="37" rel="bibliography" /><sup>[<a class="sup">17</a>,<a class="sup">18</a>]</sup></citation>.</p>
                </div>
                <h4 class="anchor-tag" id="176" name="176"><b>4.3 状态转移函数的修改</b></h4>
                <div class="p1">
                    <p id="177">在二进制翻译中,有时为了获取更高的效率,会忽略宿主机器翻译执行过程中的部分状态是否与源机器的执行状态相互对应、而只是关注在部分关心的状态节点是否能够相互对应.这种忽略源机器执行序列过程,而只在意部分节点对应的方法,是在具体问题中对源机器所定义的偏序集{<i>S</i><sub>R</sub>,<i>γ</i><sub>R</sub>}进行了修改、在删减部分不关心的状态之后,并使用其前驱元素和后继元素构建成新的状态转移函数,如此提高后继状态的计算速度.经过这种修改后,在宿主机器得到的执行状态序列与源平台的状态序列其对应关系不再严格满足,此时式(6)中关于正确性的描述是不成立的.为了使得翻译中正确性和优化带来的影响能够有区别的讨论,因此对二进制翻译的模型修改如图6所示:</p>
                </div>
                <div class="area_img" id="178">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909021_178.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 二进制翻译双映射过程" src="Detail/GetImg?filename=images/JFYZ201909021_178.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 二进制翻译双映射过程  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909021_178.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 The quadratic mapping process of binary 
 translation</p>

                </div>
                <div class="p1">
                    <p id="179">图6描述翻译过程中的双映射.在翻译过程中,首先根据具体问题缩小论域范围,即根据应用需求删减源机器的状态元素,修改其状态转移函数,该过程被抽象为映射<i>φ</i>′<sub><i>S</i></sub>.通过<i>φ</i>′<sub><i>S</i></sub>将源平台所定义的偏序集{<i>S</i><sub>R</sub>,<i>γ</i><sub>R</sub>}映射为一个虚拟的机器<i>M</i>′R所定义的偏序集{<i>S</i>′R,<i>γ</i>′R},即取偏序集{<i>S</i><sub>R</sub>,<i>γ</i><sup>*</sup><sub>R</sub>}的1个子集.该过程的正确性由具体问题的性质决定,只删除和修改问题不关心的状态或者序列.此时当映射<i>φ</i><sub><i>S</i></sub>满足式(6)时,则问题关心的翻译结果也是正确的.</p>
                </div>
                <h4 class="anchor-tag" id="180" name="180"><b>4.4 复合优化翻译模式</b></h4>
                <div class="p1">
                    <p id="181">删减状态元素有利于降低问题的复杂程度,忽略一些不关注的机器状态及其处理过程.在现实中,根据用户的需求和关注的对象,如进程级的翻译系统在操作系统层及其以下做了本地虚拟化的处理,忽略了一些底层实现的翻译,而在软件无源移植的过程中相较于系统级的翻译系统具有巨大优势.</p>
                </div>
                <div class="p1">
                    <p id="182">然而此类优化是基于对具体问题的求解需求进行分析的.处理方法是将不关心的过程的起始状态及其终止状态进行界定,为了保证问题讨论的完备性,对起始状态进行划分,划分的依据即对于问题的具体讨论,然后根据专业知识构建起始状态每个子类到终止状态的状态转移函数.</p>
                </div>
                <div class="p1">
                    <p id="183">本质上,修改状态转移函数的优化方法也是需要预先知道优化状态及其状态转移函数的信息才能进行的.因此通过映射<i>φ</i>′<sub><i>S</i></sub>得到的虚拟机器<i>M</i>′R的状态转移函数<i>γ</i>′R可以是复合了<i>γ</i><sub>R</sub>的2种表达形式而定义的.</p>
                </div>
                <div class="p1">
                    <p id="184">为了保持描述的一致性,此处仍使用<i>M</i>′R定义的符号讨论的后继状态的计算.尽管<i>M</i>′R的后继状态求解也是<i>M</i><sub>R</sub>的求解,并且<i>M</i><sub>H</sub>模拟的是<i>M</i>′R.</p>
                </div>
                <div class="p1">
                    <p id="185">设机器<i>M</i>′R上的状态集<i>S</i><sub><i>i</i></sub>有基于同构图的状态转移函数<i>γ</i>={<i>δ</i><mathml id="204"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mrow><mi>S</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msubsup></mrow></math></mathml>,<i>δ</i><mathml id="205"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mi>S</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msubsup></mrow></math></mathml>,<i>δ</i><mathml id="206"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>3</mn><mrow><mi>S</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msubsup></mrow></math></mathml>,…},<i>S</i><sub><i>i</i></sub>∈<i>A</i><sub><i>i</i></sub>,<i>i</i>∈<i>I</i>.当对其进行有限迭代计算总能得到后继状态集<i>S</i><sub><i>j</i></sub>,并且对于状态集<i>S</i><sub><i>i</i></sub>的子集<i>S</i>′<sub><i>i</i></sub>存在函数<i>f</i><mathml id="207"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>,使得<i>f</i><mathml id="208"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>(<i>S</i>′<sub><i>i</i></sub>)=<i>γ</i><sup><i>t</i></sup><sub>R</sub>(<i>S</i>′<sub><i>i</i></sub>)⊂<i>S</i><sub><i>j</i></sub>成立.</p>
                </div>
                <div class="p1">
                    <p id="186">图7中使用优化后的基于状态集与状态转移函数描述了后继状态的计算过程,使用该方法形成的状态转移函数同时使用了基于子函数以及基于同构图2中状态转移函数的表示方法.</p>
                </div>
                <div class="area_img" id="187">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909021_187.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 后继状态计算过程(2)" src="Detail/GetImg?filename=images/JFYZ201909021_187.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 后继状态计算过程(2)  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909021_187.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 Subsequent state calculation progress (2)</p>

                </div>
                <div class="p1">
                    <p id="188">不同于图5中逐单条源指令后继状态的变换以及后继转移函数的推导,图7中计算状态<i>S</i><sub><i>i</i></sub>的子集<i>S</i>′<sub><i>i</i></sub>的后继状态<i>γ</i><sup><i>t</i></sup><sub>R</sub>(<i>S</i>′<sub><i>i</i></sub>)时所使用的状态转移函数是基于对状态子集<i>S</i>′<sub><i>i</i></sub>在状态集<i>S</i><sub><i>i</i></sub>中进行归类计算生成的状态转移函数<i>f</i><mathml id="209"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>,而<i>f</i><mathml id="210"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>生成则需要对状态子集<i>S</i>′<sub><i>i</i></sub>在基于同构图的转移函数进行分析,结合从状态集<i>S</i>′<sub><i>i</i></sub>到状态集<i>S</i><sub><i>j</i></sub>的每个后继转移函数<i>δ</i><sup><i>S</i></sup><sup>′</sup><sub><sup><i>i</i></sup></sub>迭代计算的操作语义,归纳为该过程对应的较为高级的表示形式,即状态转移函数<i>f</i><mathml id="211"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>.与图5的计算过程相较,此类优化方法结合2种表示方式,对动态翻译过程中的局部问题进行了静态翻译,被称为动静结合的二进制翻译模式.这种综合的优化方法因为优化的灵活性好、针对性强,在二进制翻译的应用中被广泛应用.</p>
                </div>
                <div class="p1">
                    <p id="192">然而,该优化的效果因为优化复杂度的提升而难以获得保证,针对状态子集<i>S</i>′<sub><i>i</i></sub>构建的状态归类函数<i>δ</i><mathml id="212"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>所增加的开销,以及通过状态转移函数<i>f</i><mathml id="213"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>替换<i>δ</i><sup><i>S</i></sup><sup>′</sup><sub><sup><i>i</i></sup></sub>迭代计算所获取的收益,共同决定了能否获得整体上的收益.并且对于其他的状态子集<mathml id="214"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mo stretchy="true">¯</mo></mover></mrow></math></mathml>而言,加了对于<i>S</i>′<sub><i>i</i></sub>的划分过程,也是对整个翻译过程开销的增加.</p>
                </div>
                <div class="p1">
                    <p id="193">综合来看,若是构建的状态归类函数<i>δ</i><mathml id="215"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mi>S</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></msubsup></mrow></math></mathml>在映射到宿主机上能够获得本地的良好支持,通常是明显优于<i>δ</i><sup><i>S</i></sup><sup>′</sup><sub><sup><i>i</i></sup></sub>迭代计算的效率.而状态子集<i>S</i>′<sub><i>i</i></sub>构建的状态归类函数所增加的开销与<i>S</i><sub><i>i</i></sub>子集划分的数量相关.其他状态子集<mathml id="216"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mrow><msup><mi>S</mi><mo>′</mo></msup><msub><mrow></mrow><mi>i</mi></msub></mrow><mo stretchy="true">¯</mo></mover></mrow></math></mathml>增加的关于<i>S</i><sub><i>i</i></sub>的划分过程的开销与具体实例中状态在<i>S</i>′<sub><i>i</i></sub>和<i>S</i><sub><i>i</i></sub>中的比例相关.</p>
                </div>
                <div class="p1">
                    <p id="194">在软件移植的应用中,对应用程序的主体采用动态的二进制翻译技术,对程序执行所依赖的过程函数,根据函数的特性,可以不做任何处理,模仿源平台调用过程的动态翻译;也可以根据函数说明,分析参数传递,做本地函数封装调用的替换处理;也可以对依赖的自定义库函数进行静态翻译成本地库函数,再封装调用替换.在上述相关工作中,特别是库函数的替换处理以及库函数的静态翻译,对该模型的性质进行了验证.</p>
                </div>
                <h3 id="195" name="195" class="anchor-tag"><b>5 总  结</b></h3>
                <div class="p1">
                    <p id="196">二进制翻译技术在体系结构优化、程序性能优化、安全性分析以及软件移植的研究中具有重要作用.</p>
                </div>
                <div class="p1">
                    <p id="197">本文首先分析了基于指令解释的映射模型在二进制翻译关于正确性以及翻译效率研究中的不足,给出了基于后继关系的映射模型;继而定义了正确翻译并形式化地描述了正确翻译的过程;最后就翻译过程汇中翻译效率的优化方法分别进行了讨论.</p>
                </div>
                <div class="p1">
                    <p id="198">在分析翻译正确性和翻译优化方法的过程中,结合实际也对翻译正确性的性质以及翻译优化方法的效果进行了论证.并在最后指出了二进制翻译研究中的热点以及难点——动静结合的二进制翻译模式.</p>
                </div>
                <div class="p1">
                    <p id="199">本文所论述的二进制翻译中的正确性以及优化方法的形式化也是该翻译模式研究的基础.针对如何通过动静结合的二进制翻译模式有效提高二进制翻译技术的实用性将作为下一步的研究目标.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJK201104014&amp;v=MjM3Njk5RE1xNDlFWUlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJzRnkvZ1ZMN0tMejdCWmJHNEg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b>Tan Yusong,Wu Qingbo.A study of virtualization and operating system technologies [J].Computer Engineering &amp; Science,2011,33(4):62- 68 (in Chinese)(谭郁松,吴庆波.虚拟化与操作系统辨析[J].计算机工程与科学,2011,33(4):62- 68)
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200612026&amp;v=MjY4MDJDVVJMT2VaZVJzRnkvZ1ZMN0tMeXZTZExHNEh0Zk5yWTlIWW9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b>Tang Feng,Wu Chenggang,Zhang Zhaoqing,et al.Exception handling in application level binary translation [J].Journal of Computer Research and Development,2006,43(12):2166- 2173 (in Chinese)(唐锋,武成岗,张兆庆,等.二进制翻译应用级异常处理[J].计算机研究与发展,2006,43(12):2166- 2173)
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200612027&amp;v=MjIyNjRkTEc0SHRmTnJZOUhZNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS9nVkw3S0x5dlM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b>Yang Hao,Tang Feng,Xie Haibin,et al.Library function disposing approach in binary translation [J].Journal of Computer Research and Development,2006,43(12):2174- 2179 (in Chinese)(杨浩,唐锋,谢海斌,等.二进制翻译中的库函数处理[J].计算机研究与发展,2006,43(12):2174- 2179)
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201201005&amp;v=MDA0ODVMRzRIOVBNcm85RllZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSc0Z5L2dWTDdLTHl2U2Q=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b>Zhao Tianlei,Tang Yuxing,Fu Guitao,et al.Accelerating program behavior analysis with dynamic binary translation [J].Journal of Computer Research and Development,2012,49(1):35- 43 (in Chinese)(赵天磊,唐遇星,付桂涛,等.利用动态二进制翻译加速应用程序行为特征分析[J].计算机研究与发展,2012,49(1):35- 43)
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Automatic vectorization by runtime binary translation">

                                <b>[5]</b>Nakamura T,Miki S,Oikawa S.Automatic vectorization by runtime binary translation [C] //Proc of the 2nd Int Conf on Networking and Computing.Washington:IEEE Computer Society,2011:87- 94
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Automatic validation for binary translation">

                                <b>[6]</b>Chen Jiuye,Yang Wu,Shen Boye,et al.Automatic validation for binary translation[J].Computer Languages Systems &amp; Structures,2015,43(C):96- 115
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Operand and limits optimization for binary translation system">

                                <b>[7]</b>William Y J,Bauman M A,Kao Fengjung,et al.Operand and limits optimization for binary translation system:America,US9021454[P].2015-04-28
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Specification-driven dynamic binary translation">

                                <b>[8]</b>Tröger J.Specification-driven dynamic binary translation [D].Brisbane,Australia:Queensland University of Technology,2005
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJAM&amp;filename=SJAM120524012713&amp;v=MjQxNTBNOHp4VVNtRGQ5U0g3bjN4RTlmYnZuS3JpZlp1OXVGQ3ZuVTdqTkoxOFdOaWZLWTdLNkh0VE9xNDlFWnV3T0R4&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[9]</b>Rabin M O.Computable algebra,general theory and theory of computable fields [J].Transactions of the American Mathematical Society,1960,95(2):341- 360
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A formalization of an emulation based co-designed virtual machine">

                                <b>[10]</b>Chen Wei,Xu Weixia,Wang Zhiying,et al.A formalization of an emulation based co-designed virtual machine[C] //Proc of the 5th Int Conf on Innovative Mobile and Internet Services in Ubiquitous Computing.Washington:IEEE Computer Society,2011:164- 168
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1013228534.nh&amp;v=MTM4MjlqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSc0Z5L2dWTDdLVkYyNkhiRzZGdFRQcTVFYlBJUUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b>Liao Yin.Dynamic binary translation modeling and parallelization research [D].Hefei:University of Science and Technology of China,2013 (in Chinese)(廖银.动态二进制翻译建模及其并行化研究[D].合肥:中国科学技术大学,2013)
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The Formal Semantics of Programming Languages">

                                <b>[12]</b>Winskel G.The Formal Semantics of Programming Languages [M].Cambridge,MA:MIT Press,2004
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ198904007&amp;v=MDY2MjFIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJzRnkvZ1ZMN0tMeXZTZExLeEZ0ak1xNDlGWTRRS0Q=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b>Song Fangmin.Proof of equivalence of programs [J].Journal of Computer Research and Development,1989,26(4):34- 38 (in Chinese)(宋方敏.程序的等价性证明[J].计算机研究与发展,1989,26(4):34- 38)
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Model Theory:An Introduction">

                                <b>[14]</b>David M.Model Theory:An Introduction [M].Berlin:Springer,2007
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB201307017&amp;v=MjI0ODdlWmVSc0Z5L2dWTDdLTnlmVGJMRzRIOUxNcUk5RVk0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b>Shen Yuming,Ma Yue,Cao Cungen,et al.Faithful and full translations between logics [J].Journal of Software,2013,24(7):1626- 1637 (in Chinese)(申宇铭,马越,曹存根,等.逻辑之间的语义忠实语义满翻译[J].软件学报,2013,24(7):1626- 1637)
                            </a>
                        </p>
                        <p id="33">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=RJXB200908009&amp;v=MDg5MTZxQnRHRnJDVVJMT2VaZVJzRnkvZ1ZMN0tOeWZUYkxHNEh0ak1wNDlGYllRS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b>Tao Qiuming,Zhao Chen,Guo Liang.Proving soundness of program transformations in optimizing compilation based on temporal logic [J].Journal of Software,2009,20(8):2074- 2086 (in Chinese)(陶秋铭,赵琛,郭亮,等.基于时序逻辑证明编译优化程序变换的保义性[J].软件学报,2009,20(8):2074- 2086)
                            </a>
                        </p>
                        <p id="35">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=ZDZC201607016&amp;v=MTE5ODBGckNVUkxPZVplUnNGeS9nVkw3S1B5blJiYkc0SDlmTXFJOUVZb1FLREg4NHZSNFQ2ajU0TzN6cXFCdEc=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b>Dai Tao,Shan Zheng,Lu Shuaibing,et al.Register allocation algorithm of dynamic binary translation based on priority [J].Journal of Zhejiang University:Engineering Science,2016,50(7):1338- 1346 (in Chinese)(戴涛,单征,卢帅兵,等.基于优先级动态二进制翻译寄存器分配算法[J].浙江大学学报:工学版,2016,50(7):1338- 1346)
                            </a>
                        </p>
                        <p id="37">
                            <a id="bibliography_18" >
                                    <b>[18]</b>
                                Wen Yanhua,Tang Daguo,Qi Fengbin.Register mapping and register function cutting out implementation in binary translation [J].Journal of Software,2009,20(Supplement):1- 7 (in Chinese)(文延华,唐大国,漆锋滨.二进制翻译中的寄存器映射与剪裁的实现[J].软件学报,2009,20(增刊):1- 7)
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201909021" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201909021&amp;v=MDAxMDNVUkxPZVplUnNGeS9nVkw3TEx5dlNkTEc0SDlqTXBvOUhaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdUM0kzRG9TcDlCdGYzMD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>


    <link href="/kxreader/Content/css/LeftDetail?v=NLcKG8I1SJUaVFrQ0iGpF2klAT0OsmHRaVSZ1rKb5xg1" rel="stylesheet"/>

</body>
</html>

