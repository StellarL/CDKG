<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637133237779658750%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201903007%26RESULT%3d1%26SIGN%3dKm48kupgXyAjTgRsvRvw901YgjE%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903007&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903007&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903007&amp;v=MTg5NjRkTEc0SDlqTXJJOUZZNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplVnZGeTdtVzczT0x5dlM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#72" data-title="&lt;b&gt;1 相关知识&lt;/b&gt; "><b>1 相关知识</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#73" data-title="&lt;b&gt;1.1 双线性映射&lt;/b&gt;"><b>1.1 双线性映射</b></a></li>
                                                <li><a href="#79" data-title="&lt;b&gt;1.2 多项式分解定理&lt;/b&gt;"><b>1.2 多项式分解定理</b></a></li>
                                                <li><a href="#82" data-title="&lt;b&gt;1.3 泰勒展开式&lt;/b&gt;"><b>1.3 泰勒展开式</b></a></li>
                                                <li><a href="#86" data-title="&lt;b&gt;1.4 双线性&lt;i&gt;q&lt;/i&gt;&lt;/b&gt; -&lt;b&gt;阶强判定性Diffie-Hellman假设&lt;/b&gt;"><b>1.4 双线性<i>q</i></b> -<b>阶强判定性Diffie-Hellman假设</b></a></li>
                                                <li><a href="#90" data-title="&lt;b&gt;1.5 变体的双线性Diffie-Hellman指数假设&lt;/b&gt;"><b>1.5 变体的双线性Diffie-Hellman指数假设</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#94" data-title="&lt;b&gt;2 BMPVDB模型&lt;/b&gt; "><b>2 BMPVDB模型</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#96" data-title="&lt;b&gt;2.1 BMPVDB模型的架构&lt;/b&gt;"><b>2.1 BMPVDB模型的架构</b></a></li>
                                                <li><a href="#100" data-title="&lt;b&gt;2.2 BMPVDB的形式化定义&lt;/b&gt;"><b>2.2 BMPVDB的形式化定义</b></a></li>
                                                <li><a href="#107" data-title="&lt;b&gt;2.3 BMPVDB的正确性及安全性定义&lt;/b&gt;"><b>2.3 BMPVDB的正确性及安全性定义</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#123" data-title="&lt;b&gt;3 BMPVDB模型的实施方案&lt;/b&gt; "><b>3 BMPVDB模型的实施方案</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#125" data-title="&lt;b&gt;3.1 BMPVDB模型实施方案的总体描述&lt;/b&gt;"><b>3.1 BMPVDB模型实施方案的总体描述</b></a></li>
                                                <li><a href="#142" data-title="&lt;b&gt;3.2 BMPVDB模型实施方案的详细设计及安全性证明&lt;/b&gt;"><b>3.2 BMPVDB模型实施方案的详细设计及安全性证明</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#304" data-title="&lt;b&gt;4 性能分析&lt;/b&gt; "><b>4 性能分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#305" data-title="&lt;b&gt;4.1 方案对比&lt;/b&gt;"><b>4.1 方案对比</b></a></li>
                                                <li><a href="#309" data-title="&lt;b&gt;4.2 效率分析&lt;/b&gt;"><b>4.2 效率分析</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#322" data-title="&lt;b&gt;5 结 论&lt;/b&gt; "><b>5 结 论</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#98" data-title="图1 BMPVDB方案的架构">图1 BMPVDB方案的架构</a></li>
                                                <li><a href="#308" data-title="&lt;b&gt;表1 方案对比&lt;/b&gt;"><b>表1 方案对比</b></a></li>
                                                <li><a href="#312" data-title="图2 初始化算法运行时间比较">图2 初始化算法运行时间比较</a></li>
                                                <li><a href="#314" data-title="图3 查询算法运行时间比较">图3 查询算法运行时间比较</a></li>
                                                <li><a href="#316" data-title="图4 验证算法运行时间比较">图4 验证算法运行时间比较</a></li>
                                                <li><a href="#318" data-title="图5 证据大小比较">图5 证据大小比较</a></li>
                                                <li><a href="#320" data-title="图6 存储空间比较">图6 存储空间比较</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="363">


                                    <a id="bibliography_1" title="Li Jingwei, Squicciarini A C, Lin Dan, et al. MMBcloud -Tree: Authenticated index for verifiable cloud service selection[J]. IEEE Transactions on Dependable and Secure Computing, 2017, 14 (2) : 185- 198" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=MMBcloud-Tree:Authenticated Index for Verifiable Cloud Service Selection">
                                        <b>[1]</b>
                                        Li Jingwei, Squicciarini A C, Lin Dan, et al. MMBcloud -Tree: Authenticated index for verifiable cloud service selection[J]. IEEE Transactions on Dependable and Secure Computing, 2017, 14 (2) : 185- 198
                                    </a>
                                </li>
                                <li id="365">


                                    <a id="bibliography_2" title="Khan S, Gani A, Wahab A W A, et al. Cloud log forensics: Foundations, state of the art, and future directions[J]. ACM Computing Surveys, 2016, 49 (1) : 1- 42" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMC0D23C769FAABD9C1018946474785C9E&amp;v=MTM4NzhRMzVkbGh3cnUzd3E0PU5pZklZOEM0YXRQUDNJaERiWjErZlE1TnhtVVM2ajUxUVh2a3FCVXhmcnFSTnJQcUNPTnZGU2lXV3I3SklGcG1hQnVIWWZPR1FsZkNwYg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                        Khan S, Gani A, Wahab A W A, et al. Cloud log forensics: Foundations, state of the art, and future directions[J]. ACM Computing Surveys, 2016, 49 (1) : 1- 42
                                    </a>
                                </li>
                                <li id="367">


                                    <a id="bibliography_3" title="Kellaris G, Kollios G, Nissim K, et al. Generic attacks on secure outsourced databases[C] //Proc of the 23rd ACM Conf on Computer and Communications Security. New York: ACM, 2016: 1329- 1340" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Generic attacks on secure outsourced databases">
                                        <b>[3]</b>
                                        Kellaris G, Kollios G, Nissim K, et al. Generic attacks on secure outsourced databases[C] //Proc of the 23rd ACM Conf on Computer and Communications Security. New York: ACM, 2016: 1329- 1340
                                    </a>
                                </li>
                                <li id="369">


                                    <a id="bibliography_4" title="Mykletun E, Narasimha M, Tsudik G. Signature bouquets: Immutability for aggregated/condensed signatures[C] //Proc of the 9th European Symp on Research in Computer Security. Berlin: Springer, 2004: 160- 176" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Signature bouquets:Immutability for aggregated/condensed signatures">
                                        <b>[4]</b>
                                        Mykletun E, Narasimha M, Tsudik G. Signature bouquets: Immutability for aggregated/condensed signatures[C] //Proc of the 9th European Symp on Research in Computer Security. Berlin: Springer, 2004: 160- 176
                                    </a>
                                </li>
                                <li id="371">


                                    <a id="bibliography_5" title="Jang M, Yoon M, Song Y, et al. A signature-based data authentication method with bitmap-based transformed datain database outsourcing[J]. Procedia Computer Science, 2015, 52 (1) : 680- 684" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES2FE83B764EDCD06CD0F9019B216B6725&amp;v=MDQzODRJRnBtYUJ1SFlmT0dRbGZDcGJRMzVkbGh3cnUzd3E0PU5pZk9mYkhPYTluUDNZaERZSjU3ZndnNXlXVm42a2wwU0g3cjNoQTBmOENTUXJpYUNPTnZGU2lXV3I3Sg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                        Jang M, Yoon M, Song Y, et al. A signature-based data authentication method with bitmap-based transformed datain database outsourcing[J]. Procedia Computer Science, 2015, 52 (1) : 680- 684
                                    </a>
                                </li>
                                <li id="373">


                                    <a id="bibliography_6" title="Yang Yin, Papadias D, Papadopoulos S, et al. Authenticated join processing in outsourced databases[C] //Proc of ACM SIGMOD’09. New York: ACM, 2009: 5- 18" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Authenticated Join Processing in Outsourced Databases&amp;quot;">
                                        <b>[6]</b>
                                        Yang Yin, Papadias D, Papadopoulos S, et al. Authenticated join processing in outsourced databases[C] //Proc of ACM SIGMOD’09. New York: ACM, 2009: 5- 18
                                    </a>
                                </li>
                                <li id="375">


                                    <a id="bibliography_7" title="Zhang Min, Hong Cheng, Chen Chi. Server transparent query authentication of outsourced database[J]. Journal of Computer Research and Development, 2010, 47 (1) : 182- 190 (in Chinese) (张敏, 洪澄, 陈驰. 一种服务器透明的外包数据库查询验证方法[J]. 计算机研究与发展, 2010, 47 (1) : 182- 190) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201001028&amp;v=MDExMjFyQ1VSTE9lWmVWdkZ5N21XNzNPTHl2U2RMRzRIOUhNcm85SGJJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0Y=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                        Zhang Min, Hong Cheng, Chen Chi. Server transparent query authentication of outsourced database[J]. Journal of Computer Research and Development, 2010, 47 (1) : 182- 190 (in Chinese) (张敏, 洪澄, 陈驰. 一种服务器透明的外包数据库查询验证方法[J]. 计算机研究与发展, 2010, 47 (1) : 182- 190) 
                                    </a>
                                </li>
                                <li id="377">


                                    <a id="bibliography_8" title="Miller A J, Hicks M, Katz J, et al. Authenticated data structures, generically[J]. ACM SIGPLAN Notices, 2014, 49 (1) : 411- 423" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM14041100000960&amp;v=MTQ1NDBVYjdJSmwwY2FCUT1OaWZJWTdLOEh0WE5ybzlGWk9zUEJYbzVvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[8]</b>
                                        Miller A J, Hicks M, Katz J, et al. Authenticated data structures, generically[J]. ACM SIGPLAN Notices, 2014, 49 (1) : 411- 423
                                    </a>
                                </li>
                                <li id="379">


                                    <a id="bibliography_9" title="Camenisch J, Lysyanskaya A. Dynamic accumulators and application to efficient revocation of anonymous credentials[C] //Proc of the 22nd Annual Int Cryptology Conf. Berlin: Springer, 2002: 61- 76" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Dynamic accumulators and application to efficient revocation of anonymous credentials">
                                        <b>[9]</b>
                                        Camenisch J, Lysyanskaya A. Dynamic accumulators and application to efficient revocation of anonymous credentials[C] //Proc of the 22nd Annual Int Cryptology Conf. Berlin: Springer, 2002: 61- 76
                                    </a>
                                </li>
                                <li id="381">


                                    <a id="bibliography_10" title="Camenisch J, Kohlweiss M, Soriente C. An accumulator based on bilinear maps and efficient revocation for anonymous credentials[C] //Proc of the 12th Int Workshop on Practice and Theory in Public Key Cryptography. Berlin: Springer, 2009: 481- 500" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An Accumulator Based on Bilinear Maps and Efficient Revocation for Anonymous Credentials">
                                        <b>[10]</b>
                                        Camenisch J, Kohlweiss M, Soriente C. An accumulator based on bilinear maps and efficient revocation for anonymous credentials[C] //Proc of the 12th Int Workshop on Practice and Theory in Public Key Cryptography. Berlin: Springer, 2009: 481- 500
                                    </a>
                                </li>
                                <li id="383">


                                    <a id="bibliography_11" title="Niaz M S, Saake G. Merkle hash tree based techniques for data integrity of outsourced data[C] //Proc of the 27th GI-Workshop on Foundations of Databases. Volkse, Germany: Workshop Grundlagen von Datenbanken, 2015: 66- 71" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Merkle hash tree based techniques for data integrity of outsourced data">
                                        <b>[11]</b>
                                        Niaz M S, Saake G. Merkle hash tree based techniques for data integrity of outsourced data[C] //Proc of the 27th GI-Workshop on Foundations of Databases. Volkse, Germany: Workshop Grundlagen von Datenbanken, 2015: 66- 71
                                    </a>
                                </li>
                                <li id="385">


                                    <a id="bibliography_12" title="Zhang Yupeng, Katz J, Papamanthou C. IntegriDB: Verifiable SQL for outsourced databases[C] //Proc of the 22nd ACM Conf on Computer and Communications Security. New York: ACM, 2015: 1480- 1491" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=IntegriDB: Verifiable SQL for outsourced databases">
                                        <b>[12]</b>
                                        Zhang Yupeng, Katz J, Papamanthou C. IntegriDB: Verifiable SQL for outsourced databases[C] //Proc of the 22nd ACM Conf on Computer and Communications Security. New York: ACM, 2015: 1480- 1491
                                    </a>
                                </li>
                                <li id="387">


                                    <a id="bibliography_13" >
                                        <b>[13]</b>
                                    Papamanthou C, Tamassia R, Triandopoulos N. Optimal verification of operations on dynamic sets[C] //Proc of the 31st Annual Int Cryptology Conf. Berlin: Springer, 2011: 91- 110</a>
                                </li>
                                <li id="389">


                                    <a id="bibliography_14" title="Xian Hequn, Feng Dengguo. An integrity checking scheme in outsourced database model[J]. Journal of Computer Research and Development, 2010, 47 (6) : 1107- 1115 (in Chinese) (咸鹤群, 冯登国. 外包数据库模型中的完整性检测方案[J]. 计算机研究与发展, 2010, 47 (6) : 1107- 1115) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201006024&amp;v=MjUyMDRkTEc0SDlITXFZOUhZSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplVnZGeTdtVzczT0x5dlM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[14]</b>
                                        Xian Hequn, Feng Dengguo. An integrity checking scheme in outsourced database model[J]. Journal of Computer Research and Development, 2010, 47 (6) : 1107- 1115 (in Chinese) (咸鹤群, 冯登国. 外包数据库模型中的完整性检测方案[J]. 计算机研究与发展, 2010, 47 (6) : 1107- 1115) 
                                    </a>
                                </li>
                                <li id="391">


                                    <a id="bibliography_15" title="Zhou Rui. Study of outsourced data query authentication technology in cloud computing[D]. Guangzhou: Jinan University, 2015 (in Chinese) (周锐. 云计算下外包数据查询验证技术的研究[D]. 广州: 暨南大学, 2015) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CMFD&amp;filename=1015978424.nh&amp;v=MzE4NjIyNkc3cS9GdFhPcTVFYlBJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNzNPVkY=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                        Zhou Rui. Study of outsourced data query authentication technology in cloud computing[D]. Guangzhou: Jinan University, 2015 (in Chinese) (周锐. 云计算下外包数据查询验证技术的研究[D]. 广州: 暨南大学, 2015) 
                                    </a>
                                </li>
                                <li id="393">


                                    <a id="bibliography_16" title="Wang Jianfeng. Study on efficient search and secure audit for outsourced data in cloud computing[D]. Xi’an: Xidian University, 2016 (in Chinese) (王剑锋. 云环境下外包数据的高效检索及安全审计技术研究[D]. 西安: 西安电子科技大学, 2016) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1016245829.nh&amp;v=MjYyMjRHTEc4RzluT3BwRWJQSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplVnZGeTdtVzczT1ZGMjY=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                        Wang Jianfeng. Study on efficient search and secure audit for outsourced data in cloud computing[D]. Xi’an: Xidian University, 2016 (in Chinese) (王剑锋. 云环境下外包数据的高效检索及安全审计技术研究[D]. 西安: 西安电子科技大学, 2016) 
                                    </a>
                                </li>
                                <li id="395">


                                    <a id="bibliography_17" title="Miao Meixia, Wang Jianfeng, Ma Jianfeng, et al. Publicly verifiable databases with efficient insertion/deletion operations[J]. Journal of Computer and System Sciences, 2017, 86: 49- 58" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES516AC4932F1C97ECBE703A9E9C0845DA&amp;v=MTg4NjRmYmE1R0tDL3E0WkdacDBPZjNVK3VtVmhuemg5U3c3cjJSdEdlYnFRUU03dUNPTnZGU2lXV3I3SklGcG1hQnVIWWZPR1FsZkNwYlEzNWRsaHdydTN3cTQ9TmlmTw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                        Miao Meixia, Wang Jianfeng, Ma Jianfeng, et al. Publicly verifiable databases with efficient insertion/deletion operations[J]. Journal of Computer and System Sciences, 2017, 86: 49- 58
                                    </a>
                                </li>
                                <li id="397">


                                    <a id="bibliography_18" title="Azraoui M, Elkhiyaoui K, Onen M, et al. Publicly verifiable conjunctive keyword search in outsourced databases[C] //Proc of IEEE CNS’15. Piscataway, NJ: IEEE, 2015: 619- 627" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Publicly verifiable conjunctive keyword search in outsourced databases">
                                        <b>[18]</b>
                                        Azraoui M, Elkhiyaoui K, Onen M, et al. Publicly verifiable conjunctive keyword search in outsourced databases[C] //Proc of IEEE CNS’15. Piscataway, NJ: IEEE, 2015: 619- 627
                                    </a>
                                </li>
                                <li id="399">


                                    <a id="bibliography_19" title="Papadopoulos D, Papadopoulos S, Triandopoulos N. Taking authenticated range queries to arbitrary dimensions[C] //Proc of the 21st ACM Conf on Computer and Communications Security. New York: ACM, 2014: 819- 830" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Taking authenticated range queries to arbitrary dimensions">
                                        <b>[19]</b>
                                        Papadopoulos D, Papadopoulos S, Triandopoulos N. Taking authenticated range queries to arbitrary dimensions[C] //Proc of the 21st ACM Conf on Computer and Communications Security. New York: ACM, 2014: 819- 830
                                    </a>
                                </li>
                                <li id="401">


                                    <a id="bibliography_20" title="Costello C, Fournet C, Howell J, et al. Geppetto: Versatile verifiable computation[C] //Proc of the 36th IEEE Symp on Security and Privacy. Piscataway, NJ: IEEE, 2015: 253- 270" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Geppetto: Versatile verifiable computation">
                                        <b>[20]</b>
                                        Costello C, Fournet C, Howell J, et al. Geppetto: Versatile verifiable computation[C] //Proc of the 36th IEEE Symp on Security and Privacy. Piscataway, NJ: IEEE, 2015: 253- 270
                                    </a>
                                </li>
                                <li id="403">


                                    <a id="bibliography_21" title="Parno B, Howell J, Gentry C, et al. Pinocchio: Nearly practical verifiable computation[C] //Proc of the 34th IEEE Symp on Security and Privacy. Piscataway, NJ: IEEE, 2013: 238- 252" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Pinocchio: Nearly practical verifiable computation">
                                        <b>[21]</b>
                                        Parno B, Howell J, Gentry C, et al. Pinocchio: Nearly practical verifiable computation[C] //Proc of the 34th IEEE Symp on Security and Privacy. Piscataway, NJ: IEEE, 2013: 238- 252
                                    </a>
                                </li>
                                <li id="405">


                                    <a id="bibliography_22" title="Braun B, Feldman A J, Ren Zuocheng, et al. Verifying computations with state[C] //Proc of the 24th ACM Symp on Operating Systems Principles. New York: ACM, 2013: 341- 357" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Verifying computations with state">
                                        <b>[22]</b>
                                        Braun B, Feldman A J, Ren Zuocheng, et al. Verifying computations with state[C] //Proc of the 24th ACM Symp on Operating Systems Principles. New York: ACM, 2013: 341- 357
                                    </a>
                                </li>
                                <li id="407">


                                    <a id="bibliography_23" title="Bensasson E, Chiesa A, Tromer E, et al. Scalable zero knowledge via cycles of elliptic curves[C] //Proc of the 34th Annual Int Cryptology Conf. Berlin: Springer, 2014: 276- 294" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Scalable zero knowledge via cycles of elliptic curves">
                                        <b>[23]</b>
                                        Bensasson E, Chiesa A, Tromer E, et al. Scalable zero knowledge via cycles of elliptic curves[C] //Proc of the 34th Annual Int Cryptology Conf. Berlin: Springer, 2014: 276- 294
                                    </a>
                                </li>
                                <li id="409">


                                    <a id="bibliography_24" title="Bensasson E, Chiesa A, Genkin D, et al. SNARKs for C: Verifying program executions succinctly and in zero knowledge[C] //Proc of the 33rd Annual Int Cryptology Conf. Berlin: Springer, 2013: 90- 108" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=SNARKs for C: Verifying program executions succinctly and in zero knowledge">
                                        <b>[24]</b>
                                        Bensasson E, Chiesa A, Genkin D, et al. SNARKs for C: Verifying program executions succinctly and in zero knowledge[C] //Proc of the 33rd Annual Int Cryptology Conf. Berlin: Springer, 2013: 90- 108
                                    </a>
                                </li>
                                <li id="411">


                                    <a id="bibliography_25" title="Bensasson E, Chiesa A, Tromer E, et al. Succinct non-interactive zero knowledge for a von Neumann architecture[C] //Proc of the 23rd USENIX Security Symp. Berkeley, CA: USENIX Association, 2014: 781- 796" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Succinct non-interactive zero knowledge for a von Neumann architecture">
                                        <b>[25]</b>
                                        Bensasson E, Chiesa A, Tromer E, et al. Succinct non-interactive zero knowledge for a von Neumann architecture[C] //Proc of the 23rd USENIX Security Symp. Berkeley, CA: USENIX Association, 2014: 781- 796
                                    </a>
                                </li>
                                <li id="413">


                                    <a id="bibliography_26" title="Boneh D, Boyen X. Short signatures without random oracles and the SDH assumption in bilinear groups[J]. Journal of Cryptology, 2008, 21 (2) : 149- 177" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00000174959&amp;v=MDg0MDc1ekJkaDRqOTlTWHFScnhveGNNSDdSN3FlYnVkdEZTbmxWYnpBSWxnPU5qN0Jhck80SHRITXJvaEJiZTRHWTNr&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[26]</b>
                                        Boneh D, Boyen X. Short signatures without random oracles and the SDH assumption in bilinear groups[J]. Journal of Cryptology, 2008, 21 (2) : 149- 177
                                    </a>
                                </li>
                                <li id="415">


                                    <a id="bibliography_27" title="Boneh D, Boyen X, Goh E J. Hierarchical identity based encryption with constant size ciphertext[C] //Proc of the 24th Annual Int Conf on the Theory and Applications of Cryptographic Techniques. Berlin: Springer, 2005: 440- 456" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Hierarchical Identity-Based Encryption with Constant Ciphertext">
                                        <b>[27]</b>
                                        Boneh D, Boyen X, Goh E J. Hierarchical identity based encryption with constant size ciphertext[C] //Proc of the 24th Annual Int Conf on the Theory and Applications of Cryptographic Techniques. Berlin: Springer, 2005: 440- 456
                                    </a>
                                </li>
                                <li id="417">


                                    <a id="bibliography_28" title="Papamanthou C, Tamassia R, Triandopoulos N. Optimal verification of operations on dynamic sets[C] //Proc of the 31st Annual Int Cryptology Conf. Berlin: Springer, 2011: 91- 110" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Optimal verification of operations on dynamic sets">
                                        <b>[28]</b>
                                        Papamanthou C, Tamassia R, Triandopoulos N. Optimal verification of operations on dynamic sets[C] //Proc of the 31st Annual Int Cryptology Conf. Berlin: Springer, 2011: 91- 110
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(03),521-532 DOI:10.7544/issn1000-1239.2019.20170839            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于双线性映射的支持全操作的公共可验证外包数据库模型</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%8B%E5%BC%BA&amp;code=06573471&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">王强</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%91%A8%E7%A6%8F%E6%89%8D&amp;code=06569394&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">周福才</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%84%E9%B9%8F%E5%BC%80&amp;code=36215912&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">玄鹏开</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%90%B4%E6%B7%87%E6%AF%93&amp;code=36215913&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">吴淇毓</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%9C%E5%8C%97%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2&amp;code=0111402&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">东北大学软件学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>为解决现有可验证外包数据库方案存在的查询类型较单一、更新和验证代价较高、数据膨胀率较大、效率较低难以应用于实际等问题, 提出了一个基于双线性映射的支持全操作的公共可验证外包数据库 (publicly verifiable database model with full operations based on bilinear map, BMPVDB) 模型.给出了该模型的架构及交互流程, 并对该模型进行了形式化定义, 针对该模型的安全需求给出了该模型的安全性定义.利用双线性映射构造了一个高效且支持全操作的公共可验证外包数据库方案, 并对该方案中各算法进行了详细描述, 证明了该方案的安全性, 其安全性可归约为<i>q</i>-BSDH (bilinear <i>q</i>-strong Diffie-Hellman) 和VBDHE (variant of bilinear Diffie-Hellman exponent) 难题.最后将该方案与现有方案进行了对比, 理论与实验分析表明:该方案功能更全面 (各类集合操作、函数查询、嵌套查询) 、更新与验证代价更低为常数级、数据膨胀率更低、效率更高可应用于实际.此外, 该方案的验证与更新无需私钥参与, 拥有公钥和摘要的用户均可进行验证与更新, 实现了公共可验证和公共可更新.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">双线性映射;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%A4%96%E5%8C%85%E6%95%B0%E6%8D%AE%E5%BA%93&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">外包数据库;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%85%A8%E6%93%8D%E4%BD%9C&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">全操作;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%85%AC%E5%85%B1%E5%8F%AF%E9%AA%8C%E8%AF%81&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">公共可验证;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">动态更新;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    王强, wangq3635@126.com;
                                </span>
                                <span>
                                    *周福才, fczhou@mail.neu.edu.cn;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2017-11-07</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目 (61772127, 61472184, 61321491) ;国家自然科学基金青年科学基金项目 (61703088);</span>
                                <span>中央高校基本科研业务费专项资金项目 (N151704002);</span>
                    </p>
            </div>
                    <h1><b>Publicly Verifiable Database Model with Full Operations Based on Bilinear Map</b></h1>
                    <h2>
                    <span>Wang Qiang</span>
                    <span>Zhou Fucai</span>
                    <span>Xuan Pengkai</span>
                    <span>Wu Qiyu</span>
            </h2>
                    <h2>
                    <span>Software College, Northeastern University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>The existing verifiable outsourced database schemes only support some kind of tailored queries with low efficiency and large data expanding rate. Besides, the overheads of verification and update of these schemes are unacceptable. As a result, they cannot be applied into practice. To resolve these problem, we propose a novel primitive called publicly verifiable outsourced database with full operations based on bilinear map. We present a system model and security model of our scheme. Based on bilinear map, we construct a publicly verifiable outsourced database scheme with full operations, and design each algorithm in detail. We present the rigorous security proof under <i>q</i>-BSDH assumption and VBDHE assumption. Finally, we make a comparison with other state of art schemes in two directions: functionality and performance. The theoretical analysis and simulation confirm that our scheme is more functional, efficient and practical. Furthermore, verification and update phases do not require data owner's private key, and any client owning public key and digest can verify the correctness of query and update database. Therefore, our scheme supports public verification and public update.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=bilinear%20map&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">bilinear map;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=outsourced%20database&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">outsourced database;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=full%20operation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">full operation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=public%20verification&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">public verification;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=dynamic%20update&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">dynamic update;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Wang Qiang, born in 1991.PhD candidate.His main research interests include verifiable computation and outsourced database.<image id="359" type="formula" href="images/JFYZ201903007_35900.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Zhou Fucai, born in 1964.PhD, professor and PhD supervisor.Senior member of CCF.His main research interests include cryptography and network security, trusted computing, and critical technology in electronic commerence.<image id="360" type="formula" href="images/JFYZ201903007_36000.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Xuan Pengkai, born in 1994.Master of the Software College, Northeastern University.His main research interests include verifiable computation and outsourced database.<image id="361" type="formula" href="images/JFYZ201903007_36100.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Wu Qiyu, born in 1994.Master of the Software College, Northeastern University.Her main research interests include verifiable computation and network security.<image id="362" type="formula" href="images/JFYZ201903007_36200.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2017-11-07</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Natural Science Foundation of China (61772127, 61472184, 61321491) ;the National Natural Science Foundation of China for Young Scientists (61703088);</span>
                                <span>the Fundamental Research Funds for the Central Universities (N151704002);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="65">随着云计算的发展, 数据库外包服务<citation id="419" type="reference"><link href="363" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>成为近些年新兴的一种应用模式.越来越多资源受限的客户或企业为了节约硬件存储资源和管理成本, 取消自己的数据中心, 将数据库外包给专业的数据库服务提供商<citation id="420" type="reference"><link href="365" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>进行管理和维护.但是数据外包后, 数据拥有者丧失了对数据的直接控制<citation id="421" type="reference"><link href="367" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>, 云服务器可能会篡改数据库的内容或伪造查询结果来减少响应的时间和计算代价, 因此研究外包数据库查询结果的完整性问题具有重要意义.</p>
                </div>
                <div class="p1">
                    <p id="66">目前, 为解决外包数据库的查询结果完整性验证问题, 国内外学者展开了大量的研究, 主要分为3类:基于数字签名的<citation id="424" type="reference"><link href="369" rel="bibliography" /><link href="371" rel="bibliography" /><link href="373" rel="bibliography" /><link href="375" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">6</a>,<a class="sup">7</a>]</sup></citation>、基于认证数据结构的<citation id="425" type="reference"><link href="377" rel="bibliography" /><link href="379" rel="bibliography" /><link href="381" rel="bibliography" /><link href="383" rel="bibliography" /><link href="385" rel="bibliography" /><link href="387" rel="bibliography" /><link href="389" rel="bibliography" /><link href="391" rel="bibliography" /><link href="393" rel="bibliography" /><sup>[<a class="sup">8</a>,<a class="sup">9</a>,<a class="sup">10</a>,<a class="sup">11</a>,<a class="sup">12</a>,<a class="sup">13</a>,<a class="sup">14</a>,<a class="sup">15</a>,<a class="sup">16</a>]</sup></citation>、基于可验证计算的<citation id="426" type="reference"><link href="395" rel="bibliography" /><link href="397" rel="bibliography" /><link href="399" rel="bibliography" /><link href="401" rel="bibliography" /><link href="403" rel="bibliography" /><link href="405" rel="bibliography" /><link href="407" rel="bibliography" /><link href="409" rel="bibliography" /><link href="411" rel="bibliography" /><sup>[<a class="sup">17</a>,<a class="sup">18</a>,<a class="sup">19</a>,<a class="sup">20</a>,<a class="sup">21</a>,<a class="sup">22</a>,<a class="sup">23</a>,<a class="sup">24</a>,<a class="sup">25</a>]</sup></citation>.1) 使用数字签名技术的方法<citation id="427" type="reference"><link href="369" rel="bibliography" /><link href="371" rel="bibliography" /><link href="373" rel="bibliography" /><link href="375" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">6</a>,<a class="sup">7</a>]</sup></citation>中, 数据拥有者需要对外包数据库中的每个元组进行签名, 客户查询时, 服务器需返回查询结果和查询结果中每个元组所对应的签名.但是该类方法存在的问题是验证和更新的代价较高, 且只支持范围查询.2) 基于认证数据结构的方法是对基于数字签名方法的改进, 通常是基于认证树和累加器的.基于认证树<citation id="428" type="reference"><link href="377" rel="bibliography" /><link href="383" rel="bibliography" /><link href="385" rel="bibliography" /><link href="389" rel="bibliography" /><link href="391" rel="bibliography" /><sup>[<a class="sup">8</a>,<a class="sup">11</a>,<a class="sup">12</a>,<a class="sup">14</a>,<a class="sup">15</a>]</sup></citation>不需要对每一条元组进行签名, 而是先对元组排序, 再使用Hash函数计算出树中每个节点的Hash值, 最终对树的根节点签名, 客户使用认证路径和根节点签名值进行验证.但是该类方法存在的问题是由于叶子节点是排序好的元组的Hash值, 任何一次更新都可能破坏已有认证数据结构, 更新代价较高.认证路径随元组的数量呈对数级增长, 只支持范围和元素隶属关系的查询.另一种基于累加器的<citation id="429" type="reference"><link href="379" rel="bibliography" /><link href="381" rel="bibliography" /><link href="387" rel="bibliography" /><sup>[<a class="sup">9</a>,<a class="sup">10</a>,<a class="sup">13</a>]</sup></citation>, 只支持集合交集、并集、差集及元素隶属关系的查询, 不支持求和、计数、范围, 最大值和最小值查询.此外, 文献<citation id="422" type="reference">[<a class="sup">16</a>]</citation>提出了一种基于可翻转的布隆过滤器的外包数据库验证方案, 该方案虽解决了数据更新操作时额外的计算开销, 但布隆过滤器存在误算率, 会导致查询结果的精准性.3) 基于可验证计算的方法分为2类:①针对特定查询类型的<citation id="430" type="reference"><link href="395" rel="bibliography" /><link href="397" rel="bibliography" /><link href="399" rel="bibliography" /><sup>[<a class="sup">17</a>,<a class="sup">18</a>,<a class="sup">19</a>]</sup></citation>;②针对通用方案的<citation id="431" type="reference"><link href="401" rel="bibliography" /><link href="403" rel="bibliography" /><link href="405" rel="bibliography" /><link href="407" rel="bibliography" /><link href="409" rel="bibliography" /><link href="411" rel="bibliography" /><sup>[<a class="sup">20</a>,<a class="sup">21</a>,<a class="sup">22</a>,<a class="sup">23</a>,<a class="sup">24</a>,<a class="sup">25</a>]</sup></citation>.前者的效率优于后者, 但是查询类型单一.例如Papadopoulos等人<citation id="423" type="reference"><link href="399" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>基于双线性映射累加器提出了支持多维范围查询的完整性验证的方案, 该方案只支持多维范围查询且不支持高效地更新数据.针对通用方案的可分为2类:基于电路的<citation id="432" type="reference"><link href="401" rel="bibliography" /><link href="403" rel="bibliography" /><sup>[<a class="sup">20</a>,<a class="sup">21</a>]</sup></citation>和基于RAM (random access memory) 模型的<citation id="433" type="reference"><link href="405" rel="bibliography" /><link href="407" rel="bibliography" /><link href="409" rel="bibliography" /><link href="411" rel="bibliography" /><sup>[<a class="sup">22</a>,<a class="sup">23</a>,<a class="sup">24</a>,<a class="sup">25</a>]</sup></citation>.两者均是将外包库编译到程序中 (表示成一个布尔/算数电路, 或者是基于RAM模型进行计算) , 在编译好的程序中输入查询语句, 返回与之对应的结果.这2种方法计算代价高并不实用.基于电路的方法效率低, 程序中电路的大小至少与数据库本身一样大, 不支持嵌套查询, 每进行更新操作都需要重新编码.基于RAM模型支持全部查询操作, 但是编码难度较高和性能较差.</p>
                </div>
                <div class="p1">
                    <p id="67">综上所述, 现有的方案存在的问题:1) 查询类型单一不支持全操作;2) 证据随查询结果呈线性或对数增长;3) 验证和更新代价较高;4) 方案的整体效率低下难以应用.</p>
                </div>
                <div class="p1">
                    <p id="68">针对上述问题, 本文提出了一个基于双线性映射的支持全操作的公共可验证外包数据库 (publicly verifiable database model with full operations based on bilinear map, BMPVDB) 模型, 该模型具有3个特点:</p>
                </div>
                <div class="p1">
                    <p id="69">1) 功能全面 (全操作) .该模型支持的查询操作全面, 包含了交集、并集、补集等各种集合操作, 求和、计数、最小值、最大值、范围查询以及嵌套查询操作.</p>
                </div>
                <div class="p1">
                    <p id="70">2) 高效.验证代价为常数级, 独立于外包数据库的大小和查询的中间结果.证据大小只依赖于查询语句分解为单个查询语句的数量, 不依赖于外包数据库和中间结果的大小.更新的代价为常数级, 不依赖于外包数据库和中间结果的大小.</p>
                </div>
                <div class="p1">
                    <p id="71">3) 公共可验证、公共可更新.任何客户拥有公钥和摘要都能对查询结果进行完整性验证.任何一个被数据拥有者授权的客户无需私钥参与就能对外包的数据进行更新.</p>
                </div>
                <h3 id="72" name="72" class="anchor-tag"><b>1 相关知识</b></h3>
                <h4 class="anchor-tag" id="73" name="73"><b>1.1 双线性映射</b></h4>
                <div class="p1">
                    <p id="74">双线性映射指的是2个循环群之间相对应的线性映射关系.定义一个概率多项式时间双线性映射生成算法 (<i>e</i>, <i>g</i>, <i>G</i>, <i>G</i><sub>T</sub>, <i>p</i>) ←<i>BMGen</i> (1<sup><i>λ</i></sup>) 生成双线性映射<i>e</i>:<i>G</i>×<i>G</i>→<i>G</i><sub>T</sub>, 其中<i>p</i>为<i>λ</i>比特的素数, <i>G</i>和<i>G</i><sub>T</sub>均为<i>p</i>阶乘法循环群, <i>g</i>为群<i>G</i>的生成元, 双线性映射<i>e</i>满足3个性质:</p>
                </div>
                <div class="p1">
                    <p id="75">1) 双线性.对于任意的<i>a</i>, <i>b</i>∈Z<sub><i>p</i></sub>和<i>P</i>, <i>Q</i>∈<i>G</i>, 均满足<i>e</i> (<i>P</i><sup><i>a</i></sup>, <i>Q</i><sup><i>b</i></sup>) =<i>e</i> (<i>P</i>, <i>Q</i>) <sup><i>ab</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="76">2) 非退化性.<i>e</i> (<i>g</i>, <i>g</i>) ≠1<sub><i>G</i><sub>T</sub></sub>, 其中1<sub><i>G</i><sub>T</sub></sub>为群<i>G</i><sub>T</sub>的单位元.</p>
                </div>
                <div class="p1">
                    <p id="77">3) 可计算性.对于任意的<i>P</i>, <i>Q</i>∈<i>G</i>, 都存在有效的算法计算出<i>e</i> (<i>P</i>, <i>Q</i>) .</p>
                </div>
                <div class="p1">
                    <p id="78">双线性映射可通过超奇异椭圆曲线上的Weil和Tate配对来进行构造.</p>
                </div>
                <h4 class="anchor-tag" id="79" name="79"><b>1.2 多项式分解定理</b></h4>
                <div class="p1">
                    <p id="80">对于任意的<i>n</i>元多项式<i>f</i> (<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>n</i></sub>) , 给定输入 (<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, …, <i>a</i><sub><i>n</i></sub>) , 则多项式<i>f</i> (<i>x</i><sub>1</sub>, <i>x</i><sub>2</sub>, …, <i>x</i><sub><i>n</i></sub>) -<i>f</i> (<i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>, …, <i>a</i><sub><i>n</i></sub>) 可表示为<mathml id="81"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false"> (</mo></mstyle><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>a</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mi>q</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>.</mo></mrow></math></mathml></p>
                </div>
                <h4 class="anchor-tag" id="82" name="82"><b>1.3 泰勒展开式</b></h4>
                <div class="p1">
                    <p id="83">若函数<i>f</i> (<i>x</i>) 在包含<i>x</i><sub>0</sub>的某个闭区间[<i>a</i>, <i>b</i>]上具有<i>n</i>阶导数, 且在开区间 (<i>a</i>, <i>b</i>) 上具有 (<i>n</i>+1) 阶导数, 则对闭区间[<i>a</i>, <i>b</i>]上任意一点<i>x</i>, 均有:</p>
                </div>
                <div class="p1">
                    <p id="84" class="code-formula">
                        <mathml id="84"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>=</mo><mrow><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">) </mo><mo>+</mo></mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mfrac><mrow><mi>f</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false"> (</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">) </mo></mrow><mrow><mi>i</mi><mo>!</mo></mrow></mfrac></mrow></mstyle><mo stretchy="false"> (</mo><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mi>i</mi></msup><mo>+</mo><mi>R</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="85">其中, <i>f</i><sup> (<i>i</i>) </sup> (<i>x</i>) 为<i>f</i> (<i>x</i>) 的<i>i</i>阶导数, <i>R</i><sub><i>n</i></sub> (<i>x</i>) 为泰勒公式的余项, 是 (<i>x</i>-<i>x</i><sub>0</sub>) <sup><i>n</i></sup>的高阶无穷小.</p>
                </div>
                <h4 class="anchor-tag" id="86" name="86"><b>1.4 双线性<i>q</i></b> -<b>阶强判定性Diffie-Hellman假设</b><citation id="434" type="reference"><link href="413" rel="bibliography" /><sup>[<a class="sup">26</a>]</sup></citation><sup></sup></h4>
                <div class="p1">
                    <p id="87">双线性<i>q</i> -阶强判定性Diffie-Hellman困难性假设 (bilinear <i>q</i> -strong Diffie-Hellman, <i>q</i> -BSDH) , 给定 (<i>e</i>, <i>g</i>, <i>G</i>, <i>G</i><sub>T</sub>, <i>p</i>) ←<i>BMGen</i> (1<sup><i>λ</i></sup>) 和<i>q</i>元组 (<i>g</i><sup><i>α</i></sup>, …, <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) , 不存在一个概率多项式算法A能以不可忽略的概率输出 (<i>c</i>, <i>h</i>) , 使得<i>h</i>=<i>e</i> (<i>g</i>, <i>g</i>) <sup> (<i>α</i>+<i>c</i>) <sup>-1</sup></sup>.其形式化定义为</p>
                </div>
                <div class="p1">
                    <p id="88" class="code-formula">
                        <mathml id="88"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>Ρ</mi><mi>r</mi></mrow><mrow><mo>[</mo><mtable columnalign="left"><mtr><mtd><mo stretchy="false"> (</mo><mi>e</mi><mo>, </mo><mi>g</mi><mo>, </mo><mi>G</mi><mo>, </mo><mi>G</mi><msub><mrow></mrow><mtext>Τ</mtext></msub><mo>, </mo><mi>p</mi><mo stretchy="false">) </mo><mo>←</mo><mi>B</mi><mi>Μ</mi><mi>G</mi><mi>e</mi><mi>n</mi><mo stretchy="false"> (</mo><mn>1</mn><msup><mrow></mrow><mi>λ</mi></msup><mo stretchy="false">) </mo><mo>;</mo></mtd></mtr><mtr><mtd><mi>α</mi><mo>←</mo><mtext>Ζ</mtext><msub><mrow></mrow><mi>p</mi></msub><mo>;</mo><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mi>q</mi></msup></mrow></msup><mo stretchy="false">) </mo><mo>∈</mo><mi>G</mi><msup><mrow></mrow><mi>q</mi></msup><mo>;</mo></mtd></mtr><mtr><mtd><mo stretchy="false"> (</mo><mi>c</mi><mo>, </mo><mi>h</mi><mo stretchy="false">) </mo><mo>←</mo><mtext>A</mtext><mo stretchy="false"> (</mo><mi>e</mi><mo>, </mo><mi>g</mi><mo>, </mo><mi>G</mi><mo>, </mo><mi>G</mi><msub><mrow></mrow><mtext>Τ</mtext></msub><mo>, </mo><mi>p</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mi>q</mi></msup></mrow></msup><mo stretchy="false">) </mo><mo>:</mo></mtd></mtr><mtr><mtd><mi>h</mi><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>+</mo><mi>c</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></msup></mtd></mtr></mtable><mo>]</mo></mrow><mo>≤</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false"> (</mo><mi>λ</mi><mo stretchy="false">) </mo><mo>, </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="89">其中, <i>neg</i> (<i>λ</i>) 为可忽略函数.</p>
                </div>
                <h4 class="anchor-tag" id="90" name="90"><b>1.5 变体的双线性Diffie-Hellman指数假设</b><citation id="435" type="reference"><link href="415" rel="bibliography" /><sup>[<a class="sup">27</a>]</sup></citation><sup></sup></h4>
                <div class="p1">
                    <p id="91">变体的双线性Diffie-Hellman指数困难性假设 (variant of bilinear Diffie-Hellman exponent, VBDHE) , 给定 (<i>e</i>, <i>g</i>, <i>G</i>, <i>G</i><sub>T</sub>, <i>p</i>) ←<i>BMGen</i> (1<sup><i>λ</i></sup>) , <i>g</i><sup><i>α</i><sup><i>i</i></sup></sup> (<i>i</i>∈[1, <i>q</i>]) 和<i>g</i><sup><i>β</i><sup><i>i</i></sup><i>α</i><sup><i>j</i></sup></sup> ( (<i>i</i>, <i>j</i>) ∈[1, <i>q</i>]×[1, <i>q</i>]) , 不存在一个概率多项式算法 A能以不可忽略的概率输出 (G (·) , <i>h</i>) , 使得<i>h</i>=<i>e</i> (<i>g</i>, <i>g</i>) <sup>G (<i>α</i>) <i>β</i><sup><i>q</i></sup></sup>.其形式化定义为</p>
                </div>
                <div class="p1">
                    <p id="92" class="code-formula">
                        <mathml id="92"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>Ρ</mi><mi>r</mi></mrow><mrow><mo>[</mo><mtable columnalign="left"><mtr><mtd><mo stretchy="false"> (</mo><mi>e</mi><mo>, </mo><mi>g</mi><mo>, </mo><mi>G</mi><mo>, </mo><mi>G</mi><msub><mrow></mrow><mtext>Τ</mtext></msub><mo>, </mo><mi>p</mi><mo stretchy="false">) </mo><mo>←</mo><mi>B</mi><mi>Μ</mi><mi>G</mi><mi>e</mi><mi>n</mi><mo stretchy="false"> (</mo><mn>1</mn><msup><mrow></mrow><mi>λ</mi></msup><mo stretchy="false">) </mo><mo>;</mo></mtd></mtr><mtr><mtd><mi>α</mi><mo>, </mo><mi>β</mi><mo>←</mo><mtext>Ζ</mtext><msubsup><mrow></mrow><mi>p</mi><mo>*</mo></msubsup><mo>;</mo><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mi>q</mi></msup></mrow></msup><mo stretchy="false">) </mo><mo>∈</mo><mi>G</mi><msup><mrow></mrow><mi>q</mi></msup><mo>;</mo></mtd></mtr><mtr><mtd><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>β</mi><mtext> </mtext><mi>α</mi><msup><mrow></mrow><mn>1</mn></msup></mrow></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>β</mi><mtext> </mtext><mi>α</mi><msup><mrow></mrow><mi>q</mi></msup></mrow></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>β</mi><msup><mrow></mrow><mi>q</mi></msup><mi>α</mi><msup><mrow></mrow><mn>1</mn></msup></mrow></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>β</mi><msup><mrow></mrow><mi>q</mi></msup><mi>α</mi><msup><mrow></mrow><mi>q</mi></msup></mrow></msup><mo stretchy="false">) </mo><mo>∈</mo><mi>G</mi><msup><mrow></mrow><mrow><mi>q</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></msup></mtd></mtr><mtr><mtd><mo stretchy="false"> (</mo><mi>c</mi><mo>, </mo><mi>h</mi><mo stretchy="false">) </mo><mo>←</mo><mtext>A</mtext><mo stretchy="false"> (</mo><mi>e</mi><mo>, </mo><mi>g</mi><mo>, </mo><mi>G</mi><mo>, </mo><mi>G</mi><msub><mrow></mrow><mtext>Τ</mtext></msub><mo>, </mo><mi>p</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mi>q</mi></msup></mrow></msup><mo stretchy="false">) </mo><mo>:</mo></mtd></mtr><mtr><mtd><mi>h</mi><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mtext>G</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mi>β</mi><msup><mrow></mrow><mi>q</mi></msup></mrow></msup></mtd></mtr></mtable><mo>]</mo></mrow><mo>≤</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false"> (</mo><mi>λ</mi><mo stretchy="false">) </mo><mo>, </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="93">其中, <i>neg</i> (<i>λ</i>) 为可忽略函数.</p>
                </div>
                <h3 id="94" name="94" class="anchor-tag"><b>2 BMPVDB模型</b></h3>
                <div class="p1">
                    <p id="95">本节主要介绍了基于双线性映射的支持全操作的公共可验证外包数据库BMPVDB模型.首先给出了模型的架构及交互流程, 然后对模型进行了形式化定义, 最后针对模型应满足的不同安全需求给出了安全性定义.</p>
                </div>
                <h4 class="anchor-tag" id="96" name="96"><b>2.1 BMPVDB模型的架构</b></h4>
                <div class="p1">
                    <p id="97">BMPVDB模型中包含数据拥有者、客户、云服务器3方实体, 其中数据拥有者和客户是可信的, 云服务器是不可信的.其模型架构图如图1所示:</p>
                </div>
                <div class="area_img" id="98">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903007_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 BMPVDB方案的架构" src="Detail/GetImg?filename=images/JFYZ201903007_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 BMPVDB方案的架构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903007_098.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 The architecture of BMPVDB</p>

                </div>
                <div class="p1">
                    <p id="99">数据拥有者首先执行密钥生成算法生成公私钥对, 其中公钥主要用于生成和验证证据, 私钥主要用于对外包数据库的更新.然后执行初始化算法生成外包数据库摘要.将数据库外包到云服务器进行存储和管理, 同时将公钥发送给云服务器.然后将公钥和摘要发送给客户.当客户向云服务器发起查询请求后, 云服务器返回查询的结果和证据.客户利用本地储存的公钥、摘要及云服务器返回的证据对结果进行验证.该模型中云服务是不可信的, 可能篡改查询的结果.为保证查询结果的完整性, 云服务器在返回查询结果的同时, 还将返回相应的证据供客户验证.验证时涉及公钥和摘要, 且均为公开的, 因此该方案支持公共可验证, 即拥有公钥的客户都可对查询的结果进行验证.</p>
                </div>
                <h4 class="anchor-tag" id="100" name="100"><b>2.2 BMPVDB的形式化定义</b></h4>
                <div class="p1">
                    <p id="101">该模型可用五元组表示为{<i>KeyGen</i>, <i>Setup</i>, <i>Query</i>, <i>Verify</i>, <i>Update</i>}, 五元组中每个元组都代表一个多项式时间算法.5个算法具体描述如下:</p>
                </div>
                <div class="p1">
                    <p id="102">1) 密钥生成算法 (<i>PK</i>, <i>SK</i>) ←<i>KeyGen</i> (1<sup><i>λ</i></sup>) .输入安全参数<i>λ</i>, 数据拥有者执行该算法生成公私钥对 (<i>PK</i>, <i>SK</i>) .其中私钥<i>SK</i>被数据拥有者私密保存, 公钥<i>PK</i>被公开.</p>
                </div>
                <div class="p1">
                    <p id="103">2) 初始化算法<i>σ</i><sub><i>DB</i></sub>←<i>Setup</i> (<i>PK</i>, <i>DB</i>) .数据拥有者将公钥<i>PK</i>和外包数据库<i>DB</i>作为输入, 调用该算法得到数据库摘要<i>σ</i><sub><i>DB</i></sub>, 最后公开<i>σ</i><sub><i>DB</i></sub>.</p>
                </div>
                <div class="p1">
                    <p id="104">3) 查询算法 (<i>R</i>, <i>π</i>) ←<i>Query</i> (<i>Q</i>, <i>PK</i>, <i>DB</i>) .云服务器将公钥<i>PK</i>, 外包数据库<i>DB</i>和客户给定的查询<i>Q</i>输入至该算法, 算法输出查询的结果<i>R</i>及证据<i>π</i>.</p>
                </div>
                <div class="p1">
                    <p id="105">4) 验证算法{‘1’ or ‘0’}←<i>Verify</i> (<i>PK</i>, <i>σ</i><sub><i>DB</i></sub>, <i>R</i>, <i>π</i>) .客户对云服务器返回的结果进行验证.算法输出‘1’表示验证通过, 接受查询结果<i>R</i>, 否则输出‘0’, 拒绝查询结果<i>R</i>.</p>
                </div>
                <div class="p1">
                    <p id="106">5) 更新算法<i>σ</i>′<sub><i>DB</i></sub>←<i>Update</i> (<i>σ</i><sub><i>DB</i></sub>, <i>upd</i>, <i>SK</i>) :数据拥有者给定外包数据库摘要<i>σ</i><sub><i>DB</i></sub>, 更新信息<i>upd</i>∈{ (ADD, <i>x</i>) , (REMOVE, <i>x</i>) , (MODIFY, <i>x</i>) }和私钥<i>SK</i>, 执行该算法输出更新后的摘要<i>σ</i>′<sub><i>DB</i></sub>.</p>
                </div>
                <h4 class="anchor-tag" id="107" name="107"><b>2.3 BMPVDB的正确性及安全性定义</b></h4>
                <h4 class="anchor-tag" id="108" name="108">2.3.1 正确性</h4>
                <div class="p1">
                    <p id="109">模型的正确性简单来说, 当模型中每个算法都正确执行, 验证算法<i>Verify</i>始终输出‘1’, 即永远不会拒绝一个正确的查询结果.其形式化定义为</p>
                </div>
                <div class="p1">
                    <p id="110" class="code-formula">
                        <mathml id="110"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>Ρ</mi><mi>r</mi></mrow><mrow><mo>[</mo><mtable columnalign="left"><mtr><mtd><mo stretchy="false"> (</mo><mi>Ρ</mi><mi>Κ</mi><mo>, </mo><mi>S</mi><mi>Κ</mi><mo stretchy="false">) </mo><mo>←</mo><mi>Κ</mi><mi>e</mi><mi>y</mi><mi>G</mi><mi>e</mi><mi>n</mi><mo stretchy="false"> (</mo><mn>1</mn><msup><mrow></mrow><mi>λ</mi></msup><mo stretchy="false">) </mo><mo>;</mo></mtd></mtr><mtr><mtd><mi>σ</mi><msub><mrow></mrow><mrow><mi>D</mi><mi>B</mi></mrow></msub><mo>←</mo><mi>S</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>p</mi><mo stretchy="false"> (</mo><mi>Ρ</mi><mi>Κ</mi><mo>, </mo><mi>D</mi><mi>B</mi><mo stretchy="false">) </mo><mo>;</mo></mtd></mtr><mtr><mtd><mo stretchy="false"> (</mo><mi>R</mi><mo>, </mo><mi>π</mi><mo stretchy="false">) </mo><mo>←</mo><mi>Q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mo stretchy="false"> (</mo><mi>Q</mi><mo>, </mo><mi>Ρ</mi><mi>Κ</mi><mo>, </mo><mi>D</mi><mi>B</mi><mo stretchy="false">) </mo><mo>:</mo></mtd></mtr><mtr><mtd><mo>‘</mo><mn>1</mn><mo>’</mo><mo>←</mo><mi>V</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>f</mi><mi>y</mi><mo stretchy="false"> (</mo><mi>Ρ</mi><mi>Κ</mi><mo>, </mo><mi>σ</mi><msub><mrow></mrow><mrow><mi>D</mi><mi>B</mi></mrow></msub><mo>, </mo><mi>R</mi><mo>, </mo><mi>π</mi><mo stretchy="false">) </mo></mtd></mtr></mtable><mo>]</mo></mrow><mo>≥</mo><mn>1</mn><mo>-</mo><mi>n</mi><mi>e</mi><mi>g</mi><mo stretchy="false"> (</mo><mi>λ</mi><mo stretchy="false">) </mo><mo>, </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="111">其中, <i>neg</i> (<i>λ</i>) 为可忽略函数.</p>
                </div>
                <h4 class="anchor-tag" id="112" name="112">2.3.2 安全性</h4>
                <div class="p1">
                    <p id="113">模型的安全性是针对不可信云服务器来说的.简单来说, 云服务器伪造一个恶意的结果和证据始终不能通过验证.下面通过构造敌手A和挑战者C之间的安全性实验∑来定义该模型的安全性.</p>
                </div>
                <div class="p1">
                    <p id="114">对于任意的查询<i>Q</i>, 敌手A试图通过4个步骤来伪造一个查询结果和证据并通过验证:</p>
                </div>
                <div class="p1">
                    <p id="115">1) 给定安全参数<i>λ</i>, C执行算法<i>KeyGen</i>生成公私钥对 (<i>PK</i>, <i>SK</i>) , 并将<i>PK</i>发送给A, 私钥<i>SK</i>私密保留.</p>
                </div>
                <div class="p1">
                    <p id="116">2) 敌手A选定一个外包数据库<i>DB</i>, 并将<i>DB</i>发送给挑战者C.</p>
                </div>
                <div class="p1">
                    <p id="117">3) 挑战者C在接收到<i>DB</i>后, 执行算法<i>Setup</i>, 生成外包数据库<i>DB</i>的摘要<i>σ</i><sub><i>DB</i></sub>.</p>
                </div>
                <div class="p1">
                    <p id="118">4) 敌手A可向挑战者C发起多项式<i>poly</i> (<i>λ</i>) 次更新与查询:</p>
                </div>
                <div class="p1">
                    <p id="119">更新.A选定更新操作<i>upd</i>, 将<i>upd</i>发送给C.C执行算法<i>Update</i>后, 将更新的摘要<i>σ</i>′<sub><i>DB</i></sub>发送给A.</p>
                </div>
                <div class="p1">
                    <p id="121">查询.A对于查询<i>Q</i>伪造一个结果<i>R</i><sup>*</sup>和证据<i>π</i><sup>*</sup>.如果算法<i>Verify</i> (<i>PK</i>, <i>σ</i><sub><i>DB</i></sub>, <i>R</i><sup>*</sup>, <i>π</i><sup>*</sup>) 输出‘1’, 敌手获胜.</p>
                </div>
                <div class="p1">
                    <p id="122">对于任意一个概率多项式时间的敌手A, 如果A在上述安全性实验∑中获胜的概率是可忽略的, 则称BMPVDB是安全的.</p>
                </div>
                <h3 id="123" name="123" class="anchor-tag"><b>3 BMPVDB模型的实施方案</b></h3>
                <div class="p1">
                    <p id="124">本节主要介绍了基于双线性映射的支持全操作的公共可验证外包数据库BMPVDB模型的实施方案.首先给出了该模型实施方案的总体描述及核心思想, 然后给出了该模型实施方案中各算法的详细设计, 并给出了安全性证明.最后给出了该模型实施方案的扩展及应用.</p>
                </div>
                <h4 class="anchor-tag" id="125" name="125"><b>3.1 BMPVDB模型实施方案的总体描述</b></h4>
                <div class="p1">
                    <p id="126">对数据库任意查询操作都可看成对表中行或列的操作, 而数据库表中每行或每列所包含的元素均可看作一个集合, 因此对数据库的查询就相当于对集合的操作.从查询输入和输出的类型可以将查询分成5类:</p>
                </div>
                <div class="p1">
                    <p id="127">1) 输入2个集合输出1个集合, 该类型的查询对应于交集∩、并集∪、差集\和对称差集Δ.</p>
                </div>
                <div class="p1">
                    <p id="128">2) 输入输出均为一个集合, 该类型的查询对应于补集和范围查询RANGE.</p>
                </div>
                <div class="p1">
                    <p id="129">3) 输入一个集合输出一个整数, 该类型的查询包含最大值MAX、最小值MIN、计数COUNT和求和SUM.</p>
                </div>
                <div class="p1">
                    <p id="130">4) 输入一个集合输出为一个布尔值, 该类型的查询包含了属于∈<sub><i>x</i></sub>和不属于∉<sub><i>x</i></sub>.</p>
                </div>
                <div class="p1">
                    <p id="131">5) 嵌套查询, 该类型查询是上述4种类型查询的自由组合.</p>
                </div>
                <div class="p1">
                    <p id="132">在本方案中类型1和类型2中所包含的查询均可通过交集查询来实现 (详见3.2节) , 范围查询可通过最大值, 最小值和集合操作来实现详见 (详见3.2节) , 嵌套查询可通过复合上述4种类型查询来实现详见 (详见3.2节) , 下面将重点介绍集合交集、最大值、最小值、求和、计数.</p>
                </div>
                <div class="p1">
                    <p id="133">为了便于表述, 假定集合X={1, 2, 3}, Y={2, 3, 4} ⊆<i>F</i><sup>*</sup><sub><i>q</i></sub>, 交集I=X ∩Y={2, 3}.分别计算X, Y的摘要<mathml id="134"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><msub><mrow></mrow><mtext>X</mtext></msub><mtext> </mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>=</mo><mi>g</mi><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mo>=</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mn>1</mn></msup><mo>+</mo><mi>α</mi><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mi>α</mi><msup><mrow></mrow><mn>3</mn></msup></mrow></msup></mrow></math></mathml>和<mathml id="135"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><msub><mrow></mrow><mtext>Y</mtext></msub><mo stretchy="false"> (</mo><mi>β</mi><mo>, </mo><mi>α</mi><mo stretchy="false">) </mo><mo>=</mo><mi>g</mi><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>Y</mtext></mrow></munder><mi>β</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mi>α</mi><msup><mrow></mrow><mrow><mi>q</mi><mo>-</mo><mi>i</mi></mrow></msup></mrow></msup><mo>=</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>β</mi><msup><mrow></mrow><mn>2</mn></msup><mi>α</mi><msup><mrow></mrow><mrow><mi>q</mi><mo>-</mo><mn>2</mn></mrow></msup><mo>+</mo><mi>β</mi><msup><mrow></mrow><mn>3</mn></msup><mi>α</mi><msup><mrow></mrow><mrow><mi>q</mi><mo>-</mo><mn>3</mn></mrow></msup><mo>+</mo><mi>β</mi><msup><mrow></mrow><mn>4</mn></msup><mi>α</mi><msup><mrow></mrow><mrow><mi>q</mi><mo>-</mo><mn>4</mn></mrow></msup></mrow></msup></mrow></math></mathml>, 其中<i>α</i>, <i>β</i>为从域<i>F</i><sup>*</sup><sub><i>q</i></sub>中随机选取的2元素, 在本方案中当作私钥.对于交集查询, <i>σ</i><sub>X</sub> (<i>α</i>) 和<i>σ</i><sub>Y</sub> (<i>β</i>, <i>α</i>) 指数的乘积为</p>
                </div>
                <div class="p1">
                    <p id="136"> (<i>α</i><sup>1</sup>+<i>α</i><sup>2</sup>+<i>α</i><sup>3</sup>) (<i>β</i><sup>2</sup><i>α</i><sup><i>q</i>-2</sup>+<i>β</i><sup>3</sup><i>α</i><sup><i>q</i>-3</sup>+<i>β</i><sup>4</sup><i>α</i><sup><i>q</i>-4</sup>) = (<i>β</i><sup>2</sup><i>α</i><sup><i>q</i>-1</sup>+<i>β</i><sup>3</sup><i>α</i><sup><i>q</i>-2</sup>+<i>β</i><sup>4</sup><i>α</i><sup><i>q</i>-3</sup>) + (<i>β</i><sup>2</sup><i>α</i><sup><i>q</i></sup>+<i>β</i><sup>3</sup><i>α</i><sup><i>q</i>-1</sup>+<i>β</i><sup>4</sup><i>α</i><sup><i>q</i>-2</sup>) + (<i>β</i><sup>2</sup><i>α</i><sup><i>q</i>+1</sup>+<i>β</i><sup>3</sup><i>α</i><sup><i>q</i></sup>+<i>β</i><sup>4</sup><i>α</i><sup><i>q</i>-1</sup>) = (<i>β</i><sup>2</sup>+<i>β</i><sup>3</sup>) <i>α</i><sup><i>q</i></sup>+Q (<i>β</i>, <i>α</i>) .</p>
                </div>
                <div class="p1">
                    <p id="140">不难看出上述多项式中<i>β</i><sup><i>i</i></sup><i>α</i><sup><i>q</i></sup>项中的<i>i</i>所组成的集合就是交集的结果.为保证结果的正确性, 将<i>σ</i><sub>I</sub> (<i>β</i>) 和<i>g</i><sup>Q (<i>β</i>, <i>α</i>) </sup>当作证据.客户通过验证<i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>σ</i><sub>Y</sub> (<i>β</i>, <i>α</i>) ) =<i>e</i> (<i>σ</i><sub>I</sub> (<i>β</i>) , <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>g</i>, <i>g</i><sup>Q (<i>β</i>, <i>α</i>) </sup>) 和<mathml id="141"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><msub><mrow></mrow><mtext>Ι</mtext></msub><mo stretchy="false"> (</mo><mi>β</mi><mo stretchy="false">) </mo><mo>=</mo><mi>g</mi><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>Ι</mtext></mrow></munder><mi>β</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup></mrow></math></mathml>.为了便于描述, 令X (<i>α</i>) =<i>α</i><sup>1</sup>+<i>α</i><sup>2</sup>+<i>α</i><sup>3</sup>.X (1) 为对集合X计数查询的结果.X ′ (1) 为对集合X求和查询的结果.多项式X (<i>α</i>) 中最小指数值为最小值查询的结果.多项式X (<i>α</i>) 中最大指数值为最大值查询的结果.</p>
                </div>
                <h4 class="anchor-tag" id="142" name="142"><b>3.2 BMPVDB模型实施方案的详细设计及安全性证明</b></h4>
                <div class="p1">
                    <p id="143">本节首先详细介绍了基于双线性映射的支持全操作的公共可验证外包数据库方案中密钥生成算法, 初始化算法和更新算法.然后给出了不同查询类型下的查询算法与验证算法的具体构造, 并进行了安全性证明.下面分别对其进行描述.</p>
                </div>
                <div class="p1">
                    <p id="144">1) 密钥生成算法 (<i>PK</i>, <i>SK</i>) ←<i>KeyGen</i> (1<sup><i>λ</i></sup>) .该算法用于生成公私钥对 (<i>PK</i>, <i>SK</i>) .算法的主要步骤为:</p>
                </div>
                <div class="p1">
                    <p id="145">① 从Z<sup>*</sup><sub><i>p</i></sub>随机选取2个随机数<i>α</i>和<i>β</i>作为<i>SK</i>.</p>
                </div>
                <div class="p1">
                    <p id="146">② 给定安全参数<i>λ</i>, 调用算法<i>BMGen</i>生成 (<i>e</i>, <i>g</i>, <i>G</i>, <i>G</i><sub>T</sub>, <i>p</i>) .</p>
                </div>
                <div class="p1">
                    <p id="147">③ 对于所有的<i>i</i>, <i>j</i>∈Z<sub><i>q</i></sub>, 计算<i>g</i><sup><i>α</i><sup><i>i</i></sup></sup>和<i>g</i><sup><i>β</i><sup><i>i</i></sup><i>α</i><sup><i>j</i></sup></sup>, 其中<i>q</i>=<i>poly</i> (<i>λ</i>) .</p>
                </div>
                <div class="p1">
                    <p id="148">④ 将 (<i>e</i>, <i>g</i>, <i>G</i>, <i>G</i><sub>T</sub>, <i>p</i>) , <i>g</i><sup><i>α</i><sup><i>i</i></sup></sup> (<i>i</i>∈[1, <i>q</i>]) 和<i>g</i><sup><i>β</i><sup><i>i</i></sup><i>α</i><sup><i>j</i></sup></sup> ( (<i>i</i>, <i>j</i>) ∈[1, <i>q</i>]×[1, <i>q</i>]) 当作公钥<i>PK</i>.</p>
                </div>
                <div class="p1">
                    <p id="149">⑤ 输出 (<i>PK</i>, <i>SK</i>) .</p>
                </div>
                <div class="p1">
                    <p id="150">2) 初始化算法<i>σ</i><sub>X</sub>←<i>Setup</i> (<i>PK</i>, X ) .该算法主要用于计算集合X的摘要.算法主要步骤为:</p>
                </div>
                <div class="p1">
                    <p id="151">① 根据公钥<i>PK</i>计算<i>σ</i><sub>X</sub> (<i>α</i>) 和<i>σ</i><sub>X</sub> (<i>β</i>, <i>α</i>) , 其中<mathml id="152"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>σ</mi><msub><mrow></mrow><mtext>X</mtext></msub><mtext> </mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>=</mo></mrow><mi>g</mi><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mo>, </mo><mi>σ</mi><msub><mrow></mrow><mtext>X</mtext></msub><mtext> </mtext><mo stretchy="false"> (</mo><mi>β</mi><mo>, </mo><mi>α</mi><mo stretchy="false">) </mo><mo>=</mo><mi>g</mi><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>β</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mi>α</mi><msup><mrow></mrow><mrow><mi>q</mi><mo>-</mo><mi>i</mi></mrow></msup></mrow></msup><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="153">② 输出集合X的摘要<i>σ</i><sub>X</sub>= (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>σ</i><sub>X</sub> (<i>β</i>, <i>α</i>) ) .</p>
                </div>
                <div class="p1">
                    <p id="154">3) 更新算法<i>σ</i>′<sub>X</sub>←<i>Update</i> (<i>σ</i><sub>X</sub>, <i>upd</i>, <i>SK</i>) .该算法主要用于更新摘要.当<i>upd</i>= (ADD, <i>x</i>) 时, 计算<i>σ</i>′<sub>X</sub> (<i>α</i>) =<i>σ</i><sub>X</sub> (<i>α</i>) <i>g</i><sup><i>α</i><sup><i>x</i></sup></sup>和<i>σ</i>′<sub>X</sub> (<i>β</i>, <i>α</i>) =<i>σ</i><sub>X</sub> (<i>β</i>, <i>α</i>) <i>g</i><sup><i>β</i><sup><i>x</i></sup><i>α</i><sup><i>q</i>-<i>x</i></sup></sup>, 返回更新后的摘要<i>σ</i>′<sub>X</sub>= (<i>σ</i>′<sub>X</sub> (<i>α</i>) , <i>σ</i>′<sub>X</sub> (<i>β</i>, <i>α</i>) ) .当<i>upd</i>= (REMOVE, <i>x</i>) , 计算<i>σ</i>′<sub>X</sub> (<i>α</i>) =<i>σ</i><sub>X</sub> (<i>α</i>) /<i>g</i><sup><i>α</i><sup><i>x</i></sup></sup>和<i>σ</i>′<sub>X</sub> (<i>β</i>, <i>α</i>) =<i>σ</i><sub>X</sub> (<i>β</i>, <i>α</i>) /<i>g</i><sup><i>β</i><sup><i>x</i></sup><i>α</i><sup><i>q</i>-<i>x</i></sup></sup>, 返回更新后的摘要<i>σ</i>′<sub>X</sub>= (<i>σ</i>′<sub>X</sub> (<i>α</i>) , <i>σ</i>′<sub>X</sub> (<i>β</i>, <i>α</i>) ) .当<i>upd</i>= (MODIFY, <i>x</i>) , 可通过上述2种操作实现.</p>
                </div>
                <div class="p1">
                    <p id="155">4) 查询与验证算法</p>
                </div>
                <div class="p1">
                    <p id="156">查询算法用于返回查询的结果和证据.验证算法用于验证查询结果的正确性.</p>
                </div>
                <div class="p1">
                    <p id="157">① 交集I=X ∩Y</p>
                </div>
                <div class="p1">
                    <p id="158">查询:</p>
                </div>
                <div class="p1">
                    <p id="159"> (i) 计算出集合X, Y交集的结果I.</p>
                </div>
                <div class="p1">
                    <p id="160"> (ii) 根据集合X, I和Y中元素, 求得多项式</p>
                </div>
                <div class="p1">
                    <p id="161" class="code-formula">
                        <mathml id="161"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mtext>X</mtext><mtext> </mtext><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>=</mo></mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>x</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mo>, </mo><mtext>Ι</mtext><mo stretchy="false"> (</mo><mi>y</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>Ι</mtext></mrow></munder><mi>y</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mo>, </mo><mtext>Y</mtext><mo stretchy="false"> (</mo><mi>y</mi><mo>, </mo><mi>x</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>Y</mtext></mrow></munder><mi>y</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mi>x</mi><msup><mrow></mrow><mrow><mi>q</mi><mo>-</mo><mi>i</mi></mrow></msup><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="162"> (iii) 求得多项式</p>
                </div>
                <div class="p1">
                    <p id="163">Q (<i>y</i>, <i>x</i>) =X (<i>x</i>) Y (<i>y</i>, <i>x</i>) -I (<i>y</i>) <i>x</i><sup><i>q</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="164"> (iv) 根据公钥<i>PK</i>, 计算出证据<i>π</i>= (<i>g</i><sup>I (<i>β</i>) </sup>, <i>g</i><sup>Q (<i>β</i>, <i>α</i>) </sup>) , 返回I和<i>π</i>.说明:如果证据<i>π</i>中包含2个元素, 则令<i>π</i>= (<i>π</i>[0], <i>π</i><citation id="436" type="reference">[<a class="sup">1</a>]</citation>) .</p>
                </div>
                <div class="p1">
                    <p id="165">验证:</p>
                </div>
                <div class="p1">
                    <p id="166"> (i) 利用查询返回的结果I, 计算<mathml id="167"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><msub><mrow></mrow><mtext>Ι</mtext></msub><mo stretchy="false"> (</mo><mi>β</mi><mo stretchy="false">) </mo><mo>=</mo><mi>g</mi><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>Ι</mtext></mrow></munder><mi>β</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup></mrow></math></mathml>.验证等式<i>σ</i><sub>I</sub> (<i>β</i>) =<i>π</i>[0]是否成立.如果不成立, 拒绝结果I, 输出‘0’, 否则继续进行.</p>
                </div>
                <div class="p1">
                    <p id="168"> (ii) 根据公钥<i>PK</i>, <i>σ</i><sub>X</sub> (<i>α</i>) , <i>σ</i><sub>Y</sub> (<i>β</i>, <i>α</i>) 和证据<i>π</i>来验证下列等式是否成立:</p>
                </div>
                <div class="p1">
                    <p id="169"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>σ</i><sub>Y</sub> (<i>β</i>, <i>α</i>) ) =<i>e</i> (<i>π</i>[0], <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>π</i><citation id="437" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i>) .</p>
                </div>
                <div class="p1">
                    <p id="170"> (iii) 如果等式成立, 则接受交集查询的结果I, 输出‘1’, 否则拒绝结果I, 输出‘0’.</p>
                </div>
                <div class="p1">
                    <p id="171">安全性证明见定理1:</p>
                </div>
                <div class="p1">
                    <p id="172"><b>定理1</b>. 如果在概率多项式时间内存在一个敌手A能以不可忽略的概率伪造出错误的结果I<sup>*</sup>和证据<i>π</i><sup>*</sup>= (<i>g</i><sup>∑<i>a</i><sub><i>i</i></sub><i>β</i><sup><i>i</i></sup></sup>, <i>g</i><sup>∑<i>b</i><sub><i>i</i>, <i>j</i></sub><i>α</i><sup><i>i</i></sup><i>β</i><sup><i>j</i></sup></sup>) 通过验证 (即赢得安全性实验∑) , 那么任意一个敌手A能找到一个有效的算法B解决VBDHE难题和<i>q</i> -BSDH难题.</p>
                </div>
                <div class="p1">
                    <p id="173">证明. 因为A伪造的结果及证据通过验证, 则有:</p>
                </div>
                <div class="p1">
                    <p id="174"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>σ</i><sub>Y</sub> (<i>β</i>, <i>α</i>) ) =<i>e</i> (<i>π</i><sup>*</sup>[0], <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>π</i><sup>*</sup><citation id="438" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i>) ,      (1) </p>
                </div>
                <div class="p1">
                    <p id="175">对于正确的结果和证据, 则有:</p>
                </div>
                <div class="p1">
                    <p id="176"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>σ</i><sub>Y</sub> (<i>β</i>, <i>α</i>) ) =<i>e</i> (<i>π</i>[0], <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>π</i><citation id="439" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i>) .      (2) </p>
                </div>
                <div class="p1">
                    <p id="177">由式 (1) 和式 (2) 可得:</p>
                </div>
                <div class="p1">
                    <p id="178"><i>e</i> (<i>π</i>[0], <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>π</i><citation id="440" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i>) =</p>
                </div>
                <div class="p1">
                    <p id="179"><i>e</i> (<i>π</i><sup>*</sup>[0], <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>π</i><sup>*</sup><citation id="441" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i>) ⇔</p>
                </div>
                <div class="p1">
                    <p id="180"><i>e</i> (<i>π</i>[0], <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>π</i><citation id="442" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i>) =</p>
                </div>
                <div class="p1">
                    <p id="181"><i>e</i> (<i>g</i><sup>∑<i>a</i><sub><i>i</i></sub><i>β</i><sup><i>i</i></sup></sup>, <i>g</i><sup><i>α</i><sup><i>q</i></sup></sup>) <i>e</i> (<i>g</i><sup>∑<i>b</i><sub><i>i</i>, <i>j</i></sub><i>α</i><sup><i>i</i></sup><i>β</i><sup><i>j</i></sup></sup>, <i>g</i>) ⇔</p>
                </div>
                <div class="p1">
                    <p id="182"><i>g</i><sup>I (<i>β</i>) <i>α</i><sup><i>q</i></sup>+Q (<i>β</i>, <i>α</i>) </sup>=<i>g</i><sup> (∑<i>a</i><sub><i>i</i></sub><i>β</i><sup><i>i</i></sup>) <i>α</i><sup><i>q</i></sup>+∑<i>b</i><sub><i>i</i>, <i>j</i></sub><i>α</i><sup><i>i</i></sup><i>β</i><sup><i>j</i></sup></sup>⇔</p>
                </div>
                <div class="p1">
                    <p id="183"><i>g</i><sup> (I (<i>β</i>) -∑<i>a</i><sub><i>i</i></sub><i>β</i><sup><i>i</i></sup>) <i>α</i><sup><i>q</i></sup></sup>=<i>g</i><sup>∑<i>b</i><sub><i>i</i>, <i>j</i></sub><i>α</i><sup><i>i</i></sup><i>β</i><sup><i>j</i></sup>-Q (<i>β</i>, <i>α</i>) </sup>.</p>
                </div>
                <div class="p1">
                    <p id="184">令G (<i>β</i>) =I (<i>β</i>) -∑<i>a</i><sub><i>i</i></sub><i>β</i><sup><i>i</i></sup>, 如果I (<i>β</i>) ≠∑<i>a</i><sub><i>i</i></sub><i>β</i><sup><i>i</i></sup>, 可求得<i>g</i><sup>G (<i>β</i>) <i>α</i><sup><i>q</i></sup></sup>=<i>g</i><sup>∑<i>b</i><sub><i>i</i>, <i>j</i></sub><i>α</i><sup><i>i</i></sup><i>β</i><sup><i>j</i></sup>-Q (<i>β</i>, <i>α</i>) </sup>, 因此A可找到有效的算法B解决VBDHE问题.又因为该问题是难解的, 所以I (<i>β</i>) ≠∑<i>a</i><sub><i>i</i></sub><i>β</i><sup><i>i</i></sup>不成立, 故有<i>π</i><sup>*</sup>[0]=<i>π</i>[0]且I≠I<sup>*</sup>.令<i>x</i><sub>min</sub>为I∪I<sup>*</sup>中最小元素, 因为<i>π</i><sup>*</sup>[0]=<i>π</i>[0], 所以:</p>
                </div>
                <div class="p1">
                    <p id="185"><i>e</i> (<i>g</i>, <i>π</i>[0]) =<i>e</i> (<i>g</i>, <i>π</i><sup>*</sup>[0]) ⇔</p>
                </div>
                <div class="p1">
                    <p id="186"><i>e</i> (<i>g</i>, <i>g</i><sup>I (<i>β</i>) </sup>) =<i>e</i> (<i>g</i>, <i>g</i><sup>I<sup>*</sup> (<i>β</i>) </sup>) ⇔</p>
                </div>
                <div class="p1">
                    <p id="187" class="code-formula">
                        <mathml id="187"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mi>β</mi><msup><mrow></mrow><mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub></mrow></msup></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mtext>Ι</mtext><mo stretchy="false"> (</mo><mi>β</mi><mo stretchy="false">) </mo><mo>-</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>Ι</mtext><msup><mrow></mrow><mo>*</mo></msup><mo>\</mo><mo stretchy="false">{</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub><mo stretchy="false">}</mo></mrow></munder><mi>β</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mn>1</mn><mo>/</mo><mi>β</mi></mrow></msup><mo>=</mo><mi>e</mi><mrow><mo> (</mo><mrow><mi>g</mi><msup><mrow></mrow><mrow><mtext>Ι</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>-</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>Ι</mtext><msup><mrow></mrow><mo>*</mo></msup><mo>\</mo><mo stretchy="false">{</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub><mo stretchy="false">}</mo></mrow></munder><mi>β</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mn>1</mn><mo>/</mo><mi>β</mi><msup><mrow></mrow><mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub><mo>+</mo><mn>1</mn></mrow></msup></mrow></msup></mrow><mo>) </mo></mrow><mo>.</mo><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="188">式 (3) 右边提供了有效的算法B解决<i>q</i> -BSDH问题.又因为该问题是难解的, 所以<i>π</i><sup>*</sup>[0]=<i>π</i>[0]且I ≠I<sup>*</sup>不成立.</p>
                </div>
                <div class="p1">
                    <p id="189">综上, 在概率多项式时间内A难以以不可忽略的概率赢得安全性实验∑, 因此该方案是安全的. 证毕.</p>
                </div>
                <div class="p1">
                    <p id="190">② 其他集合操作</p>
                </div>
                <div class="p1">
                    <p id="191">集合的其他操作可通过交集来实现<citation id="443" type="reference"><link href="417" rel="bibliography" /><sup>[<a class="sup">28</a>]</sup></citation>, 其查询算法, 验证算法和安全性证明均与交集相似, 这里将不在赘述, 只给出验证查询结果正确性的等式.</p>
                </div>
                <div class="p1">
                    <p id="192"> (i) 并集Z=X ∪Y (Z=X ∪ (Y/I ) , 验证等式:</p>
                </div>
                <div class="p1">
                    <p id="193"><i>σ</i><sub>Z</sub> (<i>α</i>) =<i>σ</i><sub>X</sub> (<i>α</i>) <i>σ</i><sub>Y</sub> (<i>α</i>) /<i>σ</i><sub>I</sub> (<i>α</i>) .</p>
                </div>
                <div class="p1">
                    <p id="194"> (ii) 差集D=X \Y (D=X ∩I ) , 验证等式:</p>
                </div>
                <div class="p1">
                    <p id="195"><i>σ</i><sub>D</sub> (<i>α</i>) =<i>σ</i><sub>X</sub> (<i>α</i>) /<i>σ</i><sub>I</sub> (<i>α</i>) .</p>
                </div>
                <div class="p1">
                    <p id="196"> (iii) 对称补集S=X <i>Δ</i>Y (S=X /I ) ∪ (Y/I ) , 验证等式:</p>
                </div>
                <div class="p1">
                    <p id="197"><i>σ</i><sub>S</sub> (<i>α</i>) =<i>σ</i><sub>X</sub> (<i>α</i>) <i>σ</i><sub>Y</sub> (<i>α</i>) /<i>σ</i><sub>I</sub> (<i>α</i>) <sup>2</sup>.</p>
                </div>
                <div class="p1">
                    <p id="198"> (iv) 补集<mathml id="199"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mtext>X</mtext><mo>¯</mo></mover><mo stretchy="false"> (</mo><mover accent="true"><mtext>X</mtext><mo>¯</mo></mover><mo>=</mo><mtext>U</mtext><mo>-</mo><mtext>X</mtext></mrow></math></mathml>, 其中U=[<i>q</i>-1]) , 验证等式:</p>
                </div>
                <div class="p1">
                    <p id="200" class="code-formula">
                        <mathml id="200"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><msub><mrow></mrow><mover accent="true"><mtext>X</mtext><mo>¯</mo></mover></msub><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>=</mo><mi>σ</mi><msub><mrow></mrow><mtext>U</mtext></msub><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>/</mo><mi>σ</mi><msub><mrow></mrow><mtext>X</mtext></msub><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="201"> (v) 子集X ⊆Y (X =X ∩Y ) , 验证等式:</p>
                </div>
                <div class="p1">
                    <p id="202"><i>σ</i><sub>X</sub> (<i>α</i>) =<i>σ</i><sub>I</sub> (<i>α</i>) .</p>
                </div>
                <div class="p1">
                    <p id="203"> (vi) 属于<i>x</i>∈X ({<i>x</i>}=X ∩ (<i>x</i>) ) , 验证等式:</p>
                </div>
                <div class="p1">
                    <p id="204"><i>σ</i><sub>I</sub> (<i>α</i>) =<i>g</i><sup><i>α</i><sup><i>x</i></sup></sup>.</p>
                </div>
                <div class="p1">
                    <p id="205"> (vii) 不属于<i>x</i>∉X (∅=X ∩ (<i>x</i>) ) , 验证等式:</p>
                </div>
                <div class="p1">
                    <p id="206"><i>σ</i><sub>I</sub> (<i>α</i>) =1.</p>
                </div>
                <div class="p1">
                    <p id="207">③ 计数<i>count</i> (X ) </p>
                </div>
                <div class="p1">
                    <p id="208">查询:</p>
                </div>
                <div class="p1">
                    <p id="209"> (i) 根据集合X中的元素, 求得X (<i>x</i>) =<mathml id="210"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>x</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>.  (ii) 计算X (1) 或者统计X中的元素个数作为计数查询的结果<i>R</i>=<i>count</i> (X ) .</p>
                </div>
                <div class="p1">
                    <p id="211"> (iii) 根据多项式分解定理 (详见1.2节) , 计算出多项式Q (<i>x</i>) = (X (<i>x</i>) -X (1) ) / (<i>x</i>-1) .</p>
                </div>
                <div class="p1">
                    <p id="212"> (iv) 根据公钥<i>PK</i>, 计算出证据<i>π</i>=<i>g</i><sup>Q (<i>α</i>) </sup>, 并返回<i>R</i>和<i>π</i>.</p>
                </div>
                <div class="p1">
                    <p id="213">验证:</p>
                </div>
                <div class="p1">
                    <p id="214"> (i) 利用查询返回的结果<i>R</i>, 计算<i>g</i><sup><i>R</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="215"> (ii) 根据公钥<i>PK</i>, <i>σ</i><sub>X</sub> (<i>α</i>) 和证据<i>π</i>来验证下列等式是否成立:</p>
                </div>
                <div class="p1">
                    <p id="216"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i>, <i>g</i><sup><i>R</i></sup>) <i>e</i> (<i>π</i>, <i>g</i><sup><i>α</i>-1</sup>) .</p>
                </div>
                <div class="p1">
                    <p id="217"> (iii) 如果等式成立, 则接受交集查询的结果<i>R</i>, 输出‘1’, 否则拒绝结果<i>R</i>, 输出‘0’.</p>
                </div>
                <div class="p1">
                    <p id="218">安全性证明见定理2:</p>
                </div>
                <div class="p1">
                    <p id="219"><b>定理2</b>. 如果在概率多项式时间内存在一个敌手A能以不可忽略的概率伪造出错误的结果<i>R</i><sup>*</sup>和证据<i>π</i><sup>*</sup>通过验证 (即赢得安全性实验∑) , 那么任意一个敌手A能找到一个有效的算法B解决<i>q</i> -BSDH难题.</p>
                </div>
                <div class="p1">
                    <p id="220">证明. 因为A伪造的结果及证据通过验证, 则有:</p>
                </div>
                <div class="p1">
                    <p id="221"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i>, <i>g</i><sup><i>R</i><sup>*</sup></sup>) <i>e</i> (<i>π</i><sup>*</sup>, <i>g</i><sup><i>α</i>-1</sup>) =<i>e</i> (<i>g</i>, <i>g</i><sup><i>R</i><sup>*</sup></sup>) <i>e</i> (<i>g</i><sup>Q<sup>*</sup> (<i>α</i>) </sup>, <i>g</i><sup><i>α</i>-1</sup>) ,      (4) </p>
                </div>
                <div class="p1">
                    <p id="223">对于正确的结果和证据, 则有:</p>
                </div>
                <div class="p1">
                    <p id="224"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i>, <i>g</i><sup><i>R</i></sup>) <i>e</i> (<i>π</i>, <i>g</i><sup><i>α</i>-1</sup>) =<i>e</i> (<i>g</i>, <i>g</i><sup><i>R</i></sup>) <i>e</i> (<i>g</i><sup>Q (<i>α</i>) </sup>, <i>g</i><sup><i>α</i>-1</sup>) .      (5) </p>
                </div>
                <div class="p1">
                    <p id="226">由式 (4) 和式 (5) 可得:</p>
                </div>
                <div class="p1">
                    <p id="227" class="code-formula">
                        <mathml id="227"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mtext>Q</mtext><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mi>R</mi></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mtext>Q</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mtext>Q</mtext><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>-</mo><mtext>Q</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mi>R</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mn>1</mn><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mrow><mtext>Q</mtext><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>-</mo><mtext>Q</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow><mrow><mi>R</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></mfrac></mrow></msup><mo>.</mo><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>6</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="228">式 (6) 右边提供了有效的算法B解决<i>q</i> -BSDH问题.又因为该问题是难解的, 所以在概率多项式时间内A难以以不可忽略的概率赢得安全性实验∑, 因此该方案是安全的. 证毕.</p>
                </div>
                <div class="p1">
                    <p id="229">④ 求和<i>sum</i> (X ) </p>
                </div>
                <div class="p1">
                    <p id="230">查询:</p>
                </div>
                <div class="p1">
                    <p id="231"> (i) 根据集合X中的元素, 求得X (<i>x</i>) =<mathml id="232"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>x</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>.  (ii) 计算X ′ (1) 或者对X中的元素求和作为计数查询的结果<i>R</i>=<i>sum</i> (X ) .</p>
                </div>
                <div class="p1">
                    <p id="233"> (iii) 计算X (1) , 根据泰勒展开式 (详见1.3节, 其中<i>n</i>=2) , 计算出多项式Q (<i>x</i>) = (X (<i>x</i>) -X (1) -X ′ (1) (<i>x</i>-1) ) / (<i>x</i>-1) <sup>2</sup>.</p>
                </div>
                <div class="p1">
                    <p id="234"> (iv) 根据公钥<i>PK</i>, 计算出<i>g</i><sup>Q (<i>α</i>) </sup>, 将 (X (1) , <i>g</i><sup>Q (<i>α</i>) </sup>) 作为证据<i>π</i>, 返回<i>R</i>和<i>π</i>.</p>
                </div>
                <div class="p1">
                    <p id="235">验证:</p>
                </div>
                <div class="p1">
                    <p id="236"> (i) 利用查询返回的结果<i>R</i>, 计算<i>g</i><sup><i>R</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="237"> (ii) 根据公钥<i>PK</i>, <i>σ</i><sub>X</sub> (<i>α</i>) 和证据<i>π</i>来验证下列等式是否成立:</p>
                </div>
                <div class="p1">
                    <p id="238"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><a class="sup">π[0]</a></sup>, <i>g</i>) <i>e</i> (<i>g</i><sup><i>R</i></sup>, <i>g</i><sup> (<i>α</i>-1) </sup>) <i>e</i> (<i>π</i><citation id="444" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i><sup> (<i>α</i>-1) <sup>2</sup></sup>) .</p>
                </div>
                <div class="p1">
                    <p id="240"> (iii) 如果等式成立, 则接受交集查询的结果<i>R</i>, 输出‘1’, 否则拒绝结果<i>R</i>, 输出‘0’.</p>
                </div>
                <div class="p1">
                    <p id="241">安全性证明见定理3:</p>
                </div>
                <div class="p1">
                    <p id="242"><b>定理3</b>. 如果在概率多项式时间内存在一个敌手A能以不可忽略的概率伪造出错误的结果<i>R</i><sup>*</sup>和证据<i>π</i><sup>*</sup>通过验证 (即赢得安全性实验∑) , 那么任意一个敌手A能找到一个有效的算法B解决<i>q</i> -BSDH难题.</p>
                </div>
                <div class="p1">
                    <p id="243">证明. 因为A伪造的结果及证据通过验证, 则有:</p>
                </div>
                <div class="p1">
                    <p id="244"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><a class="sup">π*[0]</a></sup>, <i>g</i>) <i>e</i> (<i>g</i><sup><i>R</i><sup>*</sup></sup>, <i>g</i><sup> (<i>α</i>-1) </sup>) <i>e</i> (<i>π</i><sup>*</sup><citation id="445" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i><sup> (<i>α</i>-1) <sup>2</sup></sup>) =<i>e</i> (<i>g</i><sup><i>π</i><sup>*</sup>[0]+<i>R</i><sup>*</sup> (<i>α</i>-1) </sup>, <i>g</i>) <i>e</i> (<i>π</i><sup>*</sup><citation id="446" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i><sup> (<i>α</i>-1) <sup>2</sup></sup>) ,      (7) </p>
                </div>
                <div class="p1">
                    <p id="247">对于正确的结果和证据, 则有:</p>
                </div>
                <div class="p1">
                    <p id="248"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><a class="sup">π[0]</a></sup>, <i>g</i>) <i>e</i> (<i>g</i><sup><i>R</i></sup>, <i>g</i><sup> (<i>α</i>-1) </sup>) <i>e</i> (<i>π</i><citation id="447" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i><sup> (<i>α</i>-1) <sup>2</sup></sup>) =<i>e</i> (<i>g</i><sup><i>π</i>[0]+<i>R</i> (<i>α</i>-1) </sup>, <i>g</i>) <i>e</i> (<i>π</i><citation id="448" type="reference">[<a class="sup">1</a>]</citation>, <i>g</i><sup> (<i>α</i>-1) <sup>2</sup></sup>) .      (8) </p>
                </div>
                <div class="p1">
                    <p id="251">由式 (7) 和式 (8) 可得:</p>
                </div>
                <div class="p1">
                    <p id="252" class="code-formula">
                        <mathml id="252"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>π</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>π</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mtext>Q</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>π</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>R</mi><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo>+</mo><mtext>Q</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>π</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>-</mo><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">) </mo><mo>+</mo><mo stretchy="false"> (</mo><mi>R</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">) </mo><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><mo>+</mo><mtext>Q</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mn>1</mn><mrow><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo></mtd></mtr><mtr><mtd><mrow><mo> (</mo><mrow><mfrac><mrow><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false">) </mo></mrow><mrow><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>R</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">) </mo><mo>+</mo><mtext>Q</mtext><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mo>×</mo><mo stretchy="false"> (</mo><mi>α</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo></mrow></mfrac></mrow><mo>) </mo></mrow><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>π</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>-</mo><mi>π</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup></mrow></msup><mo>.</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="253">上式右边提供了有效的算法B解决<i>q</i> -BSDH问题.又因为该问题是难解的, 所以在概率多项式时间内A难以以不可忽略的概率赢得安全性实验∑, 因此该方案是安全的. 证毕.</p>
                </div>
                <div class="p1">
                    <p id="254">⑤ 最小值min (X ) </p>
                </div>
                <div class="p1">
                    <p id="255">查询:</p>
                </div>
                <div class="p1">
                    <p id="256"> (i) 根据集合X中的元素, 求得X (<i>x</i>) =<mathml id="257"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>x</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="258"> (ii) 查看集合中最小元素或将多项式最小指数最为最小值查询的结果<i>R</i>=min (X ) .</p>
                </div>
                <div class="p1">
                    <p id="259"> (iii) 根据公钥<i>PK</i>, 计算出证据<i>π</i>=<i>g</i><sup> (X (<i>α</i>) -<i>α</i><sup><i>R</i></sup>) /<i>α</i><sup><i>R</i>+1</sup></sup>, 并返回<i>R</i>和<i>π</i>.</p>
                </div>
                <div class="p1">
                    <p id="260">验证:</p>
                </div>
                <div class="p1">
                    <p id="261"> (i) 根据公钥<i>PK</i>, <i>σ</i><sub>X</sub> (<i>α</i>) , 证据<i>π</i>和结果<i>R</i>来验证下列等式是否成立:</p>
                </div>
                <div class="p1">
                    <p id="262"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><i>α</i><sup><i>R</i></sup></sup>, <i>g</i>) <i>e</i> (<i>π</i>, <i>g</i><sup><i>α</i><sup><i>R</i>+1</sup></sup>) .</p>
                </div>
                <div class="p1">
                    <p id="263"> (ii) 如果等式成立, 则接受交集查询的结果<i>R</i>, 输出‘1’, 否则拒绝结果<i>R</i>, 输出‘0’.</p>
                </div>
                <div class="p1">
                    <p id="264">安全性证明见定理4:</p>
                </div>
                <div class="p1">
                    <p id="265"><b>定理4</b>. 如果在概率多项式时间内存在一个敌手A能以不可忽略的概率伪造出错误的结果<i>R</i><sup>*</sup>和证据<i>π</i><sup>*</sup>通过验证 (即赢得安全性实验∑) , 那么任意一个敌手A能找到一个有效的算法B解决<i>q</i> -BSDH难题.</p>
                </div>
                <div class="p1">
                    <p id="266">证明. 如果敌手A伪造的结果及证据通过验证, 则有:</p>
                </div>
                <div class="p1">
                    <p id="267"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup></sup></sup>, <i>g</i>) <i>e</i> (<i>π</i>, <i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup>+1</sup></sup>) .      (9) </p>
                </div>
                <div class="p1">
                    <p id="268">当<i>R</i><sup>*</sup>&lt;<i>R</i>=min (X ) 时, 由式 (9) 可得:</p>
                </div>
                <div class="p1">
                    <p id="269"><i>e</i> (<i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup></sup></sup>, <i>g</i>) =<i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) /<i>e</i> (<i>π</i><sup>*</sup>, <i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup>+1</sup></sup>) ⇔<i>e</i> (<i>g</i>, <i>g</i>) <sup>1/<i>α</i></sup>=<i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , (<i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup>+1</sup></sup>) <sup>-1</sup>) /<i>e</i> (<i>π</i><sup>*</sup>, <i>g</i>) . (10) </p>
                </div>
                <div class="p1">
                    <p id="271">当<i>R</i><sup>*</sup>&gt;<i>R</i>=min (X ) 时, 定义U={<i>i</i>∈X:<i>i</i>&lt;<i>R</i>}和W={<i>i</i>∈X:<i>i</i>≥<i>R</i>}.因为U∪W=X且U∩W=∅, 故可得<i>σ</i><sub>X</sub> (<i>α</i>) =<i>σ</i><sub>U</sub> (<i>α</i>) ×<i>σ</i><sub>W</sub> (<i>α</i>) , 因此式 (9) 可得:</p>
                </div>
                <div class="p1">
                    <p id="272"><i>e</i> (<i>σ</i><sub>X</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup></sup></sup>, <i>g</i>) <i>e</i> (<i>π</i>, <i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup>+1</sup></sup>) ⇔</p>
                </div>
                <div class="p1">
                    <p id="273"><i>e</i> (<i>σ</i><sub>U</sub> (<i>α</i>) , <i>g</i>) <i>e</i> (<i>σ</i><sub>W</sub> (<i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup></sup></sup>, <i>g</i>) <i>e</i> (<i>π</i>, <i>g</i><sup><i>α</i><sup><i>R</i><sup>*</sup>+1</sup></sup>) ⇔</p>
                </div>
                <div class="p1">
                    <p id="274" class="code-formula">
                        <mathml id="274"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>+</mo><mn>1</mn></mrow></msup></mrow></msup><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo stretchy="false">) </mo><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mo>.</mo><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="275">因为U∩W=∅, 可得<i>α</i><sup><i>R</i></sup>是U (<i>α</i>) 和W (<i>α</i>) 最大公因子, 再由广义欧几里德定理可得, 存在2个多项式<i>a</i> (<i>α</i>) 和<i>b</i> (<i>α</i>) , 使得:</p>
                </div>
                <div class="p1">
                    <p id="276" class="code-formula">
                        <mathml id="276"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mo>+</mo><mi>b</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup><mo>=</mo><mi>α</mi><msup><mrow></mrow><mi>R</mi></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mo>=</mo><mi>α</mi><msup><mrow></mrow><mi>R</mi></msup><mo>-</mo><mi>b</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup><mo>, </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="277">因此式 (11) 可得:</p>
                </div>
                <div class="p1">
                    <p id="278" class="code-formula">
                        <mathml id="278"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mi>α</mi></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><mo>×</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mn>1</mn><mrow><mi>α</mi><msup><mrow></mrow><mrow><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><mo>×</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mn>1</mn><mrow><mi>α</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>-</mo><mi>R</mi><mo stretchy="false">) </mo></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><mo>×</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mi>R</mi></msup><mo>-</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>U</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mn>1</mn><mrow><mi>α</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>-</mo><mi>R</mi><mo stretchy="false">) </mo></mrow></msup></mrow></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><mo>×</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mo>-</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mi>b</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>⇔</mo></mtd></mtr><mtr><mtd><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><mo>, </mo><mi>g</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mfrac><mn>1</mn><mi>α</mi></mfrac></mrow></msup><mo>=</mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>-</mo><mi>R</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>π</mi><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>-</mo><mi>R</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>×</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>-</mo><mi>R</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup></mrow></msup><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mo>-</mo><mi>a</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>W</mtext></mrow></munder><mi>α</mi></mstyle><msup><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></msup></mrow></msup><mo stretchy="false">) </mo><mi>e</mi><mo stretchy="false"> (</mo><mi>g</mi><msup><mrow></mrow><mrow><mi>α</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>R</mi><msup><mrow></mrow><mo>*</mo></msup><mo>-</mo><mi>R</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup></mrow></msup><mo>, </mo><mi>g</mi><msup><mrow></mrow><mrow><mi>b</mi><mo stretchy="false"> (</mo><mi>α</mi><mo stretchy="false">) </mo></mrow></msup><mo stretchy="false">) </mo><mo>.</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="279">上式右边提供了有效的算法B解决<i>q</i> -BSDH问题.又因为该问题是难解的, 所以在概率多项式时间内A难以以不可忽略的概率赢得安全性实验∑, 因此该方案是安全的. 证毕.</p>
                </div>
                <div class="p1">
                    <p id="280">⑥ 最大值max (X ) </p>
                </div>
                <div class="p1">
                    <p id="281">查询:</p>
                </div>
                <div class="p1">
                    <p id="282"> (i) 根据集合X中的元素, 求得</p>
                </div>
                <div class="p1">
                    <p id="283">X (<i>y</i>, <i>x</i>) =<mathml id="284"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mtext>X</mtext></mrow></munder><mi>y</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup><mi>x</mi><msup><mrow></mrow><mrow><mi>q</mi><mo>-</mo><mi>i</mi></mrow></msup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="285"> (ii) 查看集合中最大元素或将多项式中关于<i>y</i>最大指数作为最大值查询的结果<i>R</i>=max (X ) .</p>
                </div>
                <div class="p1">
                    <p id="286"> (iii) 根据公钥<i>PK</i>, 计算出证据<i>π</i>=<i>g</i><sup> (X (<i>β</i>, <i>α</i>) -<i>β</i><sup><i>R</i></sup><i>α</i><sup><i>q</i>-<i>R</i></sup>) /<i>α</i><sup><i>q</i>-<i>R</i>+1</sup></sup>, 并返回<i>R</i>和<i>π</i>.</p>
                </div>
                <div class="p1">
                    <p id="287">验证:</p>
                </div>
                <div class="p1">
                    <p id="288"> (i) 根据公钥<i>PK</i>, <i>σ</i><sub>X</sub> (<i>α</i>) , 证据<i>π</i>和结果<i>R</i>来验证下列等式是否成立:</p>
                </div>
                <div class="p1">
                    <p id="289"><i>e</i> (<i>σ</i><sub>X</sub> (<i>β</i>, <i>α</i>) , <i>g</i>) =<i>e</i> (<i>g</i><sup><i>β</i><sup><i>R</i></sup><i>α</i><sup><i>q</i>-<i>R</i></sup></sup>, <i>g</i>) <i>e</i> (<i>π</i>, <i>g</i><sup><i>α</i><sup><i>q</i>-<i>R</i>+1</sup></sup>) .</p>
                </div>
                <div class="p1">
                    <p id="290"> (ii) 如果等式成立, 则接受交集查询的结果<i>R</i>, 输出‘1’, 否则拒绝结果<i>R</i>, 输出‘0’.</p>
                </div>
                <div class="p1">
                    <p id="291">最大值查询的安全性证明与最小值查询类似, 因此不再赘述.</p>
                </div>
                <div class="p1">
                    <p id="292">⑦ 范围查询<i>range</i> (<i>l</i>, <i>r</i>) </p>
                </div>
                <div class="p1">
                    <p id="293">查询:</p>
                </div>
                <div class="p1">
                    <p id="294"> (i) 根据查询范围[<i>l</i>, <i>r</i>], 将被查询集合X 分割成3个不相交集合U, V, W, 其中U={<i>i</i>:<i>i</i>∈X, <i>i</i>&lt;<i>l</i>}, V={<i>i</i>:<i>i</i>∈X, <i>l</i>≤<i>i</i>≤<i>r</i>}, U={<i>i</i>:<i>i</i>∈X, <i>i</i>&gt;<i>r</i>}.</p>
                </div>
                <div class="p1">
                    <p id="295"> (ii) 分别调用集合U∩V, U∩W和V∩W查询算法返回对应的结果和证据.</p>
                </div>
                <div class="p1">
                    <p id="296"> (iii) 分别调用集合U和W的最大值和最小值查询算法返回对应的结果和证据.</p>
                </div>
                <div class="p1">
                    <p id="297">验证:</p>
                </div>
                <div class="p1">
                    <p id="298"> (i) 分别调用集合U∩V, U∩W和V∩W验证算法, 若验证失败, 输出‘0’, 否则, 执行下一步.</p>
                </div>
                <div class="p1">
                    <p id="299"> (ii) 分别调用集合U和W的最大值和最小值验证算法, 若验证失败, 输出‘0’, 否则, 执行下一步.</p>
                </div>
                <div class="p1">
                    <p id="300"> (iii) 验证max (U) &lt;<i>l</i>, min (V) ≥<i>l</i>, max (V) ≤<i>r</i>, min (W) &gt;<i>r</i>.若成立, 则接受查询结果<i>R</i>, 输出‘1’, 否则拒绝结果<i>R</i>, 输出‘0’.</p>
                </div>
                <div class="p1">
                    <p id="301">范围查询的安全性证明依赖于集合的交集、最大值和最小值查询的安全性, 上文已证, 因此不再赘述.</p>
                </div>
                <div class="p1">
                    <p id="302">⑧ 嵌套查询</p>
                </div>
                <div class="p1">
                    <p id="303">本方案是嵌套查询, 查询时递归调用嵌套查询中的每个查询, 但是无需返回中间的结果, 只需返回中间结果的摘要和对应的证据.验证时, 同样递归调用嵌套查询中的每个查询所对应的验证算法, 验证查询结果的正确性.该查询的安全性依赖于上述各类查询的安全性, 因此该查询也是安全的.</p>
                </div>
                <h3 id="304" name="304" class="anchor-tag"><b>4 性能分析</b></h3>
                <h4 class="anchor-tag" id="305" name="305"><b>4.1 方案对比</b></h4>
                <div class="p1">
                    <p id="306">本节将本文所提方案与基于签名、基于RSA累加器、基于双线性映射累加器、基于电路和基于RAM的5类方案进行了对比.功能方面, 主要比较了各类型方案中所支持的查询类型和是否支持更新操作.性能方面, 主要从理论上比较了各类型方案中, 初始化算法、查询算法、验证算法和更新算法的计算代价及证据的大小.比较结果如表1所示, 其中<i>n</i>, |<i>R</i>|, <i>d</i>分别为外包数据集的大小, 查询结果的大小, 嵌套查询中分解为单个查询的数量, <mathml id="307"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi>Ο</mi><mo>˜</mo></mover><mo stretchy="false"> (</mo><mi>n</mi><mo stretchy="false">) </mo><mo>=</mo><mrow><mi>Ο</mi><mo stretchy="false"> (</mo><mi>n</mi><msup><mrow></mrow><mrow><mn>1</mn><mo>+</mo></mrow></msup><mi>Ο</mi><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow><mo stretchy="false">) </mo></mrow></math></mathml>.从表1可看出, 在功能方面上, 只有本文所提出的方案和基于RAM的方案支持全操作即集合操作、求和、计数、最大值/最小值、范围、嵌套和更新操作.在性能方面上, 在初始化算法上, 本方案与基于签名、基于RAM、基于电路和基于RSA累加器的方案所消耗的代价相同均为<i>O</i> (<i>n</i>) , 且优于基于双线性映射累加器的方案.在查询算法上, 本方案与基于签名和基于RSA累加器的方案所消耗的代价相同均为<i>O</i> (<i>n</i>) , 且优于其他3个方案.在验证算法上, 由于本方案与基于RAM的方案支持嵌套查询, 查询验证的时间与嵌套查询中分解为单个查询的数量<i>d</i>有关, 且2类方案验证所消耗的代价相同均为<i>O</i> (<i>d</i>+|<i>R</i>|) .在不进行嵌套查询时, 验证的效率与其他4类相同均为<i>O</i> (|<i>R</i>|) .在更新算法上, 本方案所花费的代价为常数级, 均优于其他方案.在不进行嵌套查询时, 本方案中证据大小与其他方案中证据的大小相同均为<i>O</i> (1) .在进行嵌套查询时, 基于RAM方案中证据的大小小于本方案的大小.综合以上分析, 理论上本文所提方案在功能及性能方面与基于RAM方案相似, 整体上均优于其他方案.</p>
                </div>
                <div class="area_img" id="308">
                    <p class="img_tit"><b>表1 方案对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table1 Comparison with Prior Work</b></p>
                    <p class="img_note"></p>
                    <table id="308" border="1"><tr><td>Schemes</td><td>Set Ops</td><td>Sum</td><td>Count</td><td>Max/Min</td><td>Range</td><td>Nested</td><td>Update</td><td>Setup</td><td>Query</td><td>Verification</td><td>Update</td><td>Witness Size</td></tr><tr><td><br />Signature-based<sup>[4-7]</sup></td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>√</td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (|<i>R</i>|) </td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (1) </td></tr><tr><td><br />RSA Acc<sup>[9]</sup></td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>√</td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (|<i>R</i>|) </td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (1) </td></tr><tr><td><br />Bilinear Acc<sup>[10, 13]</sup></td><td>√</td><td>√</td><td>×</td><td>×</td><td>×</td><td>×</td><td>√</td><td><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>Ο</mi><mo>˜</mo></mover></math> (<i>n</i>) </td><td><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>Ο</mi><mo>˜</mo></mover></math> (<i>n</i>) </td><td><i>O</i> (|<i>R</i>|) </td><td><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>Ο</mi><mo>˜</mo></mover></math> (<i>n</i>) </td><td><i>O</i> (<i>d</i>) </td></tr><tr><td><br />Circuit-based<sup>[20-21]</sup></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>×</td><td>×</td><td><i>O</i> (<i>n</i>) </td><td><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>Ο</mi><mo>˜</mo></mover></math> (<i>n</i>) </td><td><i>O</i> (|<i>R</i>|) </td><td>×</td><td><i>O</i> (1) </td></tr><tr><td><br />RAM-based<sup>[22-25]</sup></td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td><i>O</i> (<i>n</i>) </td><td><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi>Ο</mi><mo>˜</mo></mover></math> (<i>n</i>) </td><td><i>O</i> (<i>d</i>+|<i>R</i>|) </td><td><i>Ω</i> (log <i>n</i>) </td><td><i>O</i> (1) </td></tr><tr><td><br />Our Scheme</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (<i>n</i>) </td><td><i>O</i> (<i>d</i>+|<i>R</i>|) </td><td><i>O</i> (1) </td><td><i>O</i> (<i>d</i>) </td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note">Notes:√ means the scheme is applicable;× means the scheme is not applicable.</p>
                </div>
                <h4 class="anchor-tag" id="309" name="309"><b>4.2 效率分析</b></h4>
                <div class="p1">
                    <p id="310">根据4.1节中方案的对比分析可知:基于签名的可验证外包数据库方案无论在功能上还是性能上都低于其他2类方法;基于认证数据结构的方法中, 虽然在部分方案与基于可验证计算的方案中性能相近, 但是前者所支持的操作远小于基于可验证计算方案所支持的操作.因此只与基于可验证计算的方案相比较.而在基于可验证计算的方案中, 基于电路的方案所支持的查询操作不及基于RAM的方案丰富, 且基于RAM的方案中SNARK方案<citation id="449" type="reference"><link href="411" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>较高效.因此在实验分析中只与SNARK 方案进行对比.实验中, 主机的配置为Intel<sup>®</sup> Core<sup>TM</sup> i7-4770 3.40 GHz主频的处理器和32 GB内存, 选定的安全参数<i>λ</i>=128, 测试语句为嵌套查询语句<i>count</i> ( (X ∩Y) ∪ (U ∩W) ) , 其中每个集合大小相等均为<i>n</i>.数据集利用伪随机数生成器以时间戳为输入随机产生.每次执行时, 数据集都不相同.保证了数据集的随机可靠性和程序的健壮性.对本方案和SNARK方案中的初始化算法的效率、查询算法的效率、验证算法的效率、证据的大小和云服务器所需的存储空间进行了测试、对比与分析.</p>
                </div>
                <div class="p1">
                    <p id="311">两方案中初始化算法的效率比较结果如图2所示, 横坐标为集合的大小, 纵坐标为该算法运行的时间.将本方案运行时间放大10 000倍, 仍远小于SNARK方案的运行时间.因此, 在初始化算法上, 虽然理论分析上两方案相近, 但本方案更高效.</p>
                </div>
                <div class="area_img" id="312">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903007_312.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 初始化算法运行时间比较" src="Detail/GetImg?filename=images/JFYZ201903007_312.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 初始化算法运行时间比较  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903007_312.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 Comparison for setup in time cost</p>

                </div>
                <div class="p1">
                    <p id="313">两方案查询算法的效率比较结果如图3所示, 将本方案运行时间放大100倍, 仍小于SNARK方案的运行时间.因此, 在查询算法上, 虽然理论分析上两方案相同, 但本方案更高效.</p>
                </div>
                <div class="area_img" id="314">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903007_314.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 查询算法运行时间比较" src="Detail/GetImg?filename=images/JFYZ201903007_314.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 查询算法运行时间比较  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903007_314.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 Comparison for query in time cost</p>

                </div>
                <div class="p1">
                    <p id="315">两方案中验证算法的效率比较结果如图4示, 两方案中验证效率均为常数级, 不随集合大小增加而增大, 且本方案验证效率小于SNARK方案.因此在验证算法上, 虽然理论分析上两方案相近, 但本方案更高效.在进行更新操作时, 本方案在任意大小的数据下所消耗的时间大约为2.6 μs.由于SNARK对硬件要求较高, 在现有的实验条件内未测出SNARK更新操作所需的精准时间, 但实验表明了其所需时间要远大于本方案所需时间.此外, 4.1节理论分析可知, 更新时, SNARK的效率为<i>Ω</i> (log <i>n</i>) , 本方案的效率为<i>O</i> (1) 远小于SNARK的效率.基于以上2点, 本方案中更新算法的效率远高于SNARK方案中更新算法的效率.</p>
                </div>
                <div class="area_img" id="316">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903007_316.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 验证算法运行时间比较" src="Detail/GetImg?filename=images/JFYZ201903007_316.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 验证算法运行时间比较  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903007_316.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 Comparison for verify in time cost</p>

                </div>
                <div class="p1">
                    <p id="317">两方案中证据的大小比较结果如图5所示, 两方案中证据的大小恒定不变, 不随集合大小的增加而增加, 且本方案中证据的大小小于SNARK方案.因此在证据的大小上, 虽然理论分析上两方案相同, 但本方案通信代价更低.</p>
                </div>
                <div class="area_img" id="318">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903007_318.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 证据大小比较" src="Detail/GetImg?filename=images/JFYZ201903007_318.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 证据大小比较  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903007_318.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Comparison for witness size</p>

                </div>
                <div class="p1">
                    <p id="319">两方案中云服务器所需要的存储空间比较结果如图6所示, 横坐标为集合的大小, 纵坐标为云服务器所需的存储空间.将本方案所需的存储空间放大10倍, 仍小于SNARK方案.因此本方案的数据膨胀率更低.</p>
                </div>
                <div class="area_img" id="320">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201903007_320.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 存储空间比较" src="Detail/GetImg?filename=images/JFYZ201903007_320.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 存储空间比较  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201903007_320.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 Comparison for storage size</p>

                </div>
                <div class="p1">
                    <p id="321">以上实验结果表明, 本方案在初始化算法的效率、查询算法的效率、验证算法的效率、证据的大小及存储空间上均优于SNARK方案.因此本方案效率更高、通信代价更小、数据膨胀率更低, 更适合应用于实际.</p>
                </div>
                <h3 id="322" name="322" class="anchor-tag"><b>5 结 论</b></h3>
                <div class="p1">
                    <p id="323">针对现有可验证外包数据方案存在查询类型单一、效率低下、验证和更新代价较高, 难以应用于实际等问题, 深入系统地研究了国内外关于可验证外包数据库相关方案, 并总结各方案的优缺点.在此基础上, 基于双线性映射提出了一个支持全操作的公共可验证外包数据库方案, 给出了该方案的形式化定义, 正确性及安全性定义.然后给出了方案的构建, 并证明了方案的安全性.最后将本方案与已有方案相比较, 理论与实验分析表明该方案功能更全面性, 效率更高, 数据的膨胀率更低, 更新计算代价更低.本方案中数据的验证和更新不依赖于私钥, 实现了公共可验证和公共可更新.因此本方案对外包数据库查询结果完整性问题的研究具有一定的理论意义和实践价值.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="363">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=MMBcloud-Tree:Authenticated Index for Verifiable Cloud Service Selection">

                                <b>[1]</b>Li Jingwei, Squicciarini A C, Lin Dan, et al. MMBcloud -Tree: Authenticated index for verifiable cloud service selection[J]. IEEE Transactions on Dependable and Secure Computing, 2017, 14 (2) : 185- 198
                            </a>
                        </p>
                        <p id="365">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMC0D23C769FAABD9C1018946474785C9E&amp;v=MTExMDZ1SFlmT0dRbGZDcGJRMzVkbGh3cnUzd3E0PU5pZklZOEM0YXRQUDNJaERiWjErZlE1TnhtVVM2ajUxUVh2a3FCVXhmcnFSTnJQcUNPTnZGU2lXV3I3SklGcG1hQg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b>Khan S, Gani A, Wahab A W A, et al. Cloud log forensics: Foundations, state of the art, and future directions[J]. ACM Computing Surveys, 2016, 49 (1) : 1- 42
                            </a>
                        </p>
                        <p id="367">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Generic attacks on secure outsourced databases">

                                <b>[3]</b>Kellaris G, Kollios G, Nissim K, et al. Generic attacks on secure outsourced databases[C] //Proc of the 23rd ACM Conf on Computer and Communications Security. New York: ACM, 2016: 1329- 1340
                            </a>
                        </p>
                        <p id="369">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Signature bouquets:Immutability for aggregated/condensed signatures">

                                <b>[4]</b>Mykletun E, Narasimha M, Tsudik G. Signature bouquets: Immutability for aggregated/condensed signatures[C] //Proc of the 9th European Symp on Research in Computer Security. Berlin: Springer, 2004: 160- 176
                            </a>
                        </p>
                        <p id="371">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES2FE83B764EDCD06CD0F9019B216B6725&amp;v=MjU1MTZTSDdyM2hBMGY4Q1NRcmlhQ09OdkZTaVdXcjdKSUZwbWFCdUhZZk9HUWxmQ3BiUTM1ZGxod3J1M3dxND1OaWZPZmJIT2E5blAzWWhEWUo1N2Z3ZzV5V1ZuNmtsMA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b>Jang M, Yoon M, Song Y, et al. A signature-based data authentication method with bitmap-based transformed datain database outsourcing[J]. Procedia Computer Science, 2015, 52 (1) : 680- 684
                            </a>
                        </p>
                        <p id="373">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=&amp;quot;Authenticated Join Processing in Outsourced Databases&amp;quot;">

                                <b>[6]</b>Yang Yin, Papadias D, Papadopoulos S, et al. Authenticated join processing in outsourced databases[C] //Proc of ACM SIGMOD’09. New York: ACM, 2009: 5- 18
                            </a>
                        </p>
                        <p id="375">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201001028&amp;v=MjMzNTQ5SGJJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNzNPTHl2U2RMRzRIOUhNcm8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b>Zhang Min, Hong Cheng, Chen Chi. Server transparent query authentication of outsourced database[J]. Journal of Computer Research and Development, 2010, 47 (1) : 182- 190 (in Chinese) (张敏, 洪澄, 陈驰. 一种服务器透明的外包数据库查询验证方法[J]. 计算机研究与发展, 2010, 47 (1) : 182- 190) 
                            </a>
                        </p>
                        <p id="377">
                            <a id="bibliography_8" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM14041100000960&amp;v=MjMyMzBxUVRNbndaZVp1SHlqbVViN0lKbDBjYUJRPU5pZklZN0s4SHRYTnJvOUZaT3NQQlhvNW9CTVQ2VDRQUUgvaXJSZEdlcg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[8]</b>Miller A J, Hicks M, Katz J, et al. Authenticated data structures, generically[J]. ACM SIGPLAN Notices, 2014, 49 (1) : 411- 423
                            </a>
                        </p>
                        <p id="379">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Dynamic accumulators and application to efficient revocation of anonymous credentials">

                                <b>[9]</b>Camenisch J, Lysyanskaya A. Dynamic accumulators and application to efficient revocation of anonymous credentials[C] //Proc of the 22nd Annual Int Cryptology Conf. Berlin: Springer, 2002: 61- 76
                            </a>
                        </p>
                        <p id="381">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An Accumulator Based on Bilinear Maps and Efficient Revocation for Anonymous Credentials">

                                <b>[10]</b>Camenisch J, Kohlweiss M, Soriente C. An accumulator based on bilinear maps and efficient revocation for anonymous credentials[C] //Proc of the 12th Int Workshop on Practice and Theory in Public Key Cryptography. Berlin: Springer, 2009: 481- 500
                            </a>
                        </p>
                        <p id="383">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Merkle hash tree based techniques for data integrity of outsourced data">

                                <b>[11]</b>Niaz M S, Saake G. Merkle hash tree based techniques for data integrity of outsourced data[C] //Proc of the 27th GI-Workshop on Foundations of Databases. Volkse, Germany: Workshop Grundlagen von Datenbanken, 2015: 66- 71
                            </a>
                        </p>
                        <p id="385">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=IntegriDB: Verifiable SQL for outsourced databases">

                                <b>[12]</b>Zhang Yupeng, Katz J, Papamanthou C. IntegriDB: Verifiable SQL for outsourced databases[C] //Proc of the 22nd ACM Conf on Computer and Communications Security. New York: ACM, 2015: 1480- 1491
                            </a>
                        </p>
                        <p id="387">
                            <a id="bibliography_13" >
                                    <b>[13]</b>
                                Papamanthou C, Tamassia R, Triandopoulos N. Optimal verification of operations on dynamic sets[C] //Proc of the 31st Annual Int Cryptology Conf. Berlin: Springer, 2011: 91- 110
                            </a>
                        </p>
                        <p id="389">
                            <a id="bibliography_14" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201006024&amp;v=MDQ5NTJPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNzNPTHl2U2RMRzRIOUhNcVk5SFlJUUtESDg0dlI0VDZqNTQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[14]</b>Xian Hequn, Feng Dengguo. An integrity checking scheme in outsourced database model[J]. Journal of Computer Research and Development, 2010, 47 (6) : 1107- 1115 (in Chinese) (咸鹤群, 冯登国. 外包数据库模型中的完整性检测方案[J]. 计算机研究与发展, 2010, 47 (6) : 1107- 1115) 
                            </a>
                        </p>
                        <p id="391">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CMFD&amp;filename=1015978424.nh&amp;v=MTgxODhGdFhPcTVFYlBJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNzNPVkYyNkc3cS8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b>Zhou Rui. Study of outsourced data query authentication technology in cloud computing[D]. Guangzhou: Jinan University, 2015 (in Chinese) (周锐. 云计算下外包数据查询验证技术的研究[D]. 广州: 暨南大学, 2015) 
                            </a>
                        </p>
                        <p id="393">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1016245829.nh&amp;v=MTkwOTJwcEViUElRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVZ2Rnk3bVc3M09WRjI2R0xHOEc5bk8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b>Wang Jianfeng. Study on efficient search and secure audit for outsourced data in cloud computing[D]. Xi’an: Xidian University, 2016 (in Chinese) (王剑锋. 云环境下外包数据的高效检索及安全审计技术研究[D]. 西安: 西安电子科技大学, 2016) 
                            </a>
                        </p>
                        <p id="395">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES516AC4932F1C97ECBE703A9E9C0845DA&amp;v=MzIzODdPZmJhNUdLQy9xNFpHWnAwT2YzVSt1bVZobnpoOVN3N3IyUnRHZWJxUVFNN3VDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVkbGh3cnUzd3E0PU5pZg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b>Miao Meixia, Wang Jianfeng, Ma Jianfeng, et al. Publicly verifiable databases with efficient insertion/deletion operations[J]. Journal of Computer and System Sciences, 2017, 86: 49- 58
                            </a>
                        </p>
                        <p id="397">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Publicly verifiable conjunctive keyword search in outsourced databases">

                                <b>[18]</b>Azraoui M, Elkhiyaoui K, Onen M, et al. Publicly verifiable conjunctive keyword search in outsourced databases[C] //Proc of IEEE CNS’15. Piscataway, NJ: IEEE, 2015: 619- 627
                            </a>
                        </p>
                        <p id="399">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Taking authenticated range queries to arbitrary dimensions">

                                <b>[19]</b>Papadopoulos D, Papadopoulos S, Triandopoulos N. Taking authenticated range queries to arbitrary dimensions[C] //Proc of the 21st ACM Conf on Computer and Communications Security. New York: ACM, 2014: 819- 830
                            </a>
                        </p>
                        <p id="401">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Geppetto: Versatile verifiable computation">

                                <b>[20]</b>Costello C, Fournet C, Howell J, et al. Geppetto: Versatile verifiable computation[C] //Proc of the 36th IEEE Symp on Security and Privacy. Piscataway, NJ: IEEE, 2015: 253- 270
                            </a>
                        </p>
                        <p id="403">
                            <a id="bibliography_21" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Pinocchio: Nearly practical verifiable computation">

                                <b>[21]</b>Parno B, Howell J, Gentry C, et al. Pinocchio: Nearly practical verifiable computation[C] //Proc of the 34th IEEE Symp on Security and Privacy. Piscataway, NJ: IEEE, 2013: 238- 252
                            </a>
                        </p>
                        <p id="405">
                            <a id="bibliography_22" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Verifying computations with state">

                                <b>[22]</b>Braun B, Feldman A J, Ren Zuocheng, et al. Verifying computations with state[C] //Proc of the 24th ACM Symp on Operating Systems Principles. New York: ACM, 2013: 341- 357
                            </a>
                        </p>
                        <p id="407">
                            <a id="bibliography_23" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Scalable zero knowledge via cycles of elliptic curves">

                                <b>[23]</b>Bensasson E, Chiesa A, Tromer E, et al. Scalable zero knowledge via cycles of elliptic curves[C] //Proc of the 34th Annual Int Cryptology Conf. Berlin: Springer, 2014: 276- 294
                            </a>
                        </p>
                        <p id="409">
                            <a id="bibliography_24" target="_blank" href="http://scholar.cnki.net/result.aspx?q=SNARKs for C: Verifying program executions succinctly and in zero knowledge">

                                <b>[24]</b>Bensasson E, Chiesa A, Genkin D, et al. SNARKs for C: Verifying program executions succinctly and in zero knowledge[C] //Proc of the 33rd Annual Int Cryptology Conf. Berlin: Springer, 2013: 90- 108
                            </a>
                        </p>
                        <p id="411">
                            <a id="bibliography_25" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Succinct non-interactive zero knowledge for a von Neumann architecture">

                                <b>[25]</b>Bensasson E, Chiesa A, Tromer E, et al. Succinct non-interactive zero knowledge for a von Neumann architecture[C] //Proc of the 23rd USENIX Security Symp. Berkeley, CA: USENIX Association, 2014: 781- 796
                            </a>
                        </p>
                        <p id="413">
                            <a id="bibliography_26" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00000174959&amp;v=MDYxMDR6QmRoNGo5OVNYcVJyeG94Y01IN1I3cWVidWR0RlNubFZiekFJbGc9Tmo3QmFyTzRIdEhNcm9oQmJlNEdZM2s1&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[26]</b>Boneh D, Boyen X. Short signatures without random oracles and the SDH assumption in bilinear groups[J]. Journal of Cryptology, 2008, 21 (2) : 149- 177
                            </a>
                        </p>
                        <p id="415">
                            <a id="bibliography_27" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Hierarchical Identity-Based Encryption with Constant Ciphertext">

                                <b>[27]</b>Boneh D, Boyen X, Goh E J. Hierarchical identity based encryption with constant size ciphertext[C] //Proc of the 24th Annual Int Conf on the Theory and Applications of Cryptographic Techniques. Berlin: Springer, 2005: 440- 456
                            </a>
                        </p>
                        <p id="417">
                            <a id="bibliography_28" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Optimal verification of operations on dynamic sets">

                                <b>[28]</b>Papamanthou C, Tamassia R, Triandopoulos N. Optimal verification of operations on dynamic sets[C] //Proc of the 31st Annual Int Cryptology Conf. Berlin: Springer, 2011: 91- 110
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201903007" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903007&amp;v=MTg5NjRkTEc0SDlqTXJJOUZZNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplVnZGeTdtVzczT0x5dlM=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
