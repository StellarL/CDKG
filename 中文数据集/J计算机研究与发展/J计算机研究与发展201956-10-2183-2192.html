

<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>

</head>

<body>

    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637127130889676250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201910013%26RESULT%3d1%26SIGN%3d%252beFq5YIGuMPdmyzk5a4j04U8VLc%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201910013&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201910013&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>


    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201910013&amp;v=MDEzNTE0TzN6cXFCdEdGckNVUkxPZVplUnNGeXpoVTd6QUx5dlNkTEc0SDlqTnI0OUVaNFFLREg4NHZSNFQ2ajU=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#47" data-title="&lt;b&gt;1 基础知识&lt;/b&gt; "><b>1 基础知识</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#48" data-title="&lt;b&gt;1.1 前缀算法&lt;/b&gt;"><b>1.1 前缀算法</b></a></li>
                                                <li><a href="#75" data-title="&lt;b&gt;1.2 保留前缀Hash加密&lt;/b&gt;"><b>1.2 保留前缀Hash加密</b></a></li>
                                                <li><a href="#82" data-title="&lt;b&gt;1.3 Sharif提出的条件代码加密方法介绍&lt;/b&gt;"><b>1.3 Sharif提出的条件代码加密方法介绍</b></a></li>
                                                <li><a href="#89" data-title="&lt;b&gt;1.4 基于保留前缀加密的分支混淆方法介绍&lt;/b&gt;"><b>1.4 基于保留前缀加密的分支混淆方法介绍</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#106" data-title="&lt;b&gt;2 多输入条件下的秘钥生成&lt;/b&gt; "><b>2 多输入条件下的秘钥生成</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#108" data-title="&lt;b&gt;2.1 拉格朗日插值法&lt;/b&gt;"><b>2.1 拉格朗日插值法</b></a></li>
                                                <li><a href="#113" data-title="&lt;b&gt;2.2 输入处理多项式生成&lt;/b&gt;"><b>2.2 输入处理多项式生成</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#121" data-title="&lt;b&gt;3 基于分支条件混淆的条件代码加密&lt;/b&gt; "><b>3 基于分支条件混淆的条件代码加密</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#123" data-title="&lt;b&gt;3.1 Sharif条件代码加密方法的改进&lt;/b&gt;"><b>3.1 Sharif条件代码加密方法的改进</b></a></li>
                                                <li><a href="#129" data-title="&lt;b&gt;3.2 大小比较分支的条件代码加密&lt;/b&gt;"><b>3.2 大小比较分支的条件代码加密</b></a></li>
                                                <li><a href="#134" data-title="&lt;b&gt;3.3 复杂条件分支的条件代码加密&lt;/b&gt;"><b>3.3 复杂条件分支的条件代码加密</b></a></li>
                                                <li><a href="#149" data-title="&lt;b&gt;3.4 多线程处理&lt;/b&gt;"><b>3.4 多线程处理</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#152" data-title="&lt;b&gt;4 分析与评估&lt;/b&gt; "><b>4 分析与评估</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#153" data-title="&lt;b&gt;4.1 条件代码加密的时间和空间消耗&lt;/b&gt;"><b>4.1 条件代码加密的时间和空间消耗</b></a></li>
                                                <li><a href="#158" data-title="&lt;b&gt;4.2 与其他加密方法的比较&lt;/b&gt;"><b>4.2 与其他加密方法的比较</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#166" data-title="&lt;b&gt;5 结  论&lt;/b&gt; "><b>5 结  论</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#84" data-title="图1 条件代码加密示意图">图1 条件代码加密示意图</a></li>
                                                <li><a href="#85" data-title="图2 重复条件代码和复合条件代码的复制处理">图2 重复条件代码和复合条件代码的复制处理</a></li>
                                                <li><a href="#86" data-title="图3 基于保留前缀Hash加密的分支条件混淆示意图">图3 基于保留前缀Hash加密的分支条件混淆示意图</a></li>
                                                <li><a href="#128" data-title="图4 复合条件和重复条件处理示意图">图4 复合条件和重复条件处理示意图</a></li>
                                                <li><a href="#131" data-title="图5 区间条件分支处理示意图">图5 区间条件分支处理示意图</a></li>
                                                <li><a href="#147" data-title="图6 复杂条件分支处理示意图">图6 复杂条件分支处理示意图</a></li>
                                                <li><a href="#148" data-title="图7 多线程代码加解密示意图">图7 多线程代码加解密示意图</a></li>
                                                <li><a href="#157" data-title="&lt;b&gt;表1 加密消耗的时间和空间数据&lt;/b&gt;"><b>表1 加密消耗的时间和空间数据</b></a></li>
                                                <li><a href="#164" data-title="&lt;b&gt;表2 加密方法优势对比&lt;/b&gt;"><b>表2 加密方法优势对比</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="203">


                                    <a id="bibliography_1" title="Schrittwieser S,Katzenbeisser S,Kieseberg P,et al.Covert computation:Hiding code in code for obfuscation purposes[C] //Proc of the 8th ACM SIGSAC Symp on Information,Computer and Communications Security.New York:ACM,2013:529- 534" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Covert computation:Hiding code in code for obfuscation purposes">
                                        <b>[1]</b>
                                        Schrittwieser S,Katzenbeisser S,Kieseberg P,et al.Covert computation:Hiding code in code for obfuscation purposes[C] //Proc of the 8th ACM SIGSAC Symp on Information,Computer and Communications Security.New York:ACM,2013:529- 534
                                    </a>
                                </li>
                                <li id="205">


                                    <a id="bibliography_2" title="Balachandran V,Emmanuel S.Potent and stealthy control flow obfuscation by stack based self-modifying code[J].IEEE Transactions on Information Forensics and Security,2013,8(4):669- 681" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Potent and stealthy control flow obfuscation by stack based self-modifying code">
                                        <b>[2]</b>
                                        Balachandran V,Emmanuel S.Potent and stealthy control flow obfuscation by stack based self-modifying code[J].IEEE Transactions on Information Forensics and Security,2013,8(4):669- 681
                                    </a>
                                </li>
                                <li id="207">


                                    <a id="bibliography_3" title="Cappaert J,Preneel B,Anckaert B,et al.Towards tamper resistant code encryption:Practice and experience[C] //Proc of the 4th Int Conf on Information Security Practice and Experience.Berlin:Springer,2008:86- 100" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Towards tamper resistant code encryption:practice and experience">
                                        <b>[3]</b>
                                        Cappaert J,Preneel B,Anckaert B,et al.Towards tamper resistant code encryption:Practice and experience[C] //Proc of the 4th Int Conf on Information Security Practice and Experience.Berlin:Springer,2008:86- 100
                                    </a>
                                </li>
                                <li id="209">


                                    <a id="bibliography_4" title="Wu Zhenyu,Steven Gianvecchio,Xie Mengjun,et al.Mimimorphism:A new approach to binary code obfuscation[C] //Proc of the 17th ACM Conf on Computer and Communications Security (CCS&#39;12).New York:ACM,2012:536- 546" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Mimimorphism:A new approach to binary code obfuscation">
                                        <b>[4]</b>
                                        Wu Zhenyu,Steven Gianvecchio,Xie Mengjun,et al.Mimimorphism:A new approach to binary code obfuscation[C] //Proc of the 17th ACM Conf on Computer and Communications Security (CCS&#39;12).New York:ACM,2012:536- 546
                                    </a>
                                </li>
                                <li id="211">


                                    <a id="bibliography_5" title="Vrba Z.Cryptexec:Next-generation runtime binary encryption using on-demand function extraction[EB/OL].[2019-06-11].http://www.phrack.org/issues/63/13.html#article" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Cryptexec:Next-generation runtime binary encryption using on-demand function extraction">
                                        <b>[5]</b>
                                        Vrba Z.Cryptexec:Next-generation runtime binary encryption using on-demand function extraction[EB/OL].[2019-06-11].http://www.phrack.org/issues/63/13.html#article
                                    </a>
                                </li>
                                <li id="213">


                                    <a id="bibliography_6" title="Vrba Ž,Halvorsen P,Griwodz C.Program obfuscation by strong cryptography[C] //Proc of 2010 Int Conf on Availability,Reliability and Security.Piscataway,NJ:IEEE,2010:242- 247" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Program obfuscation by strong cryptography">
                                        <b>[6]</b>
                                        Vrba Ž,Halvorsen P,Griwodz C.Program obfuscation by strong cryptography[C] //Proc of 2010 Int Conf on Availability,Reliability and Security.Piscataway,NJ:IEEE,2010:242- 247
                                    </a>
                                </li>
                                <li id="215">


                                    <a id="bibliography_7" title="Cappaert J,Kisserli N,Schellekens D,et al.Self-encrypting code to protect against analysis and tampering[C/OL] //Proc of the 1st Benelux Workshop on Information and Sytem Security (WISSec 2006).2006 [2019-06-10].https://www.esat.kuleuven.be/cosic/publications/article-811.pdf" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Self-encrypting code to protect against analysis and tampering[C/OL]">
                                        <b>[7]</b>
                                        Cappaert J,Kisserli N,Schellekens D,et al.Self-encrypting code to protect against analysis and tampering[C/OL] //Proc of the 1st Benelux Workshop on Information and Sytem Security (WISSec 2006).2006 [2019-06-10].https://www.esat.kuleuven.be/cosic/publications/article-811.pdf
                                    </a>
                                </li>
                                <li id="217">


                                    <a id="bibliography_8" title="Balachandran V,Keong N W,Emmanuel S.Function level control flow obfuscation for software security[C] //Proc of the 8th Int Conf on Complex,Intelligent and Software Intensive Systems.Piscataway,NJ:IEEE,2014:133- 140" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Function level control flow obfuscation for software security">
                                        <b>[8]</b>
                                        Balachandran V,Keong N W,Emmanuel S.Function level control flow obfuscation for software security[C] //Proc of the 8th Int Conf on Complex,Intelligent and Software Intensive Systems.Piscataway,NJ:IEEE,2014:133- 140
                                    </a>
                                </li>
                                <li id="219">


                                    <a id="bibliography_9" title="Sharif M,Lanzi A,Giffin J,et al.Impeding malware analysis using conditional code obfuscation[C] //Proc of the Network and Distributed System Security Symp.Rosten,VA:Internet Society,2008:321- 333" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Impeding malware analysis using conditional codeobfuscation">
                                        <b>[9]</b>
                                        Sharif M,Lanzi A,Giffin J,et al.Impeding malware analysis using conditional code obfuscation[C] //Proc of the Network and Distributed System Security Symp.Rosten,VA:Internet Society,2008:321- 333
                                    </a>
                                </li>
                                <li id="221">


                                    <a id="bibliography_10" title="Jia Chunfu,Wang Zhi,Liu Xin,et al.Branch obfuscation:An efficient binary code obfuscation to impede symbolic execution[J].Journal of Computer Research and Development,2011,48(11):2111- 2119 (in Chinese)(贾春福,王志,刘昕,等.路径模糊:一种有效抵抗符号执行的二进制混淆技术[J].计算机研究与发展,2011,48(11):2111- 2119)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201111023&amp;v=MDIxOTMzenFxQnRHRnJDVVJMT2VaZVJzRnl6aFU3ekFMeXZTZExHNEg5RE5ybzlIWjRRS0RIODR2UjRUNmo1NE8=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                        Jia Chunfu,Wang Zhi,Liu Xin,et al.Branch obfuscation:An efficient binary code obfuscation to impede symbolic execution[J].Journal of Computer Research and Development,2011,48(11):2111- 2119 (in Chinese)(贾春福,王志,刘昕,等.路径模糊:一种有效抵抗符号执行的二进制混淆技术[J].计算机研究与发展,2011,48(11):2111- 2119)
                                    </a>
                                </li>
                                <li id="223">


                                    <a id="bibliography_11" title="Wang Zhi,Jia Chunfu,Liu Weijie,et al.Branch obfuscation to combat symbolic execution[J].Acta Electronica Sinica,2015,43(5):870- 878 (in Chinese)(王志,贾春福,刘伟杰,等.一种抵抗符号执行的路径分支混淆技术[J].电子学报,2015,43(5):870- 878)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU201505006&amp;v=MjI3OTlBSVRmVGU3RzRIOVRNcW85RllvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSc0Z5emhVN3o=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                        Wang Zhi,Jia Chunfu,Liu Weijie,et al.Branch obfuscation to combat symbolic execution[J].Acta Electronica Sinica,2015,43(5):870- 878 (in Chinese)(王志,贾春福,刘伟杰,等.一种抵抗符号执行的路径分支混淆技术[J].电子学报,2015,43(5):870- 878)
                                    </a>
                                </li>
                                <li id="225">


                                    <a id="bibliography_12" title="Lin Hong,Zhang Xiaohua,Ma Yong,et al.Branch obfuscation using binary code side effects[C] //Proc of the 1st Int Conf on Computer,Networks and Communication Engineering (ICCNCE 2013).Amsterdam,Netherlands:Atlantis Press,2013" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Branch obfuscation using binary code side effects">
                                        <b>[12]</b>
                                        Lin Hong,Zhang Xiaohua,Ma Yong,et al.Branch obfuscation using binary code side effects[C] //Proc of the 1st Int Conf on Computer,Networks and Communication Engineering (ICCNCE 2013).Amsterdam,Netherlands:Atlantis Press,2013
                                    </a>
                                </li>
                                <li id="227">


                                    <a id="bibliography_13" title="Banescu S,Collberg C,Pretschner A.Predicting the resilience of obfuscated code against symbolic execution attacks via machine learning[C] //Proc of the 26th USENIX Security Symposium (USENIX Security 17).Berkeley,CA:USENIX Association,2017:661- 678" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Predicting the resilience of obfuscated code against symbolic execution attacks via machine learning">
                                        <b>[13]</b>
                                        Banescu S,Collberg C,Pretschner A.Predicting the resilience of obfuscated code against symbolic execution attacks via machine learning[C] //Proc of the 26th USENIX Security Symposium (USENIX Security 17).Berkeley,CA:USENIX Association,2017:661- 678
                                    </a>
                                </li>
                                <li id="229">


                                    <a id="bibliography_14" title="Avidan E,Feitelson D G.From obfuscation to comprehension[C] //Proc of the 23rd Int Conf on Program Comprehension.Piscataway,NJ:IEEE,2015:178- 181" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=From obfuscation to comprehension">
                                        <b>[14]</b>
                                        Avidan E,Feitelson D G.From obfuscation to comprehension[C] //Proc of the 23rd Int Conf on Program Comprehension.Piscataway,NJ:IEEE,2015:178- 181
                                    </a>
                                </li>
                                <li id="231">


                                    <a id="bibliography_15" title="Yadegari B,Debray S.Symbolic execution of obfuscated code[C] //Proc of the 22nd ACM SIGSAC Conf on Computer and Communications Security.New York:ACM,2015:732- 744" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Symbolic execution of obfuscated code">
                                        <b>[15]</b>
                                        Yadegari B,Debray S.Symbolic execution of obfuscated code[C] //Proc of the 22nd ACM SIGSAC Conf on Computer and Communications Security.New York:ACM,2015:732- 744
                                    </a>
                                </li>
                                <li id="233">


                                    <a id="bibliography_16" title="Banescu S,Collberg C,Ganesh V,et al.Code obfuscation against symbolic execution attacks[C] //Proc of the 32nd Annual Conf on Computer Security Applications.New York:ACM,2016:189- 200" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Code obfuscation against symbolic execution attacks">
                                        <b>[16]</b>
                                        Banescu S,Collberg C,Ganesh V,et al.Code obfuscation against symbolic execution attacks[C] //Proc of the 32nd Annual Conf on Computer Security Applications.New York:ACM,2016:189- 200
                                    </a>
                                </li>
                                <li id="235">


                                    <a id="bibliography_17" >
                                        <b>[17]</b>
                                    Fan Jinliang,Xu Jun,Amma M H,et al.Prefix-preserving IP address anonymization:Measurement-based security evaluation and a new cryptography-based scheme[J].Computer Networks,2004,46(2):253- 272■Geng Pu,born in 1982.PhD candidate.His main research interests include code obfuscation and information security.■Zhu Yuefei,born in 1962.PhD,professor and PhD supervisor.His main research interests include cyberspace security and elliptic curve cyphers.</a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(10),2183-2192 DOI:10.7544/issn1000-1239.2019.20190368            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>一种基于分支条件混淆的代码加密技术</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%80%BF%E6%99%AE&amp;code=43047277&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">耿普</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%A5%9D%E8%B7%83%E9%A3%9E&amp;code=43047278&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">祝跃飞</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%88%98%E7%95%A5%E6%94%AF%E6%8F%B4%E9%83%A8%E9%98%9F%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E5%A4%A7%E5%AD%A6&amp;code=1702647&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">战略支援部队信息工程大学</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>基于分支条件混淆的代码加密技术,实现了秘钥和程序的分离,能够对抗程序静态和动态分析手段,但仅能用于相等条件分支.通过引入拉格朗日插值法,生成输入处理函数,在保证分支条件混淆安全的前提下,解决了多输入分支条件下通过输入产生秘钥的问题,实现多输入分支下的条件代码加密;把多输入分支下生成唯一秘钥方法应用到等于条件取或分支、大小比较条件分支和复杂条件分支,实现了基于分支条件混淆的代码加密技术从相等条件分支到区间条件分支和复杂条件分支的扩展.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%AF%86&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">条件代码加密;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B7%AF%E5%BE%84%E5%88%86%E6%94%AF%E6%B7%B7%E6%B7%86&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">路径分支混淆;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">拉格朗日插值法;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%A4%9A%E8%BE%93%E5%85%A5%E5%88%86%E6%94%AF&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">多输入分支;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">代码保护;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    Geng Pu,born in 1982.PhD candidate.Hismain research interests include codeobfuscation and information security.&lt;image id="198" type="formula" href="images/JFYZ201910013_19800.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Zhu Yuefei,born in 1962.PhD,professorand PhD supervisor.His main researchinterests include cyberspace security andelliptic curve cyphers.&lt;image id="200" type="formula" href="images/JFYZ201910013_20000.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2019-06-11</p>

            </div>
                    <h1><b>A Code Encrypt Technique Based on Branch Condition Obfuscation</b></h1>
                    <h2>
                    <span>Geng Pu</span>
                    <span>Zhu Yuefei</span>
            </h2>
                    <h2>
                    <span>Strategic Support Force Information Engineering University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Code encryption based on path branch obfuscation of equal condition can make the key be apart from the encrypted program, so this encryption can oppose static and dynamic programming analysis method at the same time, but it can't be used with branches controlled by other comparative relationships. In this paper, using Lagrange interpolation method to produce input-preprocess function, we not only resolve the uniqueness problem of key which produced by multi-inputs of the branch, but also preserve the security of obfuscation on branch conditions, so the conditional code of multi-inputs branch can be encrypted. Using the method which resolves the uniqueness problem of key, code encryption based on equal condition branch obfuscation can be extended to branch of greater-than and less-than condition branch, and complicate condition branch formed by blending of interval condition and equal condition.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=conditional%20code%20encryption&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">conditional code encryption;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=path%20branch%20obfuscation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">path branch obfuscation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Lagrange%20interpolation%20method&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Lagrange interpolation method;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=multi-input%20branch&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">multi-input branch;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=code%20protection&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">code protection;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2019-06-11</p>
                            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="39">代码加密<citation id="240" type="reference"><link href="203" rel="bibliography" /><link href="205" rel="bibliography" /><link href="207" rel="bibliography" /><link href="209" rel="bibliography" /><link href="211" rel="bibliography" /><link href="213" rel="bibliography" /><link href="215" rel="bibliography" /><sup>[<a class="sup">1</a>,<a class="sup">2</a>,<a class="sup">3</a>,<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">6</a>,<a class="sup">7</a>]</sup></citation>和代码混淆都是重要的代码保护技术,传统的代码加密技术在加密代码的粒度上越来越细,从文件、程序节区粒度到函数<citation id="241" type="reference"><link href="215" rel="bibliography" /><link href="217" rel="bibliography" /><sup>[<a class="sup">7</a>,<a class="sup">8</a>]</sup></citation>、基本块粒度,甚至到单个机器指令<citation id="237" type="reference"><link href="211" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>的粒度;另外在解密函数上也引入了多态<citation id="238" type="reference"><link href="209" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>的方法,加密代码每次解密执行后的再次加密会通过秘钥变化和解密函数变化来增加逆向分析的难度;但是在隐藏解密秘钥方面还缺少相关研究.分支条件混淆<citation id="242" type="reference"><link href="219" rel="bibliography" /><link href="221" rel="bibliography" /><link href="223" rel="bibliography" /><link href="225" rel="bibliography" /><link href="227" rel="bibliography" /><sup>[<a class="sup">9</a>,<a class="sup">10</a>,<a class="sup">11</a>,<a class="sup">12</a>,<a class="sup">13</a>]</sup></citation>是代码混淆<citation id="239" type="reference"><link href="229" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>研究的一个新方向,通过混淆分支条件,能够隐藏程序执行逻辑、对抗符号执行<citation id="243" type="reference"><link href="223" rel="bibliography" /><link href="231" rel="bibliography" /><link href="233" rel="bibliography" /><sup>[<a class="sup">11</a>,<a class="sup">15</a>,<a class="sup">16</a>]</sup></citation>,特别是在对触发条件的保护上具有较好的效果,能够阻碍生成满足触发条件的程序输入.</p>
                </div>
                <div class="p1">
                    <p id="40">虽然分支条件混淆能够保护程序的触发条件,但是无法保护基于触发条件的程序代码.于是Sharif等人<citation id="244" type="reference"><link href="219" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>结合分支条件混淆和代码加密,提出了一种基于分支条件混淆的条件代码加密技术,使用满足分支条件的输入作为代码加解密秘钥对条件代码进行加密,因此在程序内存中不需要存储秘钥,而是在运行时直接获取分支条件的输入作为秘钥;另外由于混淆使得逆向分析者难以获取满足分支条件的输入,也就无法获取加解密秘钥,因此结合分支条件混淆的代码加密实现了解密秘钥的隐藏.然而该分支混淆方法均只能应用于等于条件;另外,受限于解密秘钥唯一性要求,基于分支条件混淆的代码加密技术只能应用于单个等于条件的分支;这些限制极大阻碍了基于分支条件混淆的代码加密技术的应用.</p>
                </div>
                <div class="p1">
                    <p id="41">王志等人<citation id="245" type="reference"><link href="223" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>在Sharif<citation id="246" type="reference"><link href="219" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>分支条件混淆方法的基础上,提出了一种基于保留前缀加密的分支混淆技术,把分支条件混淆从等于判断的条件扩展到大小判断的条件.然而在非等条件下,分支条件为真的输入不具备唯一性要求,因此不能使用分支输入作为秘钥对条件代码进行加密.在分支条件取值为真的输入不唯一的条件下,为解决使用分支输入产生唯一性秘钥的要求,在多输入分支条件下,结合分支条件混淆,本文提出了一种基于拉格朗日插值法的秘钥生成技术,实现了解密秘钥和分支条件混淆的结合,隐藏了代码解密秘钥.</p>
                </div>
                <div class="p1">
                    <p id="42">本文的主要贡献有4个方面:</p>
                </div>
                <div class="p1">
                    <p id="43">1) 基于拉格朗日插值法,在分支条件取值为真的输入不唯一的条件下,提出了一种使用分支条件输入生成代码加解密秘钥的方法;</p>
                </div>
                <div class="p1">
                    <p id="44">2) 通过对多个等于条件取或形成的复合条件的分支输入进行处理,完成了多输入条件下的秘钥生成,实现条件代码加密,避免了代码复制和复合条件拆分带来的空间损耗;</p>
                </div>
                <div class="p1">
                    <p id="45">3) 完成了基于分支混淆的条件代码加密方法从等于条件分支到区间条件分支的扩展;</p>
                </div>
                <div class="p1">
                    <p id="46">4) 针对等于条件和区间条件通过逻辑运行形成的复杂条件,实现了分支混淆和复杂条件代码加密的结合,实现了复杂条件分支下的基于分支混淆的代码加密.</p>
                </div>
                <h3 id="47" name="47" class="anchor-tag"><b>1 基础知识</b></h3>
                <h4 class="anchor-tag" id="48" name="48"><b>1.1 前缀算法</b></h4>
                <div class="p1">
                    <p id="49">前缀算法是一种把一个整数区间转变为一个前缀集合的算法,并且保证区间中的每一个整数均在前缀集合能找到一个与之匹配的前缀,反之在集合中没有匹配到前缀的整数一定不属于该区间.并且前缀算法得到的前缀集合元素个数有2个特点,其中<i>n</i>表示整数的二进制位数:</p>
                </div>
                <div class="p1">
                    <p id="50">1) 区间前缀集合元素个数最大值为2<i>n</i>-2;</p>
                </div>
                <div class="p1">
                    <p id="51">2) 区间前缀集合元素个数平均值为((<i>n</i>-2)×2<sup>2</sup><sup><i>n</i></sup><sup>-1</sup>+(<i>n</i>+1)2<sup><i>n</i></sup>+1)/(2<sup>2</sup><sup><i>n</i></sup><sup>-1</sup>+2<sup><i>n</i></sup><sup>-1</sup>),在32 b或者64 b程序中,该值都接近为<i>n</i>-2.</p>
                </div>
                <div class="p1">
                    <p id="52">前缀算法伪代码如算法1所示:</p>
                </div>
                <div class="p1">
                    <p id="53"><b>算法1</b>. 一个整数区间到前缀集合的转换算法.</p>
                </div>
                <div class="p1">
                    <p id="54">输入:区间起始值的二进制表示<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>n</i></sub>;区间结束值的二进制表示<i>b</i><sub>1</sub><i>b</i><sub>2</sub>…<i>b</i><sub><i>n</i></sub>;</p>
                </div>
                <div class="p1">
                    <p id="55">输出:区间的前缀集合<i>Prefix</i>.</p>
                </div>
                <div class="area_img" id="201">
                                <img alt="" src="Detail/GetImg?filename=images/JFYZ201910013_20100.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="75" name="75"><b>1.2 保留前缀Hash加密</b></h4>
                <div class="p1">
                    <p id="76">保留前缀加密<citation id="247" type="reference"><link href="235" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>.假设<i>a</i>=<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>n</i></sub>,<i>b</i>=<i>b</i><sub>1</sub><i>b</i><sub>2</sub>…<i>b</i><sub><i>n</i></sub>为2个<i>n</i>位整数,如果<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>k</i></sub>=<i>b</i><sub>1</sub><i>b</i><sub>2</sub>…<i>b</i><sub><i>k</i></sub>,其中<i>k</i>&lt;<i>n</i>且<i>a</i><sub><i>k</i></sub><sub>+1</sub>≠<i>b</i><sub><i>k</i></sub><sub>+1</sub>,则称整数<i>a</i>和整数<i>b</i>是<i>k</i>位前缀匹配的.<i>F</i>是一个定义在{0,1}<sup><i>n</i></sup>到{0,1}<sup><i>n</i></sup>上的一对一的加密函数,对任意2个给定的整数<i>a</i>,<i>b</i>,如果<i>a</i>,<i>b</i>是<i>k</i>位前缀匹配时一定有<i>F</i>(<i>a</i>)和<i>F</i>(<i>b</i>)也是<i>k</i>位前缀匹配,则称<i>F</i>为保留前缀加密哈数.</p>
                </div>
                <div class="p1">
                    <p id="77">标准形式定理(canonical form theorem)<citation id="248" type="reference"><link href="235" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>.假设<i>f</i><sub><i>i</i></sub>是一个从{0,1}<sup><i>i</i></sup>到{0,1}上的函数,其中<i>i</i>=1,2,…,<i>n</i>-1,并且<i>f</i><sub>0</sub>是一个常量函数,<i>F</i>是一个{0,1}<sup><i>n</i></sup>上的函数,其定义对任意给定的整数<i>a</i>=<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>n</i></sub>,令:</p>
                </div>
                <div class="p1">
                    <p id="78"><i>F</i>(<i>a</i>)<image href="images/JFYZ201910013_168.jpg" type="" display="inline" placement="inline"><alt></alt></image><i>a</i>′<sub>1</sub><i>a</i>′<sub>2</sub>…<i>a</i>′<sub><i>n</i></sub>,</p>
                </div>
                <div class="p1">
                    <p id="79"><i>a</i>′<sub><i>i</i></sub>=<i>a</i><sub><i>i</i></sub>⊕<i>f</i><sub><i>i</i></sub><sub>-1</sub>(<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>i</i></sub><sub>-1</sub>),(1)</p>
                </div>
                <div class="p1">
                    <p id="80">其中,⊕表示异或运算,<i>i</i>=1,2,…,<i>n</i>,<i>f</i><sub>0</sub>为常数,可以得出结论:1)<i>F</i>是一个保留前缀加密函数;2)任意保留前缀加密函数必定有<i>F</i>的表示形式.定理的证明参见文献[6],此处省略.</p>
                </div>
                <div class="p1">
                    <p id="81">保留前缀Hash加密<citation id="250" type="reference"><link href="223" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>是一种把Hash函数引入到保留前缀加密计算的加密算法,表示为<i>Fh</i>(<i>a</i>)<image href="images/JFYZ201910013_169.jpg" type="" display="inline" placement="inline"><alt></alt></image><i>a</i>′<sub>1</sub><i>a</i>′<sub>2</sub>…<i>a</i>′<sub><i>n</i></sub>,<i>a</i>′<sub><i>i</i></sub>=<i>a</i><sub><i>i</i></sub><image id="202" type="formula" href="images/JFYZ201910013_20200.jpg" display="inline" placement="inline"><alt></alt></image><i>f</i><sub><i>i</i></sub><sub>-1</sub>(<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>i</i></sub><sub>-1</sub>),其中<i>f</i><sub><i>i</i></sub><sub>-1</sub>(<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>i</i></sub><sub>-1</sub>)=<i>T</i>(Hash(<i>a</i><sub>1</sub><i>a</i><sub>2</sub>…<i>a</i><sub><i>i</i></sub><sub>-1</sub>)),其中<i>T</i>为取位函数,即选择Hash结果的某一位.</p>
                </div>
                <h4 class="anchor-tag" id="82" name="82"><b>1.3 Sharif提出的条件代码加密方法介绍</b></h4>
                <div class="p1">
                    <p id="83">Sharif提出的基于分支条件混淆的条件代码加密如图1所示,主要是通过分支输入生成条件代码的加解密秘钥,从而保证程序中不需要存储秘钥,实现了解密秘钥隐藏和分支条件混淆的结合.逆向攻击者解密代码的难度等同于找到使得分支条件取值为真的输入的难度,而分支条件混淆的目的正是阻碍攻击者获取使得分支条件取值为真的输入.</p>
                </div>
                <div class="area_img" id="84">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201910013_084.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 条件代码加密示意图" src="Detail/GetImg?filename=images/JFYZ201910013_084.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 条件代码加密示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201910013_084.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 Example of conditional code encryption</p>

                </div>
                <div class="area_img" id="85">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201910013_085.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 重复条件代码和复合条件代码的复制处理" src="Detail/GetImg?filename=images/JFYZ201910013_085.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 重复条件代码和复合条件代码的复制处理  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201910013_085.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 The process of duplicate condition and compound condition</p>

                </div>
                <div class="area_img" id="86">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201910013_086.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 基于保留前缀Hash加密的分支条件混淆示意图" src="Detail/GetImg?filename=images/JFYZ201910013_086.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 基于保留前缀Hash加密的分支条件混淆示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201910013_086.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 The example of branch obfuscation based on prefix-preserving algorithm</p>

                </div>
                <div class="p1">
                    <p id="87">另外,本文把形如<i>a</i>≤<i>x</i>≤<i>b</i>的条件称为区间条件,把单个的等于比较条件、单个的区间条件成为基本条件.多个基本条件通过逻辑运算组合成的条件成为复合条件.</p>
                </div>
                <div class="p1">
                    <p id="88">在Sharif提出的基于分支条件混淆的代码加密方法中,对重复条件和多个等于条件取或的复合条件,需要使用条件代码复制的方法,把复合条件拆分为多个简单条件,然后再对各个简单条件的代码进行加解密,增加了混淆的损耗,同时降低了混淆的隐蔽性.如图3所示:</p>
                </div>
                <h4 class="anchor-tag" id="89" name="89"><b>1.4 基于保留前缀加密的分支混淆方法介绍</b></h4>
                <div class="p1">
                    <p id="90">Sharif等人<citation id="251" type="reference"><link href="219" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>提出的分支条件混淆仅针对等于条件,通过使用Hash值比较代替明文比较,使得攻击者难以从Hash值比较中恢复出明文比较关系,达到分支条件混淆的目的.如对分支条件if(<i>x</i>=<i>a</i>),其中<i>x</i>是任意类型的值,实质就是一片内存的内容,通过分支条件混淆后变为if(Hash(<i>x</i>)=Hash(<i>a</i>)).</p>
                </div>
                <div class="p1">
                    <p id="91">王志等人<citation id="252" type="reference"><link href="223" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>提出了基于保留前缀加密和Hash函数的路径分支混淆技术,使用加密前缀匹配替代分支条件,实现分支条件混淆.例如分支条件if(9≤<i>x</i>≤15),首先把条件转换为整数区间[9,15];然后使用前缀算法获取区间的前缀集合<i>S</i>={1001,101<sup>*</sup>,11<sup>*</sup>};接下来使用保留前缀Hash加密算法对<i>S</i>进行加密得到<i>ES</i>;最后使用加密前缀匹配函数替换分支条件,即if(9≤<i>x</i>≤15)变为if(<i>isMatch</i>(<i>x</i>,<i>ES</i>)),其中<i>isMatch</i>(<i>x</i>,<i>ES</i>)如算法2所示.</p>
                </div>
                <div class="p1">
                    <p id="92"><b>算法2</b>. isMatch算法.</p>
                </div>
                <div class="p1">
                    <p id="93">输入:整数<i>x</i>、加密前缀集合<i>ES</i>;</p>
                </div>
                <div class="p1">
                    <p id="94">输出:true或者false,true表示<i>x</i>满足分支条件,false表示<i>x</i>不满足分支条件.</p>
                </div>
                <div class="p1">
                    <p id="95">bool <i>isMatch</i>(<i>x</i>,<i>HS</i>)</p>
                </div>
                <div class="p1">
                    <p id="96">{int <i>encPrefixofInput</i>=<i>encInput</i>(<i>x</i>);</p>
                </div>
                <div class="p1">
                    <p id="97">int <i>tmpFlag</i>[32]={0};<i>tmpFlag</i>[0]=1≪31;</p>
                </div>
                <div class="p1">
                    <p id="98">for(int <i>i</i>=1;<i>i</i>&lt;32;<i>i</i>++){<i>tmpFlag</i>[<i>i</i>]=<i>tmpFlag</i>[<i>i</i>-1]|(1≪(31-<i>i</i>));}</p>
                </div>
                <div class="p1">
                    <p id="99">for(int <i>j</i>=0;<i>j</i>&lt;<i>NumofES</i>;<i>j</i>++)</p>
                </div>
                <div class="p1">
                    <p id="100">{<i>tmpLen</i>=<i>ES</i>[<i>j</i>].<i>prefixLen</i>;</p>
                </div>
                <div class="p1">
                    <p id="101"><i>tmpPrefix</i>=<i>encPrefixofinput</i>&amp;<i>tmpFlag</i>[<i>tmpLen</i>];</p>
                </div>
                <div class="p1">
                    <p id="102">if(<i>tmpPrefix</i>=<i>ES</i>[<i>j</i>].<i>prefix</i>){return true;}</p>
                </div>
                <div class="p1">
                    <p id="103">}</p>
                </div>
                <div class="p1">
                    <p id="104">return fasle;</p>
                </div>
                <div class="p1">
                    <p id="105">}</p>
                </div>
                <h3 id="106" name="106" class="anchor-tag"><b>2 多输入条件下的秘钥生成</b></h3>
                <div class="p1">
                    <p id="107">基于分支条件混淆的条件代码加密,由于使用分支条件的输入作为加解密秘钥,导致该加密方法仅能用于单个等于条件的分支.对于具有多个输入值使得分支条件取值为真的分支,由于输入不具有唯一性,导致秘钥不能直接使用分支输入.因此需要对输入进行处理,使得多个输入<i>x</i><sub>1</sub>,<i>x</i><sub>2</sub>,<i>x</i><sub>3</sub>,…输入经过处理后得到相同的输出<i>y</i>,使用<i>y</i>作为解密秘钥,从而保证秘钥的唯一性.</p>
                </div>
                <h4 class="anchor-tag" id="108" name="108"><b>2.1 拉格朗日插值法</b></h4>
                <div class="p1">
                    <p id="109">拉格朗日插值法是18世纪法国数学家约瑟夫·拉格朗日发明的一种多项式插值方法.用于寻找二维平面上经过<i>n</i>+1个点的<i>n</i>次多项式,使得多项式在给定的<i>n</i>+1个观测点能取到给定的值.经过<i>n</i>+1个点的次数不超过<i>n</i>的多项式只有一个,即拉格朗日多项式.本文使用拉格朗日插值保证多输入条件下的输出唯一性.</p>
                </div>
                <div class="p1">
                    <p id="110">对给定的<i>n</i>+1个点(<i>x</i><sub>0</sub>,<i>y</i><sub>0</sub>),(<i>x</i><sub>1</sub>,<i>y</i><sub>1</sub>),(<i>x</i><sub>2</sub>,<i>y</i><sub>2</sub>),…,(<i>x</i><sub><i>n</i></sub>,<i>y</i><sub><i>n</i></sub>),首先根据每个点得出<i>n</i>+1个拉格朗日基本多项式,其中第<i>i</i>个点(<i>x</i><sub><i>i</i></sub>,<i>y</i><sub><i>i</i></sub>) 的拉格朗日基本多项式为</p>
                </div>
                <div class="p1">
                    <p id="111"><mathml id="170"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>j</mi><mo>≠</mo><mi>i</mi></mrow><mi>n</mi></munderover><mrow><mfrac><mrow><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mi>j</mi></msub></mrow><mrow><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></mfrac></mrow></mstyle><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo><mo stretchy="false">(</mo><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>⋯</mo><mo stretchy="false">(</mo><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>⋯</mo><mo stretchy="false">(</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow></math></mathml>,</p>
                </div>
                <div class="p1">
                    <p id="112">显然该多项式在<i>x</i><sub><i>i</i></sub>处的取值为1、在其他点<i>x</i><sub><i>j</i></sub>(其中<i>j</i>≠<i>i</i>)处的取值为零;令拉格朗日插值多项式<mathml id="171"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>y</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>L</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math></mathml>,显然<i>L</i>(<i>x</i>)经过<i>n</i>+1个给定的点.在本文中,由于需要对<i>n</i>个输入<i>x</i><sub>1</sub>,<i>x</i><sub>2</sub>,…,<i>x</i><sub><i>n</i></sub>计算得到相同的输出<i>y</i>,因此取<i>y</i><sub><i>i</i></sub>=<i>y</i>,其中<i>i</i>=1,2,…,<i>n</i>.</p>
                </div>
                <h4 class="anchor-tag" id="113" name="113"><b>2.2 输入处理多项式生成</b></h4>
                <div class="p1">
                    <p id="114">一方面,拉格朗日多项式的系数不是整数,即存在除法,因此在使用计算机计算的过程中可能会出现实际值与计算值有出入的问题;另外一方面,拉格朗日多项式具备鲜明的特征,给攻击者从拉格朗日多项式中获取分支输入提供了便利;最后,如果多项式的次数过低,则在某个分支输入已知的情况下会导致其他分支输入泄露,从而会导致分支条件混淆被还原.因此需要对拉格朗日多项式进行变换,以实现多项式系数的整数化、消除拉格朗日多项式的特征和提高多项式次数.</p>
                </div>
                <div class="p1">
                    <p id="115">首先,通过对插值多项式<i>L</i>(<i>x</i>)进行去分母和模运算变化,使得多项式的系数整数化,同时消除拉格朗日多项式的特征.即取</p>
                </div>
                <div class="p1">
                    <p id="116" class="code-formula">
                        <mathml id="116"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><msup><mi>L</mi><mo>′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo>(</mo><mrow><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>C</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub></mrow><mo>)</mo></mrow><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo></mtd></mtr><mtr><mtd><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>y</mi></mstyle><mrow><mo>(</mo><mrow><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>j</mi><mo>≠</mo><mi>i</mi></mrow><mi>n</mi></munderover><mi>C</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub></mrow><mo>)</mo></mrow><mi>f</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>x</mi><msup><mrow></mrow><mi>i</mi></msup><mspace width="0.25em" /><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>Ι</mi><mi>Μ</mi><mi>A</mi><mi>X</mi><mo>,</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="117">其中,<mathml id="172"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><msub><mrow></mrow><mi>j</mi></msub><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo>,</mo><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo></mstyle><mi>x</mi><msub><mrow></mrow><mi>j</mi></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></math></mathml>,乘法和加法均为模<i>IMAX</i>运算,<i>IMAX</i>取值为<i>n</i>位整数的最大值加1,比如整数位长为32时,<i>IMAX</i>取值为2<sup>32</sup>.<i>IMAX</i>的取值是为了方便编程实现,因为在计算机的整数运算过程中,由于整数表示范围有限,导致加减乘除运算在不对溢出位进行处理时都可以看成是模<i>IMAX</i>的运算.通过模运算去分母后,多项式在插值点处的取值发生了改变,但是在每个插值点仍然取到同样的唯一值,仅仅是该值从<i>y</i>变为</p>
                </div>
                <div class="p1">
                    <p id="118" class="code-formula">
                        <mathml id="118"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>×</mo><mo stretchy="false">(</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>C</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mspace width="0.25em" /><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>Ι</mi><mi>Μ</mi><mi>A</mi><mi>X</mi><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="119">其次,如果<i>L</i>(<i>x</i>)的次数较低时,通过添加一个在插值点处取值为零的高次多项式的方式增加多项式<i>L</i>(<i>x</i>)的次数.令插值点为<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>,…,<i>x</i><sub><i>k</i></sub>,取<i>m</i>个随机数<i>x</i><sub><i>k</i></sub><sub>+1</sub>,…,<i>x</i><sub><i>k</i></sub><sub>+</sub><sub><i>m</i></sub>,令<mathml id="173"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>k</mi><mo>+</mo><mi>m</mi></mrow></munderover><mo stretchy="false">(</mo></mstyle><mi>x</mi><mo>-</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></math></mathml>,取<mathml id="174"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>L</mi><mo>′</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>k</mi><mo>+</mo><mi>m</mi></mrow></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>x</mi><msup><mrow></mrow><mi>i</mi></msup><mspace width="0.25em" /><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>Ι</mi><mi>Μ</mi><mi>A</mi><mi>X</mi></mrow></math></mathml>,则多项式次数变为<i>k</i>+<i>m</i>,如果不需要改变多项式次数,则取<i>R</i>(<i>x</i>)=0.由于<i>R</i>(<i>x</i>)在插值点处取值为零,因此变换后的输入预处理函数与次数变换前的多项式在插值点处保持相同的取值.</p>
                </div>
                <div class="p1">
                    <p id="120">经过变换后得到的多项式成为输入处理多项式函数,记为<mathml id="175"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>i</mi><mi>n</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>Ρ</mi><mi>r</mi><mi>o</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>x</mi><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>.该函数在输入<i>x</i><sub><i>i</i></sub>处取值均为<mathml id="176"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>y</mi><mo>′</mo></msup><mo>=</mo><mi>y</mi><mo>×</mo><mo stretchy="false">(</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><mi>C</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo stretchy="false">)</mo><mspace width="0.25em" /><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>Ι</mi><mi>Μ</mi><mi>A</mi><mi>X</mi></mrow></math></mathml>,使用<i>y</i>′生成秘钥,则保证了在多点输入条件下使用输入产生的秘钥具有唯一性.并且inputProcess函数是一个普通的多项式函数,不会泄露{<i>x</i><sub>0</sub>,<i>x</i><sub>1</sub>,…,<i>x</i><sub><i>n</i></sub>}和<i>y</i>′的值;即使在某一个或者某几个<i>x</i><sub><i>i</i></sub>暴露的情况下,虽然<i>y</i>′已知,多项式函数inputProcess可以理解为一元高次方程<mathml id="177"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mi>a</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>x</mi><msup><mrow></mrow><mi>i</mi></msup><mo>-</mo><msup><mi>y</mi><mo>′</mo></msup><mo>=</mo><mn>0</mn></mrow></math></mathml>,但是高次方程的求解困难保证了其余解不会泄露,即其余的输入不会因输入处理多项式已知而泄露.</p>
                </div>
                <h3 id="121" name="121" class="anchor-tag"><b>3 基于分支条件混淆的条件代码加密</b></h3>
                <div class="p1">
                    <p id="122">使用拉格朗日多项式进行多输入分支的条件代码加密密钥生成,解决了大小比较分支的输入不唯一问题,使得条件代码加密和分支混淆紧密结合在一起,对条件代码进行更好的混淆保护.同时通过密钥构造解决Sharif条件代码加密方法中的代码复制问题,提升混淆的效率和隐蔽性.</p>
                </div>
                <h4 class="anchor-tag" id="123" name="123"><b>3.1 Sharif条件代码加密方法的改进</b></h4>
                <div class="p1">
                    <p id="124">重复条件和复合条件需要使用代码复制变转换为多个简单条件,根本原因在于能够执行到条件代码的分支输入不唯一,因此不能直接使用分支输入作为秘钥.通过对输入进行处理,使得多个输入生成相同的输出,则不需要使用代码复制的手段,减少了加密导致的空间占用.在Sharif分支条件混淆的基础上,对多输入进行处理的步骤如图4所示.</p>
                </div>
                <div class="p1">
                    <p id="125">1) 判断等于条件的输入<i>x</i>,<i>y</i>是否为整数,若不是整数,则对输入进行加盐的Hash计算,然后取Hash值的前4个字节作为拉格朗日插值法的插值点的横坐标;若<i>x</i>,<i>y</i>为整数,则直接取<i>x</i>,<i>y</i>作为插值点横坐标;然后取一个随机整数作为多项式在插值点<i>x</i>和<i>y</i>处的取值,生成拉格朗日多项式.</p>
                </div>
                <div class="p1">
                    <p id="126">2) 使用拉格朗日多项式变换,得到输入预处理函数inputProcess.</p>
                </div>
                <div class="p1">
                    <p id="127">3) 在使用Hash值比较替代整数比较的过程中,依次判断输入<i>x</i>,<i>y</i>是否使得分支条件取值为真,使用第一个使分支条件取值为真的输入作为inputProcess函数的参数计算该分支的输出值<i>keysource</i>,使用<i>keysource</i>生成解密秘钥,最后进行条件代码的解密和再次加密.</p>
                </div>
                <div class="area_img" id="128">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201910013_128.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 复合条件和重复条件处理示意图" src="Detail/GetImg?filename=images/JFYZ201910013_128.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 复合条件和重复条件处理示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201910013_128.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 The process of compound condition and duplicate condition</p>

                </div>
                <h4 class="anchor-tag" id="129" name="129"><b>3.2 大小比较分支的条件代码加密</b></h4>
                <div class="p1">
                    <p id="130">对分支条件if(<i>a</i>≤<i>x</i>≤<i>b</i>),应用基于保留前缀加密Hash算法的分支条件混淆技术混淆后,分支条件为if(<i>isMatch</i>(<i>x</i>,<i>ES</i>)),其中<i>ES</i>={<i>es</i><sub>1</sub>,<i>es</i><sub>2</sub>,…,<i>es</i><sub><i>m</i></sub>}为区间[<i>a</i>,<i>b</i>]对应前缀集合应用保留前缀Hash加密算法<i>Fh</i>计算后得到加密前缀数据.对区间条件在基于保留前缀Hash加密的分支混淆后,条件代码加密过程如图5所示,加密步骤如下:</p>
                </div>
                <div class="area_img" id="131">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201910013_131.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 区间条件分支处理示意图" src="Detail/GetImg?filename=images/JFYZ201910013_131.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 区间条件分支处理示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201910013_131.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Example of interval condition process</p>

                </div>
                <div class="p1">
                    <p id="132">1) 对<i>n</i>位整数区间[<i>a</i>,<i>b</i>],计算其前缀集合<i>S</i>={<i>s</i><sub>1</sub>,<i>s</i><sub>2</sub>,…,<i>s</i><sub><i>k</i></sub>},对<i>j</i>位前缀元素<i>s</i><sub><i>i</i></sub>,取随机数<i>r</i><sub><i>i</i></sub>的尾部<i>n</i>-<i>j</i>比特与<i>s</i><sub><i>i</i></sub>一起组合成<i>n</i>位整数<i>t</i><sub><i>i</i></sub>,使用<i>t</i><sub>1</sub>,<i>t</i><sub>2</sub>,…,<i>t</i><sub><i>k</i></sub>作为拉格朗日插值点的横坐标,取随机数<i>tmp</i>作为所有插值点的纵坐标,计算输入预处理函数inputProcess.保存随机数数组<i>R</i>={<i>r</i><sub>1</sub>,<i>r</i><sub>2</sub>,…,<i>r</i><sub><i>k</i></sub>}.</p>
                </div>
                <div class="p1">
                    <p id="133">2) 在算法2中,若<i>x</i>使得isMatch返回true,则在isMatch中记录与<i>x</i>相匹配的加密前缀<i>es</i><sub><i>i</i></sub>的下标<i>i</i>,获取<i>es</i><sub><i>i</i></sub>对应前缀的位长,假设为<i>m</i>;然后取<i>x</i>的前<i>m</i>位和<i>r</i><sub><i>i</i></sub>的后<i>n</i>-<i>m</i>位组合成inputProcess函数的输入<i>inputNum</i>,计算得到分支的输出<i>keysource</i>,然后使用<i>keysource</i>生成解密秘钥<i>key</i>,使用<i>key</i>进行条件代码的解密和再次加密.</p>
                </div>
                <h4 class="anchor-tag" id="134" name="134"><b>3.3 复杂条件分支的条件代码加密</b></h4>
                <div class="p1">
                    <p id="135">由等于条件和区间条件通过逻辑运算形成的复杂条件中,复杂条件的混淆是通过对构成复杂条件的每个基本条件进行混淆而完成;秘钥生成则是通过对每个基本条件进行单独的输入处理,但是需要保证每个基本条件在其输入使得条件取值为真时的输出都是相等的.为统一表示,令等于条件if(<i>x</i>=<i>a</i>)混淆后为if(<i>isMatch</i>(<i>x</i>,<i>ES</i>)),但是在等于条件下,isMatch算法变为{return <i>memcmp</i>(Hash(<i>x</i>),<i>ES</i>,<i>hashLen</i>);},其中<i>ES</i>为<i>a</i>的Hash值;令等于条件if(<i>x</i>=<i>a</i>)的输入处理函数为<i>inputProcess</i>(<i>x</i>),等于条件下的inputProcess函数伪代码如下:</p>
                </div>
                <div class="p1">
                    <p id="136"><i>inputProcess</i>(<i>x</i>)</p>
                </div>
                <div class="p1">
                    <p id="137">{</p>
                </div>
                <div class="p1">
                    <p id="138">if (<i>x</i> is interger){return <i>x</i>;}</p>
                </div>
                <div class="p1">
                    <p id="139">else {int <i>tmp</i>=Hash(<i>x</i>);</p>
                </div>
                <div class="p1">
                    <p id="140">return <i>firstFourBytes</i>(<i>tmp</i>);}</p>
                </div>
                <div class="p1">
                    <p id="141">}</p>
                </div>
                <div class="p1">
                    <p id="142">下面介绍复杂分支条件下的代码加密过程,加密示意图如图6所示.</p>
                </div>
                <div class="p1">
                    <p id="143">1) 根据与运算和或运算的结合律:(<i>c</i><sub>11</sub>)&amp;&amp;(<i>c</i><sub>12</sub>‖<i>c</i><sub>13</sub>)=(<i>c</i><sub>11</sub>&amp;&amp;<i>c</i><sub>12</sub>)‖(<i>c</i><sub>11</sub>&amp;&amp;<i>c</i><sub>13</sub>),把复杂条件转换为基本条件与运算结合成的复合条件的或运算式,即形如(<i>c</i><sub>11</sub>&amp;&amp;<i>c</i><sub>12</sub>)‖(<i>c</i><sub>21</sub>&amp;&amp;<i>c</i><sub>22</sub>)‖(<i>c</i><sub>31</sub>&amp;&amp;<i>c</i><sub>32</sub>),其中<i>c</i><sub><i>ij</i></sub>表示基本条件;记无或运算相隔的与运算条件为一组,即<i>group</i>[0]={<i>c</i><sub>11</sub>,<i>c</i><sub>12</sub>},<i>group</i>[1]={<i>c</i><sub>21</sub>,<i>c</i><sub>22</sub>},<i>group</i><citation id="255" type="reference">[<a class="sup">2</a>]</citation>={<i>c</i><sub>31</sub>,<i>c</i><sub>32</sub>}共3组.</p>
                </div>
                <div class="p1">
                    <p id="144">2) 对分支条件if((<i>c</i><sub>11</sub>&amp;&amp;<i>c</i><sub>12</sub>)‖(<i>c</i><sub>21</sub>&amp;&amp;<i>c</i><sub>22</sub>)‖(<i>c</i><sub>31</sub>&amp;&amp;<i>c</i><sub>32</sub>))的每个基本条件进行混淆,混淆后的分支条件为if(<i>isMatch</i>(<i>x</i><sub>11</sub>,<i>ES</i><sub>11</sub>) &amp;&amp; <i>isMatch</i>(<i>x</i><sub>12</sub>,<i>ES</i><sub>12</sub>))‖(<i>isMatch</i>(<i>x</i><sub>21</sub>,<i>ES</i><sub>21</sub>) &amp;&amp; <i>isMatch</i>(<i>x</i><sub>22</sub>,<i>ES</i><sub>22</sub>))‖(<i>isMatch</i>(<i>x</i><sub>31</sub>,<i>ES</i><sub>31</sub>) &amp;&amp; <i>isMatch</i>(<i>x</i><sub>32</sub>,<i>ES</i><sub>32</sub>))).</p>
                </div>
                <div class="p1">
                    <p id="145">3) 对每个基本条件<i>c</i><sub><i>ij</i></sub>分别计算输入其输入处理函数,并记为<i>inputPrecess</i>[<i>i</i>][<i>j</i>];设函数<i>inputPrecess</i>[<i>i</i>][<i>j</i>]的分支输出为为<i>Y</i><sub><i>ij</i></sub>,<i>randA</i>为一随机整数数,并令<i>R</i><sub><i>ij</i></sub>=<i>randA</i>-<i>Y</i><sub><i>ij</i></sub>,修改<i>inputPrecess</i>[<i>i</i>][<i>j</i>]=<i>inputPrecess</i>[<i>i</i>][<i>j</i>]+<i>R</i><sub><i>ij</i></sub>,则修改后所有基本条件的预处理函数<i>inputProcess</i>[<i>i</i>][<i>j</i>],在其输入为使得条件<i>C</i><sub><i>ij</i></sub>取值为真的分支输入值时,预处理函数的取值均为<i>randA</i>.</p>
                </div>
                <div class="p1">
                    <p id="146">4) 在混淆后复杂条件执行时,按照顺序计算每组条件与运算的取值,找到第1组取值为true的条件.假设第<i>i</i>组条件与运算的取值为true,则随机选择第<i>i</i>组条件中的任意一个条件代表该复杂分支条件进行分支输出计算,假设选中条件为<i>C</i><sub><i>ij</i></sub>,则选取<i>inputProcess</i>[<i>i</i>][<i>j</i>]为复杂分支条件的输出计算函数,选取<i>x</i>[<i>i</i>][<i>j</i>]为<i>inputProcess</i>[<i>i</i>][<i>j</i>]的计算参数,计算结果则为<i>randA</i>,使用<i>randA</i>计算秘钥,然后对条件代码进行解密和2次加密.</p>
                </div>
                <div class="area_img" id="147">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201910013_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 复杂条件分支处理示意图" src="Detail/GetImg?filename=images/JFYZ201910013_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 复杂条件分支处理示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201910013_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 Example of complicated condition process</p>

                </div>
                <div class="area_img" id="148">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201910013_148.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 多线程代码加解密示意图" src="Detail/GetImg?filename=images/JFYZ201910013_148.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 多线程代码加解密示意图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201910013_148.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 The encipher and decipher example of multi-thread code</p>

                </div>
                <h4 class="anchor-tag" id="149" name="149"><b>3.4 多线程处理</b></h4>
                <div class="p1">
                    <p id="150">如果需要加密的代码是一段多个线程共用的代码,则在解密和2次加密的过程中需要进行加解密的操作同步,否则会导致加解密错乱,程序执行出现不可控错误.本文采用临界区对加加解密操作进行同步,解密操作在进入临界区后首先判断加密代码是否在使用中.如果否,则解密;如果是,则不需要解密、直接返回,退出临界区.</p>
                </div>
                <div class="p1">
                    <p id="151">同样,在2次加密的过程中,进入临界区后首先判断需要加密的代码是否在使用中.如果否,则对代码进行2次加密;如果是,则加密函数直接返回,退出临界区.处理过程如图7所示.</p>
                </div>
                <h3 id="152" name="152" class="anchor-tag"><b>4 分析与评估</b></h3>
                <h4 class="anchor-tag" id="153" name="153"><b>4.1 条件代码加密的时间和空间消耗</b></h4>
                <div class="p1">
                    <p id="154">由于本文提出的代码加密是基于分支条件混淆,因此时间和空间的消耗都是基于分支条件已经被混淆的程序来计算的.</p>
                </div>
                <div class="p1">
                    <p id="155">首先是加密算法消耗的存储空间,本文采用AES-128加密算法对条件代码进行加密,AES算法源代码通过编译得到的obj文件占用空间为58 807 B;其次inputProcess函数通过把系数和最高次数记为参数后,该函数的算法占用416 B.上述算法是所有的分支条件代码加密所共用的代码,因此随着被选择加密的分支条件越多,每个分支占用的共用空间就越少.另外由于每个分支条件需要存储自己的多项式系数,需要增加加密和解密的外包函数,因此每个分支条件单独占用的空间平均是30×4+83+83=283 B.即对单个区间条件构成的分支,对<i>m</i>个分支条件的代码进行加密,平均每个分支条件的代码加密需要消耗283+(416+58 807)/<i>m</i>字节的空间.如果是<i>m</i>个复杂条件,且每个复杂条件由<i>k</i>个基本条件构成,则每个复杂分支平均消耗120×<i>k</i>+(416+58 807)/<i>m</i>字节的空间用于代码加密.</p>
                </div>
                <div class="p1">
                    <p id="156">其次是时间消耗,时间消耗主要在于AES128一次加密和解密的时间,即平均每个分支多消耗0.003 3 ms(由10 000次AES加密和解密消耗32.8 ms时间计算得到单次加解密时间).</p>
                </div>
                <div class="area_img" id="157">
                    <p class="img_tit"><b>表1 加密消耗的时间和空间数据</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 1 Consumption Data of Time and Space</b></p>
                    <p class="img_note"></p>
                    <table id="157" border="1"><tr><td><br />Properties<br />Types</td><td>Branch Shaped with<br />Three Equal Conditions</td><td>Branch Shaped with Single<br />Size Comparison Condition</td><td>Branch Shaped with <br />Six Basic Conditions</td></tr><tr><td><br />Number of Branches</td><td><i>m</i></td><td><i>m</i></td><td><i>m</i></td></tr><tr><td><br />Per-branch Average<br />Space Consumption/B</td><td>59 223/<i>m</i></td><td>59 223/<i>m</i>+283</td><td>59 223/<i>m</i>+120×6</td></tr><tr><td><br />Per-branch Average<br />Time Consumption/ms</td><td>0.003 3</td><td>0.003 3</td><td>0.003 3</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="158" name="158"><b>4.2 与其他加密方法的比较</b></h4>
                <div class="p1">
                    <p id="159">Sharif第1次提出了基于分支条件混淆的代码解密方法,通过分支条件混淆实现了秘钥隐藏;通过逆向分析获取加解密秘钥的的难度,等同于找到使得被混淆分支条件取值为真的程序输入的难度.即相比其他的加密方法,基于分支条件混淆的代码加密方法能更好的对抗解密秘钥获取攻击.</p>
                </div>
                <div class="p1">
                    <p id="160">在基于分支条件混淆的代码加密研究方面,除了Sharif在基于等于条件混淆的代码加密研究外,还没有相关的研究.与Sharif的加密方法相比,本文提出的方法在2个方面具有优势:</p>
                </div>
                <div class="p1">
                    <p id="161">1) 把Sharif的方法从等于条件扩展到了区间条件和复杂条件,具有更好的通用性;</p>
                </div>
                <div class="p1">
                    <p id="162">2) 对多个等于条件取或的分支,本文提出的方法不需要代码复制,从而节省了代码占用的空间.</p>
                </div>
                <div class="p1">
                    <p id="163">综上所述,本文提出的代码加密方法在时间和空间消耗上是可接受的;由于解密秘钥通过分支混淆隐藏,使得加密后代码能较好对抗逆向分析,因此该加密方法能够实际使用,且具有比较好的代码保护功能.</p>
                </div>
                <div class="area_img" id="164">
                    <p class="img_tit"><b>表2 加密方法优势对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 2 Comparison of Different Methods</b></p>
                    <p class="img_note"></p>
                    <table id="164" border="1"><tr><td><br />Method of Encryption</td><td>Time Consumption</td><td>Space Consumption</td><td>Key Concealed</td><td>Application Range</td></tr><tr><td><br />Sharif Method</td><td>Time of Single Encryption <br />and Decryption</td><td>Cipher Algorithm</td><td>Concealed</td><td>Conditional Code Shaped with <br />Equal Condition</td></tr><tr><td><br />Our Method</td><td>Time of Single Encryption <br />and Decryption</td><td>Cipher Algorithm <br />and Polynomial</td><td>Concealed</td><td>Conditional Code Shaped with Equal <br />Condition and Size Comparison Condition</td></tr><tr><td><br />Methods That Are Not Based <br />on Branch Obfuscation</td><td>Time of Single Encryption <br />and Decryption</td><td>Cipher Algorithm</td><td>Not Concealed</td><td>Almost All Code</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h3 id="166" name="166" class="anchor-tag"><b>5 结  论</b></h3>
                <div class="p1">
                    <p id="167">基于分支条件混淆的条件代码加密,通过满足分支条件的输入产生秘钥,同时利用分支混淆隐藏分支条件,从而隔离秘钥和程序,极大地提高了解密难度.由于秘钥生成和分支条件紧密联系在一起,只有在加密的条件代码所在分支因正确的输入而得到执行时,通过分支输入可以计算出秘钥,实现解密,否则就会导致解密错误,产生不可预测的错误导致程序运行终止.虽然基于分支条件混淆的条件代码解密具有较好的抗程序分析效果,但是当前研究仅能在等于条件分支上实现该类加密方式,极大地限制了该方法的使用.本文通过构建输入预处理函数,对具有多个正确输入的分支进行处理,完成了多输入分支下利用分支输入产生具有唯一性秘钥的方法.利用该方法,对多个等于条件取或的分支和重复条件代码分支的条件代码加密进行了优化,减少了加密对空间的消耗;区间条件分支使用基于保留前缀加密和Hash函数的分支混淆方法进行分支条件混淆,本文使用整数区间对应的前缀集合生成输入预处理函数,实现了区间条件分支下基于分支输入产生唯一性秘钥的方法,从而对区间条件分支的条件代码进行加密.最后对等于和区间条件复合而成的复杂条件分支进行处理,对该分支同样实现了基于分支输入产生唯一性秘钥的方法,进而对条件代码进行加密.通过以上处理完成了基于分支条件混淆的条件代码加密从等于条件分支到区间条件分支和复杂条件分支的扩展,提高了代码保护的范围,增强了代码安全性.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="203">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Covert computation:Hiding code in code for obfuscation purposes">

                                <b>[1]</b>Schrittwieser S,Katzenbeisser S,Kieseberg P,et al.Covert computation:Hiding code in code for obfuscation purposes[C] //Proc of the 8th ACM SIGSAC Symp on Information,Computer and Communications Security.New York:ACM,2013:529- 534
                            </a>
                        </p>
                        <p id="205">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Potent and stealthy control flow obfuscation by stack based self-modifying code">

                                <b>[2]</b>Balachandran V,Emmanuel S.Potent and stealthy control flow obfuscation by stack based self-modifying code[J].IEEE Transactions on Information Forensics and Security,2013,8(4):669- 681
                            </a>
                        </p>
                        <p id="207">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Towards tamper resistant code encryption:practice and experience">

                                <b>[3]</b>Cappaert J,Preneel B,Anckaert B,et al.Towards tamper resistant code encryption:Practice and experience[C] //Proc of the 4th Int Conf on Information Security Practice and Experience.Berlin:Springer,2008:86- 100
                            </a>
                        </p>
                        <p id="209">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Mimimorphism:A new approach to binary code obfuscation">

                                <b>[4]</b>Wu Zhenyu,Steven Gianvecchio,Xie Mengjun,et al.Mimimorphism:A new approach to binary code obfuscation[C] //Proc of the 17th ACM Conf on Computer and Communications Security (CCS'12).New York:ACM,2012:536- 546
                            </a>
                        </p>
                        <p id="211">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Cryptexec:Next-generation runtime binary encryption using on-demand function extraction">

                                <b>[5]</b>Vrba Z.Cryptexec:Next-generation runtime binary encryption using on-demand function extraction[EB/OL].[2019-06-11].http://www.phrack.org/issues/63/13.html#article
                            </a>
                        </p>
                        <p id="213">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Program obfuscation by strong cryptography">

                                <b>[6]</b>Vrba Ž,Halvorsen P,Griwodz C.Program obfuscation by strong cryptography[C] //Proc of 2010 Int Conf on Availability,Reliability and Security.Piscataway,NJ:IEEE,2010:242- 247
                            </a>
                        </p>
                        <p id="215">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Self-encrypting code to protect against analysis and tampering[C/OL]">

                                <b>[7]</b>Cappaert J,Kisserli N,Schellekens D,et al.Self-encrypting code to protect against analysis and tampering[C/OL] //Proc of the 1st Benelux Workshop on Information and Sytem Security (WISSec 2006).2006 [2019-06-10].https://www.esat.kuleuven.be/cosic/publications/article-811.pdf
                            </a>
                        </p>
                        <p id="217">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Function level control flow obfuscation for software security">

                                <b>[8]</b>Balachandran V,Keong N W,Emmanuel S.Function level control flow obfuscation for software security[C] //Proc of the 8th Int Conf on Complex,Intelligent and Software Intensive Systems.Piscataway,NJ:IEEE,2014:133- 140
                            </a>
                        </p>
                        <p id="219">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Impeding malware analysis using conditional codeobfuscation">

                                <b>[9]</b>Sharif M,Lanzi A,Giffin J,et al.Impeding malware analysis using conditional code obfuscation[C] //Proc of the Network and Distributed System Security Symp.Rosten,VA:Internet Society,2008:321- 333
                            </a>
                        </p>
                        <p id="221">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201111023&amp;v=MDM4MjllUnNGeXpoVTd6QUx5dlNkTEc0SDlETnJvOUhaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVo=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b>Jia Chunfu,Wang Zhi,Liu Xin,et al.Branch obfuscation:An efficient binary code obfuscation to impede symbolic execution[J].Journal of Computer Research and Development,2011,48(11):2111- 2119 (in Chinese)(贾春福,王志,刘昕,等.路径模糊:一种有效抵抗符号执行的二进制混淆技术[J].计算机研究与发展,2011,48(11):2111- 2119)
                            </a>
                        </p>
                        <p id="223">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU201505006&amp;v=MDUwNzVxcUJ0R0ZyQ1VSTE9lWmVSc0Z5emhVN3pBSVRmVGU3RzRIOVRNcW85RllvUUtESDg0dlI0VDZqNTRPM3o=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b>Wang Zhi,Jia Chunfu,Liu Weijie,et al.Branch obfuscation to combat symbolic execution[J].Acta Electronica Sinica,2015,43(5):870- 878 (in Chinese)(王志,贾春福,刘伟杰,等.一种抵抗符号执行的路径分支混淆技术[J].电子学报,2015,43(5):870- 878)
                            </a>
                        </p>
                        <p id="225">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Branch obfuscation using binary code side effects">

                                <b>[12]</b>Lin Hong,Zhang Xiaohua,Ma Yong,et al.Branch obfuscation using binary code side effects[C] //Proc of the 1st Int Conf on Computer,Networks and Communication Engineering (ICCNCE 2013).Amsterdam,Netherlands:Atlantis Press,2013
                            </a>
                        </p>
                        <p id="227">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Predicting the resilience of obfuscated code against symbolic execution attacks via machine learning">

                                <b>[13]</b>Banescu S,Collberg C,Pretschner A.Predicting the resilience of obfuscated code against symbolic execution attacks via machine learning[C] //Proc of the 26th USENIX Security Symposium (USENIX Security 17).Berkeley,CA:USENIX Association,2017:661- 678
                            </a>
                        </p>
                        <p id="229">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=From obfuscation to comprehension">

                                <b>[14]</b>Avidan E,Feitelson D G.From obfuscation to comprehension[C] //Proc of the 23rd Int Conf on Program Comprehension.Piscataway,NJ:IEEE,2015:178- 181
                            </a>
                        </p>
                        <p id="231">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Symbolic execution of obfuscated code">

                                <b>[15]</b>Yadegari B,Debray S.Symbolic execution of obfuscated code[C] //Proc of the 22nd ACM SIGSAC Conf on Computer and Communications Security.New York:ACM,2015:732- 744
                            </a>
                        </p>
                        <p id="233">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Code obfuscation against symbolic execution attacks">

                                <b>[16]</b>Banescu S,Collberg C,Ganesh V,et al.Code obfuscation against symbolic execution attacks[C] //Proc of the 32nd Annual Conf on Computer Security Applications.New York:ACM,2016:189- 200
                            </a>
                        </p>
                        <p id="235">
                            <a id="bibliography_17" >
                                    <b>[17]</b>
                                Fan Jinliang,Xu Jun,Amma M H,et al.Prefix-preserving IP address anonymization:Measurement-based security evaluation and a new cryptography-based scheme[J].Computer Networks,2004,46(2):253- 272■Geng Pu,born in 1982.PhD candidate.His main research interests include code obfuscation and information security.■Zhu Yuefei,born in 1962.PhD,professor and PhD supervisor.His main research interests include cyberspace security and elliptic curve cyphers.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201910013" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201910013&amp;v=MDEzNTE0TzN6cXFCdEdGckNVUkxPZVplUnNGeXpoVTd6QUx5dlNkTEc0SDlqTnI0OUVaNFFLREg4NHZSNFQ2ajU=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9EWlhQTjV0S1d5QTI3SmhDbz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>


    <link href="/kxreader/Content/css/LeftDetail?v=NLcKG8I1SJUaVFrQ0iGpF2klAT0OsmHRaVSZ1rKb5xg1" rel="stylesheet"/>

</body>
</html>

