<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637133237581690000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201903004%26RESULT%3d1%26SIGN%3d1Eo9wxSMi1ME7SopCcz6rofXhlQ%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903004&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201903004&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903004&amp;v=MTcxMTdJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNy9PTHl2U2RMRzRIOWpNckk5Rlk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#72" data-title="&lt;b&gt;1 预备知识&lt;/b&gt; "><b>1 预备知识</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#74" data-title="&lt;b&gt;1.1 符 号&lt;/b&gt;"><b>1.1 符 号</b></a></li>
                                                <li><a href="#89" data-title="&lt;b&gt;1.2 离散高斯&lt;/b&gt;"><b>1.2 离散高斯</b></a></li>
                                                <li><a href="#114" data-title="&lt;b&gt;1.3 容错学习 (learning with errors, LWE&lt;/b&gt;) "><b>1.3 容错学习 (learning with errors, LWE</b>) </a></li>
                                                <li><a href="#127" data-title="&lt;b&gt;1.4 层级全同态加密&lt;/b&gt;"><b>1.4 层级全同态加密</b></a></li>
                                                <li><a href="#144" data-title="&lt;b&gt;1.5 基本工具&lt;/b&gt;"><b>1.5 基本工具</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#179" data-title="&lt;b&gt;2 GSW方案&lt;/b&gt; "><b>2 GSW方案</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#181" data-title="&lt;b&gt;2.1 GSW方案&lt;/b&gt;"><b>2.1 GSW方案</b></a></li>
                                                <li><a href="#228" data-title="&lt;b&gt;2.2 安全性&lt;/b&gt;"><b>2.2 安全性</b></a></li>
                                                <li><a href="#231" data-title="&lt;b&gt;2.3 密钥恢复攻击&lt;/b&gt;"><b>2.3 密钥恢复攻击</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#251" data-title="&lt;b&gt;3 MGSW方案&lt;/b&gt; "><b>3 MGSW方案</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#253" data-title="&lt;b&gt;3.1 MGSW方案&lt;/b&gt;"><b>3.1 MGSW方案</b></a></li>
                                                <li><a href="#303" data-title="&lt;b&gt;3.2 对MGSW方案的自适应攻击 (自适应攻击2&lt;/b&gt;) "><b>3.2 对MGSW方案的自适应攻击 (自适应攻击2</b>) </a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#341" data-title="&lt;b&gt;4 DMGSW方案&lt;/b&gt; "><b>4 DMGSW方案</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#365" data-title="&lt;b&gt;4.1 DMGSW方案&lt;/b&gt;"><b>4.1 DMGSW方案</b></a></li>
                                                <li><a href="#430" data-title="&lt;b&gt;4.2 正确性&lt;/b&gt;"><b>4.2 正确性</b></a></li>
                                                <li><a href="#472" data-title="&lt;b&gt;4.3 DMGSW方案的安全性&lt;/b&gt;"><b>4.3 DMGSW方案的安全性</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#482" data-title="&lt;b&gt;5 抵抗自适应攻击的DMGSW方案的安全性&lt;/b&gt; "><b>5 抵抗自适应攻击的DMGSW方案的安全性</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#507" data-title="&lt;b&gt;6 总 结&lt;/b&gt; "><b>6 总 结</b></a><i></i></p>
                                                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="575">


                                    <a id="bibliography_1" title="Regev O. On lattices, learning with errors, random linear codes, and cryptography[C] //Proc of the 37th ACM Symp on the Theory of Computing (STOC’05) . New York: ACM, 2005: 84- 93" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On lattices,learning with errors,random linear codes,and cryptography">
                                        <b>[1]</b>
                                        Regev O. On lattices, learning with errors, random linear codes, and cryptography[C] //Proc of the 37th ACM Symp on the Theory of Computing (STOC’05) . New York: ACM, 2005: 84- 93
                                    </a>
                                </li>
                                <li id="577">


                                    <a id="bibliography_2" title="Gentry C, Peikert C, Vaikun-tanathan V. Trapdoors for hard lattices and new cryptographic constructions[C] //Proc of the 40th ACM Symp on the Theory of Computing (STOC’08) . New York: ACM, 2008: 197- 206" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Trapdoors for hard lattices andnew cryptographic constructions">
                                        <b>[2]</b>
                                        Gentry C, Peikert C, Vaikun-tanathan V. Trapdoors for hard lattices and new cryptographic constructions[C] //Proc of the 40th ACM Symp on the Theory of Computing (STOC’08) . New York: ACM, 2008: 197- 206
                                    </a>
                                </li>
                                <li id="579">


                                    <a id="bibliography_3" title="Chenal M, Tang Qiang. On key recovery attacks against existing somewhat homomorphic encryption schemes[C] //Proc of the 3rd Cryptology and Information Security in Latin (LaintCrypt’14) . Berlin: Springer, 2014: 239- 258" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On key recovery attacks against existing somewhat homomorphic encryption schemes">
                                        <b>[3]</b>
                                        Chenal M, Tang Qiang. On key recovery attacks against existing somewhat homomorphic encryption schemes[C] //Proc of the 3rd Cryptology and Information Security in Latin (LaintCrypt’14) . Berlin: Springer, 2014: 239- 258
                                    </a>
                                </li>
                                <li id="581">


                                    <a id="bibliography_4" title="Chenal M, Tang Qiang. Key recovery attacks against NTRU-based somewhat homomorphic encryption schemes[C] //Proc of the 18th Information Security Conf (ISC’15) . Berlin: Springer, 2015: 397- 418" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Key recovery attacks against NTRU-based somewhat homomorphic encryption schemes">
                                        <b>[4]</b>
                                        Chenal M, Tang Qiang. Key recovery attacks against NTRU-based somewhat homomorphic encryption schemes[C] //Proc of the 18th Information Security Conf (ISC’15) . Berlin: Springer, 2015: 397- 418
                                    </a>
                                </li>
                                <li id="583">


                                    <a id="bibliography_5" title="Dahab R, Galbraith D S, Morais E. Adaptive key recovery attacks on NTRU-based somewhat homomorphic encryption schemes[C] //Proc of the 8th Int Conf on Information Theoretic Security (ICITS’15) . Berlin: Springer, 2015: 283- 296" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Adaptive key recovery attacks on NTRU-based somewhat homomorphic encryption schemes">
                                        <b>[5]</b>
                                        Dahab R, Galbraith D S, Morais E. Adaptive key recovery attacks on NTRU-based somewhat homomorphic encryption schemes[C] //Proc of the 8th Int Conf on Information Theoretic Security (ICITS’15) . Berlin: Springer, 2015: 283- 296
                                    </a>
                                </li>
                                <li id="585">


                                    <a id="bibliography_6" title="Loftus J, May A, Smart P N, et al. On CCA-secure somewhat homomorphic encryption[C] //Proc of the 18th Selected Areas in Cryptography (SAC’11) . Berlin: Springer, 2011: 55- 72" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On CCA-secure somewhat homomorphic encryption">
                                        <b>[6]</b>
                                        Loftus J, May A, Smart P N, et al. On CCA-secure somewhat homomorphic encryption[C] //Proc of the 18th Selected Areas in Cryptography (SAC’11) . Berlin: Springer, 2011: 55- 72
                                    </a>
                                </li>
                                <li id="587">


                                    <a id="bibliography_7" title="Zhang Zhenfei, Plantard T, Susilo W. On the CCA-1 security of somewhat homomorphic encryption over the integers[C] //Proc of the 8th Information Security Practice and Experience (ISPEC’12) . Berlin: Springer, 2012: 353- 368" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On the CCA-1 security of somewhat homomorphic encryption over the integers">
                                        <b>[7]</b>
                                        Zhang Zhenfei, Plantard T, Susilo W. On the CCA-1 security of somewhat homomorphic encryption over the integers[C] //Proc of the 8th Information Security Practice and Experience (ISPEC’12) . Berlin: Springer, 2012: 353- 368
                                    </a>
                                </li>
                                <li id="589">


                                    <a id="bibliography_8" title="Brakerski Z. Fully homomorphic encryption without modulus switching from classical gapsvp[C] //Proc of the 32nd Int Cryptology Conf (CRYPTO’12) . Berlin: Springer, 2012: 868- 886" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fully Homomorphic Encryption without Modulus Switching from Classical GapSVP">
                                        <b>[8]</b>
                                        Brakerski Z. Fully homomorphic encryption without modulus switching from classical gapsvp[C] //Proc of the 32nd Int Cryptology Conf (CRYPTO’12) . Berlin: Springer, 2012: 868- 886
                                    </a>
                                </li>
                                <li id="591">


                                    <a id="bibliography_9" title="Brakerski Z, Gentry C, Vaikuntanathan V. (Leveled) Fully homomorphic encryption without bootstrapping[C] //Proc of Innovations in (Theoretical) Computer Science (ITCS’12) . New York: ACM, 2012: 309- 325" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fully homomorphic encryption without bootstrapping">
                                        <b>[9]</b>
                                        Brakerski Z, Gentry C, Vaikuntanathan V. (Leveled) Fully homomorphic encryption without bootstrapping[C] //Proc of Innovations in (Theoretical) Computer Science (ITCS’12) . New York: ACM, 2012: 309- 325
                                    </a>
                                </li>
                                <li id="593">


                                    <a id="bibliography_10" title="Brakerski Z, Vaikuntanathan V. Efficient fully homomorphic encryption from (standard) LWE[C] //Proc of the 52nd IEEE Annual Symp on Foundations of Computer Science (FOCS’11) . Piscataway, NJ: IEEE, 2011: 97- 106" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient fully homomorphic encryption from(standard)LWE">
                                        <b>[10]</b>
                                        Brakerski Z, Vaikuntanathan V. Efficient fully homomorphic encryption from (standard) LWE[C] //Proc of the 52nd IEEE Annual Symp on Foundations of Computer Science (FOCS’11) . Piscataway, NJ: IEEE, 2011: 97- 106
                                    </a>
                                </li>
                                <li id="595">


                                    <a id="bibliography_11" title="Gentry C, Sahai A, Waters B. Homomorphic encryption from learning with errors: Conceptually-simpler, asymptoti-cally-faster, attribute-based[C] //Proc of the 33rd Int Cryptology Conf (CRYPTO’13) . Berlin: Springer, 2013: 75- 92" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Homomorphic encryption form learning with errors:conceptually-simpler,asymptotically-faster,attributed-based">
                                        <b>[11]</b>
                                        Gentry C, Sahai A, Waters B. Homomorphic encryption from learning with errors: Conceptually-simpler, asymptoti-cally-faster, attribute-based[C] //Proc of the 33rd Int Cryptology Conf (CRYPTO’13) . Berlin: Springer, 2013: 75- 92
                                    </a>
                                </li>
                                <li id="597">


                                    <a id="bibliography_12" title="Gentry C. Fully homomorphic encryption using ideal lattices[C] //Proc of the 41st ACM Symp on the Theory of Computing (STOC’09) . New York: ACM, 2009: 169- 178" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fully Homomorphic Encryption using ideal lattices">
                                        <b>[12]</b>
                                        Gentry C. Fully homomorphic encryption using ideal lattices[C] //Proc of the 41st ACM Symp on the Theory of Computing (STOC’09) . New York: ACM, 2009: 169- 178
                                    </a>
                                </li>
                                <li id="599">


                                    <a id="bibliography_13" title="Smart P N, Vercauteren F. Fully homomorphic encryption with relatively small key and ciphertext sizes[C] //Proc of the 13th Int Conf on Theory and Practice of Public Key Cryptography (PKC’10) . Berlin: Springer, 2010: 420- 443" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fully homomorphic encryption with relatively small key and ciphertext sizes">
                                        <b>[13]</b>
                                        Smart P N, Vercauteren F. Fully homomorphic encryption with relatively small key and ciphertext sizes[C] //Proc of the 13th Int Conf on Theory and Practice of Public Key Cryptography (PKC’10) . Berlin: Springer, 2010: 420- 443
                                    </a>
                                </li>
                                <li id="601">


                                    <a id="bibliography_14" title="Biasse F J, Fieker C. Subexponential class group and unit group computation in large degree number fields[J]. LMS Journal of Computation &amp;amp; Mathematics, 2014, 17 (A) : 385- 403" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Subexponential class group and unit group computation in large degree number fields">
                                        <b>[14]</b>
                                        Biasse F J, Fieker C. Subexponential class group and unit group computation in large degree number fields[J]. LMS Journal of Computation &amp;amp; Mathematics, 2014, 17 (A) : 385- 403
                                    </a>
                                </li>
                                <li id="603">


                                    <a id="bibliography_15" title="Biasse J F, Song Fang. Efficient quantum algorithms for computing class groups and solving the principal ideal problem in arbitrary degree number fields[C] //Proc of the 27th ACM-SIAM Symp on Discrete Algorithms (SODA’16) . New York: ACM, 2016: 893- 902" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient quantum algorithms for computing class groups and solving the principal ideal problem in arbitrary degree number fields">
                                        <b>[15]</b>
                                        Biasse J F, Song Fang. Efficient quantum algorithms for computing class groups and solving the principal ideal problem in arbitrary degree number fields[C] //Proc of the 27th ACM-SIAM Symp on Discrete Algorithms (SODA’16) . New York: ACM, 2016: 893- 902
                                    </a>
                                </li>
                                <li id="605">


                                    <a id="bibliography_16" title="Cramer R, Ducas L, Peikert C, et al. Recovering short generators of principal ideals in cyclotomic rings[C] //Proc of the 35th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’16) . Berlin: Springer, 2016: 559- 585" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Recovering short generators of principal ideals in cyclotomic rings">
                                        <b>[16]</b>
                                        Cramer R, Ducas L, Peikert C, et al. Recovering short generators of principal ideals in cyclotomic rings[C] //Proc of the 35th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’16) . Berlin: Springer, 2016: 559- 585
                                    </a>
                                </li>
                                <li id="607">


                                    <a id="bibliography_17" title="Canetti R, Raghuraman S, Richelson S, et al. Chosen-ciphertext secure fully homomorphic encryption[C] //Proc of the 20th Int Conf on Theory and Practice of Public Key Cryptography (PKC’17) . Berlin: Springer, 2017: 213- 240" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Chosen-ciphertext secure fully homomorphic encryption">
                                        <b>[17]</b>
                                        Canetti R, Raghuraman S, Richelson S, et al. Chosen-ciphertext secure fully homomorphic encryption[C] //Proc of the 20th Int Conf on Theory and Practice of Public Key Cryptography (PKC’17) . Berlin: Springer, 2017: 213- 240
                                    </a>
                                </li>
                                <li id="609">


                                    <a id="bibliography_18" title="Bleichenbacher D. Chosen ciphertext attacks against protocols based on the RSA encryption standard PKCS #1[C] //Proc of the 18th Int Cryptology Conf (CRYPTO’98) . Berlin: Springer, 1998: 1- 12" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Chosen-ciphertext attacks against protocols based on the RSA encryption standard PKCS#1">
                                        <b>[18]</b>
                                        Bleichenbacher D. Chosen ciphertext attacks against protocols based on the RSA encryption standard PKCS #1[C] //Proc of the 18th Int Cryptology Conf (CRYPTO’98) . Berlin: Springer, 1998: 1- 12
                                    </a>
                                </li>
                                <li id="611">


                                    <a id="bibliography_19" title="Li Zengpeng, Galbraith D S, Ma Chunguang. Preventing adaptive key recovery attacks on the GSW levelled homomorphic encryption scheme[C] //Proc of the 10th Provable Security (ProvSec’16) . Berlin: Springer, 2016: 373- 383" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Preventing adaptive key recovery attacks on the GSW levelled homomorphic encryption scheme">
                                        <b>[19]</b>
                                        Li Zengpeng, Galbraith D S, Ma Chunguang. Preventing adaptive key recovery attacks on the GSW levelled homomorphic encryption scheme[C] //Proc of the 10th Provable Security (ProvSec’16) . Berlin: Springer, 2016: 373- 383
                                    </a>
                                </li>
                                <li id="613">


                                    <a id="bibliography_20" title="Clear M, McGoldrick C. Multi-identity and multi-key leveled FHE from learning with errors[C] //Proc of the 35th Int Cryptology Conf (CRYPTO’15) . Berlin: Springer, 2015: 630- 656" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Multi-identity and multi-key leveled FHE from learning with errors">
                                        <b>[20]</b>
                                        Clear M, McGoldrick C. Multi-identity and multi-key leveled FHE from learning with errors[C] //Proc of the 35th Int Cryptology Conf (CRYPTO’15) . Berlin: Springer, 2015: 630- 656
                                    </a>
                                </li>
                                <li id="615">


                                    <a id="bibliography_21" title="Mukherjee P, Wichs D. Two round multiparty computation via multi-key FHE[C] //Proc of the 35th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’16) . Berlin: Springer, 2016: 735- 763" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Two round multiparty computation via multi-key FHE">
                                        <b>[21]</b>
                                        Mukherjee P, Wichs D. Two round multiparty computation via multi-key FHE[C] //Proc of the 35th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’16) . Berlin: Springer, 2016: 735- 763
                                    </a>
                                </li>
                                <li id="617">


                                    <a id="bibliography_22" title="Peikert C. Public-key cryptosystems from the worst-case shortest vector problem: Extended abstract[C] //Proc of the 41st ACM Symp on the Theory of Computing (STOC’09) . New York: ACM, 2009: 333- 342" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Public-key cryptosystems from the worst-case shortest vector problem">
                                        <b>[22]</b>
                                        Peikert C. Public-key cryptosystems from the worst-case shortest vector problem: Extended abstract[C] //Proc of the 41st ACM Symp on the Theory of Computing (STOC’09) . New York: ACM, 2009: 333- 342
                                    </a>
                                </li>
                                <li id="619">


                                    <a id="bibliography_23" title="Agrawal S, Boneh D, Boyen X. Efficient lattice (H) IBE in the standard model[C] //Proc of the 29th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’10) . Berlin: Springer, 2010: 553- 572" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient Lattice (H)IBE in the Standard Model">
                                        <b>[23]</b>
                                        Agrawal S, Boneh D, Boyen X. Efficient lattice (H) IBE in the standard model[C] //Proc of the 29th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’10) . Berlin: Springer, 2010: 553- 572
                                    </a>
                                </li>
                                <li id="621">


                                    <a id="bibliography_24" title="Lyubashevsky V. Lattice signatures without trapdoors[C] //Proc of the 31st Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’12) . Berlin: Springer, 2012: 738- 755" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Lattice signatures without trapdoors">
                                        <b>[24]</b>
                                        Lyubashevsky V. Lattice signatures without trapdoors[C] //Proc of the 31st Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’12) . Berlin: Springer, 2012: 738- 755
                                    </a>
                                </li>
                                <li id="623">


                                    <a id="bibliography_25" title="Peikert C, Waters B. Lossy trapdoor functions and their applications[J]. SIAM Journal on Computing, 2011, 40 (6) : 1803- 1844" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Lossy Trapdoor Functions and Their Applications">
                                        <b>[25]</b>
                                        Peikert C, Waters B. Lossy trapdoor functions and their applications[J]. SIAM Journal on Computing, 2011, 40 (6) : 1803- 1844
                                    </a>
                                </li>
                                <li id="625">


                                    <a id="bibliography_26" title="Li Zengpeng, Galbraith D S, Ma Chunguang. Preventing adaptive key recovery attacks on the gentry-sahai-waters leveled homomorphic encryption scheme, 2016/1146[R/OL]. New York: IACR Cryptology ePrint Archive, 2016 [2017-06-01]. https://eprint.iacr.org/2016/1146.pdf" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Preventing adaptive key recovery attacks on the GSW levelled homomorphic encryption scheme">
                                        <b>[26]</b>
                                        Li Zengpeng, Galbraith D S, Ma Chunguang. Preventing adaptive key recovery attacks on the gentry-sahai-waters leveled homomorphic encryption scheme, 2016/1146[R/OL]. New York: IACR Cryptology ePrint Archive, 2016 [2017-06-01]. https://eprint.iacr.org/2016/1146.pdf
                                    </a>
                                </li>
                                <li id="627">


                                    <a id="bibliography_27" title="Alperin-Sheriff J, Peikert C. Faster bootstrapping with polynomial error[C] //Proc of the 34th Int Cryptology Conf (CRYPTO’14) . Berlin: Springer, 2014: 297- 314" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Faster bootstrapping with polynomial error">
                                        <b>[27]</b>
                                        Alperin-Sheriff J, Peikert C. Faster bootstrapping with polynomial error[C] //Proc of the 34th Int Cryptology Conf (CRYPTO’14) . Berlin: Springer, 2014: 297- 314
                                    </a>
                                </li>
                                <li id="629">


                                    <a id="bibliography_28" title="Ajtai M. Generating hard instances of lattice problems (extended abstract) [C] //Proc of the 8th ACM Symp on the Theory of Computing (STOC’96) . New York: ACM, 1996: 99- 108" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Generating hard instances of lattice problems (extended abstract)">
                                        <b>[28]</b>
                                        Ajtai M. Generating hard instances of lattice problems (extended abstract) [C] //Proc of the 8th ACM Symp on the Theory of Computing (STOC’96) . New York: ACM, 1996: 99- 108
                                    </a>
                                </li>
                                <li id="631">


                                    <a id="bibliography_29" title="Micciancio D. Generalized compact knapsacks, cyclic lattices, and efficient one-way functions from worst-case complexity assumptions[C] //Proc of the 43rd IEEE Annual Symp on Foundations of Computer Science (FOCS’02) . Los Alamitos, CA: IEEE Computer Society, 2002: 356- 365" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Generalized compact knapsacks, cyclic lattices, and efficient one-way functions from worst-case complexity assumptions">
                                        <b>[29]</b>
                                        Micciancio D. Generalized compact knapsacks, cyclic lattices, and efficient one-way functions from worst-case complexity assumptions[C] //Proc of the 43rd IEEE Annual Symp on Foundations of Computer Science (FOCS’02) . Los Alamitos, CA: IEEE Computer Society, 2002: 356- 365
                                    </a>
                                </li>
                                <li id="633">


                                    <a id="bibliography_30" title="Agrawal S, Gentry C, Halevi S, et al. Discrete gaussian leftover hash lemma over infinite domains[C] //Proc of the 19th Int Conf on the Theory and Application of Cryptology and Information Security (ASIACRYPT’13) . Berlin: Springer, 2013: 97- 116" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Discrete gaussian leftover hash lemma over infinite domains">
                                        <b>[30]</b>
                                        Agrawal S, Gentry C, Halevi S, et al. Discrete gaussian leftover hash lemma over infinite domains[C] //Proc of the 19th Int Conf on the Theory and Application of Cryptology and Information Security (ASIACRYPT’13) . Berlin: Springer, 2013: 97- 116
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(03),496-507 DOI:10.7544/issn1000-1239.2019.20170443            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>抵抗自适应密钥恢复攻击的层级全同态加密</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9D%8E%E5%A2%9E%E9%B9%8F&amp;code=29720999&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">李增鹏</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%A9%AC%E6%98%A5%E5%85%89&amp;code=10529409&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">马春光</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%B5%B5%E6%98%8E%E6%98%8A&amp;code=41425013&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">赵明昊</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%93%88%E5%B0%94%E6%BB%A8%E5%B7%A5%E7%A8%8B%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2&amp;code=0119964&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">哈尔滨工程大学计算机科学与技术学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E9%9D%92%E5%B2%9B%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2&amp;code=0201790&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">青岛大学计算机科学技术学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2&amp;code=0187103&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">清华大学软件学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>由于攻击者可以通过自适应攻击的方式获得私钥, 因此目前一个重要的公开问题是如何保护层级全同态加密 (fully homomorphic encryption, FHE) 免受自适应攻击.在该问题的研究中, 为实现抵抗自适应密钥恢复攻击的目标, 近来, 李增鹏等人 (PROVSEC’16) 在容错学习 (learning with errors, LWE) 假设下, 提出了一个多私钥的全同态加密方案, 该方案并不依赖于Loftus等人 (SAC’11) 利用的“有效密文”概念.然而尽管该方案能抵抗私钥信息的泄漏, 但利用噪声信息仍然能够实现自适应的密钥恢复攻击.基于李增鹏等人 (EPRINT’16) 的工作, 给出对李增鹏等人方案的一种新的自适应攻击方法, 并提出了一种不同于EPRINT’16的对偶的多私钥全同态加密方案以抵抗该自适应攻击.其核心思想是采用对偶的加密方式, 并在每次解密算法运行时, 都生成一个“一次”私钥, 因此即使攻击者能够从每个解密查询中得到该一次私钥的某些比特, 但却无法获得噪声的某些比特, 因此, 攻击者仍不能计算出一个有效的私钥.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%87%AA%E9%80%82%E5%BA%94%E5%AF%86%E9%92%A5%E6%81%A2%E5%A4%8D%E6%94%BB%E5%87%BB&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">自适应密钥恢复攻击;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%A0%BC%E5%9F%BA%E5%AF%86%E7%A0%81%E5%AD%A6&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">格基密码学;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%AE%B9%E9%94%99%E5%AD%A6%E4%B9%A0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">容错学习;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%85%A8%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">全同态加密;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%A4%9A%E7%A7%81%E9%92%A5&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">多私钥;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    *马春光, machunguang@hrbeu.edu.cn;
                                </span>
                                <span>
                                    李增鹏, lizengpeng@hrbeu.edu.cn;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2017-06-12</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目 (61472097, 61802214);</span>
                    </p>
            </div>
                    <h1><b>Leveled Fully Homomorphic Encryption Against Adaptive Key Recovery Attacks</b></h1>
                    <h2>
                    <span>Li Zengpeng</span>
                    <span>Ma Chunguang</span>
                    <span>Zhao Minghao</span>
            </h2>
                    <h2>
                    <span>College of Computer Science and Technology, Harbin Engineering University</span>
                    <span>College of Computer Science and Technology, Qingdao University</span>
                    <span>School of Software, Tsinghua University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>A major open problem is to protect leveled homomorphic encryption from adaptive attacks that allow an adversary to learn the private key. In order to achieve the goal of preventing key recovery attacks on fully homomorphic encryption (FHE) , Li Zengpeng et al (PROVSEC'16) proposed an multiple secret keys fully homomorphic encryption scheme under the learning with errors (LWE) assumption to prevent key recovery attacks on FHE, which did not use the notion of “valid ciphertexts” of Loftus et al (SAC'11) . However, utilizing the information of noise, the attacks can still recover the information of the secret key. Li Zengpeng et al.'s scheme cannot provide an efficient method to protect the secret key. In this paper, Inspired by the work of Li Zengpeng et al (EPRINT'16) , we first give a new method of key recovery attacks to Li Zengpeng et al.'s scheme; then, we propose a new FHE scheme with multiple secret keys which differs from EPRINT'16, and prove our new scheme against key recovery attacks. Our main idea is to adopt the dual version of encryption algorithm and generate a “one-time” secret key every time, so that even if an attacker can learn some bits of the one-time private key from each decryption query and cannot obtain some bits of noise, the scheme still does not allow them to compute a valid private key.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=adaptive%20key%20recovery%20attacks&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">adaptive key recovery attacks;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=lattice-based%20cryptography&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">lattice-based cryptography;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=learning%20with%20errors&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">learning with errors;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=fully%20homomorphic%20encryption&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">fully homomorphic encryption;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=multiple%20secret%20keys&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">multiple secret keys;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Li Zengpeng, born in 1989.Assistant professor in the College of Computer Science and Technology of Qingdao University.Member of ACM, CCF, CACR, IEEE and IEICE.His main research interests include data security, data privacy and cryptography.In particular, his research focus are lattice-based cryptography, fully homomorphic encryption and cryptography protocol.<image id="570" type="formula" href="images/JFYZ201903004_57000.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Ma Chunguang, born in 1974.Professor of the College of Computer Science and Technology of Harbin Engineering University.His main research interests include cryptography and information security.<image id="571" type="formula" href="images/JFYZ201903004_57100.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Zhao Minghao, born in 1992.PhD candidate in Tsinghua University.Student member of ACM, CCF and CACR.His main research interests include cloud computing, storage system, mobile computing, privacy preserving techniques and applied cryptography.<image id="572" type="formula" href="images/JFYZ201903004_57200.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2017-06-12</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Natural Science Foundation of China (61472097, 61802214);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="66">众所周知, 若敌手访问一个解密预言机, 则能引起对基本的Regev<citation id="635" type="reference"><link href="575" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>或GPV (Gentry, Peikert, Vaikuntanathan) <citation id="636" type="reference"><link href="577" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>加密以及各种全同态加密 (fully homomorphic encryption, FHE) 方案<citation id="639" type="reference"><link href="579" rel="bibliography" /><link href="581" rel="bibliography" /><link href="583" rel="bibliography" /><link href="585" rel="bibliography" /><sup>[<a class="sup">3</a>,<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">6</a>]</sup></citation>的攻击.这些攻击能够让敌手直接获得私钥.因此, 与那些获得并利用消息的某些比特信息而进行的攻击相比, 上述攻击形式更为严重.实际上, 如果不要求方案具有同态加密的功能, 那么存在一些基于格的IND-CCA2加密方案 (如文献<citation id="637" type="reference">[<a class="sup">2</a>]</citation>) , 但是这些方法与同态加密并不兼容.因此, 本文关心的是如何获得这些方案CCA1安全的变体.此外, Brakerski等人, 如文献<citation id="640" type="reference">[<a class="sup">7</a>,<a class="sup">8</a>,<a class="sup">9</a>]</citation>利用密钥交换、自举等方法获得的一系列全同态加密方案, 但这些方案并不能实现IND-CCA1安全, 因为在这些方案中, 其公钥包含了对私钥信息的加密.随后, GSW (Gentry-Sahai-Waters) 方案<citation id="638" type="reference"><link href="593" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>能够实现层级全同态加密而不需要任何密钥交换过程, 因此其方案为实现FHE方案的IND-CCA1安全性提供了一种可能, 因为对于那些使用密钥交换、自举或者其他方法的全同态加密方案来说, 该方案避免了在公钥中包含对私钥加密的信息.</p>
                </div>
                <div class="p1">
                    <p id="67">LMSV (Loftus, May, Smart, Vercauteren) <citation id="641" type="reference"><link href="585" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>研究了Gentry<citation id="642" type="reference"><link href="595" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>基于理想格的同态加密方案 (及其变体<citation id="643" type="reference"><link href="597" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>) 在自适应攻击下私钥的安全性, 同时, 他们证明了如果敌手能够访问解密预言机, 那么就能确定私钥.此外, Loftus等人<citation id="644" type="reference"><link href="597" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>给出了Smart-Vercauteren密码系统的一个变体, 在该方案中, 即使敌手有一个解密预言机, 私钥仍旧安全;该结果是基于“有效密文”的概念由解密算法所保证, 并且其安全性依赖于一个非常强的知识假设.随后, 由于构造Smart-Vercauteren密码系统所依赖的计算假设, 即短主理想 (the short principal ideal) 问题被攻破<citation id="650" type="reference"><link href="599" rel="bibliography" /><link href="601" rel="bibliography" /><link href="603" rel="bibliography" /><link href="605" rel="bibliography" /><sup>[<a class="sup">13</a>,<a class="sup">14</a>,<a class="sup">15</a>,<a class="sup">16</a>]</sup></citation>, 因此LMSV方案不再被认为是安全的.近来, Cannitte等人<citation id="645" type="reference"><link href="607" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>提出了第1个真正意义上的IND-CCA1安全的FHE方案, 但他们并没有完全解决密文长度仍然依赖于电路输入长度的问题.因此IND-CCA1安全的层级全同态加密问题仍旧没有得到完全解决.值得注意的是, Loftus等人<citation id="646" type="reference"><link href="597" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>着重解释了密文有效性攻击 (ciphertext validity attacks, CVA) 的相关性, 即该模型允许敌手访问一个能够决定密文是否有效的预言机.同时, 他们证明了敌手在CVA预言机的帮助下解密挑战密文的可能性 (至少私钥仍是安全的.然而该攻击不是CCA1攻击, 而是CCA2攻击) .Loftu等人<citation id="647" type="reference"><link href="585" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>认为对同态加密方案的CCA1和CVA攻击在实践中是可实现的 (他们在文献<citation id="648" type="reference">[<a class="sup">6</a>]</citation>第6节中写道“在真实世界中, 通常是敌手将其选择的密文先发给某一参与方, 然后通过观察该参与方的行为获得该预言机”) .例如考虑一个场景, 给出了一个CVA预言机的精确描述.如果使用者正在将一个加密的数据库储存在云端并且进行查询, 那么攻击者能够发送其选择的密文作为回应.如果这些密文是无效的, 那么使用者可能重新发送相同的查询直到收到一个有效的密文作为回应.Bleichenbacher<citation id="649" type="reference"><link href="609" rel="bibliography" /><sup>[<a class="sup">18</a>]</sup></citation>利用CVA预言机来攻击RSA的某些变体就是一个典型的例子.由此可以认为, 提出新的技术来让同态加密方案的私钥变得安全, 从而抵抗CVA攻击、密钥恢复攻击 (key recovery attacks, KRA) 是非常必要且紧迫的.</p>
                </div>
                <div class="p1">
                    <p id="68">为解决这个问题, 李增鹏等人<citation id="651" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>提出一个不同于Loftus等人<citation id="652" type="reference"><link href="585" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>的方案.他们给出了GSW方案<citation id="653" type="reference"><link href="595" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>的一个变体, 即多私钥GSW方案 (MGSW) , 该变体允许有一个公钥对应着多个私钥.即通过使用“一次”一私钥的方法来避免私钥完全暴露的风险, 从而不再依赖于“有效密文”的概念.其核心思想是, 即使敌手能够从每个解密查询中得到一次私钥的某些比特, 但他们也不可能将从多个解密查询中得来的信息结合起来计算出真正的私钥.但是, 该方案也存在风险, 即当解密查询时, 利用噪声信息可能恢复出私钥信息.在本文3.1节给出该攻击方案的具体描述.此外, 不禁要问:是否存在这样一种全同态加密方案, 它可有效抵抗一些已知的密钥恢复攻击?</p>
                </div>
                <div class="p1">
                    <p id="69">为了解决上述问题, 本文提出了MGSW方案的一种“对偶”版本, 记为DMGSW方案, 并着重解释了该DMGSW方案如何能够结合多个私钥有效抵抗一些已知的自适应密钥恢复攻击.</p>
                </div>
                <div class="p1">
                    <p id="70">此外, 为证明方案能够抵抗特定类 (或某些已知攻击) 的自适应攻击, 本文利用剩余Hash引理和向量空间投影论证给出理论框架.遗憾的是, 不能证明该方案的IND-CCA1安全性.但希望本文的方案对于完全实现可证明安全的IND-CCA1全同态加密方案来说是一块垫脚石.</p>
                </div>
                <div class="p1">
                    <p id="71">诚然, 证明全同态加密的IND-CCA1安全性是一个非常有挑战性的工作, 最接近的解决方案是Loftus等人<citation id="654" type="reference"><link href="585" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>的结果, 他们使用了一个非常强的知识假设, 但是该结果现在已经被攻破了.Cannitte等人<citation id="655" type="reference"><link href="607" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>基于multi-key的全同态加密方案<citation id="656" type="reference"><link href="613" rel="bibliography" /><link href="615" rel="bibliography" /><sup>[<a class="sup">20</a>,<a class="sup">21</a>]</sup></citation>, 实现了IND-CCA1安全, 但他们的方案依赖复杂的multi-key技术, 且密文长度仍依赖于电路输入长度, 使得该问题并未完全解决.</p>
                </div>
                <h3 id="72" name="72" class="anchor-tag"><b>1 预备知识</b></h3>
                <div class="p1">
                    <p id="73">本节着重介绍本文需用到的数学符号.</p>
                </div>
                <h4 class="anchor-tag" id="74" name="74"><b>1.1 符 号</b></h4>
                <div class="p1">
                    <p id="75">令<i>n</i>∈N, [<i>n</i>]表示集合{1, 2, …, <i>n</i>}.令<i>X</i>为平均值<i>μ</i>:<i>E</i>[<i>X</i>]=<i>μ</i>的一个随机变量, 这里<i>E</i>表示<i>X</i>的平均值或期望值.<i>X</i>的标准差是<mathml id="76"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>δ</mi><mo>=</mo><msqrt><mrow><mi>E</mi><mo stretchy="false">[</mo><mo stretchy="false"> (</mo><mi>X</mi><mo>-</mo><mi>μ</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup><mo stretchy="false">]</mo></mrow></msqrt></mrow></math></mathml>.本文中, 列向量以粗体小写字母表示, 如<b><i>x</i></b>.用转置来表示行向量<b><i>x</i></b><sup>T</sup>.用粗体大写字母, 如<b><i>R</i></b>来表示矩阵.此外, 本文用到的内积和范数定义如下:〈<b><i>x</i></b>, <b><i>y</i></b>〉=<b><i>x</i></b><sup>T</sup><b><i>y</i></b>表示2个向量<b><i>x</i></b>和<b><i>y</i></b>的标准欧几里得内积.对于向量<b><i>v</i></b>= (<i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>…, <i>v</i><sub><i>n</i></sub>) <sup>T</sup>, ℓ<sub>∞</sub>范数是<mathml id="77"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mi mathvariant="bold-italic">v</mi><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>=</mo><mrow><mi>max</mi></mrow><mo stretchy="false">{</mo><mo stretchy="false">|</mo><mi>v</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">|</mo><mo>, </mo><mrow><mo stretchy="false">|</mo><mi>v</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">|</mo></mrow><mo>, </mo><mo>⋯</mo><mo>, </mo><mo stretchy="false">|</mo><mi>v</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">|</mo><mo stretchy="false">}</mo><mo>, </mo><mi>ℓ</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></math></mathml>范数是<mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mi mathvariant="bold-italic">v</mi><mo>|</mo></mrow><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo></mrow></math></mathml><mathml id="79"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mrow><mo>|</mo><mrow><mi>v</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mo>|</mo></mrow></mrow></mstyle></mrow></math></mathml>, 欧几里得范数是<mathml id="80"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mi mathvariant="bold-italic">v</mi><mo>|</mo></mrow><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><msqrt><mrow><mo>〈</mo><mi mathvariant="bold-italic">v</mi><mo>, </mo><mi mathvariant="bold-italic">v</mi><mo>〉</mo></mrow></msqrt><mo>=</mo></mrow></math></mathml><mathml id="81"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msqrt><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mrow><mo>|</mo><mrow><mi>v</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mo>|</mo></mrow></mrow></mstyle><msup><mrow></mrow><mn>2</mn></msup></mrow></msqrt></mrow></math></mathml>.对于一个向量<b><i>v</i></b>, 用<mathml id="82"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mi mathvariant="bold-italic">v</mi><mo>|</mo></mrow></mrow></math></mathml>表示其ℓ<sub>2</sub>范数.</p>
                </div>
                <div class="p1">
                    <p id="83"><b>引理1</b><citation id="657" type="reference"><link href="593" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>. 矩阵向量剩余Hash引理.令<i>κ</i>∈N, <i>n</i>∈N, <i>q</i>∈N, 且<i>m</i>≥<i>n</i> lb <i>q</i>+2<i>κ</i>.令<mathml id="84"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">A</mi><mover><mstyle mathsize="140%" displaystyle="true"><mo>←</mo></mstyle><mi>R</mi></mover><mtext>Ζ</mtext><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msubsup></mrow></math></mathml>是一个均匀随机矩阵 (注意<i>R</i>是随机选取) , 令<mathml id="85"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">r</mi><mover><mstyle mathsize="140%" displaystyle="true"><mo>←</mo></mstyle><mi>R</mi></mover><mo stretchy="false">{</mo><mn>0</mn><mo>, </mo><mn>1</mn><mo stretchy="false">}</mo><msup><mrow></mrow><mi>m</mi></msup></mrow></math></mathml>且<mathml id="86"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">y</mi><mover><mstyle mathsize="140%" displaystyle="true"><mo>←</mo></mstyle><mi>R</mi></mover><mtext>Ζ</mtext><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>, 那么:</p>
                </div>
                <div class="p1">
                    <p id="87">Δ ( (<b><i>A</i></b>, <b><i>A</i></b><sup>T</sup>·<b><i>r</i></b>) , (<b><i>A</i></b>, <b><i>y</i></b>) ) ≤2<sup>-<i>κ</i></sup>,      (1) </p>
                </div>
                <div class="p1">
                    <p id="88">其中, Δ (<b><i>A</i></b>, <b><i>B</i></b>) 表示分布<b><i>A</i></b>和<b><i>B</i></b>的统计距离.</p>
                </div>
                <h4 class="anchor-tag" id="89" name="89"><b>1.2 离散高斯</b></h4>
                <div class="p1">
                    <p id="90">实际上, 格密码方案<citation id="658" type="reference"><link href="617" rel="bibliography" /><sup>[<a class="sup">22</a>]</sup></citation>主要依赖于格上的高斯概率分布.在本文中, 依然需要分析高斯分布上错误元素的行为.首先给出高斯分布的相关定义.</p>
                </div>
                <div class="p1">
                    <p id="91"><b>定义1</b><citation id="659" type="reference"><link href="619" rel="bibliography" /><sup>[<a class="sup">23</a>]</sup></citation>. 令<i>L</i>为Z<sup><i>m</i></sup>的一个子集.对于向量<b><i>c</i></b>∈R<sup><i>m</i></sup>和参数<i>σ</i>∈R, 定义:</p>
                </div>
                <div class="area_img" id="92">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JFYZ201903004_09200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="95">以<b><i>c</i></b>为均值、以<i>σ</i>为参数<i>L</i>的离散高斯分布是:</p>
                </div>
                <div class="p1">
                    <p id="96" class="code-formula">
                        <mathml id="96"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>∀</mo><mi mathvariant="bold-italic">y</mi><mo>∈</mo><mi>L</mi><mo>, </mo><mi>D</mi><msub><mrow></mrow><mrow><mi>L</mi><mo>, </mo><mi>σ</mi><mo>, </mo><mi mathvariant="bold-italic">c</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>ρ</mi><msub><mrow></mrow><mrow><mi>σ</mi><mo>, </mo><mi mathvariant="bold-italic">c</mi></mrow></msub><mo stretchy="false"> (</mo><mi>y</mi><mo stretchy="false">) </mo></mrow><mrow><mi>ρ</mi><msub><mrow></mrow><mrow><mi>σ</mi><mo>, </mo><mi mathvariant="bold-italic">c</mi></mrow></msub><mo stretchy="false"> (</mo><mi>L</mi><mo stretchy="false">) </mo></mrow></mfrac><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="97">为了方便表示, 将<i>ρ</i><sub><i>σ</i>, 0</sub>和<i>D</i><sub><i>L</i>, <i>σ</i>, 0</sub>简写为<i>ρ</i><sub><i>σ</i></sub>和<i>D</i><sub><i>σ</i></sub>, 将<i>D</i><sub>Z<sup><i>m</i></sup>, <i>σ</i>, 0</sub>简写为<i>D</i><mathml id="98"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>σ</mi><mi>m</mi></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="99"><b>定义2</b><citation id="660" type="reference"><link href="591" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>. <i>B</i> -界分布.{<i>χ</i><sub><i>n</i></sub>}<sub><i>n</i>∈N</sub>是整数上的高斯分布, 如果满足:</p>
                </div>
                <div class="p1">
                    <p id="100" class="code-formula">
                        <mathml id="100"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mi>Ρ</mi><mi>r</mi></mrow></mstyle><mrow><mi>φ</mi><mo>←</mo><mi>χ</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munder><mo stretchy="false">[</mo><mo stretchy="false">|</mo><mi>φ</mi><mo stretchy="false">|</mo><mo>≥</mo><mi>B</mi><mo stretchy="false">]</mo><mo>≤</mo><mn>2</mn><msup><mrow></mrow><mrow><mo>-</mo><mover accent="true"><mi>Ω</mi><mo>˜</mo></mover><mo stretchy="false"> (</mo><mi>n</mi><mo stretchy="false">) </mo></mrow></msup><mo>, </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="101">则称之为<i>B</i> -界分布.</p>
                </div>
                <div class="p1">
                    <p id="102">对于整数上的一个分布<i>χ</i>=<i>χ</i> (<i>λ</i>) , 且整数界为<i>B</i>=<i>B</i> (<i>λ</i>) , 如果存在<mathml id="103"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mi>Ρ</mi><mi>r</mi></mrow></mstyle><mrow><mi>φ</mi><mo>←</mo><mi>χ</mi><mo stretchy="false"> (</mo><mi>λ</mi><mo stretchy="false">) </mo></mrow></munder><mo stretchy="false">[</mo><mo stretchy="false">|</mo><mi>φ</mi><mo stretchy="false">|</mo><mo>≤</mo><mi>B</mi><mo stretchy="false"> (</mo><mi>λ</mi><mo stretchy="false">) </mo><mo stretchy="false">]</mo></mrow></math></mathml>, 那么称<i>χ</i>是<i>B</i> -界的.</p>
                </div>
                <div class="p1">
                    <p id="104"><b>引理2</b><citation id="661" type="reference"><link href="619" rel="bibliography" /><sup>[<a class="sup">23</a>]</sup></citation>. 噪声边界满足2个条件:</p>
                </div>
                <div class="p1">
                    <p id="105">1) 对于∀<i>k</i>&gt;0, 参数<i>e</i><sub><i>i</i></sub> (<i>i</i>∈[<i>m</i>]) 满足</p>
                </div>
                <div class="p1">
                    <p id="106" class="code-formula">
                        <mathml id="106"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>Ρ</mi><mi>r</mi></mrow><mo stretchy="false">[</mo><mo stretchy="false">|</mo><mi>e</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">|</mo><mo>&gt;</mo><mi>k</mi><mtext> </mtext><mi>σ</mi><mo>, </mo><mi>e</mi><msub><mrow></mrow><mi>i</mi></msub><mo>←</mo><mi>D</mi><msubsup><mrow></mrow><mi>σ</mi><mn>1</mn></msubsup><mo stretchy="false">]</mo><mo>≤</mo><mn>2</mn><mrow><mi>exp</mi></mrow><mrow><mo> (</mo><mrow><mo>-</mo><mfrac><mrow><mi>k</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mn>2</mn></mfrac></mrow><mo>) </mo></mrow><mo>;</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="107">2) 对于∀<i>k</i>&gt;0, 向量<b><i>e</i></b>=[<i>e</i><sub>1</sub>, <i>e</i><sub>2</sub>, …, <i>e</i><sub><i>m</i></sub>]满足</p>
                </div>
                <div class="p1">
                    <p id="108" class="code-formula">
                        <mathml id="108"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mi>Ρ</mi><mi>r</mi></mrow><mo stretchy="false">[</mo><mrow><mo>|</mo><mi mathvariant="bold-italic">e</mi><mo>|</mo></mrow><mo>&gt;</mo><mi>k</mi><mtext> </mtext><mi>σ</mi><msqrt><mi>m</mi></msqrt><mo>, </mo><mi mathvariant="bold-italic">e</mi><mo>←</mo><mi>D</mi><msubsup><mrow></mrow><mi>σ</mi><mi>m</mi></msubsup><mo stretchy="false">]</mo><mo>≤</mo><mi>k</mi><msup><mrow></mrow><mi>m</mi></msup><mrow><mi>exp</mi></mrow><mrow><mo> (</mo><mrow><mfrac><mi>m</mi><mn>2</mn></mfrac><mo stretchy="false"> (</mo><mn>1</mn><mo>-</mo><mi>k</mi><msup><mrow></mrow><mn>2</mn></msup><mo stretchy="false">) </mo></mrow><mo>) </mo></mrow><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="109"><b>注1</b>. 本文中, 假设<mathml id="110"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><mo>≥</mo><mn>2</mn><msqrt><mi>n</mi></msqrt></mrow></math></mathml>.因此, 如果<b><i>e</i></b>←<i>D</i><mathml id="111"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>σ</mi><mi>m</mi></msubsup></mrow></math></mathml>, 那么在平均情况下<mathml id="112"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mi mathvariant="bold-italic">e</mi><mo>|</mo></mrow><mo>≈</mo><msqrt><mi>m</mi></msqrt><mi>σ</mi></mrow></math></mathml>.由引理2中的2) 可知, <mathml id="113"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mi mathvariant="bold-italic">e</mi><mo>|</mo></mrow><mo>≤</mo><mn>2</mn><mi>σ</mi><msqrt><mi>m</mi></msqrt><mo>.</mo></mrow></math></mathml></p>
                </div>
                <h4 class="anchor-tag" id="114" name="114"><b>1.3 容错学习 (learning with errors, LWE</b>) </h4>
                <div class="p1">
                    <p id="115">LWE问题是全同态加密GSW方案<citation id="662" type="reference"><link href="593" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>及本文方案的主要计算假设.具体如下:</p>
                </div>
                <div class="p1">
                    <p id="116"><b>定义3</b>. 对于一个秘密向量<b><i>s</i></b><sup><i>i</i></sup>∈Z<mathml id="117"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>, 通过均匀随机地选择向量<b><i>a</i></b><sup><i>i</i></sup>∈Z<mathml id="118"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>, 选取噪声变量<i>e</i><sub><i>i</i></sub>←<i>χ</i>, 并输出 (<b><i>a</i></b><sup><i>i</i></sup>, <i>b</i><sub><i>i</i></sub>=〈<b><i>s</i></b><sup><i>i</i></sup>, <b><i>a</i></b><sup><i>i</i></sup>〉+<i>e</i><sub><i>i</i></sub> (mod <i>q</i>) ) , 从而选取Z<mathml id="119"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>×Z<sup><i>q</i></sup>上的LWE分布A<sub><b><i>s</i></b>, <i>χ</i></sub>.</p>
                </div>
                <div class="p1">
                    <p id="120">LWE问题有2个版本:搜索 (search) 版本, 是已知LWE样本来寻找秘密向量;判定 (decision) 版本, 是用来区分LWE实例和均匀随机样本.</p>
                </div>
                <div class="p1">
                    <p id="121"><b>定义4</b>. 对于<i>i</i>∈[<i>m</i>], 任一均匀随机的<b><i>s</i></b><sup><i>i</i></sup>∈Z<sup><i>n</i></sup><sub><i>q</i></sub> (对于所有抽样来说是固定的) , 给定了从A<sub><b><i>s</i></b>, <i>χ</i></sub>中选取的<i>m</i>个独立样本 (<b><i>a</i></b><sup><i>i</i></sup>, <i>b</i><sub><i>i</i></sub>) ∈Z<mathml id="122"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>×Z<sup><i>q</i></sup>, 从而找到<b><i>s</i></b><sup><i>i</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="123"><b>定义5</b>. 给定<i>m</i>个独立样本 (<b><i>a</i></b><sup><i>i</i></sup>, <i>b</i><sub><i>i</i></sub>) ∈Z<mathml id="124"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>×Z<sup><i>q</i></sup>, 其中每个抽样取自2个分布:1) LWE分布A<sub><b><i>s</i></b>, <i>χ</i></sub>, 其中<b><i>s</i></b>∈Z<mathml id="125"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>是一个均匀随机的秘密向量 (对所有的抽样来说是固定的) ;2) 均匀分布.即 (以不可忽略的优势) 区分以上2个分布.</p>
                </div>
                <div class="p1">
                    <p id="126">Regev<citation id="663" type="reference"><link href="575" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>及文献<citation id="664" type="reference">[<a class="sup">20</a>,<a class="sup">21</a>,<a class="sup">24</a>]</citation>证明了对于恰当的参数, LWE问题与格的近似最短向量 (shortest vector problem, SVP) 问题同样困难.</p>
                </div>
                <h4 class="anchor-tag" id="127" name="127"><b>1.4 层级全同态加密</b></h4>
                <div class="p1">
                    <p id="128"><b>定义6</b>. 令<i>L</i>=<i>L</i> (<i>κ</i>) 为一个固定的函数.为深度是<i>L</i>的一类电路{<i>C</i><sub><i>κ</i></sub>}<sub><i>κ</i>∈Z</sub>构造的一个<i>L</i>-层级全同态加密 (leveled-FHE) 方案, 该方案包括4个PPT算法 (<i>KeyGen</i>, <i>Enc</i>, <i>Dec</i>, <i>Eval</i>) :</p>
                </div>
                <div class="p1">
                    <p id="129">1) 密钥生成算法<i>KeyGen</i>.是一个随机化算法, 它以安全参数1<sup><i>κ</i></sup>为输入, 并输出一个公钥<i>pk</i>和私钥<i>sk</i>.</p>
                </div>
                <div class="p1">
                    <p id="130">2) 加密算法<i>Enc</i>.是一个随机化算法, 它以一个公钥<i>pk</i>和一个消息<i>μ</i>∈{0, 1}为输入, 并输出一个密文<i>c</i>.</p>
                </div>
                <div class="p1">
                    <p id="131">3) 解密算法<i>Dec</i>.是一个确定性算法, 它以一个私钥<i>sk</i>和一个密文<i>ct</i>为输入, 并输出一个消息<i>μ</i>∈{0, 1}.</p>
                </div>
                <div class="p1">
                    <p id="132">4) 同态运算算法<i>Eval</i>.输入一个公钥<i>pk</i>, 一个运算电路<i>C</i>∈<i>C</i><sub><i>κ</i></sub>, 和一个密文列表<i>ct</i><sub>1</sub>, <i>ct</i><sub>2</sub>, …, <i>ct</i><sub>ℓ (<i>κ</i>) </sub>, 并输出一个密文<i>ct</i><sup>*</sup>.</p>
                </div>
                <div class="p1">
                    <p id="133">并要求2个正确性成立:</p>
                </div>
                <div class="p1">
                    <p id="134">1) 对于任意<i>κ</i>, <i>μ</i>∈{0, 1}和由<i>KeyGen</i> (1<sup><i>κ</i></sup>) 输出的任意 (<i>pk</i>, <i>sk</i>) , 有:</p>
                </div>
                <div class="p1">
                    <p id="135"><i>μ</i>=<i>Dec</i> (<i>sk</i>, (<i>Enc</i> (<i>pk</i>, <i>μ</i>) ) ) .</p>
                </div>
                <div class="p1">
                    <p id="136">2) 对于任意<i>κ</i>, <i>μ</i><sub>1</sub>, <i>μ</i><sub>2</sub>, …, <i>μ</i><sub>ℓ</sub>, 和<i>C</i>∈<i>C</i><sub><i>κ</i></sub>, 有:</p>
                </div>
                <div class="p1">
                    <p id="137"><i>C</i> (<i>μ</i><sub>1</sub>, <i>μ</i><sub>2</sub>, …, <i>μ</i><sub>ℓ</sub>) =<i>Dec</i> (<i>sk</i>, (<i>Eval</i> (<i>pk</i>, <i>C</i>, <i>Enc</i> (<i>pk</i>, <i>μ</i><sub>1</sub>) , <i>Enc</i> (<i>pk</i>, <i>μ</i><sub>2</sub>) , …, <i>Enc</i> (<i>pk</i>, <i>μ</i><sub>ℓ</sub>) ) ) .</p>
                </div>
                <div class="p1">
                    <p id="138">使用选择明文攻击 (chosen plaintext attacks, CPA) 安全性的标准概念来定义安全性.</p>
                </div>
                <div class="p1">
                    <p id="139"><b>定义7</b>. 如果对于任意多项式时间敌手A来说, 下面的公式在<i>κ</i>上是可忽略的, 那么说一个同态加密方案是不可区分选择明文攻击安全的 (也称为IND-CPA安全的) :</p>
                </div>
                <div class="p1">
                    <p id="140">|<i>Pr</i>[A (<i>pk</i>, <i>Enc</i> (<i>pk</i>, 0) ) =1]-Pr[A (pk, Enc (pk, 1) ) =1]|, </p>
                </div>
                <div class="p1">
                    <p id="142">其中, (<i>pk</i>, <i>sk</i>) ←<i>KeyGen</i> (1<sup><i>κ</i></sup>) .</p>
                </div>
                <div class="p1">
                    <p id="143">此外, 根据选择密文安全 (chosen ciphertext attacks, CCA1) 的概念, 在其攻击的第1阶段中, 敌手A已知一个公钥, 然后访问一个解密预言机.它可以获得任意输入的解密.在第2阶段中, 敌手已知一个挑战密文Enc (<i>pk</i>, <i>μ</i>) 并且不再需要对解密预言机进行查询.CCA1安全性模型适用于分析敌手是否能从解密查询中得到私钥.因此, CCA1是很适合用来研究同态加密的一个安全模型.</p>
                </div>
                <h4 class="anchor-tag" id="144" name="144"><b>1.5 基本工具</b></h4>
                <div class="p1">
                    <p id="145">下面回顾一下Brakerski等人如文献<citation id="665" type="reference">[<a class="sup">7</a>,<a class="sup">8</a>,<a class="sup">10</a>]</citation>提出的一些基本工具.令<i>q</i>, <i>m</i>∈Z.令ℓ=-lb <i>q</i>-+1, 因此, 2<sup>ℓ-1</sup>≤<i>q</i>&lt;2<sup>ℓ</sup>且<i>N</i>=<i>m</i>×ℓ.</p>
                </div>
                <div class="p1">
                    <p id="146"><b>定义8</b>. <i>PowerOf</i>2的幂运算.算法<i>PowerOf</i>2输入一个<i>m</i>维向量<b><i>v</i></b>=[<i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>, …, <i>v</i><sub><i>m</i></sub>]∈Z<mathml id="147"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>, 输出Z<sup><i>N</i></sup><sub><i>q</i></sub>中的一个<i>N</i>维向量:</p>
                </div>
                <div class="p1">
                    <p id="148"> (<i>v</i><sub>1</sub>, 2<i>v</i><sub>1</sub>, …, 2<sup>ℓ-1</sup><i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>, 2<i>v</i><sub>2</sub>, …, </p>
                </div>
                <div class="p1">
                    <p id="149">2<sup>ℓ-1</sup><i>v</i><sub>2</sub>, …, <i>v</i><sub><i>m</i></sub>, 2<i>v</i><sub><i>m</i></sub>, …, 2<sup>ℓ-1</sup><i>v</i><sub><i>m</i></sub>) <sup>T</sup>.</p>
                </div>
                <div class="p1">
                    <p id="150"><b>定义9</b>. <i>BitDecomp</i>比特分解.算法<i>BitDecomp</i>输入一个向量<b><i>v</i></b>∈Z<mathml id="151"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>, 输出一个<i>N</i>维向量, 其中<i>params</i>←MGSW.Setup (1<sup><i>κ</i></sup>, 1<sup><i>L</i></sup>) 是<i>v</i><sub><i>i</i></sub>二进制表示中的第<i>j</i>位 (按最低有效位到最高有效位排列) .换句话说:</p>
                </div>
                <div class="p1">
                    <p id="152"><i>v</i><sub><i>i</i></sub>=<mathml id="153"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>ℓ</mi><mo>-</mo><mn>1</mn></mrow></munderover><mn>2</mn></mstyle><msup><mrow></mrow><mi>j</mi></msup><mi>v</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>, </mo><mi>j</mi></mrow></msub><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="154"><b>定义10</b>. <i>BitDecomp</i>逆比特分解.算法<i>BitDecomp</i><sup>-1</sup>输入一个向量</p>
                </div>
                <div class="p1">
                    <p id="155"><b><i>v</i></b>= (<i>v</i><sub>1, 0</sub>, <i>v</i><sub>1, 1</sub>, …, <i>v</i><sub>1, ℓ-1</sub>, <i>v</i><sub>2, 0</sub>, <i>v</i><sub>2, 1</sub>, …, </p>
                </div>
                <div class="p1">
                    <p id="156"><i>v</i><sub>2, ℓ-1</sub>, …, <i>v</i><sub><i>m</i>, 0</sub>, <i>v</i><sub><i>m</i>, 1</sub>, …, <i>v</i><sub><i>m</i>, ℓ-1</sub>) <sup>T</sup>∈Z<mathml id="157"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>Ν</mi></msubsup></mrow></math></mathml>, </p>
                </div>
                <div class="p1">
                    <p id="158">输出:</p>
                </div>
                <div class="p1">
                    <p id="159"><mathml id="160"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo> (</mo><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>ℓ</mi><mo>-</mo><mn>1</mn></mrow></munderover><mn>2</mn></mstyle><msup><mrow></mrow><mi>j</mi></msup><mi>v</mi><msub><mrow></mrow><mrow><mn>1</mn><mo>, </mo><mi>j</mi></mrow></msub><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>ℓ</mi><mo>-</mo><mn>1</mn></mrow></munderover><mn>2</mn></mstyle><msup><mrow></mrow><mi>j</mi></msup><mi>v</mi><msub><mrow></mrow><mrow><mn>2</mn><mo>, </mo><mi>j</mi></mrow></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>ℓ</mi><mo>-</mo><mn>1</mn></mrow></munderover><mn>2</mn></mstyle><msup><mrow></mrow><mi>j</mi></msup><mi>v</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>, </mo><mi>j</mi></mrow></msub></mrow><mo>) </mo></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow></math></mathml>∈Z<mathml id="161"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="162">这里, 输入向量<b><i>v</i></b>不需要是{0, 1}-向量, 可以是Z<sup><i>N</i></sup>上的任意向量.</p>
                </div>
                <div class="p1">
                    <p id="163"><b>定义11</b>. <i>Flatten</i>展平运算.算法<i>Flatten</i>输入一个向量<b><i>v</i></b>∈Z<mathml id="164"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>Ν</mi></msubsup></mrow></math></mathml>, 并输出一个<i>N</i>维二元向量 (即{0, 1}<sup><i>N</i></sup>的一个元素) .将该算法定义为</p>
                </div>
                <div class="p1">
                    <p id="165"><i>Flatten</i> (<b><i>v</i></b>) =<i>BitDecomp</i> (<i>BitDecomp</i><sup>-1</sup> (<b><i>v</i></b>) ) .</p>
                </div>
                <div class="p1">
                    <p id="166"><b>注2</b>. 令<b><i>x</i></b>, <b><i>y</i></b>∈Z<mathml id="167"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>且<b><i>x</i></b>′∈Z<mathml id="168"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>Ν</mi></msubsup></mrow></math></mathml>.那么:</p>
                </div>
                <div class="p1">
                    <p id="169">〈<i>BitDecomp</i> (<b><i>x</i></b>) , <i>PowersOf</i>2 (<b><i>y</i></b>) 〉=〈<b><i>x</i></b>, <b><i>y</i></b>〉且〈<b><i>x</i></b>′, <i>PowersOf</i>2 (<b><i>y</i></b>) 〉=〈<i>BitDecomp</i><sup>-1</sup> (<b><i>x</i></b>′) , <b><i>y</i></b>〉=〈<i>BitDecomp</i> (<i>BitDecomp</i><sup>-1</sup> (<b><i>x</i></b>′) ) , <i>PowersOf</i>2 (<b><i>y</i></b>) 〉=〈<i>Flatten</i> (<b><i>x</i></b>′) , <i>PowersOf</i>2 (<b><i>y</i></b>) 〉.</p>
                </div>
                <div class="p1">
                    <p id="170">以上算法可以从向量扩展到矩阵.可以根据Micciancio和Peikert<citation id="666" type="reference"><link href="623" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>的工具矩阵 (gadget matrix) <b><i>G</i></b>来解释上面的函数.首先定义<b><i>G</i></b>=<b><i>I</i></b><sub><i>m</i></sub>⨂<b><i>g</i></b>∈Z<mathml id="171"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>, 其中, <b><i>g</i></b>= (1, 2, 4, …, 2<sup>ℓ-1</sup>) <sup>T</sup>.对于<b><i>v</i></b>∈Z<mathml id="172"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>, 有<i>PowersOf</i>2 (<b><i>v</i></b>) =<b><i>v</i></b><sup>T</sup><b><i>G</i></b>.对于<b><i>v</i></b>∈Z<mathml id="173"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>Ν</mi></msubsup></mrow></math></mathml>, 有<i>BitDecomp</i><sup>-1</sup> (<b><i>v</i></b>) =<b><i>G</i><i>v</i></b>.对于<b><i>x</i></b>∈Z<mathml id="174"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>, 算法<i>BitDecomp</i> (<b><i>x</i></b>) 可以重命名为<b><i>G</i></b><sup>-1</sup> (<b><i>x</i></b>) .上面的定义和结果能够用<b><i>G</i></b>和<b><i>G</i></b><sup>-1</sup>的方式来解释, 参见引理3.</p>
                </div>
                <div class="p1">
                    <p id="175"><b>引理3</b><citation id="667" type="reference"><link href="623" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>. 对于任意的<i>N</i>≥<i>m</i>-lb <i>q</i>-, 存在一个固定的有效可计算矩阵<b><i>G</i></b>∈Z<mathml id="176"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>和一个有效可计算确定性“短原象”函数<b><i>G</i></b><sup>-1</sup> (·) 满足如下条件.对于任意的<i>m</i>′, 输入一个矩阵<b><i>M</i></b>∈Z<mathml id="177"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><msup><mi>m</mi><mo>′</mo></msup></mrow></msubsup></mrow></math></mathml>, 逆函数<b><i>G</i></b><sup>-1</sup> (<b><i>M</i></b>) 输出一个矩阵<b><i>G</i></b><sup>-1</sup> (<b><i>M</i></b>) ∈{0, 1}<sup><i>N</i>×<i>m</i>′</sup>使得<b><i>G</i><i>G</i></b><sup>-1</sup> (<b><i>M</i></b>) =<b><i>M</i></b>.</p>
                </div>
                <div class="p1">
                    <p id="178">因此, 可以将<b><i>G</i></b>看作一个具有“公共陷门”的特殊矩阵, 它允许解决最小整数解 (short integer solution, SIS) 问题.这里, <b><i>G</i></b><sup>-1</sup> (·) 是一个有效可计算的函数.</p>
                </div>
                <h3 id="179" name="179" class="anchor-tag"><b>2 GSW方案</b></h3>
                <div class="p1">
                    <p id="180">本节首先介绍全同态加密GSW方案<citation id="668" type="reference"><link href="593" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>, 然后介绍李增鹏等人<citation id="669" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>对该方案的自适应攻击, 该攻击与Chenal和Tang<citation id="670" type="reference"><link href="579" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>的攻击类似.</p>
                </div>
                <h4 class="anchor-tag" id="181" name="181"><b>2.1 GSW方案</b></h4>
                <div class="p1">
                    <p id="182">令<i>κ</i>为安全参数, <i>L</i>为同态加密的层级数.leveled-FHE方案的层级数.给出GSW<citation id="671" type="reference"><link href="593" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>方案的简要描述, 该方案最初是根据函数<i>BitDecomp</i>, <i>BitDecomp</i><sup>-1</sup>, <i>Flatten</i>定义的, 但是本文采用Alperin-Sheriff等人<citation id="672" type="reference"><link href="627" rel="bibliography" /><sup>[<a class="sup">27</a>]</sup></citation>的简化方式, 即使用工具矩阵<b><i>G</i></b>定义.</p>
                </div>
                <h4 class="anchor-tag" id="183" name="183">1) GSW初始化算法<i>GSW</i>.<i>Setup</i> (1<sup><i>κ</i></sup>, 1<sup><i>L</i></sup>) :</h4>
                <div class="p1">
                    <p id="184">① 选择<i>κ</i>比特的一个模<i>q</i>, 参数<i>n</i>=<i>n</i> (<i>κ</i>, <i>L</i>) ∈N和Z上的错误分布<i>χ</i>=<i>χ</i> (<i>κ</i>, <i>L</i>) , 使得LWE问题对于已知攻击实现至少2<sup><i>κ</i></sup>的安全性, 选择一个参数<i>m</i>=<i>m</i> (<i>κ</i>, <i>L</i>) =<i>O</i> (<i>n</i> lb <i>q</i>) .</p>
                </div>
                <div class="p1">
                    <p id="185">② 输出参数<i>params</i>= (<i>n</i>, <i>q</i>, <i>χ</i>, <i>m</i>) , 并令ℓ=-lb <i>q</i>-+1和<i>N</i>= (<i>n</i>+1) ℓ.</p>
                </div>
                <h4 class="anchor-tag" id="186" name="186">2) GSW密钥生成算法<i>GSW</i>.<i>KeyGen</i> (<i>params</i>) :</h4>
                <div class="p1">
                    <p id="187">① 均匀选取<b><i>t</i></b>= (<i>t</i><sub>1</sub>, <i>t</i><sub>2</sub>, …, <i>t</i><sub><i>n</i></sub>) <sup>T</sup>←Z<mathml id="188"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>, 并计算:</p>
                </div>
                <div class="p1">
                    <p id="189"><b><i>s</i></b>← (1, -<b><i>t</i></b><sup>T</sup>) <sup>T</sup>= (1, -<i>t</i><sub>1</sub>, -<i>t</i><sub>2</sub>, …, -<i>t</i><sub><i>n</i></sub>) <sup>T</sup>∈Z<mathml id="190"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mo>×</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="191">② 均匀选取随机公共矩阵<b><i>B</i></b>←Z<mathml id="192"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msubsup></mrow></math></mathml>和一个错误向量<b><i>e</i></b>←<i>χ</i><sup><i>m</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="193">③ 计算向量<b><i>b</i></b>=<b><i>B</i><i>t</i></b>+<b><i>e</i></b>∈Z<mathml id="194"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>并构造矩阵<b><i>A</i></b>= (<b><i>b</i></b>|<b><i>B</i></b>) ∈Z<mathml id="195"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msubsup></mrow></math></mathml>, 并满足:</p>
                </div>
                <div class="area_img" id="573">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JFYZ201903004_57300.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="198">④ 返回私钥<i>sk</i>←<b><i>s</i></b>和公钥<i>pk</i>←<b><i>A</i></b>.</p>
                </div>
                <h4 class="anchor-tag" id="199" name="199">3) GSW加密算法<b><i>C</i></b>←<i>GSW</i>.<i>Enc</i> (<i>pk</i>, <i>μ</i>) :</h4>
                <div class="p1">
                    <p id="200">① 令<b><i>G</i></b>为上述 (<i>n</i>+1) ×<i>N</i>维的工具矩阵, 并均匀选取一个随机矩阵<b><i>R</i></b>←{0, 1}<sup><i>m</i>×<i>N</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="202">② 加密单比特消息<i>μ</i>∈{0, 1}, 并生成密文</p>
                </div>
                <div class="p1">
                    <p id="203"><b><i>C</i></b>=<i>μ</i><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b> (mod <i>q</i>) ∈Z<mathml id="204"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>, </p>
                </div>
                <div class="p1">
                    <p id="205">需注意的是, 在原GSW方案中, 加密算法使用:</p>
                </div>
                <div class="p1">
                    <p id="206"><i>Flatten</i> (<i>μ</i><b>I</b>+<i>BitDecomp</i> (<b><i>R</i><i>A</i></b>) ) ∈{0, 1}<sup><i>N</i>×<i>N</i></sup>, </p>
                </div>
                <div class="p1">
                    <p id="207">其中, <b>I</b>是一个单位矩阵.</p>
                </div>
                <h4 class="anchor-tag" id="208" name="208">4) GSW解密算法<i>μ</i>′←<i>GSW</i>.<i>Dec</i> (<i>sk</i>, <b><i>C</i></b>) :</h4>
                <div class="p1">
                    <p id="209">① 输入私钥<i>sk</i>=<b><i>s</i></b>∈Z<mathml id="210"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>, 令<i>k</i>满足<i>q</i>/4&lt;2<sup><i>k</i>-1</sup>≤<i>q</i>/2, 其中<b><i>C</i></b>[<i>k</i>]为<b><i>C</i></b>的第<i>k</i>列.</p>
                </div>
                <div class="p1">
                    <p id="211">② 在 (-<i>q</i>/2, <i>q</i>/2]范围内计算<i>x</i>←〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉 (mod <i>q</i>) , 这里有〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉=<b><i>C</i></b>[<i>k</i>]<sup>T</sup><b><i>s</i></b>, 并有:</p>
                </div>
                <div class="p1">
                    <p id="212"><b><i>C</i></b><sup>T</sup><b><i>s</i></b>=<i>μ</i><b><i>G</i></b><sup>T</sup><b><i>s</i></b>+<b><i>R</i></b><sup>T</sup><b><i>A</i><i>s</i></b>=<i>μ</i> (1, 2, 4, …) <sup>T</sup>+<b><i>R</i></b><sup>T</sup><b><i>e</i></b>.</p>
                </div>
                <div class="p1">
                    <p id="213">由上, 可以看出, 计算时所选择密文矩阵<b><i>C</i></b>的第<i>k</i>列, 对应着向量〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉的第<i>k</i>个坐标, 即<i>μ</i>2<sup><i>k</i>-1</sup>+<b><i>R</i></b><sup>T</sup><sub><i>k</i></sub><b><i>e</i></b>.</p>
                </div>
                <div class="p1">
                    <p id="214">③ 输出<mathml id="215"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>μ</mi><mo>′</mo></msup><mo>=</mo><mrow><mo>|</mo><mrow><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow><mi>x</mi><mo>/</mo><mn>2</mn><msup><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msup><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow></mrow><mo>|</mo></mrow></mrow></math></mathml>.因此, 如果|<i>x</i>|&lt;2<sup><i>k</i>-2</sup>≤<i>q</i>/4, 则返回0;否则返回1.</p>
                </div>
                <h4 class="anchor-tag" id="216" name="216">5) GSW运算算法</h4>
                <div class="p1">
                    <p id="217"><i>GSW</i>.<i>Eval</i> (<i>pk</i>, (<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>, …, <b><i>C</i></b><sub><i>l</i></sub>) ) :</p>
                </div>
                <div class="p1">
                    <p id="218">① 加法运算<i>GSW</i>.<i>Add</i> (<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>) ∈Z<mathml id="219"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>输出:</p>
                </div>
                <div class="p1">
                    <p id="220"><b><i>C</i></b><sub>1</sub>+<b><i>C</i></b><sub>2</sub>= (<i>μ</i><sub>1</sub>+<i>μ</i><sub>2</sub>) <b><i>G</i></b>+<b><i>A</i></b><sup>T</sup> (<b><i>R</i></b><sub>1</sub>+<b><i>R</i></b><sub>2</sub>) .</p>
                </div>
                <div class="p1">
                    <p id="221">② 乘法运算<i>GSW</i>.<i>Mult</i> (<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>) 计算并输出:</p>
                </div>
                <div class="p1">
                    <p id="222"><b><i>C</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) = (<i>μ</i><sub>1</sub><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>1</sub>) <b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) =<i>μ</i><sub>1</sub><b><i>C</i></b><sub>2</sub>+</p>
                </div>
                <div class="p1">
                    <p id="223"><b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) =<i>μ</i><sub>1</sub><i>μ</i><sub>2</sub><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) +</p>
                </div>
                <div class="p1">
                    <p id="224"><i>μ</i><sub>1</sub><b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>2</sub>=<i>μ</i><sub>1</sub><i>μ</i><sub>2</sub><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup> (<b><i>R</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) +<i>μ</i><sub>1</sub><b><i>R</i></b><sub>2</sub>) .</p>
                </div>
                <div class="p1">
                    <p id="225">注意<b><i>C</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) ∈Z<mathml id="226"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>.此外, 利用<b><i>G</i></b>-<b><i>C</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) 计算同态NAND门.</p>
                </div>
                <div class="p1">
                    <p id="227"><b>注3</b>. Mukherjee等<citation id="673" type="reference"><link href="613" rel="bibliography" /><sup>[<a class="sup">20</a>]</sup></citation>方案中的解密算法公式是为了选择一个特定的向量<b><i>w</i></b>来计算<b><i>s</i><i>C</i><i>G</i></b><sup>-1</sup> (<b><i>w</i></b>) <sup>T</sup>, 但相比原GSW方案的解密算法效率要低得多 (无论是计算时间还是噪声项的大小) .因此本文仍将采用原GSW方案的解密算法.此外, 当<i>q</i>为2的幂时, 还存在另外一种方式处理Z<sup><i>q</i></sup>上的信息.具体细节参见文献<citation id="674" type="reference">[<a class="sup">10</a>]</citation>.</p>
                </div>
                <h4 class="anchor-tag" id="228" name="228"><b>2.2 安全性</b></h4>
                <div class="p1">
                    <p id="229"><b>定理1</b>. 对于参数<i>m</i>=<i>O</i> (<i>n</i> lb <i>q</i>) , 令参数 (<i>m</i>, <i>n</i>, <i>q</i>, <i>χ</i>) 使得LWE困难假设成立, 那么该GSW方案是IND-CPA安全的.</p>
                </div>
                <div class="p1">
                    <p id="230">该证明的主要步骤是证明 (<b><i>A</i></b>, <b><i>RA</i></b>) 和均匀分布计算不可区分, 本文不再赘述.</p>
                </div>
                <h4 class="anchor-tag" id="231" name="231"><b>2.3 密钥恢复攻击</b></h4>
                <div class="p1">
                    <p id="232">本节着重介绍能够恢复GSW方案私钥的2种自适应攻击.尽管该类攻击方式超出了原始GSW方案<citation id="675" type="reference"><link href="593" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>安全模型的范围, 但这种类型的攻击却是众所周知的.</p>
                </div>
                <div class="p1">
                    <p id="233">1) 自适应攻击1.该类自适应密钥恢复攻击, 类似于Chenal和Tang<citation id="676" type="reference"><link href="579" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>的攻击.敌手通过询问一些解密预言机来恢复私钥<b><i>s</i></b>= (1, -<b><i>t</i></b><sup>T</sup>) <sup>T</sup>.</p>
                </div>
                <div class="p1">
                    <p id="234">敌手选择密文矩阵<b><i>C</i></b>并询问解密预言机, 并且该预言机将返回〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉的“最高有效位 (most signification bit, <i>MSB</i>) ”, 其中<b><i>C</i></b>[<i>k</i>]是<b><i>C</i></b>的第<i>k</i>列并且<i>k</i>对于敌手来说是已知的.实际计算-<b><i>C</i></b>[<i>k</i>]<sup>T</sup><b><i>s</i></b> (mod <i>q</i>) /2<sup><i>k</i>-1</sup>-, 即<i>MSB</i>.</p>
                </div>
                <div class="p1">
                    <p id="235">简单来说, 敌手选择适当<i>M</i>值放在指定的密文位置, 即敌手选择<b><i>C</i></b>[<i>k</i>]= (0, 0, …, 0, <i>M</i>, 0, …, 0) <sup>T</sup>, 并逐位计算得到该私钥的各位.例如为了计算<i>t</i><sub>1</sub>∈Z<sub><i>q</i></sub>, 令<b><i>C</i></b>[<i>k</i>]= (0, 1, 0, …, 0) <sup>T</sup>, 然后对该密文矩阵进行一次解密预言机查询.因此:</p>
                </div>
                <div class="p1">
                    <p id="236">〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉=-<i>t</i><sub>1</sub>, </p>
                </div>
                <div class="p1">
                    <p id="237">所以敌手能够得到<i>t</i><sub>1</sub>的<i>MSB</i>之后, 重新计算 (例如通过选择密文向量<b><i>C</i></b>[<i>k</i>]= (0, 2, 0, …, 0) ) 获得2 (-<i>t</i><sub>1</sub>) (mod <i>q</i>) 的<i>MSB</i>, 这样就产生了关于下一个<i>MSB</i>的信息 (但是, 如果当<i>MSB</i>=1时, 敌手需要考虑到规约, 即进行降模处理) .而实际攻击时, 为了区分正负值, 敌手可以选择形如<b><i>C</i></b>[<i>k</i>]= (<i>M</i>, 1, 0, …, 0) 的密文向量, 因为该向量提供〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉=<i>M</i>-<i>t</i><sub>1</sub>的<i>MSB</i>.本文不再赘述, 有关该类攻击的详细讨论可参见文献<citation id="677" type="reference">[<a class="sup">3</a>]</citation>.</p>
                </div>
                <div class="p1">
                    <p id="238">如上描述, 调用解密预言机所查询矩阵的第<i>k</i>列是一个单位向量.因此, 一个通用的方法是通过禁止选择这种形式的密文来避免这种攻击.但是由于GSW方案是同态的, 攻击者总能够将一个随机的0的加密添加到密文上, 使得该修改后的密文矩阵<b><i>C</i></b>与其他密文矩阵一样, 不能被解密算法区分而正常解密.当然, 正如Loftus等人<citation id="678" type="reference"><link href="585" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>所做的工作, 考虑其他形式的解密算法, 只需确定一个密文是否“正确地形成”即可, 即是否是“有效密文”.但李增鹏等人<citation id="679" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>则提出“多密钥的同态加密”方案来抵抗上述自适应攻击1, 将在第4节给出更详细的描述.</p>
                </div>
                <div class="p1">
                    <p id="239">2) 自适应攻击2.上述攻击1的主要目标是得到<b><i>b</i></b>=<b><i>B</i><i>t</i></b>+<b><i>e</i></b>中的秘密值<b><i>t</i></b>.然而, 如果能够计算出噪声向量<b><i>e</i></b>, 然后利用公共矩阵<b><i>B</i></b>和LWE实例<b><i>b</i></b>所存在的运算关系, 也能够确定秘密向量<b><i>t</i></b>的值.因此本文给出了一个方法来确定噪声向量<b><i>e</i></b>.具体步骤为:</p>
                </div>
                <div class="p1">
                    <p id="240">步骤1. 对于任意的1≤<i>j</i>≤<i>m</i>, 为了得到噪声向量<b><i>e</i></b>的第<i>j</i>个噪声项<i>e</i><sub><i>j</i></sub>, 首先考虑公钥矩阵<b><i>A</i></b>的第<i>j</i>行, 并记为<b><i>a</i></b><sup><i>j</i></sup>= (<b><i>b</i></b><sup><i>j</i></sup><b><i>t</i></b>+<i>e</i><sub><i>j</i></sub> (mod <i>q</i>) |<b><i>b</i></b><sup><i>j</i></sup>) ∈Z<sup>1× (<i>n</i>+1) </sup><sub><i>q</i></sub>.然后, 将这一行插入到密文矩阵的第<i>k</i>列中, 因此设<b><i>C</i></b>[<i>k</i>]= (<b><i>a</i></b><sup><i>j</i></sup>) <sup>T</sup>, 并令<b><i>C</i></b>的其他列为0.</p>
                </div>
                <div class="p1">
                    <p id="241">步骤2. 在上述情况下, 解密预言机计算:</p>
                </div>
                <div class="p1">
                    <p id="242">〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉=<b><i>C</i></b>[<i>k</i>]<sup>T</sup><b><i>s</i></b>=<b><i>a</i></b><sup><i>j</i></sup><b><i>s</i></b>= (<b><i>b</i></b><sup><i>j</i></sup><b><i>t</i></b>+<i>e</i><sub><i>j</i></sub> (mod <i>q</i>) |<b><i>b</i></b><sup><i>j</i></sup>) (1, -<b><i>t</i></b><sup>T</sup>) <sup>T</sup>=<b><i>b</i></b><sup><i>j</i></sup><b><i>t</i></b>+<i>e</i><sub><i>j</i></sub>-<b><i>b</i></b><sup><i>j</i></sup><b><i>t</i></b>=<i>e</i><sub><i>j</i></sub>, </p>
                </div>
                <div class="p1">
                    <p id="245">并返回<mathml id="246"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow><mi>e</mi><msub><mrow></mrow><mi>j</mi></msub><mo>/</mo><mn>2</mn><msup><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msup><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow></mrow><mo>|</mo></mrow></mrow></math></mathml>.因此能够得到<i>e</i><sub><i>j</i></sub>的<i>MSB</i> (因为该位肯定为0, 因为<i>e</i><sub><i>j</i></sub>应该是小于<i>q</i>的) .</p>
                </div>
                <div class="p1">
                    <p id="247">步骤3. 为了扩展该攻击, 敌手选择一个整数-<i>q</i>/2&lt;<i>μ</i>&lt;<i>q</i>/2, 并利用<mathml id="248"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">a</mi><mo>¯</mo></mover><msup><mrow></mrow><mi>j</mi></msup><mo>=</mo><mi mathvariant="bold-italic">a</mi><msup><mrow></mrow><mi>j</mi></msup><mo>+</mo><mo stretchy="false"> (</mo><mi>μ</mi><mo stretchy="false">|</mo><mn>0</mn><mo>, </mo><mn>0</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml>来替换<b><i>a</i></b><sup><i>j</i></sup>, 并通过逐步尝试<i>μ</i>=1, 2, 4, …, 2<sup><i>d</i></sup>值来重复进行解密计算, 以此实现对方案的自适应攻击.因此解密预言机返回<mathml id="249"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow><mo stretchy="false"> (</mo><mi>e</mi><msub><mrow></mrow><mi>j</mi></msub><mo>+</mo><mi>μ</mi><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>/</mo><mn>2</mn><msup><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msup><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow></mrow><mo>|</mo></mrow></mrow></math></mathml>, 并确定该不等式|<i>e</i><sub><i>j</i></sub>+<i>μ</i>|&lt;2<sup><i>k</i>-2</sup>是否成立.</p>
                </div>
                <div class="p1">
                    <p id="250">步骤4. 通过尝试<i>μ</i>=1, 2, 4, …, 2<sup><i>d</i></sup>能够确定使得<i>e</i><sub><i>j</i></sub>+2<sup><i>d</i></sup>≥2<sup><i>k</i>-2</sup>成立的2的最小乘幂.这意味着不等式2<sup><i>k</i>-2</sup>-2<sup><i>d</i></sup>≤<i>e</i><sub><i>j</i></sub>&lt;2<sup><i>k</i>-2</sup>-2<sup><i>d</i>-1</sup>成立.此外, 利用二进制搜索类型算法, 使用大约<i>d</i>次解密预言机查询, 可以精确地确定噪声项<i>e</i><sub><i>j</i></sub>.</p>
                </div>
                <h3 id="251" name="251" class="anchor-tag"><b>3 MGSW方案</b></h3>
                <div class="p1">
                    <p id="252">第3节中已经概述了对GSW全同态加密方案的2种自适应攻击方法.本节首先概述李增鹏等人<citation id="680" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>抵抗自适应攻击1的多私钥GSW全同态加密方案 (MGSW) .然后, 给出对MGSW方案的自适应攻击2.</p>
                </div>
                <h4 class="anchor-tag" id="253" name="253"><b>3.1 MGSW方案</b></h4>
                <div class="p1">
                    <p id="254">为抵抗该攻击1, 李增鹏等人<citation id="681" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>改进了GSW方案的密钥生成算法.而GSW方案的密钥生成算法是选择形如[<b><i>B</i><i>t</i></b>+<b><i>e</i></b>|<b><i>B</i></b>]的公钥<b><i>A</i></b>, 其中私钥<b><i>t</i></b>是均匀随机选取的, <b><i>e</i></b>是一个短噪声向量, 而李增鹏等人<citation id="682" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>则不再仅使用只包含单个LWE实例的公钥, 而是采用结构的新公钥矩阵:</p>
                </div>
                <div class="p1">
                    <p id="255"><b><i>A</i></b>′=[<b><i>B</i><i>t</i></b><sup>1</sup>+<b><i>e</i></b><sup>1</sup>|<b><i>B</i><i>t</i></b><sup>2</sup>+<b><i>e</i></b><sup>2</sup>|…|<b><i>B</i><i>t</i></b><sup>ℓ</sup>+<b><i>e</i></b><sup>ℓ</sup>|<b><i>B</i></b>], </p>
                </div>
                <div class="p1">
                    <p id="256">其中, 秘密向量<b><i>t</i></b><sup>1</sup>, <b><i>t</i></b><sup>2</sup>, …, <b><i>t</i></b><sup>ℓ</sup>均匀取自分布Z<mathml id="257"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>, 噪声向量<b><i>e</i></b><sup>1</sup>, <b><i>e</i></b><sup>2</sup>, …, <b><i>e</i></b><sup>ℓ</sup>取自离散高斯分布<i>χ</i><sup><i>m</i></sup>.为方便, 记噪声元素为<b><i>e</i></b><sup><i>i</i></sup>= (<i>e</i><mathml id="258"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>i</mi></msubsup></mrow></math></mathml>, <i>e</i><mathml id="259"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>, …, <i>e</i><mathml id="260"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>m</mi><mi>i</mi></msubsup></mrow></math></mathml>) <sup>T</sup>.基于此, 令私钥为<b><i>s</i></b><sup>1</sup>= (1, 0, …, 0, - (<b><i>t</i></b><sup>1</sup>) <sup>T</sup>) <sup>T</sup>, …, <b><i>s</i></b><sup>ℓ</sup>= (0, …, 0, 1, - (<b><i>t</i></b><sup>ℓ</sup>) <sup>T</sup>) <sup>T</sup>.因此<b><i>A</i></b>′<b><i>s</i></b><sup><i>i</i></sup>=<b><i>e</i></b><sup><i>i</i></sup> (mod <i>q</i>) , 其中1≤<i>i</i>≤ℓ.最后, 每运行一次解密算法, 生成一个新的随机一次秘密:</p>
                </div>
                <div class="p1">
                    <p id="261"><b><i>s</i></b>′=<mathml id="262"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>ℓ</mi></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">s</mi><msup><mrow></mrow><mi>i</mi></msup><mo>, </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="263">当整数<i>λ</i><sub><i>i</i></sub>很小 (例如可以取<i>λ</i><sub><i>i</i></sub>∈{0, 1}或{-1, 0, 1}或取自一个离散高斯分布) , 那么:</p>
                </div>
                <div class="p1">
                    <p id="264" class="code-formula"><mathml id="265"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><msup><mi mathvariant="bold-italic">A</mi><mo>′</mo></msup><msup><mi mathvariant="bold-italic">s</mi><mo>′</mo></msup><mo>=</mo></mrow></math></mathml><mathml id="266"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>ℓ</mi></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><msup><mi mathvariant="bold-italic">A</mi><mo>′</mo></msup><mi mathvariant="bold-italic">s</mi><msup><mrow></mrow><mi>i</mi></msup><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>ℓ</mi></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="267">是一个短向量, 且至少存在2<sup>ℓ</sup>个可能的私钥.因此, 在这种情况下, 即使为了确保在实际使用过程中, 方案中所有的私钥使用次数不超过一次, 那么ℓ也并不需要很大的取值.</p>
                </div>
                <div class="p1">
                    <p id="268">简要回顾李增鹏等人<citation id="683" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>的MGSW方案.</p>
                </div>
                <h4 class="anchor-tag" id="269" name="269">1) MGSW初始化算法</h4>
                <div class="p1">
                    <p id="270"><i>params</i>←<i>MGSW</i>.<i>Setup</i> (1<sup><i>κ</i></sup>, 1<sup><i>L</i></sup>) :</p>
                </div>
                <div class="p1">
                    <p id="271">① 与GSW方案的初始化算法相同, 区别在于选择参数ϕ=<i>O</i> (lb <i>n</i>) (私钥的数量) .</p>
                </div>
                <div class="p1">
                    <p id="272">② 输出公共参数<i>params</i>= (<i>n</i>, <i>q</i>, <i>χ</i>, <i>m</i>, ϕ) , 并令ℓ=-lb <i>q</i>-+1且<i>N</i>= (ϕ+<i>n</i>) ℓ.</p>
                </div>
                <h4 class="anchor-tag" id="273" name="273">2) MGSW密钥生成算法</h4>
                <div class="p1">
                    <p id="274"> (<i>pk</i>, <i>sk</i>) ←<i>MGSW</i>.<i>KeyGen</i> (<i>params</i>) :</p>
                </div>
                <div class="p1">
                    <p id="275">① 均匀选取<b><i>t</i></b><sup><i>i</i></sup>←Z<mathml id="276"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>, <i>i</i>∈[ϕ]并输出:</p>
                </div>
                <div class="p1">
                    <p id="277"><b><i>s</i></b><sup><i>i</i></sup>← (<b><i>I</i></b><sub><i>i</i></sub>|- (<b><i>t</i></b><sup><i>i</i></sup>) <sup>T</sup>) <sup>T</sup>= (0, 0, …, 1, …, 0, -<i>t</i><mathml id="279"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>i</mi></msubsup></mrow></math></mathml>, -<i>t</i><mathml id="280"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>, …, -<i>t</i><mathml id="281"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>n</mi><mi>i</mi></msubsup></mrow></math></mathml>) <sup>T</sup>∈Z<mathml id="282"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>+</mo><mtext>ϕ</mtext></mrow></msubsup></mrow></math></mathml>, </p>
                </div>
                <div class="p1">
                    <p id="283">其中, <b><i>I</i></b><sub><i>i</i></sub>是 (ϕ×ϕ) 维单位矩阵<b><i>I</i></b>的第<i>i</i>行且使得<b><i>s</i></b><sup><i>i</i></sup>的第<i>i</i>个坐标等于1.</p>
                </div>
                <div class="p1">
                    <p id="284">② 对于<i>i</i>∈[ϕ], 均匀选取公共矩阵<b><i>B</i></b>←Z<mathml id="285"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msubsup></mrow></math></mathml>和ϕ个噪声向量<b><i>e</i></b><sup><i>i</i></sup>←<i>χ</i><sup><i>m</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="286">③ 计算<b><i>b</i></b><sup><i>i</i></sup>=<b><i>B</i><i>t</i></b><sup><i>i</i></sup>+<b><i>e</i></b><sup><i>i</i></sup>∈Z<mathml id="287"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>m</mi></msubsup></mrow></math></mathml>, 并生成公钥矩阵<b><i>A</i></b>′=[<b><i>b</i></b><sup><i>i</i></sup>|<b><i>b</i></b><sup>2</sup>|…|<b><i>b</i></b><sup>ϕ</sup>|<b><i>B</i></b>]∈Z<mathml id="288"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>m</mi><mo>×</mo><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mtext>ϕ</mtext><mo stretchy="false">) </mo></mrow></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="289">④ 输出<i>pk</i>←<b><i>A</i></b>′和<i>sk</i>←{<b><i>s</i></b><sup>1</sup>, <b><i>s</i></b><sup>2</sup>, …, <b><i>s</i></b><sup>ϕ</sup>}.</p>
                </div>
                <h4 class="anchor-tag" id="290" name="290">3) MGSW加密算法<b><i>C</i></b>←<i>MGSW</i>.<i>Enc</i> (<i>pk</i>, <i>μ</i>) :</h4>
                <div class="p1">
                    <p id="291">① 加密一个消息<i>μ</i>∈Z<sub><i>q</i></sub>, 均匀选取一个随机矩阵<b><i>R</i></b>′∈{0, 1}<sup><i>m</i>×<i>N</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="292">② 计算并输出密文<b><i>C</i></b>=<i>μ</i><b><i>G</i></b>+<b><i>A</i></b>′<sup>T</sup><b><i>R</i></b>′∈Z<mathml id="293"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>+</mo><mtext>ϕ</mtext><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>, 其中<b><i>G</i></b>为 (<i>n</i>+ϕ) ×<i>N</i>维工具矩阵.</p>
                </div>
                <h4 class="anchor-tag" id="294" name="294">4) MGSW解密算法<i>μ</i>′←<i>MGSW</i>.<i>Dec</i> (<i>sk</i>, <b><i>C</i></b>) :</h4>
                <div class="p1">
                    <p id="295">① 从{0, 1}均匀选择非0的<i>λ</i><sub>1</sub>, <i>λ</i><sub>2</sub>, …, <i>λ</i><sub>ϕ</sub>, 并生成一个一次密钥<b><i>s</i></b>′=<mathml id="296"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">s</mi><msup><mrow></mrow><mi>i</mi></msup><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="297">② 选择一个整数1≤<i>i</i>≤ϕ, 使得<i>λ</i><sub><i>i</i></sub>=1, 且令<i>k</i>= (<i>i</i>-1) ℓ+<i>j</i>, 使得<b><i>G</i></b>的第<i>k</i>列的第<i>i</i>个数是2<sup><i>j</i>-1</sup>, 其中<i>q</i>/4&lt;2<sup><i>j</i>-1</sup>≤<i>q</i>/2.</p>
                </div>
                <div class="p1">
                    <p id="298">③ 在 (-<i>q</i>/2, <i>q</i>/2]范围内计算:</p>
                </div>
                <div class="p1">
                    <p id="299"><i>x</i>=〈<b><i>C</i></b>[<i>k</i>], <b><i>s</i></b>〉 (mod <i>q</i>) =<b><i>C</i></b>[<i>k</i>]<sup>T</sup><b><i>s</i></b> (mod <i>q</i>) .</p>
                </div>
                <div class="p1">
                    <p id="300">④ 输出<i>μ</i>′=<mathml id="301"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow><mi>x</mi><mo>/</mo><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow></mrow><mo>|</mo></mrow><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="302">同态运算跟原始GSW方案完全相同.</p>
                </div>
                <h4 class="anchor-tag" id="303" name="303"><b>3.2 对MGSW方案的自适应攻击 (自适应攻击2</b>) </h4>
                <div class="p1">
                    <p id="304">该类攻击的主要目标是利用噪声向量<b><i>e</i></b>来恢复秘密向量<b><i>t</i></b>, 为实现该目标, 需要将<b><i>C</i></b>的第<i>k</i>列设成<b><i>A</i></b>的第<i>j</i>行<b><i>a</i></b><sup><i>j</i></sup>的转置, 并将<b><i>C</i></b>的所有其他列设为0.实际上, 与对MGSW方案的自适应攻击1的最主要不同在于<i>k</i>值是变化的, 且攻击者并不知晓.显然, 该攻击方法比自适应攻击1要困难的多.重复使用上述方法去计算向量<b><i>e</i></b><sup>1</sup>的第<i>j</i>个元素<i>e</i><mathml id="305"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mn>1</mn></msubsup></mrow></math></mathml>, 攻击者便可以获得向量<b><i>e</i></b><sup>1</sup>, 那么敌手就能通过使用格算法来解决LWE的一个更简单的实例<mathml id="306"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">B</mi><mo>, </mo><msup><mi mathvariant="bold-italic">b</mi><mo>′</mo></msup><mo>=</mo><mi mathvariant="bold-italic">B</mi><mtext> </mtext><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mn>1</mn></msup><mo>+</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false">) </mo></mrow></math></mathml>从而完成密码分析.</p>
                </div>
                <div class="p1">
                    <p id="307">对该攻击的具体描述如下, 令:</p>
                </div>
                <div class="p1">
                    <p id="308"><b><i>a</i></b><sup><i>j</i></sup>= (<b><i>b</i></b><sup><i>j</i></sup><b><i>t</i></b><sup>1</sup>+<i>e</i><mathml id="309"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>, <b><i>b</i></b><sup><i>j</i></sup><b><i>t</i></b><sup>2</sup>+<i>e</i><mathml id="310"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>j</mi></msubsup></mrow></math></mathml>, …, <b><i>b</i></b><sup><i>j</i></sup><b><i>t</i></b><sup>ϕ</sup>+<i>e</i><mathml id="311"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mtext>ϕ</mtext><mi>j</mi></msubsup></mrow></math></mathml>, <b><i>b</i></b><sub><i>j</i></sub>) , </p>
                </div>
                <div class="p1">
                    <p id="312">且一次私钥是<b><i>s</i></b>′= (<i>λ</i><sub>1</sub>, <i>λ</i><sub>2</sub>, …, <i>λ</i><sub>ϕ</sub>, <mathml id="313"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mi>i</mi></munder><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow></math></mathml>.令<i>k</i>′使得<i>q</i>/4&lt;2<sup><i>k</i>′-1</sup>≤<i>q</i>/2成立, 将<b><i>a</i></b><sub><i>j</i></sub>放入<b><i>C</i></b>的第<i>k</i>′列, 并且将其他所有列全设为0.攻击者希望解密算法选择<i>λ</i><sub>1</sub>=1和<i>k</i>=<i>k</i>′.那么有1/2的概率使得<i>λ</i><sub>1</sub>=1, 平均情况下大约有ϕ/2的概率使得<i>λ</i><sub><i>i</i></sub>=1.</p>
                </div>
                <div class="p1">
                    <p id="314">这里需注意的是, 对于攻击者为什么能够获知<i>λ</i><sub><i>i</i></sub>=1, 其原因在于, 当解密者选择一些<i>i</i>并令<i>λ</i><sub><i>i</i></sub>=1, 进而计算<mathml id="315"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo></mrow></math></mathml><mathml id="316"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>和<mathml id="317"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mo>⋅</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mi>μ</mi><mi>λ</mi><msub><mrow></mrow><mi>i</mi></msub><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>E</mi></mrow></math></mathml>.而攻击者则选择一个<b><i>C</i></b>使得除第<i>k</i>列<b><i>C</i></b>[<i>k</i>]外其他所有列均为0.那么, 如果<i>λ</i><sub><i>i</i></sub>≠1, 解密返回值为0.而如果攻击者从解密预言机中获得一个非零值, 那么他就确定<i>λ</i><sub><i>i</i></sub>=1.</p>
                </div>
                <div class="p1">
                    <p id="318">因此, 解密预言机选择<i>k</i>=<i>k</i>′的概率大约为 (1/2) (2/ϕ) =1/ϕ.若<i>k</i>=<i>k</i>′那么解密预言机计算:</p>
                </div>
                <div class="p1">
                    <p id="319" class="code-formula">
                        <mathml id="319"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><msup><mi mathvariant="bold-italic">s</mi><mo>′</mo></msup><mo>=</mo><mi mathvariant="bold-italic">a</mi><msup><mrow></mrow><mi>j</mi></msup><msup><mi mathvariant="bold-italic">s</mi><mo>′</mo></msup><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mi>i</mi></munder><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">b</mi><msup><mrow></mrow><mi>j</mi></msup><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup><mo>+</mo><mi>e</mi><msubsup><mrow></mrow><mi>i</mi><mi>j</mi></msubsup><mo stretchy="false">) </mo><mo>-</mo><mi mathvariant="bold-italic">b</mi><msup><mrow></mrow><mi>j</mi></msup><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mtext>ϕ</mtext><mo stretchy="false">]</mo></mrow></munder><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup><mo>=</mo></mtd></mtr><mtr><mtd><mi>e</mi><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup><mo>+</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>e</mi><msubsup><mrow></mrow><mi>i</mi><mi>j</mi></msubsup><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo><mo>.</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="320">换句话说, 尽管攻击者可以“看到”<i>e</i><mathml id="321"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>, 但实际却是一个含有噪音项的<mathml id="322"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>e</mi><msubsup><mrow></mrow><mi>i</mi><mi>j</mi></msubsup></mrow></math></mathml>.而这里, 由于<i>e</i><mathml id="323"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>j</mi></msubsup></mrow></math></mathml>项是固定的, 噪音项<i>E</i>的分布主要在于<i>λ</i><sub><i>i</i></sub>的选择.然而, 因为<i>e</i><mathml id="324"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>j</mi></msubsup></mrow></math></mathml>最初取自离散高斯, 这使得<i>E</i>的均值接近于0且<i>E</i>的分布类似于高斯分布.因此, 很自然地希望噪音项<i>E</i>能够通过重复进行解密预言机查询而被“平均掉”, 从而恢复出<i>e</i><mathml id="325"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="326">具体来说, 攻击者选择一个恰当的整数-<i>q</i>/2&lt;<i>u</i>&lt;<i>q</i>/2, 并对密文矩阵<b><i>C</i></b>调用解密预言查询, 这里的密文矩阵<b><i>C</i></b>的第<i>k</i>′列是向量<mathml id="327"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">a</mi><mo>¯</mo></mover><msup><mrow></mrow><mi>j</mi></msup><mo>=</mo><mi mathvariant="bold-italic">a</mi><msup><mrow></mrow><mi>j</mi></msup><mo>+</mo><mo stretchy="false"> (</mo><mi>u</mi><mo stretchy="false">|</mo><mn>0</mn><mo>, </mo><mn>0</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml>的转置.因此, 解密预言机 (假设<i>k</i>=<i>k</i>′) 计算<i>e</i><mathml id="328"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>+<i>μ</i>+<i>E</i> (mod <i>q</i>) , 其中<i>E</i>是噪音项, 并返回<mathml id="329"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow><mo stretchy="false"> (</mo><mi>e</mi><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup><mo>+</mo><mi>μ</mi><mo>+</mo><mi>E</mi><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>/</mo><mn>2</mn><msup><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msup><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow></mrow><mo>|</mo></mrow><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="330">为获得<i>e</i><mathml id="331"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>的<i>MSB</i>, 采取与Chenal和Tang<citation id="684" type="reference"><link href="579" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>相同的方法来获得<i>e</i><mathml id="332"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>的<i>MSB</i>.因此攻击者在得知<mathml id="333"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow><mo stretchy="false"> (</mo><mi>e</mi><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup><mo>+</mo><mi>μ</mi><mo>+</mo><mi>E</mi><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo><mo>/</mo><mn>2</mn><msup><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msup><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow></mrow><mo>|</mo></mrow></mrow></math></mathml>后判定|<i>e</i><mathml id="334"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>+<i>μ</i>+<i>E</i>|&lt;2<sup><i>k</i>-2</sup>是否成立.因此, 重复进行相同的查询 (同时要求<i>k</i>=<i>k</i>′) 将给出相同的计算但对应相同的噪音值<i>E</i>是不同的, 直到满足上述不等式, 即可获得<i>e</i><mathml id="335"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>的<i>MSB</i>.</p>
                </div>
                <div class="p1">
                    <p id="336">显然该攻击方法比自适应攻击1要困难的多.因此, 李增鹏等人<citation id="685" type="reference"><link href="625" rel="bibliography" /><sup>[<a class="sup">26</a>]</sup></citation>的多密钥GSW方案仅能抵抗部分自适应攻击.由上述描述, 需要考虑一个不同的解决方案.</p>
                </div>
                <div class="p1">
                    <p id="337"><b>注4</b>:实际上, 完全使用该方法去计算<i>e</i><mathml id="338"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>j</mi></msubsup></mrow></math></mathml>可能是非常困难的, 因为至少对于攻击者而言, 并不知道分布<i>E</i>的均值, 上述方式仅是近似获得<i>E</i>的均值.但攻击者一旦获得噪声向量<b><i>e</i></b><sup>1</sup>足够多的信息, 那么他们就能通过使用格算法来解决LWE的一个更简单的实例<mathml id="339"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">B</mi><mo>, </mo><msup><mi mathvariant="bold-italic">b</mi><mo>′</mo></msup><mo>=</mo><mi mathvariant="bold-italic">B</mi><mtext> </mtext><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mn>1</mn></msup><mo>+</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false">) </mo></mrow></math></mathml>, 从而完成密码分析, 其中<mathml id="340"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>|</mo></mrow><mo>≪</mo><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mn>1</mn></msup></mrow><mo>|</mo></mrow><mo>.</mo></mrow></math></mathml></p>
                </div>
                <h3 id="341" name="341" class="anchor-tag"><b>4 DMGSW方案</b></h3>
                <div class="p1">
                    <p id="342">在本节中, 提出一个具有多私钥DMGSW方案, DMGSW方案的安全性基于非齐次短整数解 (inhomogeneous short integer solution, ISIS) 问题, 而非LWE问题.</p>
                </div>
                <div class="p1">
                    <p id="343"><b>定义12</b>. ISIS.令<i>q</i>, <i>n</i>, <i>m</i>∈N, <i>m</i>&gt;<i>n</i>.令<i>χ</i>为Z上一个分布.将Z<mathml id="344"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>×Z<mathml id="345"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msubsup></mrow></math></mathml>上的ISIS分布定义为</p>
                </div>
                <div class="p1">
                    <p id="346"> (<b><i>B</i><i>t</i></b> (mod <i>q</i>) , <b><i>B</i></b>) , </p>
                </div>
                <div class="p1">
                    <p id="347">其中, <b><i>B</i></b>为在Z<sup><i>q</i></sup>中均匀选择的一个<i>n</i>×<i>m</i>矩阵, <b><i>t</i></b>←<i>χ</i><sup><i>m</i></sup>是一个长度为<i>m</i>的整数向量.类似于decision-LWE问题, 判定版本ISIS问题 (decision-ISIS) 是将取自ISIS分布中的样本 (<b><i>u</i></b>, <b><i>B</i></b>) 区分于取自均匀分布的样本Z<mathml id="348"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>×Z<mathml id="349"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="350">Ajtai<citation id="686" type="reference"><link href="629" rel="bibliography" /><sup>[<a class="sup">28</a>]</sup></citation> (或Micciancio<citation id="687" type="reference"><link href="631" rel="bibliography" /><sup>[<a class="sup">29</a>]</sup></citation>) 已经证明了存在一个分布<i>χ</i>使得对于恰当选取的参数来说, ISIS问题是困难的.实际上, 分布<i>χ</i>可以取自一个离散高斯分布或取自均匀分布{0, 1}. (详见文献<citation id="688" type="reference">[<a class="sup">29</a>]</citation>) .</p>
                </div>
                <div class="p1">
                    <p id="351"><b>定理2</b><citation id="689" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>. 令<i>m</i>&gt;<i>n</i>∈N, <i>q</i>∈N, <i>χ</i>是Z上的一个离散高斯分布, 它使得ISIS问题是困难的, ϕ为整数且满足ϕ=<i>O</i> (lb <i>q</i>) .定义2个分布X和Y:</p>
                </div>
                <div class="p1">
                    <p id="352">① X是<i>n</i>× (ϕ+<i>m</i>) 矩阵上的分布[<b><i>u</i></b><sup>1</sup>|<b><i>u</i></b><sup>2</sup>|…|<b><i>u</i></b><sup>ϕ</sup>|<b><i>B</i></b>], 其中<b><i>B</i></b>∈Z<mathml id="353"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msubsup></mrow></math></mathml>是均匀随机选取的, 并且对于所有的1≤<i>i</i>≤ϕ满足, <b><i>u</i></b><sup><i>i</i></sup>=<b><i>B</i><i>t</i></b><sup><i>i</i></sup> (mod <i>q</i>) , 这里<b><i>t</i></b><sup><i>i</i></sup>取自离散高斯分布<i>χ</i><sup><i>m</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="354">② Y是 Z<mathml id="355"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mo stretchy="false"> (</mo><mtext>ϕ</mtext><mo>+</mo><mi>m</mi><mo stretchy="false">) </mo></mrow></msubsup></mrow></math></mathml>上的均匀分布, 那么2个分布X 和Y是计算不可区分的.</p>
                </div>
                <div class="p1">
                    <p id="356">证明. 令D是一个PPT敌手, 他能够以不可忽略的概率区分X和Y.对于1≤<i>i</i>≤ϕ+1来说, 引入中间分布X<sub><i>i</i></sub>如下:</p>
                </div>
                <div class="p1">
                    <p id="357">[<b><i>d</i></b><sup>1</sup>|<b><i>d</i></b><sup>2</sup>|…|<b><i>d</i></b><sup><i>i</i>-1</sup>|<b><i>u</i></b><sup><i>i</i></sup>|…|<b><i>u</i></b><sup>ϕ</sup>|<b><i>B</i></b>], </p>
                </div>
                <div class="p1">
                    <p id="358">其中, <b><i>u</i></b><sup><i>i</i></sup>如上所述, <b><i>d</i></b><sup><i>i</i></sup>是从Z<mathml id="359"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mi>n</mi></msubsup></mrow></math></mathml>中均匀选取的.因此X<sub>1</sub>=X且X<sub>ϕ+1</sub>=Y.</p>
                </div>
                <div class="p1">
                    <p id="360">由上假设, D能够以明显的概率<i>ε</i>区分X<sub>1</sub>和X<sub>ϕ+1</sub>, 因此, 通过一系列游戏序列, 存在某个<i>i</i>使得D能以至少<i>ε</i>/ϕ的概率将分布X<sub><i>i</i></sub>和X<sub><i>i</i>+1</sub>区分开来.</p>
                </div>
                <div class="p1">
                    <p id="361">显然, D给出了一个ISIS区分器:即给出一个ISIS挑战 (<b><i>y</i></b>, <b><i>B</i></b>) , 均匀地选取<b><i>d</i></b><sup>1</sup>, <b><i>d</i></b><sup>2</sup>, …, <b><i>d</i></b><sup><i>i</i>-1</sup>, 从ISIS分布中选取<b><i>u</i></b><sup><i>i</i>+1</sup>, <b><i>u</i></b><sup><i>i</i>+2</sup>, …, <b><i>u</i></b><sup>ϕ</sup>, 生成分布</p>
                </div>
                <div class="p1">
                    <p id="362">[<b><i>d</i></b><sup>1</sup>|<b><i>d</i></b><sup>2</sup>|…|<b><i>d</i></b><sup><i>i</i>-1</sup>|<b><i>y</i></b>|<b><i>u</i></b><sup><i>i</i>+1</sup>|<b><i>u</i></b><sup><i>i</i>+2</sup>|…|<b><i>u</i></b><sup>ϕ</sup>|<b><i>B</i></b>], </p>
                </div>
                <div class="p1">
                    <p id="363">并调用D对该分布进行区分.</p>
                </div>
                <div class="p1">
                    <p id="364">通过假设, 显然不存在这样的区分器. 证毕.</p>
                </div>
                <h4 class="anchor-tag" id="365" name="365"><b>4.1 DMGSW方案</b></h4>
                <div class="p1">
                    <p id="366">本节中给出一个DMGSW方案.在原GSW方案中, 公钥是基于LWE实例, 形如<b><i>A</i></b>= (<b><i>B</i><i>t</i></b>+<b><i>e</i></b>, <b><i>B</i></b>) , 密文是基于ISIS问题, 形如<b><i>A</i></b><sup>T</sup><b><i>R</i></b>.如Regev的加密方案, 其对偶方案有基于ISIS问题的公钥 (<b><i>B</i></b><sup>T</sup>, <b><i>B</i></b><sup>T</sup><b><i>T</i></b>) 和基于类似LWE实例<b><i>BR</i></b>+<b><i>X</i></b>的密文.</p>
                </div>
                <h4 class="anchor-tag" id="367" name="367">1) DMGSW初始化算法</h4>
                <div class="p1">
                    <p id="368"><i>params</i>←<i>DMGSW</i>.<i>Setup</i> (1<sup><i>κ</i></sup>, 1<sup><i>L</i></sup>) :</p>
                </div>
                <div class="p1">
                    <p id="369">① 选择模<i>q</i>=<i>q</i> (<i>κ</i>) , 格维参数<i>m</i>=<i>m</i> (<i>κ</i>, <i>L</i>) 和<i>n</i>, 以及分布<i>χ</i>=<i>χ</i> (<i>κ</i>, <i>L</i>) , 对于已知ISIS攻击, 参数的合理选择可以实现至少2<sup><i>κ</i></sup>的安全性.</p>
                </div>
                <div class="p1">
                    <p id="370">② 令ℓ=-lb <i>q</i>-+1且<i>N</i>= (ϕ+<i>m</i>) ℓ, 输出<i>params</i>= (<i>m</i>, <i>q</i>, <i>χ</i>, <i>n</i>) .</p>
                </div>
                <h4 class="anchor-tag" id="371" name="371">2) DMGSW密钥生成算法</h4>
                <div class="p1">
                    <p id="372"> (<i>pk</i>, <i>sk</i>) ←<i>DMGSW</i>.<i>KeyGen</i> (<i>params</i>) :</p>
                </div>
                <div class="p1">
                    <p id="373">① 从<i>χ</i><sup><i>m</i></sup>分布中选取向量 (<b><i>t</i></b><sup><i>i</i></sup>) <sup>T</sup>= (<i>t</i><mathml id="374"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>1</mn><mi>i</mi></msubsup></mrow></math></mathml>, <i>t</i><mathml id="375"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mi>i</mi></msubsup></mrow></math></mathml>, …, <i>t</i><mathml id="376"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>n</mi><mi>i</mi></msubsup></mrow></math></mathml>) , 计算<b><i>e</i></b><sup><i>i</i></sup>= (<b><i>I</i></b><sub><i>i</i></sub>|- (<b><i>t</i></b><sup><i>i</i></sup>) <sup>T</sup>) <sup>T</sup>, 其中行向量<b><i>I</i></b><sub><i>i</i></sub>是ϕ×ϕ维单位矩阵的第<i>i</i>行.</p>
                </div>
                <div class="p1">
                    <p id="377">② 均匀选取矩阵<b><i>B</i></b>∈Z<mathml id="378"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow></msubsup></mrow></math></mathml>, 计算向量<b><i>u</i></b><sup><i>i</i></sup>=<b><i>B</i><i>t</i></b><sup><i>i</i></sup>, 1≤<i>i</i>≤ϕ, 令矩阵</p>
                </div>
                <div class="p1">
                    <p id="379"><b><i>A</i></b>=[<b><i>u</i></b><sup>1</sup>|<b><i>u</i></b><sup>2</sup>|…|<b><i>u</i></b><sup>ϕ</sup>|<b><i>B</i></b>]∈Z<mathml id="380"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mo stretchy="false"> (</mo><mtext>ϕ</mtext><mo>+</mo><mi>m</mi><mo stretchy="false">) </mo></mrow></msubsup></mrow></math></mathml>, </p>
                </div>
                <div class="p1">
                    <p id="381">这里<b><i>A</i><i>e</i></b><sup><i>i</i></sup>=0.</p>
                </div>
                <div class="p1">
                    <p id="382">③ 输出公钥<b><i>A</i></b>和私钥 (<b><i>e</i></b><sup>1</sup>, <b><i>e</i></b><sup>2</sup>, …, <b><i>e</i></b><sup>ϕ</sup>) .</p>
                </div>
                <h4 class="anchor-tag" id="383" name="383">3) DMGSW加密算法</h4>
                <div class="p1">
                    <p id="384"><b><i>C</i></b>←<i>DMGSW</i>.<i>Enc</i> (<i>pk</i>, <i>μ</i>) :</p>
                </div>
                <div class="p1">
                    <p id="385">① 均匀选取矩阵<b><i>R</i></b>←Z<mathml id="386"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mi>n</mi><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>和<b><i>X</i></b>←<i>χ</i><sup> (ϕ+<i>m</i>) ×<i>N</i></sup>.</p>
                </div>
                <div class="p1">
                    <p id="387">② 加密消息<i>μ</i>∈{0, 1}, 计算</p>
                </div>
                <div class="p1">
                    <p id="388"><b><i>C</i></b>=<i>μ</i><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b>+<b><i>X</i></b> (mod <i>q</i>) ∈Z<mathml id="389"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mtext>ϕ</mtext><mo>+</mo><mi>m</mi><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>, </p>
                </div>
                <div class="p1">
                    <p id="390">其中<b><i>G</i></b>为 (ϕ+<i>m</i>) ×<i>N</i>维工具矩阵.</p>
                </div>
                <div class="p1">
                    <p id="391">③ 输出密文<b><i>C</i></b>.</p>
                </div>
                <div class="p1">
                    <p id="392"><b>注5</b>. DMGSW方案中密文<b><i>C</i></b>可以记为</p>
                </div>
                <div class="p1">
                    <p id="393"><i>Flatten</i> (<i>μ</i><b><i>I</i></b>+<i>BitDecomp</i> (<b><i>A</i></b><sup>T</sup><b><i>R</i></b>+<b><i>X</i></b>) ) =</p>
                </div>
                <div class="p1">
                    <p id="394"><i>BitDecomp</i> (<i>BitDecomp</i><sup>-1</sup> (<i>μ</i><b><i>I</i></b>) +<b><i>A</i></b><sup>T</sup><b><i>R</i></b>+<b><i>X</i></b>) =</p>
                </div>
                <div class="p1">
                    <p id="395"><i>BitDecomp</i> (<i>μ</i><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b>+<b><i>X</i></b>) (mod <i>q</i>) .</p>
                </div>
                <h4 class="anchor-tag" id="396" name="396">4) DMGSW解密算法</h4>
                <div class="p1">
                    <p id="397"><i>μ</i>′←<i>DMGSW</i>.<i>Dec</i> (<i>sk</i><sub><i>i</i></sub>, <b><i>C</i></b>) :</p>
                </div>
                <div class="p1">
                    <p id="398">① 从 Z选择<i>λ</i><sub>1</sub>, <i>λ</i><sub>2</sub>, …, <i>λ</i><sub>ϕ</sub>且<i>λ</i><sub><i>i</i></sub>, <i>i</i>∈[ϕ]并不全为0, 那么生成一次私钥<mathml id="399"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo></mrow></math></mathml><mathml id="400"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>, 使得<mathml id="401"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>|</mo></mrow></mrow></math></mathml>很短.这里, 同样有<mathml id="402"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">A</mi><mtext> </mtext><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>≡</mo><mn>0</mn><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="403">② 确定整数1≤<i>k</i>= (<i>i</i>-1) ℓ+<i>j</i>≤ϕ ℓ, 使得<i>λ</i><sub><i>i</i></sub>=1且2<sup><i>j</i>-1</sup>∈ (<i>q</i>/4, <i>q</i>/2].</p>
                </div>
                <div class="p1">
                    <p id="404">③ 令<b><i>C</i></b>[<i>k</i>]为<b><i>C</i></b>的第<i>k</i>列, 并计算<mathml id="405"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>μ</mi><mo>=</mo><mo>〈</mo><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>, </mo><mrow><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>〉</mo><mo>=</mo></mrow><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo></mrow></math></mathml>.这里:</p>
                </div>
                <div class="p1">
                    <p id="406"><mathml id="407"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">C</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mi>μ</mi><mtext> </mtext><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mi mathvariant="bold-italic">R</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><msup><mi mathvariant="bold-italic">A</mi><mo>′</mo></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mi>μ</mi><mtext> </mtext><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="408">因此:</p>
                </div>
                <div class="p1">
                    <p id="409" class="code-formula">
                        <mathml id="409"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mi>μ</mi><mo stretchy="false"> (</mo><mn>0</mn><mo>, </mo><mn>0</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mn>0</mn><mo>, </mo><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>, </mo><mn>0</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mn>0</mn><mo stretchy="false">) </mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mi mathvariant="bold-italic">E</mi><mo>=</mo></mtd></mtr><mtr><mtd><mi>μ</mi><mtext> </mtext><mi>λ</mi><msub><mrow></mrow><mi>i</mi></msub><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>E</mi><mo>.</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="410">其中, <mathml id="411"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi><mo>=</mo><mi mathvariant="bold-italic">X</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover></mrow></math></mathml>为一个小噪音项.</p>
                </div>
                <div class="p1">
                    <p id="412">④ 返回<mathml id="413"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow><mi>μ</mi><mo>/</mo><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup><mrow></mrow><mrow></mrow><mo>-</mo><mrow></mrow></mrow><mo>|</mo></mrow><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo>, </mo><mn>1</mn><mo stretchy="false">}</mo><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="414"><b>注6</b>. 针对步骤1) , 需特别强调的是, 有不同的方法来选择参数<i>λ</i><sub><i>i</i></sub>.其中可以采用从{0, 1}分布中均匀选取的方法.该方法可以得到恰当的<mathml id="415"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><msup><mi mathvariant="bold-italic">e</mi><mo>′</mo></msup><mo>|</mo></mrow></mrow></math></mathml>值, 因此本文分析中采用该方法.另一种是采取从Z上离散高斯分布中选取的方法, 该方法使得取值具有小的标准差且得到更高的安全性 (详见第6节中的讨论) .此外, 还可采用拒绝抽样 (rejection sampling) 的某些形式来获得向量<mathml id="416"><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover></math></mathml>.为更好控制<i>λ</i><sub><i>i</i></sub>的大小并防止泄露关于向量<b><i>e</i></b><sup><i>i</i></sup>信息.</p>
                </div>
                <h4 class="anchor-tag" id="417" name="417">5) 同态运算<i>DMGSW</i>.<i>Eval</i> (<i>pk</i>, (<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>, …, <b><i>C</i></b><sub>ℓ</sub>) ) :</h4>
                <div class="p1">
                    <p id="418">同态操作与GSW方案类似, 具体如下:</p>
                </div>
                <div class="p1">
                    <p id="419">① 同态加法<i>DMGSW</i>.<i>Add</i> (<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>) 输出:</p>
                </div>
                <div class="p1">
                    <p id="420"><b><i>C</i></b><sub>1</sub>+<b><i>C</i></b><sub>2</sub>= (<i>μ</i><sub>1</sub>+<i>μ</i><sub>2</sub>) <b><i>G</i></b>+<b><i>A</i></b><sup>T</sup> (<b><i>R</i></b><sub>1</sub>+<b><i>R</i></b><sub>2</sub>) + (<b><i>X</i></b><sub>1</sub>+<b><i>X</i></b><sub>2</sub>) ∈Z<mathml id="422"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mtext>ϕ</mtext><mo>+</mo><mi>m</mi><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="423">② 同态乘法<i>DMGSW</i>.<i>Mult</i> (<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>) 计算<i>N</i>×<i>N</i>的矩阵<b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) , 并输出<b><i>C</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) .即:</p>
                </div>
                <div class="p1">
                    <p id="424"><b><i>C</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) = (<i>μ</i><sub>1</sub><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>1</sub>+<b><i>X</i></b><sub>1</sub>) <b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) =</p>
                </div>
                <div class="p1">
                    <p id="425"><i>μ</i><sub>1</sub><b><i>C</i></b><sub>2</sub>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) +<b><i>X</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) =</p>
                </div>
                <div class="p1">
                    <p id="426"><i>μ</i><sub>1</sub><i>μ</i><sub>2</sub><b><i>G</i></b>+ (<b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) +<i>μ</i><sub>1</sub><b><i>A</i></b><sup>T</sup><b><i>R</i></b><sub>2</sub>) +</p>
                </div>
                <div class="p1">
                    <p id="427"><b><i>X</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) +<i>μ</i><sub>1</sub><b><i>X</i></b><sub>2</sub>) ∈Z<mathml id="428"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mtext>ϕ</mtext><mo>+</mo><mi>m</mi><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>.</p>
                </div>
                <div class="p1">
                    <p id="429">③ 与非运算<i>DMGSW</i>.<i>NAND</i> (<b><i>C</i></b><sub>1</sub>, <b><i>C</i></b><sub>2</sub>) 计算<b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) , 并输出<b><i>G</i></b>-<b><i>C</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) .</p>
                </div>
                <h4 class="anchor-tag" id="430" name="430"><b>4.2 正确性</b></h4>
                <div class="p1">
                    <p id="431">本节中分析解密和同态运算的正确性并确定参数大小.假设<mathml id="432"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo></mrow></math></mathml><mathml id="433"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>是由均匀随机选取的<i>λ</i><sub><i>i</i></sub>∈{0, 1}所构成.而<b><i>e</i></b><sup><i>i</i></sup>中的元素取自标准差为<i>σ</i>的离散高斯分布<i>χ</i>, <i>χ</i>是<i>B</i> -界的, 且<i>B</i>=6<i>σ</i>, 使得不等式<mathml id="434"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup></mrow><mo>|</mo></mrow><mo>≤</mo><mn>2</mn><msqrt><mi>m</mi></msqrt><mi>σ</mi></mrow></math></mathml>成立.因此, 向量<mathml id="435"><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover></math></mathml>中的元素是以<b><i>B</i></b>′=<b><i>tB</i></b>为界且满足<mathml id="436"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>|</mo></mrow><mo>≤</mo><mn>2</mn><msqrt><mrow><mi>t</mi><mi>m</mi></mrow></msqrt><mi>σ</mi><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="437">由加密算法对消息加密输出的密文称为第0层的密文<b><i>C</i></b>.而层级<i>i</i>≥1的密文<b><i>C</i></b>则是由密文运算算法Eval生成.且至多对0层密文执行<i>i</i>次运算.</p>
                </div>
                <div class="p1">
                    <p id="438"><b>定义13</b>. 如果<mathml id="439"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">C</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mi>μ</mi><mtext> </mtext><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover></mrow></math></mathml>, 那么称密文<b><i>C</i></b>∈Z<mathml id="440"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi mathvariant="bold-italic">q</mi><mrow><mo stretchy="false"> (</mo><mtext>ϕ</mtext><mo>+</mo><mi mathvariant="bold-italic">m</mi><mo stretchy="false">) </mo><mo>×</mo><mi mathvariant="bold-italic">Ν</mi></mrow></msubsup></mrow></math></mathml>是<i>E</i>噪音的, 这里<mathml id="441"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>≤</mo><mi>E</mi></mrow></math></mathml>.如果具有<i>E</i>噪音的密文<b><i>C</i></b>满足<i>E</i>&lt;<i>q</i>/8, 那么有<mathml id="442"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>≡</mo><mi>μ</mi><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>ξ</mi><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo></mrow></math></mathml>使得不等式|<i>ξ</i>|≤<i>E</i>&lt;<i>q</i>/8&lt;2<sup><i>j</i>-2</sup>成立, 且</p>
                </div>
                <div class="p1">
                    <p id="443" class="code-formula">
                        <mathml id="443"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mfrac><mrow><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo></mrow><mrow><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo>=</mo><mi>μ</mi><mo>+</mo><mfrac><mi>ξ</mi><mrow><mn>2</mn><msup><mrow></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo>=</mo><mi>μ</mi><mo>+</mo><mi>ε</mi><mo>, </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="444">其中, <mathml id="445"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>-</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>&lt;</mo><mi>ε</mi><mo>&lt;</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="446"><b>引理4</b>. 令<i>χ</i>为Z上的一个<i>B</i>界分布.如果<i>E</i>≥ϕ <i>B</i>+<i>m B</i><sup>2</sup>成立, 那么层级为0的密文是<i>E</i>噪音.</p>
                </div>
                <div class="p1">
                    <p id="447">证明. 对于密文<b><i>C</i></b>=<i>μ</i><b><i>G</i></b>+<b><i>A</i></b><sup>T</sup><b><i>R</i></b>+<b><i>X</i></b>其中<b><i>X</i></b>取自高斯分布<i>χ</i><sup> (ϕ+<i>m</i>) ×<i>N</i></sup>.为方便分析, 将<b><i>X</i></b>记为<mathml id="448"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">[</mo><mfrac><mrow><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mo>#</mo></msup></mrow><mrow><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mo>*</mo></msup></mrow></mfrac><mo stretchy="false">]</mo></mrow></math></mathml>, 其中噪声矩阵<b><i>X</i></b><sup>#</sup>∈Z<sup>ϕ×<i>N</i></sup>且<b><i>X</i></b><sup>*</sup>∈Z<sup><i>m</i>×<i>N</i></sup>.由于<mathml id="449"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mo stretchy="false"> (</mo><mi>λ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>λ</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>λ</mi><msub><mrow></mrow><mtext>ϕ</mtext></msub><mo stretchy="false">|</mo><mo>-</mo></mrow></math></mathml><mathml id="450"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mi>i</mi></munder><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow></math></mathml>, 因此有:</p>
                </div>
                <div class="p1">
                    <p id="451" class="code-formula"><mathml id="452"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mo>#</mo></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mo stretchy="false"> (</mo><mi>λ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>λ</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>λ</mi><msub><mrow></mrow><mtext>ϕ</mtext></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mo>-</mo></mrow></math></mathml><mathml id="453"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mi>i</mi></munder><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">X</mi><msup><mrow></mrow><mo>*</mo></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="454">因为<mathml id="455"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">X</mi><msubsup><mrow></mrow><mi>Ι</mi><mo>*</mo></msubsup></mrow><mo>|</mo></mrow><msub><mrow></mrow><mn>2</mn></msub><mo>≤</mo><mn>2</mn><msqrt><mi>m</mi></msqrt><mi>σ</mi></mrow></math></mathml>和<mathml id="456"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup></mrow><mo>|</mo></mrow><msub><mrow></mrow><mn>2</mn></msub><mo>≤</mo><mn>2</mn><msqrt><mi>m</mi></msqrt><mi>σ</mi></mrow></math></mathml>, 由Cauchy-Schwarz不等式可知:</p>
                </div>
                <div class="p1">
                    <p id="457">| (<b><i>X</i></b><sup>*</sup><sub><i>I</i></sub>) <sup>T</sup><b><i>t</i></b><sup><i>i</i></sup>|≤4<i>m σ</i><sup>2</sup>≤<i>m B</i><sup>2</sup>.</p>
                </div>
                <div class="p1">
                    <p id="458">因此, 有| (<b><i>X</i></b><sup>#</sup><sub><i>I</i></sub>) <sup>T</sup> (<i>λ</i><sub>1</sub>, <i>λ</i><sub>2</sub>, …, <i>λ</i><sub>ϕ</sub>) <sup>T</sup>|≤ϕ <i>B</i>.综上, 无穷范数的误差边界为ϕ <i>B</i>+<i>m B</i><sup>2</sup>. 证毕.</p>
                </div>
                <div class="p1">
                    <p id="459">下面分析同态运算噪声规模.具体来说, 对于第<i>i</i>层的密文噪声 (<i>N</i>+1) <sup><i>i</i></sup><i>E</i>, 记<i>E</i>为层级0的噪声.如果满足条件 (<i>N</i>+1) <sup><i>L</i></sup><i>E</i>≤<i>q</i>/8, 那么执行<i>L</i>层同态操作后, 解密正确.</p>
                </div>
                <div class="p1">
                    <p id="460"><b>引理5</b>. 令符号和参数如上所述 (特别是, <i>E</i>≥ϕ <i>B</i>+<i>m B</i><sup>2</sup>) .令<b><i>C</i></b>为层级<i>i</i>≤<i>L</i>上的任意密文, 那么<b><i>C</i></b>的噪音是 (<i>N</i>+1) <sup><i>i</i></sup><i>E</i> (无穷范数) .</p>
                </div>
                <div class="p1">
                    <p id="461">证明. 令<b><i>C</i></b><sub>1</sub>和<b><i>C</i></b><sub>2</sub>为<i>μ</i><sub>1</sub>, <i>μ</i><sub>2</sub>∈{0, 1}的2个密文, 满足<mathml id="462"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mi>μ</mi><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mi>E</mi><msub><mrow></mrow><mi>i</mi></msub><mo>, </mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>, </mo><mn>2</mn><mo>.</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="463">对于密文加法, 假设其<i>i</i>层密文噪声为 (<i>N</i>+1) <sup><i>i</i></sup><i>E</i>.计算<b><i>C</i></b><sup>add</sup>=<b><i>C</i></b><sub>1</sub>+<b><i>C</i></b><sub>2</sub>.那么:</p>
                </div>
                <div class="p1">
                    <p id="464" class="code-formula">
                        <mathml id="464"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><msup><mrow></mrow><mrow><mtext>a</mtext><mtext>d</mtext><mtext>d</mtext></mrow></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mo stretchy="false"> (</mo><mi>μ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mi>μ</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mo stretchy="false"> (</mo><mi>E</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mi>E</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="465">且</p>
                </div>
                <div class="p1">
                    <p id="466" class="code-formula">
                        <mathml id="466"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mrow><mo>|</mo><mrow><mi>E</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mi>E</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>≤</mo><mrow><mo>|</mo><mrow><mi>E</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>+</mo><mrow><mo>|</mo><mrow><mi>E</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>≤</mo></mtd></mtr><mtr><mtd><mn>2</mn><mo stretchy="false"> (</mo><mi>Ν</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mi>i</mi></msup><mi>E</mi><mo>≤</mo><mo stretchy="false"> (</mo><mi>Ν</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><msup><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>E</mi><mo>.</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="467">对于密文乘法, <b><i>C</i></b><sup>mult</sup>=<b><i>C</i></b><sub>1</sub><b><i>G</i></b><sup>-1</sup> (<b><i>C</i></b><sub>2</sub>) 满足:</p>
                </div>
                <div class="p1">
                    <p id="468" class="code-formula">
                        <mathml id="468"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><msup><mrow></mrow><mrow><mtext>m</mtext><mtext>u</mtext><mtext>l</mtext><mtext>t</mtext></mrow></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mi>μ</mi><msub><mrow></mrow><mn>1</mn></msub><mi>μ</mi><msub><mrow></mrow><mn>2</mn></msub><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>+</mo><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mi>E</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mi>μ</mi><msub><mrow></mrow><mn>2</mn></msub><mi>E</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="469">使得:</p>
                </div>
                <div class="p1">
                    <p id="470" class="code-formula">
                        <mathml id="470"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mi>E</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mi>μ</mi><msub><mrow></mrow><mn>2</mn></msub><mi>E</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>≤</mo><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">G</mi><msup><mrow></mrow><mrow><mo>-</mo><mn>1</mn></mrow></msup><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mi>E</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>+</mo></mtd></mtr><mtr><mtd><mrow><mo>|</mo><mrow><mi>μ</mi><msub><mrow></mrow><mn>2</mn></msub><mi>E</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>≤</mo><mi>Ν</mi><mrow><mo>|</mo><mrow><mi>E</mi><msub><mrow></mrow><mn>1</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>+</mo><mrow><mo>|</mo><mrow><mi>E</mi><msub><mrow></mrow><mn>2</mn></msub></mrow><mo>|</mo></mrow><msub><mrow></mrow><mi>∞</mi></msub><mo>.</mo><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mtext>证</mtext><mtext>毕</mtext><mo>.</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="471">同样的计算对NAND门来说同样成立.假设<i>q</i>/8&gt; (<i>N</i>+1) <sup><i>L</i></sup><i>E</i>, 计算包含NAND门且电路深度为<i>L</i>的布尔电路.输入噪声为<i>E</i>层级0的密文, 每执行一次同态运算, 噪声乘以至多为 (<i>N</i>+1) 的一个因子.因此, 经过<i>L</i>次同态运算后, 最终密文中的噪声大小为 (<i>N</i>+1) <sup><i>L</i></sup>, 且能够正确地解密.</p>
                </div>
                <h4 class="anchor-tag" id="472" name="472"><b>4.3 DMGSW方案的安全性</b></h4>
                <div class="p1">
                    <p id="473">DMGSW方案的安全性依赖于ISIS和LWE假设.利用定理2来证明该方案DMGSW在ISIS假设下是安全的.</p>
                </div>
                <div class="p1">
                    <p id="474"><b>定理3</b>. 如果ISIS假设和LWE假设是困难的, 那么DMGSW方案是IND-CPA安全的, 对于ϕ=<i>O</i> (lb <i>q</i>) 及参数<i>m</i>, <i>n</i>, <i>q</i>, <i>χ</i>.</p>
                </div>
                <div class="p1">
                    <p id="475">证明. 安全性证明以hybrid hop形式, 分2步给出.可以用hybrid hop形式表述.</p>
                </div>
                <div class="p1">
                    <p id="476">1) 使用一个均匀随机矩阵<b><i>A</i></b>替换公钥.</p>
                </div>
                <div class="p1">
                    <p id="477">2) 使用一个均匀随机矩阵<b><i>C</i></b>替换密文.当<b><i>C</i></b>是一个均匀随机矩阵时, 敌手在IND-CPA游戏中不具有不可忽略的优势, 因此<b><i>C</i></b>独立于消息<i>μ</i>.有必要说明的是, 敌手的行为在不同的游戏步骤之间是相同的.</p>
                </div>
                <div class="p1">
                    <p id="478">① Hybird.1.在本游戏中, 用均匀矩阵代替公钥.挑战密文与方案中的相同.如果这2个游戏中, 敌手成功的概率是不可忽略的, 那么敌手是一个能够将含有ISIS实例的公钥与均匀随机矩阵区分开的算法.然而, 由ISIS假设和定理2可知, 该算法不存在.</p>
                </div>
                <div class="p1">
                    <p id="479">② Hybird.2.在本游戏中, 用Z<mathml id="480"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mo stretchy="false"> (</mo><mtext>ϕ</mtext><mo>+</mo><mi>m</mi><mo stretchy="false">) </mo><mo>×</mo><mi>Ν</mi></mrow></msubsup></mrow></math></mathml>上的均匀随机的矩阵来替换密文<b><i>C</i></b>.如果在这个游戏中, 敌手成功的概率明显区别于Hybird.1中成功的概率, 那么存在一个区分器来区分LWE分布<b><i>A</i></b><sup>T</sup><b><i>R</i></b>+<b><i>X</i></b> (mod <i>q</i>) 和均匀分布.</p>
                </div>
                <div class="p1">
                    <p id="481">由LWE假设, 不存在这样的PPT区分器.最后, Hybird.2与消息位<i>μ</i>无关, 因此敌手在这个游戏中获得的优势为0. 证毕.</p>
                </div>
                <h3 id="482" name="482" class="anchor-tag"><b>5 抵抗自适应攻击的DMGSW方案的安全性</b></h3>
                <div class="p1">
                    <p id="483">在DMGSW方案中, 与MGSW方案的主要区别在于没有噪音项.因此自适应攻击2不可能发生.下面, 证明自适应攻击1同样不适用于DMGSW方案.</p>
                </div>
                <div class="p1">
                    <p id="484">该安全性分析依赖于剩余Hash引理 (leftover hash lemma, LHL) 的高斯版本, 而不同于之前的平均情况.下面, 给出Agrawal等人<citation id="690" type="reference"><link href="633" rel="bibliography" /><sup>[<a class="sup">30</a>]</sup></citation>的定理2的一种特殊情况.</p>
                </div>
                <div class="p1">
                    <p id="485"><b>定理4</b>. 一维剩余Hash引理LHL.令<i>ε</i>, <i>σ</i>∈R, 使得对于所有的绝对常数<i>ε</i>&gt;0, <i>σ</i>&gt;<i>C</i> (详见文献<citation id="691" type="reference">[<a class="sup">30</a>]</citation>) .令ϕ≥10 lb (8ϕ<sup>1.5</sup><i>σ</i>) 且<i>s</i>′≤4ϕ lb (1/<i>ε</i>) .那么统计距离为2<i>ε</i>的2个分布:</p>
                </div>
                <div class="p1">
                    <p id="486">① 选择1个长度为<i>t</i>的向量<b><i>X</i></b>∈Z<sup>ϕ</sup>, 其每个元素均选自Z<sup>ϕ</sup>上参数为<i>σ</i>的离散高斯分布;选择1个长度为ϕ的向量<b><i>z</i></b>∈Z<sup>ϕ</sup>, 其每个元素选自Z<sup>ϕ</sup>上的参数为<i>s</i>′的离散高斯分布, 计算并输出<b><i>X</i></b><sup>T</sup><b><i>z</i></b>.</p>
                </div>
                <div class="p1">
                    <p id="487">② 从 Z上参数为<i>σ s</i>′的离散高斯分布选择并输出一个元素.实际上, 对于一次私钥</p>
                </div>
                <div class="p1">
                    <p id="488" class="code-formula">
                        <mathml id="488"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup><mo>=</mo><mrow><mo> (</mo><mrow><mtable><mtr><mtd><mi>λ</mi><msub><mrow></mrow><mn>1</mn></msub></mtd></mtr><mtr><mtd><mi>λ</mi><msub><mrow></mrow><mn>2</mn></msub></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>λ</mi><msub><mrow></mrow><mtext>ϕ</mtext></msub></mtd></mtr><mtr><mtd><mo>-</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup></mtd></mtr></mtable></mrow><mo>) </mo></mrow><mo>∈</mo><mtext>Ζ</mtext><msubsup><mrow></mrow><mi>q</mi><mrow><mtext>ϕ</mtext><mo>+</mo><mi>m</mi></mrow></msubsup><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="489">执行解密计算<mathml id="490"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>〈</mo><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>, </mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo>〉</mo><mo>=</mo><mi mathvariant="bold-italic">C</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false"> (</mo><mtext>m</mtext><mtext>o</mtext><mtext>d</mtext><mspace width="0.25em" /><mi>q</mi><mo stretchy="false">) </mo></mrow></math></mathml>.如果敌手将其选择的一个向量插入到密文矩阵<b><i>C</i></b>的第<i>k</i>列中并进行一次解密查询.如自适应攻击1, 敌手不知道<i>k</i>, 但却能以很高的概率猜出该值.实际上, 敌手有1/2的概率获得<i>λ</i><sub>1</sub>=1, 当<i>λ</i><sub>1</sub>=1时, 将<b><i>C</i></b>的所有其他列设置为0, 能够确保解密预言机仅返回一个非0值.</p>
                </div>
                <div class="p1">
                    <p id="491">采取与自适应攻击1相同的方式.对于线性映射<i>L</i>:Z<mathml id="492"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>q</mi><mrow><mtext>ϕ</mtext><mo>+</mo><mi>m</mi></mrow></msubsup></mrow></math></mathml>→Z<sup><i>q</i></sup>, 对应着与密文<b><i>C</i></b>[<i>k</i>]<sup>T</sup>的乘法.此时, 敌手可以获得:</p>
                </div>
                <div class="p1">
                    <p id="493" class="code-formula"><mathml id="494"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo stretchy="false"> (</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false">) </mo><mo>=</mo></mrow></math></mathml><mathml id="495"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>L</mi><mo stretchy="false"> (</mo><mi>e</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>L</mi><mo stretchy="false"> (</mo><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">Ι</mi><msub><mrow></mrow><mi>i</mi></msub><mo>, </mo><mo>-</mo><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">t</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mo stretchy="false">) </mo><msup><mrow></mrow><mtext>Τ</mtext></msup><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="496">的1位.正如自适应攻击1, 可以声明, 几乎所有的向量 (<b><i>I</i></b><sub><i>i</i></sub>, - (<b><i>t</i></b><sup><i>i</i></sup>) <sup>T</sup>) <sup>T</sup>并不在<i>L</i>的核中.依据是否含有<i>L</i>个有缺陷的向量.需要考虑2种情况:</p>
                </div>
                <div class="p1">
                    <p id="497">1) 当<i>L</i> (<b><i>e</i></b><sup><i>i</i></sup>) 值与在Z<sub><i>q</i></sub>上均匀选取的元素一样时, 那么在该情况下, 基于在自适应攻击1中的剩余Hash引理 (并假设<i>L</i>是满射且大部分私钥不会失效) 足以推断<mathml id="498"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo stretchy="false"> (</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false">) </mo></mrow></math></mathml>上值与<i>L</i> (<b><i>e</i></b><sup><i>i</i></sup>) 上值无关且敌手不能从该形式的查询中得到私钥.</p>
                </div>
                <div class="p1">
                    <p id="499">2) 如果投影<i>L</i>将<i>L</i> ( (<i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, …, <i>w</i><sub>ϕ+<i>m</i></sub>) <sup>T</sup>) =<i>w</i><sub><i>i</i></sub>投影到坐标ϕ&lt;<i>i</i>≤ϕ+<i>m</i>上.在这种情况中, <i>L</i> (<b><i>e</i></b><sup><i>i</i></sup>) 值取自离散高斯分布且不能使用剩余Hash引理来判定<mathml id="500"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo stretchy="false"> (</mo><mover accent="true"><mi mathvariant="bold-italic">e</mi><mo>^</mo></mover><mo stretchy="false">) </mo></mrow></math></mathml>不携带关于<i>L</i> (<b><i>e</i></b><sup><i>i</i></sup>) 的任何信息.不同的是, 对于该情形, 可以使用定理4来证明.在这种情况中, 需假设<i>λ</i><sub><i>i</i></sub>是从一个参数为<i>σ</i>的离散高斯分布<i>χ</i>中选取的.</p>
                </div>
                <div class="p1">
                    <p id="501">那么假设攻击者看到<mathml id="502"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>L</mi><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">) </mo></mrow></math></mathml>, 这里<i>L</i> (<b><i>e</i></b><sup><i>i</i></sup>) 独立取自离散高斯分布<i>χ</i>.那么由定理4可知, 对于ϕ=<i>O</i> (lb <i>q</i>) (由于<mathml id="503"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>σ</mi><mo>=</mo><mi>Ο</mi><mo stretchy="false"> (</mo><msqrt><mi>m</mi></msqrt><mo stretchy="false">) </mo></mrow></math></mathml>, 使得LWE假设是困难的并满足ϕ=<i>O</i> (lb <i>σ</i>) =<i>O</i> (lb <i>q</i>) , 并且该整数ϕ与取自参数为<i>σ</i><sup>2</sup>的离散高斯中的样本不可区分.而在本文中, <i>L</i> (<b><i>e</i></b><sup><i>i</i></sup>) 是固定的而不是独立选取的, 且敌手不可获得.</p>
                </div>
                <div class="p1">
                    <p id="504">而从敌手的视角, 仅可以看到<mathml id="505"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>L</mi><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">) </mo></mrow></math></mathml>, (<i>λ</i><sub>1</sub>, <i>λ</i><sub>2</sub>, …, <i>λ</i><sub>ϕ</sub>) ∈<i>χ</i><sup>ϕ</sup>, 但是高斯剩余Hash引理仍能保证该值与<i>L</i> (<b><i>e</i></b><sup><i>i</i></sup>) 相互独立.此外, 正如前面所解释的, 攻击者仅能看到一个位而不是整个值<mathml id="506"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mtext>ϕ</mtext></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mi>L</mi><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">e</mi><msup><mrow></mrow><mi>i</mi></msup><mo stretchy="false">) </mo></mrow></math></mathml>, 因此, 本文的DMGSW方案抵抗自适应攻击.</p>
                </div>
                <h3 id="507" name="507" class="anchor-tag"><b>6 总 结</b></h3>
                <div class="p1">
                    <p id="508">自适应攻击是威胁目前主流全同态加密安全性的一种有力的攻击模式.本文给出了对李增鹏等人<citation id="692" type="reference"><link href="611" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>的多私钥GSW方案的一种自适应攻击方法, 并构造了一个抵抗该类自适应攻击的对偶多私钥GSW (DMGSW) 方案.该方案安全性基于ISIS假设和LWE假设, 同时本文给出详细的安全性分析, 并证明了该方案对“一些已知”的自适应攻击的抵抗性.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="575">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On lattices,learning with errors,random linear codes,and cryptography">

                                <b>[1]</b>Regev O. On lattices, learning with errors, random linear codes, and cryptography[C] //Proc of the 37th ACM Symp on the Theory of Computing (STOC’05) . New York: ACM, 2005: 84- 93
                            </a>
                        </p>
                        <p id="577">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Trapdoors for hard lattices andnew cryptographic constructions">

                                <b>[2]</b>Gentry C, Peikert C, Vaikun-tanathan V. Trapdoors for hard lattices and new cryptographic constructions[C] //Proc of the 40th ACM Symp on the Theory of Computing (STOC’08) . New York: ACM, 2008: 197- 206
                            </a>
                        </p>
                        <p id="579">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On key recovery attacks against existing somewhat homomorphic encryption schemes">

                                <b>[3]</b>Chenal M, Tang Qiang. On key recovery attacks against existing somewhat homomorphic encryption schemes[C] //Proc of the 3rd Cryptology and Information Security in Latin (LaintCrypt’14) . Berlin: Springer, 2014: 239- 258
                            </a>
                        </p>
                        <p id="581">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Key recovery attacks against NTRU-based somewhat homomorphic encryption schemes">

                                <b>[4]</b>Chenal M, Tang Qiang. Key recovery attacks against NTRU-based somewhat homomorphic encryption schemes[C] //Proc of the 18th Information Security Conf (ISC’15) . Berlin: Springer, 2015: 397- 418
                            </a>
                        </p>
                        <p id="583">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Adaptive key recovery attacks on NTRU-based somewhat homomorphic encryption schemes">

                                <b>[5]</b>Dahab R, Galbraith D S, Morais E. Adaptive key recovery attacks on NTRU-based somewhat homomorphic encryption schemes[C] //Proc of the 8th Int Conf on Information Theoretic Security (ICITS’15) . Berlin: Springer, 2015: 283- 296
                            </a>
                        </p>
                        <p id="585">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On CCA-secure somewhat homomorphic encryption">

                                <b>[6]</b>Loftus J, May A, Smart P N, et al. On CCA-secure somewhat homomorphic encryption[C] //Proc of the 18th Selected Areas in Cryptography (SAC’11) . Berlin: Springer, 2011: 55- 72
                            </a>
                        </p>
                        <p id="587">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On the CCA-1 security of somewhat homomorphic encryption over the integers">

                                <b>[7]</b>Zhang Zhenfei, Plantard T, Susilo W. On the CCA-1 security of somewhat homomorphic encryption over the integers[C] //Proc of the 8th Information Security Practice and Experience (ISPEC’12) . Berlin: Springer, 2012: 353- 368
                            </a>
                        </p>
                        <p id="589">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fully Homomorphic Encryption without Modulus Switching from Classical GapSVP">

                                <b>[8]</b>Brakerski Z. Fully homomorphic encryption without modulus switching from classical gapsvp[C] //Proc of the 32nd Int Cryptology Conf (CRYPTO’12) . Berlin: Springer, 2012: 868- 886
                            </a>
                        </p>
                        <p id="591">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fully homomorphic encryption without bootstrapping">

                                <b>[9]</b>Brakerski Z, Gentry C, Vaikuntanathan V. (Leveled) Fully homomorphic encryption without bootstrapping[C] //Proc of Innovations in (Theoretical) Computer Science (ITCS’12) . New York: ACM, 2012: 309- 325
                            </a>
                        </p>
                        <p id="593">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient fully homomorphic encryption from(standard)LWE">

                                <b>[10]</b>Brakerski Z, Vaikuntanathan V. Efficient fully homomorphic encryption from (standard) LWE[C] //Proc of the 52nd IEEE Annual Symp on Foundations of Computer Science (FOCS’11) . Piscataway, NJ: IEEE, 2011: 97- 106
                            </a>
                        </p>
                        <p id="595">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Homomorphic encryption form learning with errors:conceptually-simpler,asymptotically-faster,attributed-based">

                                <b>[11]</b>Gentry C, Sahai A, Waters B. Homomorphic encryption from learning with errors: Conceptually-simpler, asymptoti-cally-faster, attribute-based[C] //Proc of the 33rd Int Cryptology Conf (CRYPTO’13) . Berlin: Springer, 2013: 75- 92
                            </a>
                        </p>
                        <p id="597">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fully Homomorphic Encryption using ideal lattices">

                                <b>[12]</b>Gentry C. Fully homomorphic encryption using ideal lattices[C] //Proc of the 41st ACM Symp on the Theory of Computing (STOC’09) . New York: ACM, 2009: 169- 178
                            </a>
                        </p>
                        <p id="599">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fully homomorphic encryption with relatively small key and ciphertext sizes">

                                <b>[13]</b>Smart P N, Vercauteren F. Fully homomorphic encryption with relatively small key and ciphertext sizes[C] //Proc of the 13th Int Conf on Theory and Practice of Public Key Cryptography (PKC’10) . Berlin: Springer, 2010: 420- 443
                            </a>
                        </p>
                        <p id="601">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Subexponential class group and unit group computation in large degree number fields">

                                <b>[14]</b>Biasse F J, Fieker C. Subexponential class group and unit group computation in large degree number fields[J]. LMS Journal of Computation &amp; Mathematics, 2014, 17 (A) : 385- 403
                            </a>
                        </p>
                        <p id="603">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient quantum algorithms for computing class groups and solving the principal ideal problem in arbitrary degree number fields">

                                <b>[15]</b>Biasse J F, Song Fang. Efficient quantum algorithms for computing class groups and solving the principal ideal problem in arbitrary degree number fields[C] //Proc of the 27th ACM-SIAM Symp on Discrete Algorithms (SODA’16) . New York: ACM, 2016: 893- 902
                            </a>
                        </p>
                        <p id="605">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Recovering short generators of principal ideals in cyclotomic rings">

                                <b>[16]</b>Cramer R, Ducas L, Peikert C, et al. Recovering short generators of principal ideals in cyclotomic rings[C] //Proc of the 35th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’16) . Berlin: Springer, 2016: 559- 585
                            </a>
                        </p>
                        <p id="607">
                            <a id="bibliography_17" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Chosen-ciphertext secure fully homomorphic encryption">

                                <b>[17]</b>Canetti R, Raghuraman S, Richelson S, et al. Chosen-ciphertext secure fully homomorphic encryption[C] //Proc of the 20th Int Conf on Theory and Practice of Public Key Cryptography (PKC’17) . Berlin: Springer, 2017: 213- 240
                            </a>
                        </p>
                        <p id="609">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Chosen-ciphertext attacks against protocols based on the RSA encryption standard PKCS#1">

                                <b>[18]</b>Bleichenbacher D. Chosen ciphertext attacks against protocols based on the RSA encryption standard PKCS #1[C] //Proc of the 18th Int Cryptology Conf (CRYPTO’98) . Berlin: Springer, 1998: 1- 12
                            </a>
                        </p>
                        <p id="611">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Preventing adaptive key recovery attacks on the GSW levelled homomorphic encryption scheme">

                                <b>[19]</b>Li Zengpeng, Galbraith D S, Ma Chunguang. Preventing adaptive key recovery attacks on the GSW levelled homomorphic encryption scheme[C] //Proc of the 10th Provable Security (ProvSec’16) . Berlin: Springer, 2016: 373- 383
                            </a>
                        </p>
                        <p id="613">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Multi-identity and multi-key leveled FHE from learning with errors">

                                <b>[20]</b>Clear M, McGoldrick C. Multi-identity and multi-key leveled FHE from learning with errors[C] //Proc of the 35th Int Cryptology Conf (CRYPTO’15) . Berlin: Springer, 2015: 630- 656
                            </a>
                        </p>
                        <p id="615">
                            <a id="bibliography_21" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Two round multiparty computation via multi-key FHE">

                                <b>[21]</b>Mukherjee P, Wichs D. Two round multiparty computation via multi-key FHE[C] //Proc of the 35th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’16) . Berlin: Springer, 2016: 735- 763
                            </a>
                        </p>
                        <p id="617">
                            <a id="bibliography_22" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Public-key cryptosystems from the worst-case shortest vector problem">

                                <b>[22]</b>Peikert C. Public-key cryptosystems from the worst-case shortest vector problem: Extended abstract[C] //Proc of the 41st ACM Symp on the Theory of Computing (STOC’09) . New York: ACM, 2009: 333- 342
                            </a>
                        </p>
                        <p id="619">
                            <a id="bibliography_23" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient Lattice (H)IBE in the Standard Model">

                                <b>[23]</b>Agrawal S, Boneh D, Boyen X. Efficient lattice (H) IBE in the standard model[C] //Proc of the 29th Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’10) . Berlin: Springer, 2010: 553- 572
                            </a>
                        </p>
                        <p id="621">
                            <a id="bibliography_24" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Lattice signatures without trapdoors">

                                <b>[24]</b>Lyubashevsky V. Lattice signatures without trapdoors[C] //Proc of the 31st Annual Int Conf on the Theory and Applications of Cryptographic Techniques (EUROCRYPT’12) . Berlin: Springer, 2012: 738- 755
                            </a>
                        </p>
                        <p id="623">
                            <a id="bibliography_25" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Lossy Trapdoor Functions and Their Applications">

                                <b>[25]</b>Peikert C, Waters B. Lossy trapdoor functions and their applications[J]. SIAM Journal on Computing, 2011, 40 (6) : 1803- 1844
                            </a>
                        </p>
                        <p id="625">
                            <a id="bibliography_26" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Preventing adaptive key recovery attacks on the GSW levelled homomorphic encryption scheme">

                                <b>[26]</b>Li Zengpeng, Galbraith D S, Ma Chunguang. Preventing adaptive key recovery attacks on the gentry-sahai-waters leveled homomorphic encryption scheme, 2016/1146[R/OL]. New York: IACR Cryptology ePrint Archive, 2016 [2017-06-01]. https://eprint.iacr.org/2016/1146.pdf
                            </a>
                        </p>
                        <p id="627">
                            <a id="bibliography_27" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Faster bootstrapping with polynomial error">

                                <b>[27]</b>Alperin-Sheriff J, Peikert C. Faster bootstrapping with polynomial error[C] //Proc of the 34th Int Cryptology Conf (CRYPTO’14) . Berlin: Springer, 2014: 297- 314
                            </a>
                        </p>
                        <p id="629">
                            <a id="bibliography_28" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Generating hard instances of lattice problems (extended abstract)">

                                <b>[28]</b>Ajtai M. Generating hard instances of lattice problems (extended abstract) [C] //Proc of the 8th ACM Symp on the Theory of Computing (STOC’96) . New York: ACM, 1996: 99- 108
                            </a>
                        </p>
                        <p id="631">
                            <a id="bibliography_29" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Generalized compact knapsacks, cyclic lattices, and efficient one-way functions from worst-case complexity assumptions">

                                <b>[29]</b>Micciancio D. Generalized compact knapsacks, cyclic lattices, and efficient one-way functions from worst-case complexity assumptions[C] //Proc of the 43rd IEEE Annual Symp on Foundations of Computer Science (FOCS’02) . Los Alamitos, CA: IEEE Computer Society, 2002: 356- 365
                            </a>
                        </p>
                        <p id="633">
                            <a id="bibliography_30" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Discrete gaussian leftover hash lemma over infinite domains">

                                <b>[30]</b>Agrawal S, Gentry C, Halevi S, et al. Discrete gaussian leftover hash lemma over infinite domains[C] //Proc of the 19th Int Conf on the Theory and Application of Cryptology and Information Security (ASIACRYPT’13) . Berlin: Springer, 2013: 97- 116
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201903004" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201903004&amp;v=MTcxMTdJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N21XNy9PTHl2U2RMRzRIOWpNckk5Rlk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="1" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
