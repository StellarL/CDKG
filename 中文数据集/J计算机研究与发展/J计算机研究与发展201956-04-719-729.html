

<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>

</head>

<body>

    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637129041869181250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201904004%26RESULT%3d1%26SIGN%3d6DqcBjuMqYQGqXrhKFxySeCk38Q%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201904004&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201904004&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>


    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201904004&amp;v=MjM0NjRkTEc0SDlqTXE0OUZZSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnFGQ25oVkx6UEx5dlM=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#44" data-title="&lt;b&gt;1 VISU一致性协议正确性论证&lt;/b&gt; "><b>1 VISU一致性协议正确性论证</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#46" data-title="&lt;b&gt;1.1 一致性的定义&lt;/b&gt;"><b>1.1 一致性的定义</b></a></li>
                                                <li><a href="#48" data-title="&lt;b&gt;1.2 VISU协议的描述&lt;/b&gt;"><b>1.2 VISU协议的描述</b></a></li>
                                                <li><a href="#62" data-title="&lt;b&gt;1.3 VISU协议正确性论证&lt;/b&gt;"><b>1.3 VISU协议正确性论证</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#69" data-title="&lt;b&gt;2 VISU协议的具体实现方案&lt;/b&gt; "><b>2 VISU协议的具体实现方案</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#74" data-title="&lt;b&gt;2.1 私有共享数据的划分&lt;/b&gt;"><b>2.1 私有共享数据的划分</b></a></li>
                                                <li><a href="#78" data-title="&lt;b&gt;2.2 私有到共享的切换机制&lt;/b&gt;"><b>2.2 私有到共享的切换机制</b></a></li>
                                                <li><a href="#80" data-title="&lt;b&gt;2.3 协议中同步原语的支持&lt;/b&gt;"><b>2.3 协议中同步原语的支持</b></a></li>
                                                <li><a href="#84" data-title="&lt;b&gt;2.4 同步点共享数据的自更新&lt;/b&gt;"><b>2.4 同步点共享数据的自更新</b></a></li>
                                                <li><a href="#86" data-title="&lt;b&gt;2.5 实现中优化设计&lt;/b&gt;"><b>2.5 实现中优化设计</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#89" data-title="&lt;b&gt;3 实验结果与分析&lt;/b&gt; "><b>3 实验结果与分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#90" data-title="&lt;b&gt;3.1 实验环境&lt;/b&gt;"><b>3.1 实验环境</b></a></li>
                                                <li><a href="#95" data-title="&lt;b&gt;3.2 程序请求的分类&lt;/b&gt;"><b>3.2 程序请求的分类</b></a></li>
                                                <li><a href="#99" data-title="&lt;b&gt;3.3 VISU协议运行性能&lt;/b&gt;"><b>3.3 VISU协议运行性能</b></a></li>
                                                <li><a href="#103" data-title="&lt;b&gt;3.4 VISU的开销&lt;/b&gt;"><b>3.4 VISU的开销</b></a></li>
                                                <li><a href="#109" data-title="&lt;b&gt;3.5 VISU中延时写直达的影响&lt;/b&gt;"><b>3.5 VISU中延时写直达的影响</b></a></li>
                                                <li><a href="#113" data-title="&lt;b&gt;3.6 VISU协议对cache缺失率的影响&lt;/b&gt;"><b>3.6 VISU协议对cache缺失率的影响</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#117" data-title="&lt;b&gt;4 结束语&lt;/b&gt; "><b>4 结束语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#55" data-title="图1 VISU 私有数据读 (Rd) 、写 (Wrt) 、写回 (WB) 事务">图1 VISU 私有数据读 (Rd) 、写 (Wrt) 、写回 (WB) 事务</a></li>
                                                <li><a href="#56" data-title="图2 VISU 私有数据协议状态图">图2 VISU 私有数据协议状态图</a></li>
                                                <li><a href="#60" data-title="图3 VISU共享数据读 (Rd) 、写 (Wrt) 、写直达 (WT-timeout) 、同步点 (Sync) 事务">图3 VISU共享数据读 (Rd) 、写 (Wrt) 、写直达 (WT-timeout) 、同步点 ......</a></li>
                                                <li><a href="#72" data-title="图4 VISU协议实现框图">图4 VISU协议实现框图</a></li>
                                                <li><a href="#73" data-title="图5 TLB entry和页表项的组成">图5 TLB entry和页表项的组成</a></li>
                                                <li><a href="#83" data-title="图6 VISU中共享数据的原子操作 (RMW) 协议">图6 VISU中共享数据的原子操作 (RMW) 协议</a></li>
                                                <li><a href="#92" data-title="&lt;b&gt;表1 系统参数配置&lt;/b&gt;"><b>表1 系统参数配置</b></a></li>
                                                <li><a href="#97" data-title="图7 并行程序中各类请求的比例">图7 并行程序中各类请求的比例</a></li>
                                                <li><a href="#101" data-title="图8 归一化的运行时间">图8 归一化的运行时间</a></li>
                                                <li><a href="#105" data-title="&lt;b&gt;表2 3种协议对比&lt;/b&gt;"><b>表2 3种协议对比</b></a></li>
                                                <li><a href="#106" data-title="图9 &lt;i&gt;N&lt;/i&gt;个节点系统中block的目录表项">图9 <i>N</i>个节点系统中block的目录表项</a></li>
                                                <li><a href="#111" data-title="图10 VISU和VIPS写直达延时时间与报文数量">图10 VISU和VIPS写直达延时时间与报文数量</a></li>
                                                <li><a href="#115" data-title="图11 自更新VISU协议与自失效VIPS协议缺失率">图11 自更新VISU协议与自失效VIPS协议缺失率</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="188">


                                    <a id="bibliography_1" title="Martin M, Sorin D, Beckmann B, et al.Multifacet’s general execution-driven multiprocessor simulator (GEMS) toolset[J].ACM SIGARCH Computer Architecture News, 2005, 33 (4) :92-99" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000044587&amp;v=MzA3MDlycVFUTW53WmVadUh5am1VTHZMSVZvVGFSUT1OaWZJWTdLN0h0ak5yNDlGWk84TENYUStvQk1UNlQ0UFFIL2lyUmRHZQ==&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                        Martin M, Sorin D, Beckmann B, et al.Multifacet’s general execution-driven multiprocessor simulator (GEMS) toolset[J].ACM SIGARCH Computer Architecture News, 2005, 33 (4) :92-99
                                    </a>
                                </li>
                                <li id="190">


                                    <a id="bibliography_2" title="Cuesta B, Ros A, G&#243;mez M E, et al.Increasing the effectiveness of directory caches by deactivating coherence for private memory blocks[C]//Proc of the 38th Int Symp on Computer Architecture.New York:ACM, 2011:93-104" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Increasing theeffectiveness of directory caches by deactivating coherence forprivate memory blocks">
                                        <b>[2]</b>
                                        Cuesta B, Ros A, G&#243;mez M E, et al.Increasing the effectiveness of directory caches by deactivating coherence for private memory blocks[C]//Proc of the 38th Int Symp on Computer Architecture.New York:ACM, 2011:93-104
                                    </a>
                                </li>
                                <li id="192">


                                    <a id="bibliography_3" title="Kaxiras S, Keramidas G.SARC coherence:Scaling directory cache coherence in performance and power[J].IEEE Micro, 2010, 30 (5) :54-65" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=SARC Coherence: Scaling Directory Cache Coherence in Performance and Power">
                                        <b>[3]</b>
                                        Kaxiras S, Keramidas G.SARC coherence:Scaling directory cache coherence in performance and power[J].IEEE Micro, 2010, 30 (5) :54-65
                                    </a>
                                </li>
                                <li id="194">


                                    <a id="bibliography_4" title="Menezo L G, Puente V, Gregorio J A.Flask coherence:Amorphable hybrid coherence protocol to balance energy, performance and scalability[C]//Proc of the 21st IEEE Int Symp on High Performance Computer Architecture.Piscataway, NJ:IEEE, 2015:198-209" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Flask coherence:Amorphable hybrid coherence protocol to balance energy,performance and scalability">
                                        <b>[4]</b>
                                        Menezo L G, Puente V, Gregorio J A.Flask coherence:Amorphable hybrid coherence protocol to balance energy, performance and scalability[C]//Proc of the 21st IEEE Int Symp on High Performance Computer Architecture.Piscataway, NJ:IEEE, 2015:198-209
                                    </a>
                                </li>
                                <li id="196">


                                    <a id="bibliography_5" title="Hossain H, Dwarkadas S, Huang M.POPS:Coherence protocol optimization for both private and shared data[C]//Proc of Int Conf on Parallel Architectures and Compilation Techniques.Los Alamitos, CA:IEEE Computer Society, 2011:45-55" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=POPS: Coherence Protocol Optimizationfor Both Private and Shared Data">
                                        <b>[5]</b>
                                        Hossain H, Dwarkadas S, Huang M.POPS:Coherence protocol optimization for both private and shared data[C]//Proc of Int Conf on Parallel Architectures and Compilation Techniques.Los Alamitos, CA:IEEE Computer Society, 2011:45-55
                                    </a>
                                </li>
                                <li id="198">


                                    <a id="bibliography_6" title="Hou Fangyong, Gu Dawu, Xiao Nong, et al.Performance and consistency improvements of Hash tree based disk storage protection[C]//Proc of IEEE Int Conf on Networking, Architecture, and Storage.Los Alamitos, CA:IEEE Computer Society, 2009:51-56" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Performance and consistency improvements of Hash tree based disk storage protection">
                                        <b>[6]</b>
                                        Hou Fangyong, Gu Dawu, Xiao Nong, et al.Performance and consistency improvements of Hash tree based disk storage protection[C]//Proc of IEEE Int Conf on Networking, Architecture, and Storage.Los Alamitos, CA:IEEE Computer Society, 2009:51-56
                                    </a>
                                </li>
                                <li id="200">


                                    <a id="bibliography_7" title="Qian Xuehai, Sahelices B, Qian Depei.Pacifier:Record and replay for relaxed-consistency multiprocessors with distributed directory protocol[J].ACM SIGARCH Computer Architecture News, 2014, 42 (3) :433-444" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMCFD0709C16B22F42B9BC6A095390427D&amp;v=MTc5NTJyNFkyWmUxOURuNVB5eFJoNDAwT1RnN2lwUmMyY0xLUVI3M3JDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVOeGl4Ynk0dzY0PU5pZklZOERPYXRITA==&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                        Qian Xuehai, Sahelices B, Qian Depei.Pacifier:Record and replay for relaxed-consistency multiprocessors with distributed directory protocol[J].ACM SIGARCH Computer Architecture News, 2014, 42 (3) :433-444
                                    </a>
                                </li>
                                <li id="202">


                                    <a id="bibliography_8" title="Huang He, Liu Lei, Song Fenglong, et al.Architecture supported synchronization-based cache coherence protocol for many-core processors[J].Chinese Journal of Computers, 2009, 32 (8) :1618-1630 (in Chinese) (黄河, 刘磊, 宋风龙, 等.硬件结构支持的基于同步的高速缓存一致性协议[J].计算机学报, 2009, 32 (8) :1618-1630) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX200908018&amp;v=MDc1NzlLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnFGQ25oVkx6T0x6N0Jkckc0SHRqTXA0OUViSVE=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[8]</b>
                                        Huang He, Liu Lei, Song Fenglong, et al.Architecture supported synchronization-based cache coherence protocol for many-core processors[J].Chinese Journal of Computers, 2009, 32 (8) :1618-1630 (in Chinese) (黄河, 刘磊, 宋风龙, 等.硬件结构支持的基于同步的高速缓存一致性协议[J].计算机学报, 2009, 32 (8) :1618-1630) 
                                    </a>
                                </li>
                                <li id="204">


                                    <a id="bibliography_9" >
                                        <b>[9]</b>
                                    Li Gongming.Cache coherence techniques for chip multiprocessor architecture[D].Hefei:University of Science and Technology of China, 2013 (in Chinese) (李功明.片上多核处理器体系结构中Cache一致性模型研究[D].合肥:中国科学技术大学, 2013) </a>
                                </li>
                                <li id="206">


                                    <a id="bibliography_10" title="Zhang Jun, Tian Ze, Mei Kuizhi, et al.Node predicting based direct cache coherence protocol for chip multi-processor[J].Chinese Journal of Computers, 2014, 37 (3) :700-720 (in Chinese) (张俊, 田泽, 梅魁志, 等.基于节点预测的直接cache一致性协议[J].计算机学报, 2014, 37 (3) :700-720) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201403019&amp;v=MDQwMDNVUkxPZVplUnFGQ25oVkx6T0x6N0Jkckc0SDlYTXJJOUViWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckM=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                        Zhang Jun, Tian Ze, Mei Kuizhi, et al.Node predicting based direct cache coherence protocol for chip multi-processor[J].Chinese Journal of Computers, 2014, 37 (3) :700-720 (in Chinese) (张俊, 田泽, 梅魁志, 等.基于节点预测的直接cache一致性协议[J].计算机学报, 2014, 37 (3) :700-720) 
                                    </a>
                                </li>
                                <li id="208">


                                    <a id="bibliography_11" title="Kim D, Ahn J, Kim J, et al.Subspace snooping:Filtering snoops with operating system support[C]//Proc of the 19th Int Conf on Parallel Architectures and Compilation Techniques.New York:ACM, 2010:111-122" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Subspace snooping:Filtering snoops with operating system support">
                                        <b>[11]</b>
                                        Kim D, Ahn J, Kim J, et al.Subspace snooping:Filtering snoops with operating system support[C]//Proc of the 19th Int Conf on Parallel Architectures and Compilation Techniques.New York:ACM, 2010:111-122
                                    </a>
                                </li>
                                <li id="210">


                                    <a id="bibliography_12" title="Ros A, Kaxiras S.Complexity-effective multicore coherence[C]//Proc of the 21st Int Conf on Parallel Architectures and Compilation Techniques.New York:ACM, 2012:241-252" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Complexity-effective multicore coherence">
                                        <b>[12]</b>
                                        Ros A, Kaxiras S.Complexity-effective multicore coherence[C]//Proc of the 21st Int Conf on Parallel Architectures and Compilation Techniques.New York:ACM, 2012:241-252
                                    </a>
                                </li>
                                <li id="212">


                                    <a id="bibliography_13" title="Sorin D, Hill M, Wood D.A Primer on Memory Consistency and Cache Coherence[M].Williston, VT:Morgan&amp;amp;Claypool Publishers, 2011" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A Primer on Memory Consistency and Cache Coherence">
                                        <b>[13]</b>
                                        Sorin D, Hill M, Wood D.A Primer on Memory Consistency and Cache Coherence[M].Williston, VT:Morgan&amp;amp;Claypool Publishers, 2011
                                    </a>
                                </li>
                                <li id="214">


                                    <a id="bibliography_14" title="Agarwal N, Krishna T, Peh L S, et al.GARNET:Adetailed on-chip network model inside a full-system simulator[C]//Proc of Int Symp on Performance Analysis of Systems and Software.Piscataway, NJ:IEEE, 2009:33-42" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=GARNET:a detailed on-chip network model inside a full-system simulator">
                                        <b>[14]</b>
                                        Agarwal N, Krishna T, Peh L S, et al.GARNET:Adetailed on-chip network model inside a full-system simulator[C]//Proc of Int Symp on Performance Analysis of Systems and Software.Piscataway, NJ:IEEE, 2009:33-42
                                    </a>
                                </li>
                                <li id="216">


                                    <a id="bibliography_15" title="Muralimanohar N, Balasubramonian R, Jouppi N P.Architecting efficient interconnects for large caches with CACTI 6.0[J].IEEE Micro, 2008, 28 (1) :69-79" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Architecting efficient interconnects for large caches with CACTI 6.0">
                                        <b>[15]</b>
                                        Muralimanohar N, Balasubramonian R, Jouppi N P.Architecting efficient interconnects for large caches with CACTI 6.0[J].IEEE Micro, 2008, 28 (1) :69-79
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(04),719-729 DOI:10.7544/issn1000-1239.2019.20170898            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>一种基于自更新的简单高效Cache一致性协议</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E4%BD%95%E9%94%A1%E6%98%8E&amp;code=39547182&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">何锡明</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%A9%AC%E8%83%9C&amp;code=23817039&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">马胜</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%BB%84%E7%AB%8B%E6%B3%A2&amp;code=20381671&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">黄立波</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%99%88%E5%BE%AE&amp;code=20118834&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">陈微</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%8B%E5%BF%97%E8%8B%B1&amp;code=20250881&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">王志英</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E9%99%A2&amp;code=0269230&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">国防科技大学计算机学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>随着片上多处理器系统核数的增加, 当前一致性协议上存在的许多问题使共享存储系统复杂而低效.目前一些一致性协议极其复杂, 例如MESI (modified exclusive shared or invalid) 协议, 存在众多的中间状态和竞争.并且这些协议还会导致额外失效通信, 以及大量记录共享信息的目录存储开销 (目录协议) 或广播消息的网络开销 (监听协议) .对数据无竞争的程序实现了一种简单高效一致性协议VISU (valid/invalid states based on self-updating) , 这种协议基于自更新操作 (self-updating) 、只包含2个稳定状态 (valid/invalid) .所设计的两状态VISU协议消除了目录和间接事务.首先基于并行编程的数据无竞争 (data race free, DRF) 模型, 采用在同步点进行自更新共享数据来保证正确性.其次利用动态识别私有和共享数据的技术, 提出了对私有数据进行写回、对共享数据进行写直达的方案.对于私有数据, 简单的写回策略能够简化不必要的片上通信.在L1 cache中, 对于共享数据的写直达方式能确保LLC (last level cache) 中数据最新从而消除了几乎所有的一致性状态.实现的VISU协议开销低、不需要目录、没有间接传输和众多的一致性状态, 且更加容易验证, 同时获得了与MESI目录协议几乎相当甚至更优的性能.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">共享存储;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%89%87%E4%B8%8A%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">片上多处理器;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=cache%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">cache一致性协议;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%87%AA%E6%9B%B4%E6%96%B0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">自更新;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=VISU%E5%8D%8F%E8%AE%AE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">VISU协议;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    *马胜 (masheng@nudt.edu.cn) ;
                                </span>
                                <span>
                                    何锡明, heximing15@nudt.edu.cn;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2017-11-28</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金项目 (61572508, 61672526, 61472435, 61472432, 61202121);</span>
                                <span>国防科技大学科研计划项目 (ZK-03-06);</span>
                    </p>
            </div>
                    <h1><b>A Simple and Efficient Cache Coherence Protocol Based on Self-Updating</b></h1>
                    <h2>
                    <span>He Ximing</span>
                    <span>Ma Sheng</span>
                    <span>Huang Libo</span>
                    <span>Chen Wei</span>
                    <span>Wang Zhiying</span>
            </h2>
                    <h2>
                    <span>College of Computer, National University of Defense Technology</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>As the number of cores in a chip multiprocessor increases, cache coherence protocols have become a performance bottleneck of the share-memory system. The overhead and complexity of current cache coherence protocols seriously restrict the development of the share-memory system. Specifically, directory protocols need high storage overhead to keep track of sharer list and snooping protocols consume significant network bandwidth to broadcast messages. Some coherence protocols, such as MESI (modified exclusive shared or invalid) protocol, are extremely complex and have numerous transient states and data race. This paper implements a simple and efficient cache coherence protocol named VISU (valid/invalid states based on self-updating) for data-race-free programs. VISU is based on a self-updating mechanism and only includes two stable states (valid and invalid) . Furthermore, the VISU protocol eliminates the directory and indirection transactions and reduces significant overheads. First, we propose self-updating shared blocks at synchronization points for correction with the data-race-free guarantee of parallel programming. Second, taking advantage of techniques that dynamically classify private data (only accessed by one processor) and shared data, we propose write-back for private data and write-through for shared data. For private data, a simple write-back policy can reduce the unnecessary on-chip network traffic. In L1 cache, a write-through policy for shared data which can keep the newest shared data in LLC, would obviate almost all coherence states. Our approach implements a truly cost-less two-state coherence protocol. The VISU protocol does not require directory or indirect transfer and is easier to verify while at the same time obtains similar even better performance of MESI directory protocol.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=shared%20memory&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">shared memory;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=chip%20multiprocessors&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">chip multiprocessors;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=cache%20coherence%20protocol&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">cache coherence protocol;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=self-updating&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">self-updating;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=VISU%20protocol&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">VISU protocol;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    He Ximing, born in 1991.Received his MSc degree in computer science and technology from the National University of Defense Technology (NUDT) in 2018. His main research interests include network on-chip and cache coherence.<image id="179" type="" href="images/JFYZ201904004_17900.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Ma Sheng, born in 1986.Received his BSc and PhD degrees in computer science and technology from the National University of Defense Technology (NUDT) in 2007and 2012, respectively.He visited the University of Toronto from Sept.2010 to Sept. 2012.His main research interests include on-chip networks, SIMD architectures and arithmetic unit designs.<image id="181" type="" href="images/JFYZ201904004_18100.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Huang Libo, born in 1983.Received his BSc and PhD degrees in computer engineering from the National University of Defense Technology (NUDT) in 2005and 2010, respectively.His main research interests include VLSI design, computer architecture on-chip communication, hardware/software co-design.<image id="183" type="" href="images/JFYZ201904004_18300.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Chen Wei, born in 1982.Received her BSc, MSc and PhD degrees in computer science and technology from the National University of Defense Technology (NUDT) in 2004, 2006and 2010, respectively.She visited the University of Singapore Nanyang Technological University form Nov.2006 to Nov.2007.Her main research interests include high performance computer archi-tecture and microarchitecture.<image id="185" type="" href="images/JFYZ201904004_18500.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Wang Zhiying, born in 1956.Received his PhD degree in electrical engineering from the National University of Defense Tech-nology (NUDT) , China, in 1988.His main research interests include computer architecture, computer security, VLSI design, reliable architecture, multicore memory system, and asy nchronouscircuit.<image id="187" type="" href="images/JFYZ201904004_18700.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2017-11-28</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Natural Science Foundation of China (61572508, 61672526, 61472435, 61472432, 61202121);</span>
                                <span>the Scientific Research Project of National University of Defense Technology (ZK-03-06);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="38">共享存储是当前使用最为广泛的并行编程模型, 然而复杂的一致性协议使设计高效、低功耗、可扩展的多核共享存储系统变得十分困难.为了满足一致性的定义, 一致性协议必须对写操作立即响应, 失效其他核cache备份.这就要求目录协议实时地记录cache的备份并发送间接消息, 或者要求监听协议广播消息去失效备份.除此之外, 当前的协议还会增加各种稳定状态 (独占E或者拥有O) 来提高性能, 增加众多中间状态以处理各种情况下出现的竞争.例如GEM5<citation id="218" type="reference"><link href="188" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>中实现的MESI (modified exclusive shared or invalid) 目录协议在L1中就有15个状态.一直以来, 大多数的共享存储多处理器实现cache一致性都是基于目录协议.在国际上, 针对cache一致性协议的存储开销和验证开销的优化设计层出不穷<citation id="219" type="reference"><link href="190" rel="bibliography" /><link href="192" rel="bibliography" /><link href="194" rel="bibliography" /><link href="196" rel="bibliography" /><link href="198" rel="bibliography" /><link href="200" rel="bibliography" /><sup>[<a class="sup">2</a>,<a class="sup">3</a>,<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">6</a>,<a class="sup">7</a>]</sup></citation>.而在国内, 研究者们在一致性协议功能扩展和性能优化等方面取得了一系列的成果<citation id="220" type="reference"><link href="202" rel="bibliography" /><link href="204" rel="bibliography" /><link href="206" rel="bibliography" /><sup>[<a class="sup">8</a>,<a class="sup">9</a>,<a class="sup">10</a>]</sup></citation>.</p>
                </div>
                <div class="p1">
                    <p id="39">而实际上, 在多核程序运行过程中, 大部分的数据都只被一个处理器访问 (甚至在程序并行阶段) , 我们称之为私有数据.私有数据仅由一个处理器访问, 不存在cache一致性的问题, 不需要一致性的维护.这种数据特性被越来越多的研究者关注, 有的研究者利用这种共享特性过滤监听协议中多余的消息来降低监听协议的网络开销<citation id="221" type="reference"><link href="208" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>, 有的研究者利用这种共享特性对目录协议的存储开销进行优化, 以提高目录的利用率<citation id="222" type="reference"><link href="190" rel="bibliography" /><link href="196" rel="bibliography" /><sup>[<a class="sup">2</a>,<a class="sup">5</a>]</sup></citation>.</p>
                </div>
                <div class="p1">
                    <p id="40">2011年Cuesta 等人<citation id="223" type="reference"><link href="190" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>利用数据划分的方法对协议进行优化.他们通过测试并行测试集SPLASH-2 (Stanford parallel applications for shared memory) 中的8个程序、 scientific benchmarks中的2个程序、ALPBench (all levels of parallelism benchmark for multimedia) 中的4个程序、PARSEC (Princeton application repository for shared-memory computers) 中的4个程序, 发现平均有75%的数据块 (64 B) 是私有的.他们在目录中忽略这些私有数据块的信息, 有效地提高了目录的利用率.实验结果表明:在相同的目录大小情况下, 他们的方案获得15%的性能提高.然而他们这种针对于目录利用率的优化并没有真正地解决协议中的目录开销、大量的一致性状态和间接访问等问题.2012年Ros 等人<citation id="224" type="reference"><link href="210" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>利用划分私有和共享数据的方法, 进行动态的写策略切换.这种写策略对私有数据进行写回, 对共享数据进行写直达, 简化了一致性状态.利用并行程序的数据无竞争 (data race free, DRF) 模型<citation id="225" type="reference"><link href="212" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>, 在同步点进行共享数据自失效的方法完全避免了目录的存储开销.相对于目录协议, 他们的设计平均减少了14.2%的系统能耗.但是写直达方式以及同步点自失效的方法大大增加了系统cache的缺失率, 影响系统性能.</p>
                </div>
                <div class="p1">
                    <p id="41">针对上述问题, 本文主要研究共享存储一致性协议的简化.在满足DRF的模型下, 设计了一种基于自更新操作 (self-updating) 只包含2个稳定状态 (valid/invalid) 的简单高效一致性协议, 简称VISU (valid/invalid states based on self-updating) 协议.协议的简化主要体现在2个部分:</p>
                </div>
                <div class="p1">
                    <p id="42">1) 完全消除目录和间接事务.在目录协议中, 目录的主要功能是记录每个共享备份的位置以便获取最新的数据和失效过期的备份 (间接事务) .VISU协议利用数据的共享特性, 进行私有共享数据块的动态划分.在共享数据方面, VISU协议采用了写直达和自更新操作, LLC (last level cache) 始终保持着最新的共享数据, 同时自更新操作及时地更新过期的备份.在私有数据方面, VISU协议采用写回方式, 在协议中不需要目录记录信息, 不进行一致性的维护 (类似于单核访问) .因此整个协议消除了目录和间接事务.</p>
                </div>
                <div class="p1">
                    <p id="43">2) 简化成2个稳定状态.通过TLB表项提供的页面粒度的私有共享信息, VISU协议在cache line中只需要2个稳定的状态 (valid/invalid) 就能正确地满足一致性, 同时获得了与2种稳定状态的MESI协议相当甚至更优的性能.</p>
                </div>
                <h3 id="44" name="44" class="anchor-tag"><b>1 VISU一致性协议正确性论证</b></h3>
                <div class="p1">
                    <p id="45">为了论证VISU协议的正确性, 首先介绍关于一致性协议需要满足的2个条件, 然后具体描述VISU协议, 最后结合定义与描述论证VISU协议的正确性.</p>
                </div>
                <h4 class="anchor-tag" id="46" name="46"><b>1.1 一致性的定义</b></h4>
                <div class="p1">
                    <p id="47">Sorin 等人<citation id="226" type="reference"><link href="212" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation> 定义一致性:1) 同一时刻满足对于同一存储单元只能一个写或者多个读 (single-write multiple-read, SWMR) ;2) 在每个时期开始阶段存储单元的值都必须和最新一次的读写时期结束阶段的值相同 (data value invariant) , 本文称之为数据最新原则.</p>
                </div>
                <h4 class="anchor-tag" id="48" name="48"><b>1.2 VISU协议的描述</b></h4>
                <div class="p1">
                    <p id="49">本文设计一种基于自更新操作只包含2个稳定状的简单高效VISU协议.协议可分成私有和共享2个独立的部分.首先我们介绍数据无竞争的编程模型, 然后介绍VISU协议中私有数据和共享数据的协议.为了直观地阐述协议, 假设系统为2级cache, L1 cache和LLC (last level cache) .</p>
                </div>
                <div class="p1">
                    <p id="50">数据无竞争的编程模型保证在程序中无数据竞争, 即当2个不同的线程同时访问相同的存储单元且至少有一个是写操作时, 必然存在同步语句把它们分开.数据竞争经常导致程序的错误.DRF编程模型是C++和Java高级编程语言存储模型的基础, 绝大部分并行程序都满足DRF编程模型.因此VISU协议利用了程序的DRF特性进行一致性的设计.</p>
                </div>
                <div class="p1">
                    <p id="51">VISU协议在同步点进行自更新操作以简化间接事务, 并利用数据的共享特性, 把协议分成私有和共享2个独立的部分:</p>
                </div>
                <div class="p1">
                    <p id="52">1) 私有数据协议.私有数据协议类似于单核处理器的数据访问, 消除了私有数据冗余的一致性维护.L1 cache采用了写回的方式.</p>
                </div>
                <div class="p1">
                    <p id="53">2) 共享数据协议.与简单的私有数据协议相比, 共享数据协议在L1 cache中采用写直达的方式代替写回方式.同时, 共享数据在同步点进行自更新操作.</p>
                </div>
                <div class="p1">
                    <p id="54">① VISU协议针对私有数据的处理.VISU协议对私有数据处理类似于单核处理器的处理, 采用cache写回策略.图1和图2展示了2级cache的VISU协议.图1展示了协议中的主要事务读 (read, Rd) 、写 (write, Wrt) 、写回 (write-back, WB) .图2为VISU的状态转换图, 2种稳定状态 (V, I) 和2种中间状态 (VI, IV) , 其中图2 (a) 为L1 cache控制器的状态转换图, 图2 (b) 为LLC 控制器的状态转换图.</p>
                </div>
                <div class="area_img" id="55">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 VISU 私有数据读 (Rd) 、写 (Wrt) 、写回 (WB) 事务" src="Detail/GetImg?filename=images/JFYZ201904004_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 VISU 私有数据读 (Rd) 、写 (Wrt) 、写回 (WB) 事务  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 VISU:Rd, Wrt and WB transactions of private data</p>

                </div>
                <div class="area_img" id="56">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_056.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 VISU 私有数据协议状态图" src="Detail/GetImg?filename=images/JFYZ201904004_056.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 VISU 私有数据协议状态图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_056.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 VISU:State transitions of private data</p>

                </div>
                <div class="p1">
                    <p id="57">当发生读 (Rd) 缺失时, 如图1 (a) , L1 cache发送GetS到LLC, 然后获取Data数据;当发生写 (Wrt) 缺失时, 如图1 (b) 所示, L1发送GetX到LLC中, LLC返回Data数据.由于数据为私有数据, 其他核不存在数据的备份, 所以读缺失和写缺失不需要向其他核发送间接事务.当L1 cache发生驱逐时采用写回策略 (WB) , 如图1 (c) 所示, 把脏的数据Data写入到LLC中, 并返回Ack消息.图2 (a) (b) 分别展示了L1 cache控制器和LLC控制器的状态转换图.图2 (a) 左半部分I→IV→V展示了 L1 cache发生读写缺失, 发送了GetS/GetX消息, 然后接收到数据Data的状态转换, V→V展示了读写命中的状态转换.图2 (a) 右半部分V→VI→I展示了L1 cache的驱逐, L1发送WB事务把脏的数据写入到LLC中, 然后接收到Ack消息的状态转换.图2 (b) 左半部分展示了LLC控制器响应L1 cache的GetS/GetX消息, 然后进行I→IV→V (LLC无数据时, 从内存中读取并返回Mem_data数据) 或者V→V的状态转换.图2 (b) 右半部分则是LLC发生驱逐时, 把脏的数据 (Own-put) 写入到内存中并返回Ack消息的状态转换.整个协议只包含2种稳定状态V和I、2种中间状态VI和IV, 并且不需要目录和间接事务.</p>
                </div>
                <div class="p1">
                    <p id="58">② VISU协议针对共享数据的处理.为了满足一致性的定义, 一致性协议必须对写操作立即响应, 失效其他核cache备份, 返回最新的数据.因为没有了目录记录数据的共享者和拥有者, VISU协议对于共享数据的处理就要确定最近写入数据的位置并失效过期的备份, 所以VISU协议添加了一个额外的自更新操作, 用以自动更新过期的备份.相比于私有数据协议, 共享数据协议用写直达操作代替写回操作, 保证在LLC中始终存放最新的数据, 从而使得共享数据协议与私有数据协议一样的简单, 没有目录和间接事务.</p>
                </div>
                <div class="p1">
                    <p id="59">图3展示了共享数据的读 (Rd) 、写 (Wrt) 、写直达 (WT-timeout) 、同步点 (synchronization, Sync) 四种事务.</p>
                </div>
                <div class="area_img" id="60">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_060.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 VISU共享数据读 (Rd) 、写 (Wrt) 、写直达 (WT-timeout) 、同步点 (Sync) 事务" src="Detail/GetImg?filename=images/JFYZ201904004_060.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 VISU共享数据读 (Rd) 、写 (Wrt) 、写直达 (WT-timeout) 、同步点 (Sync) 事务  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_060.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 VISU:Rd, Wrt, WT-timeout and Sync transactions of shared data</p>

                </div>
                <div class="p1">
                    <p id="61">如图3 (a) , 首先对于读缺失, L1 cache发送GetS到LLC中获取数据Data.对于写缺失, 如图3 (b) , L1 cache发送GetX到LLC获取数据, 这部分与私有数据协议相同.不同的是在写操作之后, 共享数据协议要进行写直达 (WT) 操作, 把写入的数据及时地写直达 (WT) 到LLC中, 这样保证LLC一直拥有最新的数据.为了降低写直达产生的大量报文, 如图3 (c) 所示, 协议采用了延时写直达 (WT-timeout) 的方式.最后为了更新过期的备份, 协议利用DRF编程模型识别同步点, 在同步点 (Sync) 进行自更新操作 (SelfU) .如图3 (d) 所示, L1 cache发送SelfU到LLC中, LLC返回最新的数据, 主动地自更新操作消除了间接的失效.</p>
                </div>
                <h4 class="anchor-tag" id="62" name="62"><b>1.3 VISU协议正确性论证</b></h4>
                <div class="p1">
                    <p id="63">本文1.1节引入了描述cache一致性协议正确性的2个条件:单写多读SWMR和数据最新 (data value invariant) , 这里我们将论述在DRF编程模型下VISU协议满足这2个条件, 即论证协议的正确性.</p>
                </div>
                <div class="p1">
                    <p id="64">首先私有数据被单一处理器访问, 这些数据不存在cache一致性问题.故VISU对于私有数据采用了类似于单核处理器的cache写回 (write-back) 的访问方式.这满足单写多读和数据最新 (data value invariant) 条件, 即满足cache一致性.</p>
                </div>
                <div class="p1">
                    <p id="65">其次对于共享数据的访问, 对比目录协议, VISU协议需要论证没有目录和间接失效事务的情况下, 如何及时地失效过期的备份和保证读到最新的数据.</p>
                </div>
                <div class="p1">
                    <p id="66">1) DRF编程模型中不同线程对同一个地址的读写之间必然存在同步操作, 即在每一个写时期 (写操作开始直到遇到同步点) 不存在其他线程的读写操作.例如图3 (b) (c) 中LLC的虚线段就不存在其他线程针对同一地址的读写操作.利用写直达方式, 每次写操作都能及时把最新的数据写入到LLC中, 满足了定义中的单写多读的条件.</p>
                </div>
                <div class="p1">
                    <p id="67">2) 因为不同线程对同一地址的读写操作 (包括读写、写写、写读) 之间必然存在同步点, 每个同步点都要进行自更新操作.这样就能及时地更新过期的备份, 保证在每个时期开始阶段存储单元的值和最近一次读写时期结束阶段的值 (最新写入的值) 相同.因此满足cache一致性定义的数据最新原则.</p>
                </div>
                <div class="p1">
                    <p id="68">综上所述, 对比cache一致性定义的2个条件, VISU协议在DRF编程模型下满足一致性.</p>
                </div>
                <h3 id="69" name="69" class="anchor-tag"><b>2 VISU协议的具体实现方案</b></h3>
                <div class="p1">
                    <p id="70">VISU协议的实现主要有3个部分:数据的划分和切换机制、协议中同步原语的支持 、同步点共享数据的自更新.</p>
                </div>
                <div class="p1">
                    <p id="71">具体的设计方案如图4所示, 从右半部分可以看出, 当访存请求发生TLB缺失时, 就进行页面粒度的数据私有和共享的划分 (下文将具体描述) .图4左半部分是根据私有共享的划分执行协议, 然后进行写直达写回策略的动态切换.L1 cache发生缺失, 就根据数据的私有和共享分别采用VISU协议中私有和共享数据处理的2个部分发送相应的请求, 最终完成数据访存.下文将具体描述私有共享数据的划分、私有到共享的切换机制、协议中同步原语的支持、同步点共享数据的自更新4个部分的实现.</p>
                </div>
                <div class="area_img" id="72">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 VISU协议实现框图" src="Detail/GetImg?filename=images/JFYZ201904004_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 VISU协议实现框图  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 The block diagram of the action in VISU</p>

                </div>
                <div class="area_img" id="73">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_073.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 TLB entry和页表项的组成" src="Detail/GetImg?filename=images/JFYZ201904004_073.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 TLB entry和页表项的组成  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_073.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Format of TLB entry and page table entry</p>

                </div>
                <h4 class="anchor-tag" id="74" name="74"><b>2.1 私有共享数据的划分</b></h4>
                <div class="p1">
                    <p id="75">数据的私有和共享划分, 成为了研究者研究的热点.部分研究工作利用硬件机制进行私有和共享的划分, 这些方案虽然能够进行细粒度的数据划分, 但是造成了大量的存储开销.有的研究者利用编译器进行划分, 但由于在编译阶段较难判断数据的私有和共享, 这种方案实现较为复杂.本文采用操作系统 (OS) 辅助进行私有共享数据的划分, Cuesta 等人<citation id="227" type="reference"><link href="190" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>也采用了类似的划分方法.这种方案利用TLB 表项和页表项 (page table entry) 存储信息.这是一种页面粒度的私有共享划分方案, 当一个页面中的某一个数据共享时, 整个页面都标记为共享.</p>
                </div>
                <div class="p1">
                    <p id="76">首先对于每一个访存请求, 处理器会先查找TLB表项, 进行虚实地址转换.每一个TLB表项主要由虚拟地址和物理地址2部分组成, 再加上一些页面属性的标记位.TLB表项中往往预留一些标志位没有被使用从而允许在TLB表项中添加一个私有共享的标记位P, 因此不需要额外的硬件开销.同理在页表项中添加P域和Keeper域, 分别标记页面是否共享和页面的共享者 (第1次访问这个页面的CPU) , 如图5所示.</p>
                </div>
                <div class="p1">
                    <p id="77">当TLB表项缺失时, TLB表项和页表项中的域就需要进行处理.处理方法如图4中右半部分所示, 访存请求因TLB表项缺失进行页表的访问, 如果发生缺页, 就造成系统异常, 操作系统会进行相应的缺页错误处理并分配新的页面.如果页面被首次访问并且没有缓存在其他TLB中, 操作系统设置新分配的页面为私有 (P域设为1) 页面且记录第1个访问的核为keeper;否则就判断页面的私有和共享的状态, 若私有页面且其被不同的核访问, 触发私有到共享的切换 (下文将详细说明切换机制) , 切换完成后将页面置为共享 (P域设为0) , 最后将设置好标志位的表项添加到TLB中.</p>
                </div>
                <h4 class="anchor-tag" id="78" name="78"><b>2.2 私有到共享的切换机制</b></h4>
                <div class="p1">
                    <p id="79">TLB缺失就进行页面的访问, 当某个核首次访问一个页面时, 页面被置为私有页面且访问的核作为页面的拥有者 (Keeper) .整个页面里的数据为私有数据, 这些数据在L1 cache中采用写回的方式.第2个核访问这个页面, 发现页面被Keeper设置为私有 (P域为1) , 这时触发切换机制, 向Keeper核发送中断, 完成中断后设置页表项中的页面为共享 (P域设为0) .Keeper核接收到中断就更新这个页面的TLB 表项 (设置为共享, P域设为0) , 把L1 cache中脏的数据写入到LLC中.完成切换后, 所有核访问这个页面都会发现页面共享且Keeper核已经将最新的数据写入到LLC中, 这样页面的数据就切换成了共享数据.</p>
                </div>
                <h4 class="anchor-tag" id="80" name="80"><b>2.3 协议中同步原语的支持</b></h4>
                <div class="p1">
                    <p id="81">同步机制通常是以用户级软件例程的方式实现, 这些例程依赖于硬件提供的同步语句.在多处理器中实施同步所需要的是一组能够以原子方式读取修改和写入存储单元的硬件原语, 例如“Test&amp;Set”或者“Compare&amp;Swap”.如果测试 (test) 或者比较 (compare) 一个条件满足, 那么核就竞争到一个存储单元, 执行原子的读修改写操作;否则在L1中对这个存储单元的备份进行旋转, 直到存储单元的数据被其他核修改, 即条件被改变.</p>
                </div>
                <div class="p1">
                    <p id="82">在VISU协议中没有间接的失效操作.一个核结束了敏感区, 释放了一个条件, 在协议上不会去通知正在旋转的核条件的改变, 从而难以完成同步操作.为此VISU一致性协议针对读-修改-写 (RMW) 的原子事务, 采用重新读取LLC数据的方式 (因为存在多个核访问一个数据, 所以数据必然共享, LLC有最新的数据) , 让旋转的核能够感知条件的改变.具体协议如图6所示, 不妨设条件满足时数据为0, 条件不满足时数据为1, L1<sub>0</sub>遇到RMW原子指令, 不管当前是有效还是无效状态 (I/V) , 都发送GetX消息到LLC, LLC接收到GetX就阻塞LLC, 防止原子指令被打断.L1<sub>0</sub>获得数据Data (0) 即条件满足 (锁可用) 进入修改写入状态R (0) W<sub>0</sub> (1) , 发送WT_lock (1) , 写直达数据1占用这个锁, 并释放LLC的阻塞.此时程序进入敏感区 (critical section) 工作, 直到释放条件W<sub>0</sub> (0) .L1发送WT_unlock (0) 操作写入0到LLC中, 使条件重新可用.其他核执行RMW时, 同样发送GetX消息, 例如图6中L1<sub>1</sub>, 发现LLC被阻塞, 则进入LLC的等待队列.当LLC不阻塞时, L1<sub>1</sub>获得数据Data (1) , 发现条件不满足, L1<sub>1</sub>不断旋转, 直到竞争到条件满足读到Data (0) , 进入敏感区.这种绕过L1中的数据, 直接访问LLC的方式, 造成了一定的性能损失, 但同步操作在整个程序中出现的频率很小, 整体性能损失依然可以被接受, 第3节的实验评估也验证了这一点.VISU协议通过这种方式实现了对同步原语的支持.</p>
                </div>
                <div class="area_img" id="83">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 VISU中共享数据的原子操作 (RMW) 协议" src="Detail/GetImg?filename=images/JFYZ201904004_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 VISU中共享数据的原子操作 (RMW) 协议  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 The atomic RMW transaction of shared  data in VISU</p>

                </div>
                <h4 class="anchor-tag" id="84" name="84"><b>2.4 同步点共享数据的自更新</b></h4>
                <div class="p1">
                    <p id="85">在一致性协议中, 监听协议通过广播消息作废所有过期的备份, 而目录协议通过目录节点间接转发消息失效过期的备份.之前有研究者采用了自失效操作, 即每个核在同步点失效各自L1 cache中过期的备份来保证协议的一致性, 降低协议的复杂性.共享数据被多个核使用, 很大程度上可能被多次地读写.如果每一个同步点都采用自失效操作来失效所有的共享数据, 无疑会大大增加共享数据的cache失效率.基于此, 本文提出了在同步点进行自更新操作.自更新操作不仅能够有效地降低共享数据cache的失效率和提高性能, 而且能够起到和自失效操作相同的作用, 保证协议的正确性.每一个进入L1 cache的数据都会根据TLB表项中的私有共享标志位P在cache line中设置共享和私有.基于这些私有共享标记位, 当程序识别到同步点时, 会完成共享数据从LLC到L1 cache的更新.考虑到随着程序的运行, 共享数据的数量会不断地增加, 为此本设计中设置了一个阈值, 当共享数据数量大于这个阈值时, L1 cache中就采用自失效操作失效共享数据以防止共享数据的累增.</p>
                </div>
                <h4 class="anchor-tag" id="86" name="86"><b>2.5 实现中优化设计</b></h4>
                <div class="p1">
                    <p id="87">1) 写直达的粒度优化.VISU是基于数据无竞争的情况下满足一致性, 但是软件的DRF并不以cache line为粒度.考虑2个核在L1中同时拥有一个cache line的数据, 当这2个核同时对这个cache line中不同的字 (word) 进行写操作时, 在软件层上这2个写操作并不违反DRF原则, 因此这2个并发的写操作之间不存在同步语句.如果对这种情况不加以处理, 最终基于cache line粒度的协议延时写直达就会交错覆盖相互的值.考虑到这个问题, 设计中采用了基于word粒度的写直达方式, 在L1 cache line中针对每一个word设置1个dirty位.在写直达到LLC时, 不同的核只写入其修改的字 (word) 而不影响其他字.</p>
                </div>
                <div class="p1">
                    <p id="88">2) 直接内存处理 (direct memory access, DMA) 协议设计.DMA是现代处理器的重要特色, 在协议上也必须对其有相应的支持.DMA直接使用物理地址进行数据的搬移, 不需要经过TLB的虚实地址转换.因此VISU协议中的私有和共享的划分对其并不适用, 故此设计采用了广播DMA请求的方式, 失效L1中过期的数据, 写回脏的数据到LLC中.上述操作完成后, DMA访问LLC, 获取和写入数据, 完成读取和写入操作.</p>
                </div>
                <h3 id="89" name="89" class="anchor-tag"><b>3 实验结果与分析</b></h3>
                <h4 class="anchor-tag" id="90" name="90"><b>3.1 实验环境</b></h4>
                <div class="p1">
                    <p id="91">为了评估VISU协议的性能, 实验采用GEM5<citation id="228" type="reference"><link href="188" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>全系统模拟器模拟, 搭载Linux 2.6.22 操作系统, 采用GARNET<citation id="229" type="reference"><link href="214" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>仿真片上互联网络.同时利用CACTI 6.5<citation id="230" type="reference"><link href="216" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation> 工具采用32 nm的技术工艺对cache的开销进行评估.设计中仿真8核的片上多核处理器 (chip multiprocessors, CMP) 结构, 运行SPLASH-2中的测试程序.SPLASH-2程序分成了kernels和apps两类程序, 实验中分别选取了这2类中的FFT (64 KB complex doubles) , LU (LU-contiguous_block, 512×512 matrix) , LU-Non (LU-non_contiguous_block, 512×512 matrix) 和Water-Nsq (Water-nsquared, 512 molecules) 并行测试程序进行测试.模拟器中主要的参数如表1所示:</p>
                </div>
                <div class="area_img" id="92">
                    <p class="img_tit"><b>表1 系统参数配置</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 1 Configuration of System</b></p>
                    <p class="img_note"></p>
                    <table id="92" border="1"><tr><td><br />Modules</td><td>Configuration</td></tr><tr><td><br />Processor Frequency/GHz</td><td>1</td></tr><tr><td><br />Cache Line Size</td><td>64 B</td></tr><tr><td><br />Page Size</td><td>4 KB</td></tr><tr><td><br />Delay Timeout/cycle</td><td>500</td></tr><tr><td><br />L1 I&amp;D Cache</td><td>32 KB, 8-way</td></tr><tr><td><br />Shared L2 Cache</td><td>4 MB 512 KB/tile 8-way</td></tr><tr><td><br />Network Topology</td><td>2-dimensional Mesh (4×2) </td></tr><tr><td><br />Routing</td><td>Deterministic <i>X</i>-<i>Y</i></td></tr><tr><td><br />Garnet-network</td><td>Fixed</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="93">实验过程中通过识别操作系统和并行程序中的同步点 (旋转锁、栅栏、中断) 进行自更新操作.利用GEM5全系统模拟器, 仿真整个并行程序, 统计程序并行阶段的数据.实验中仿真了3种一致性协议:1) MESI目录协议, 该协议由2级cache组成, 实时存储着目录信息.MESI目录协议根据目录记录的信息发送消息失效所有的共享者 (写缺失) 或者发送消息获取最新的数据并降级存在的E/M状态 (读缺失) .2) VIPS协议, 这种协议由Ros 等人<citation id="231" type="reference"><link href="210" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>提出.VIPS协议在L1中也只有2种稳定的状态, 与本设计中的VISU设计类似, 但VIPS协议在同步点上采用的是自失效操作.采用同步点自失效的方法保证了协议的一致性, 但一定程度上增加了L1 cache的缺失率.3) 本文提出的VISU协议.该协议在同步点采用自更新的方式, 即在同步点对共享数据进行自更新, 提高cache的命中率, 从而提高系统性能.</p>
                </div>
                <div class="p1">
                    <p id="94">在实验过程中, 延时写直达 (同步点之前) 的延时时间设为500 cycle.写直达延时主要是因为每次写一个数据, 就很可能会访存相应cache line的其他字 (word) 的数据.延时写直达可以合并写操作, 然后一次性写直达到LLC, 降低由写直达造成的大量报文.但是延时写直达必须在下一个同步点之前完成, 所以这个延时时间影响着协议的正确性和系统性能.</p>
                </div>
                <h4 class="anchor-tag" id="95" name="95"><b>3.2 程序请求的分类</b></h4>
                <div class="p1">
                    <p id="96">VISU协议动态识别程序中的私有和共享数据, 采用2种不同的方法进行处理.实验中运行了FFT, LU, LU-Non, Water-Nsq这4个程序并记录了并行阶段这4个程序对私有数据和共享数据发送请求的数量, 把请求分成了4类:取指请求、对共享数据的请求、对私有数据的请求以及同步相关的请求, 如图7所示:</p>
                </div>
                <div class="area_img" id="97">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_097.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 并行程序中各类请求的比例" src="Detail/GetImg?filename=images/JFYZ201904004_097.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 并行程序中各类请求的比例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_097.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 Fraction of different requests in parallel programs</p>

                </div>
                <div class="p1">
                    <p id="98">一般情况下, 取指请求是一类只读请求, 在VISU协议中采用写回的方式进行处理, 不进行私有和共享的划分.从图7可以看出, 私有数据请求比例在FFT中最大, 占程序总请求的5.1%.若把私有数据请求和取指请求均作为私有请求处理 (二者采用相同的私有数据协议) , 则私有请求数量占有比例高达90.1%.而在LU和Water-Nsq程序中私有请求占比较少 (分别占有1.2%和1.8%) 、共享请求占比大, 这影响着这2个程序在VISU协议中的性能.整体上来看, 私有请求 (包括取指请求) 平均占整个并行阶段请求的77.2%.在4个程序中 (FFT, LU, LU-Non, Water-Nsp) 同步相关的请求所占比例依次为0.11%, 0.10%, 0.08%, 0.22%, 其中Water-Nsp相对来说比例较高, 4个程序同步请求平均占比0.14%.</p>
                </div>
                <h4 class="anchor-tag" id="99" name="99"><b>3.3 VISU协议运行性能</b></h4>
                <div class="p1">
                    <p id="100">为了分析VISU协议性能, 实验测试了MESI, VIPS, VISU 这3种协议, 并记录了程序并行阶段的运行时间, 如图8所示.</p>
                </div>
                <div class="area_img" id="101">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_101.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 归一化的运行时间" src="Detail/GetImg?filename=images/JFYZ201904004_101.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图8 归一化的运行时间  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_101.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 8 Normalized execution time</p>

                </div>
                <div class="p1">
                    <p id="102">实验结果以MESI协议的运行时间进行归一化.平均来看, 无目录、有2个稳定状态的VISU协议获得了与有目录、3个稳定状态的MESI协议几乎一样的性能.从FFT程序中可以看出, VISU性能较之MESI协议有11%的性能提升, 一方面来源于私有数据占有比例高;另一方面来源于同步操作, 在VISU (VIPS) 协议中对于同步操作进行自更新 (自失效) , 这是一类为了保证正确性但开销大的操作, 但在FFT中所占比例很少.Water-Nsp的同步操作占有的比例较大, 同时私有请求比例较少, 所以VISU协议的整体性能相比于MESI协议有了8%的性能损失.在同步点比例大时, VISU协议相对VIPS协议能够降低由于同步点导致的大量cache失效, 从Water-Nsp程序上可以看出, 相对VIPS协议, VISU有了4%的性能提升.整体上来看, 简单地更新有限共享数据的VISU协议性能略高于VIPS协议 (平均0.2%的性能提高) .</p>
                </div>
                <h4 class="anchor-tag" id="103" name="103"><b>3.4 VISU的开销</b></h4>
                <div class="p1">
                    <p id="104">在存储开销方面, 表2为3种协议的特征对比, MESI目录协议采用全映射 (full-map) 目录.图9展示的是<i>N</i>节点系统的MESI协议基本的目录表项, 其中2个主要的存储开销:每个数据block的拥有者 (owner) 和数据block的共享列表 (sharer list) , 每个表项都需要增加lb <i>N</i> 位和<i>N</i>位.这些存储开销严重地影响目录协议的可扩展性.在MESI目录协议中, 目录信息存储在LLC的tag中, 实验中测试了3种协议LLC tag的面积开销, 如表2所示.VIPS和VISU协议没有目录, 从而降低了25.4%的面积开销.</p>
                </div>
                <div class="area_img" id="105">
                    <p class="img_tit"><b>表2 3种协议对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 2 Comparison of Three Protocols</b></p>
                    <p class="img_note"></p>
                    <table id="105" border="1"><tr><td rowspan="2"><br />Protocol</td><td rowspan="2">Directory</td><td rowspan="2">LLC Tag <br />Area/mm<sup>2</sup></td><td rowspan="2">Invalidation</td><td colspan="2"><br />L1 States</td></tr><tr><td><br />Stable</td><td>Transient</td></tr><tr><td>MESI</td><td>Full-map</td><td>0.127</td><td>Multicast</td><td>4</td><td>11</td></tr><tr><td><br />VIPS</td><td>No</td><td>0.0952</td><td>Self-invalidation</td><td>2</td><td>2</td></tr><tr><td><br />VISU</td><td>No</td><td>0.0952</td><td>Self-updating</td><td>2</td><td>2</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="106">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_106.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 N个节点系统中block的目录表项" src="Detail/GetImg?filename=images/JFYZ201904004_106.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图9 <i>N</i>个节点系统中block的目录表项  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_106.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 9 Directory entry for a bock in a system  with <i>N</i> nodes</p>

                </div>
                <div class="p1">
                    <p id="107">cache一致性协议的验证问题是CMP设计中的重要课题, 在验证开销方面, VISU与VIPS协议分别采用自更新和自失效的方式作废过期的备份, 这是2种1对1的方式, 而MESI目录协议采用的是利用目录的共享列表进行多播, 如表2所示.</p>
                </div>
                <div class="p1">
                    <p id="108">此外目录协议通过目录向数据拥有者 (owner) 发送数据请求, 增加了额外的间接事务, 而VISU和VIPS协议没有间接访问.VISU协议利用私有和共享数据的划分, 把协议分成了独立的2个部分, 可分别进行验证.同时VISU协议只有2个稳定状态:有效 (valid) 和无效 (invalid) , 在L1 cache中只有2个中间状态 (IV, VI) , 相对于MESI协议有4种稳定状态、在L1 cache中有11种中间状态和各种间接事务, VISU和VIPS协议在验证方面具有显著的优势.</p>
                </div>
                <h4 class="anchor-tag" id="109" name="109"><b>3.5 VISU中延时写直达的影响</b></h4>
                <div class="p1">
                    <p id="110">为了进一步说明写直达中延时时间对于VISU协议的影响, 实验中分别测试了100 cycle, 500 cycle, 1 000 cycle延时对于测试程序报文数量的影响.如图10所示:</p>
                </div>
                <div class="area_img" id="111">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_111.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图10 VISU和VIPS写直达延时时间与报文数量" src="Detail/GetImg?filename=images/JFYZ201904004_111.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图10 VISU和VIPS写直达延时时间与报文数量  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_111.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 10 Number of packects in the VISU and VIPS</p>

                </div>
                <div class="p1">
                    <p id="112">采用延时写直达, 能够利用局部性原理, 合并多次对同一个cache line的写操作, 减少写直达的次数, 降低整个系统的报文数量.但延时写直达操作, 必须保证VISU协议的正确性和系统性能, 确保写入的数据能够及时对其他核可见.从图10可以看出, 当延时从100 cycles增加到500 cycles时, 报文数量显著减少, 平均减少了30.7%.但从500 cycles 增加到1 000 cycles, 报文数量整体减少了6.8%, 其中LU和LU-Non 这2个程序报文数量几乎没有减少.因此在VISU协议中设置延时写直达的时间为500 cycle.</p>
                </div>
                <h4 class="anchor-tag" id="113" name="113"><b>3.6 VISU协议对cache缺失率的影响</b></h4>
                <div class="p1">
                    <p id="114">VISU协议与VIPS协议的主要区别在于采用自更新的方式提高L1 cache的命中率.对于同步点采用自更新还是自失效, 主要取决于2个同步点之间的数据是否会被再一次访问.图11描述的是VIPS和VISU协议的L1 cache失效率, 以VIPS协议的失效率进行归一化.</p>
                </div>
                <div class="area_img" id="115">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201904004_115.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图11 自更新VISU协议与自失效VIPS协议缺失率" src="Detail/GetImg?filename=images/JFYZ201904004_115.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图11 自更新VISU协议与自失效VIPS协议缺失率  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201904004_115.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 11 Normalized cache miss rate in the VISU  and VIPS</p>

                </div>
                <div class="p1">
                    <p id="116">由于协议中自更新和自失效的数据都是共享数据, 共享数据被多个核访存, 很可能会被再一次访问到.同时为了解决在自更新的过程中共享数据不断增加的问题, 在VISU协议中采用预设一个阈值, 当共享数据的数量超过这个阈值时, 超过的部分采用自失效, 防止共享数据的累增.当共享数据的数量少于这个阈值时, 则采用自更新方式.VISU协议采用最后访问的共享数据最先被自更新的策略, 设置一个阈值<i>x</i>, 对最后被访问的<i>x</i>个共享数据进行自更新, 对其他的共享数据采用自失效, 在本实验中设置<i>x</i>=50.利用在同步点进行自更新的方式可以明显地降低cache失效率, 自更新的VISU协议相比VIPS协议平均降低了5.2%的L1 cache失效率.</p>
                </div>
                <h3 id="117" name="117" class="anchor-tag"><b>4 结束语</b></h3>
                <div class="p1">
                    <p id="118">本文针对于共享存储中的cache一致性协议进行了简化, 提出一种没有目录和间接访问、没有众多一致性状态和竞争的cache一致性协议VISU.VISU协议的关键:1) 区分私有和共享数据, 对私有数据采用写回策略, 对共享数据采用写直达策略;2) 利用DRF编程模型中的同步点进行自更新.在VISU协议中, 自更新是一种高效处理过期备份的方式.与一直以来获得广泛使用的目录式和监听式协议相比, VISU协议大大简化了复杂性, 解决了一直以来困扰目录协议可扩展性的目录开销问题.VISU协议不仅不需要像监听协议一样广播大量的请求, 并且还适用于mesh和torus等无序网络.</p>
                </div>
                <div class="p1">
                    <p id="119">通过仿真与分析, 相对于复杂的MESI协议, 简单的VISU协议具有与之相当甚至更优的性能.接下来的工作将会针对VISU自更新操作, 优化共享数据, 提高自更新操作的效率.并进一步将VISU协议扩展到层次集群式的cache结构 (hierarchical clustered cache) 上, 提高VISU协议的可扩展性.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="188">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000044587&amp;v=MjE3MTFMQ1hRK29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUx2TElWb1RhUlE9TmlmSVk3SzdIdGpOcjQ5RlpPOA==&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b>Martin M, Sorin D, Beckmann B, et al.Multifacet’s general execution-driven multiprocessor simulator (GEMS) toolset[J].ACM SIGARCH Computer Architecture News, 2005, 33 (4) :92-99
                            </a>
                        </p>
                        <p id="190">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Increasing theeffectiveness of directory caches by deactivating coherence forprivate memory blocks">

                                <b>[2]</b>Cuesta B, Ros A, Gómez M E, et al.Increasing the effectiveness of directory caches by deactivating coherence for private memory blocks[C]//Proc of the 38th Int Symp on Computer Architecture.New York:ACM, 2011:93-104
                            </a>
                        </p>
                        <p id="192">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=SARC Coherence: Scaling Directory Cache Coherence in Performance and Power">

                                <b>[3]</b>Kaxiras S, Keramidas G.SARC coherence:Scaling directory cache coherence in performance and power[J].IEEE Micro, 2010, 30 (5) :54-65
                            </a>
                        </p>
                        <p id="194">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Flask coherence:Amorphable hybrid coherence protocol to balance energy,performance and scalability">

                                <b>[4]</b>Menezo L G, Puente V, Gregorio J A.Flask coherence:Amorphable hybrid coherence protocol to balance energy, performance and scalability[C]//Proc of the 21st IEEE Int Symp on High Performance Computer Architecture.Piscataway, NJ:IEEE, 2015:198-209
                            </a>
                        </p>
                        <p id="196">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=POPS: Coherence Protocol Optimizationfor Both Private and Shared Data">

                                <b>[5]</b>Hossain H, Dwarkadas S, Huang M.POPS:Coherence protocol optimization for both private and shared data[C]//Proc of Int Conf on Parallel Architectures and Compilation Techniques.Los Alamitos, CA:IEEE Computer Society, 2011:45-55
                            </a>
                        </p>
                        <p id="198">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Performance and consistency improvements of Hash tree based disk storage protection">

                                <b>[6]</b>Hou Fangyong, Gu Dawu, Xiao Nong, et al.Performance and consistency improvements of Hash tree based disk storage protection[C]//Proc of IEEE Int Conf on Networking, Architecture, and Storage.Los Alamitos, CA:IEEE Computer Society, 2009:51-56
                            </a>
                        </p>
                        <p id="200">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMCFD0709C16B22F42B9BC6A095390427D&amp;v=MjU5NzBSaDQwME9UZzdpcFJjMmNMS1FSNzNyQ09OdkZTaVdXcjdKSUZwbWFCdUhZZk9HUWxmQ3BiUTM1TnhpeGJ5NHc2ND1OaWZJWThET2F0SExyNFkyWmUxOURuNVB5eA==&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b>Qian Xuehai, Sahelices B, Qian Depei.Pacifier:Record and replay for relaxed-consistency multiprocessors with distributed directory protocol[J].ACM SIGARCH Computer Architecture News, 2014, 42 (3) :433-444
                            </a>
                        </p>
                        <p id="202">
                            <a id="bibliography_8" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX200908018&amp;v=MTU2OTA1NE8zenFxQnRHRnJDVVJMT2VaZVJxRkNuaFZMek9MejdCZHJHNEh0ak1wNDlFYklRS0RIODR2UjRUNmo=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[8]</b>Huang He, Liu Lei, Song Fenglong, et al.Architecture supported synchronization-based cache coherence protocol for many-core processors[J].Chinese Journal of Computers, 2009, 32 (8) :1618-1630 (in Chinese) (黄河, 刘磊, 宋风龙, 等.硬件结构支持的基于同步的高速缓存一致性协议[J].计算机学报, 2009, 32 (8) :1618-1630) 
                            </a>
                        </p>
                        <p id="204">
                            <a id="bibliography_9" >
                                    <b>[9]</b>
                                Li Gongming.Cache coherence techniques for chip multiprocessor architecture[D].Hefei:University of Science and Technology of China, 2013 (in Chinese) (李功明.片上多核处理器体系结构中Cache一致性模型研究[D].合肥:中国科学技术大学, 2013) 
                            </a>
                        </p>
                        <p id="206">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201403019&amp;v=MjMwMTlHRnJDVVJMT2VaZVJxRkNuaFZMek9MejdCZHJHNEg5WE1ySTlFYllRS0RIODR2UjRUNmo1NE8zenFxQnQ=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b>Zhang Jun, Tian Ze, Mei Kuizhi, et al.Node predicting based direct cache coherence protocol for chip multi-processor[J].Chinese Journal of Computers, 2014, 37 (3) :700-720 (in Chinese) (张俊, 田泽, 梅魁志, 等.基于节点预测的直接cache一致性协议[J].计算机学报, 2014, 37 (3) :700-720) 
                            </a>
                        </p>
                        <p id="208">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Subspace snooping:Filtering snoops with operating system support">

                                <b>[11]</b>Kim D, Ahn J, Kim J, et al.Subspace snooping:Filtering snoops with operating system support[C]//Proc of the 19th Int Conf on Parallel Architectures and Compilation Techniques.New York:ACM, 2010:111-122
                            </a>
                        </p>
                        <p id="210">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Complexity-effective multicore coherence">

                                <b>[12]</b>Ros A, Kaxiras S.Complexity-effective multicore coherence[C]//Proc of the 21st Int Conf on Parallel Architectures and Compilation Techniques.New York:ACM, 2012:241-252
                            </a>
                        </p>
                        <p id="212">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A Primer on Memory Consistency and Cache Coherence">

                                <b>[13]</b>Sorin D, Hill M, Wood D.A Primer on Memory Consistency and Cache Coherence[M].Williston, VT:Morgan&amp;Claypool Publishers, 2011
                            </a>
                        </p>
                        <p id="214">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=GARNET:a detailed on-chip network model inside a full-system simulator">

                                <b>[14]</b>Agarwal N, Krishna T, Peh L S, et al.GARNET:Adetailed on-chip network model inside a full-system simulator[C]//Proc of Int Symp on Performance Analysis of Systems and Software.Piscataway, NJ:IEEE, 2009:33-42
                            </a>
                        </p>
                        <p id="216">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Architecting efficient interconnects for large caches with CACTI 6.0">

                                <b>[15]</b>Muralimanohar N, Balasubramonian R, Jouppi N P.Architecting efficient interconnects for large caches with CACTI 6.0[J].IEEE Micro, 2008, 28 (1) :69-79
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201904004" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201904004&amp;v=MjM0NjRkTEc0SDlqTXE0OUZZSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnFGQ25oVkx6UEx5dlM=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQzZ2tpSTBoVC9vc1JrQ2loSzM0UT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>


    <link href="/kxreader/Content/css/LeftDetail?v=NLcKG8I1SJUaVFrQ0iGpF2klAT0OsmHRaVSZ1rKb5xg1" rel="stylesheet"/>

</body>
</html>

