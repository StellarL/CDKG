

<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>

</head>

<body>

    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637127163929832500%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201909022%26RESULT%3d1%26SIGN%3dnKtrQbnWwYPheN7tquJy0%252b%252b7boI%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201909022&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201909022&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>


    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201909022&amp;v=Mjc2ODg2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS9nVkwzS0x5dlNkTEc0SDlqTXBvOUhab1FLREg4NHZSNFQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#64" data-title="&lt;b&gt;1 学习模型指导的优化顺序选择模型&lt;/b&gt; "><b>1 学习模型指导的优化顺序选择模型</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#65" data-title="&lt;b&gt;1.1 优化顺序问题的形式化描述&lt;/b&gt;"><b>1.1 优化顺序问题的形式化描述</b></a></li>
                                                <li><a href="#72" data-title="&lt;b&gt;1.2 监督学习模型指导的优化顺序选择模型&lt;/b&gt;"><b>1.2 监督学习模型指导的优化顺序选择模型</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#76" data-title="&lt;b&gt;2 程序特征表示&lt;/b&gt; "><b>2 程序特征表示</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#77" data-title="&lt;b&gt;2.1 程序特征&lt;/b&gt;"><b>2.1 程序特征</b></a></li>
                                                <li><a href="#84" data-title="&lt;b&gt;2.2 特征降维技术&lt;/b&gt;"><b>2.2 特征降维技术</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#105" data-title="&lt;b&gt;3 ANN构建&lt;/b&gt; "><b>3 ANN构建</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#106" data-title="&lt;b&gt;3.1 基于ANN的优化顺序预测&lt;/b&gt;"><b>3.1 基于ANN的优化顺序预测</b></a></li>
                                                <li><a href="#122" data-title="&lt;b&gt;3.2 NEAT&lt;/b&gt;"><b>3.2 NEAT</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#131" data-title="&lt;b&gt;4 实  验&lt;/b&gt; "><b>4 实  验</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#142" data-title="&lt;b&gt;5 实验结果分析&lt;/b&gt; "><b>5 实验结果分析</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#143" data-title="&lt;b&gt;5.1 采用不同特征时的预测模型性能&lt;/b&gt;"><b>5.1 采用不同特征时的预测模型性能</b></a></li>
                                                <li><a href="#151" data-title="&lt;b&gt;5.2 Features ANN与迭代编译方法的比较&lt;/b&gt;"><b>5.2 Features ANN与迭代编译方法的比较</b></a></li>
                                                <li><a href="#157" data-title="&lt;b&gt;5.3 Features ANN与非迭代编译方法的比较&lt;/b&gt;"><b>5.3 Features ANN与非迭代编译方法的比较</b></a></li>
                                                <li><a href="#162" data-title="&lt;b&gt;5.4 离线学习和在线预测时间开销比较&lt;/b&gt;"><b>5.4 离线学习和在线预测时间开销比较</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#167" data-title="&lt;b&gt;6 结束语&lt;/b&gt; "><b>6 结束语</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#74" data-title="图1 编译优化顺序预测模型">图1 编译优化顺序预测模型</a></li>
                                                <li><a href="#82" data-title="&lt;b&gt;表1 静态特征列表&lt;/b&gt;"><b>表1 静态特征列表</b></a></li>
                                                <li><a href="#83" data-title="&lt;b&gt;表2 动态特征列表&lt;/b&gt;"><b>表2 动态特征列表</b></a></li>
                                                <li><a href="#108" data-title="图2 Features ANN编译优化选择过程">图2 Features ANN编译优化选择过程</a></li>
                                                <li><a href="#110" data-title="图3 Features ANN迭代输出优化&lt;i&gt;o&lt;/i&gt;&lt;sub&gt;&lt;i&gt;i&lt;/i&gt;&lt;/sub&gt;过程">图3 Features ANN迭代输出优化<i>o</i><sub><i>i</i></sub>过程</a></li>
                                                <li><a href="#125" data-title="图4 NEAT基因映射">图4 NEAT基因映射</a></li>
                                                <li><a href="#138" data-title="&lt;b&gt;表3 大型科学计算程序&lt;/b&gt;"><b>表3 大型科学计算程序</b></a></li>
                                                <li><a href="#227" data-title="图5 优化列表（GCC8.1.0)">图5 优化列表（GCC8.1.0)</a></li>
                                                <li><a href="#146" data-title="图6 采用不同特征时平台1上测试程序加速比">图6 采用不同特征时平台1上测试程序加速比</a></li>
                                                <li><a href="#147" data-title="图7 采用不同特征时平台2上测试程序加速比">图7 采用不同特征时平台2上测试程序加速比</a></li>
                                                <li><a href="#153" data-title="图8 Features ANN与迭代编译方法的性能比较(平台1)">图8 Features ANN与迭代编译方法的性能比较(平台1)</a></li>
                                                <li><a href="#154" data-title="图9 Features ANN与迭代编译方法的性能比较(平台2)">图9 Features ANN与迭代编译方法的性能比较(平台2)</a></li>
                                                <li><a href="#159" data-title="图10 Features ANN与非迭代编译方法的性能比较(平台1)">图10 Features ANN与非迭代编译方法的性能比较(平台1)</a></li>
                                                <li><a href="#160" data-title="图11 Features ANN与非迭代编译方法的性能比较(平台2)">图11 Features ANN与非迭代编译方法的性能比较(平台2)</a></li>
                                                <li><a href="#165" data-title="&lt;b&gt;表4 WRF离线学习和在线预测时间(平台1&lt;/b&gt;) "><b>表4 WRF离线学习和在线预测时间(平台1</b>) </a></li>
                                                <li><a href="#166" data-title="&lt;b&gt;表5 WRF离线学习和在线预测时间(平台2&lt;/b&gt;) "><b>表5 WRF离线学习和在线预测时间(平台2</b>) </a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title="Ashouri H A,Bignoli A,Palermo G,et al.MiCOMP:Mitigating the compiler phase-ordering problem using optimization sub-sequences and machine learning[J].ACM Transactions on Architecture and Code Optimization,2017,14(3):No.12" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=MiCOMP:Mitigating the compiler phase-ordering problem using optimization sub-sequences and machine learning">
                                        <b>[1]</b>
                                        Ashouri H A,Bignoli A,Palermo G,et al.MiCOMP:Mitigating the compiler phase-ordering problem using optimization sub-sequences and machine learning[J].ACM Transactions on Architecture and Code Optimization,2017,14(3):No.12
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title="Nickolls J,Dally W J.The GPU computing era[J].IEEE Micro,2010,30(2):56- 69" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The GPU computing era">
                                        <b>[2]</b>
                                        Nickolls J,Dally W J.The GPU computing era[J].IEEE Micro,2010,30(2):56- 69
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title="Duran A,Klemm M.The Intel&lt;sup&gt;&#169;&lt;/sup&gt; many integrated core architecture[C] //Proc of the 2012 Int Conf on High Performance Computing and Simulation.Piscataway,NJ:IEEE,2012:365- 366" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The Intel many integrated core architecture">
                                        <b>[3]</b>
                                        Duran A,Klemm M.The Intel&lt;sup&gt;&#169;&lt;/sup&gt; many integrated core architecture[C] //Proc of the 2012 Int Conf on High Performance Computing and Simulation.Piscataway,NJ:IEEE,2012:365- 366
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title="The National Supercomputing Guangzhou Center.The TOP500 list of the world&#39;s supercomputers[OL].2017[2017-06-19].http://www.chinastor.com/hpc-top500/201706/0Q43H562017.html" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The TOP500 list of the world&amp;#39;&amp;#39;s supercomputers[OL]">
                                        <b>[4]</b>
                                        The National Supercomputing Guangzhou Center.The TOP500 list of the world&#39;s supercomputers[OL].2017[2017-06-19].http://www.chinastor.com/hpc-top500/201706/0Q43H562017.html
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title="Rajam A S,Clauss P.The polyhedral model of nonlinear loops[J].ACM Transactions on Architecture and Code Optimization,2015,12(4):No.48" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMEC76FE31126A6A01FC1306280BD27E15&amp;v=MzA0NjVveEVaZWtKZlhwSXp4ZGxtVDUrU0huZ3BCSkhEYkNUTUx1YUNPTnZGU2lXV3I3SklGcG1hQnVIWWZPR1FsZkNwYlEzNU5waHc3MjR3cW89TmlmSVk4YkxHZGU2Mg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                        Rajam A S,Clauss P.The polyhedral model of nonlinear loops[J].ACM Transactions on Architecture and Code Optimization,2015,12(4):No.48
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title="Shirako J,Hayashi A,Sarkar V.Optimized two-level parallelization for GPU accelerators using the polyhedral model[C] //Proc of the 26th Int Conf on Compiler Construction.New York:ACM,2017:22- 33" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Optimized two-level parallelization for GPU accelerators using the polyhedral model">
                                        <b>[6]</b>
                                        Shirako J,Hayashi A,Sarkar V.Optimized two-level parallelization for GPU accelerators using the polyhedral model[C] //Proc of the 26th Int Conf on Compiler Construction.New York:ACM,2017:22- 33
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title="Lu Pingjing.Research on key techniques in low-cost iterative compilation optimization[D].Changsha:National University of Defense Technology,2010 (in Chinese)(陆平静.低开销的迭代编译优化关键技术研究[D].长沙:国防科技大学,2010)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=2010271309.nh&amp;v=MzExMDI4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS9nVkwzS1YxMjZIckcvSDlMTXBwRWJQSVFLREg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                        Lu Pingjing.Research on key techniques in low-cost iterative compilation optimization[D].Changsha:National University of Defense Technology,2010 (in Chinese)(陆平静.低开销的迭代编译优化关键技术研究[D].长沙:国防科技大学,2010)
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title="Chen Yang,Fang Shuangde,Eeckhout L,et al.Practical iterative optimization for the data center[J].ACM SIGARCH Computer Architecture News,2012,40(1):49- 60" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Practical iterative optimization for the data center">
                                        <b>[8]</b>
                                        Chen Yang,Fang Shuangde,Eeckhout L,et al.Practical iterative optimization for the data center[J].ACM SIGARCH Computer Architecture News,2012,40(1):49- 60
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title="Purini S,Jain L.Finding good optimization sequences covering program space[J].ACM Transactions on Architecture and Code Optimization,2013,9(4):No.56" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000011838&amp;v=MTExNjU0OUZaT29PQkg4eG9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUwzSUoxc1RhQkE9TmlmSVk3SzdIdGpOcg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[9]</b>
                                        Purini S,Jain L.Finding good optimization sequences covering program space[J].ACM Transactions on Architecture and Code Optimization,2013,9(4):No.56
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title="Nobre R,Martins L G A,Cardoso J M P.A graph-based iterative compiler pass selection and phase ordering approach[C] //Proc of the 17th ACM SIGPLAN/SIGBED Conf on Languages,Compilers,Tools,and Theory for Embedded Systems.New York:ACM,2016:21- 30" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A graph-based iterative compiler pass selection and phase ordering approach">
                                        <b>[10]</b>
                                        Nobre R,Martins L G A,Cardoso J M P.A graph-based iterative compiler pass selection and phase ordering approach[C] //Proc of the 17th ACM SIGPLAN/SIGBED Conf on Languages,Compilers,Tools,and Theory for Embedded Systems.New York:ACM,2016:21- 30
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title="Martins L G A,Nobre R,Cardoso J M P,et al.Clustering-based selection for the exploration of compiler optimization sequences[J].ACM Transactions on Architecture and Code Optimization,2016,13(1):No.8" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM1437793C1F18BF6E9DB99F1E5013CB2B&amp;v=MTY0OTVhbmsxMFFRbmoyUmMxZUxIbk43anRDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVOcGh3NzI0d3FvPU5pZklZN0s4SGRiTHBvdzJaWjBPQkE1UHlXTQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                        Martins L G A,Nobre R,Cardoso J M P,et al.Clustering-based selection for the exploration of compiler optimization sequences[J].ACM Transactions on Architecture and Code Optimization,2016,13(1):No.8
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" title="Huang Qijing,Lian Ruolong,Canis A,et al.The effect of compiler optimizations on high-level synthesis for FPGAs[C] //Proc of the 21st Int Symp on Field Programmable Custom Computing Machines.Piscataway,NJ:IEEE,2013:89- 96" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The effect of compiler optimizations on high-level synthesis for FPGAs">
                                        <b>[12]</b>
                                        Huang Qijing,Lian Ruolong,Canis A,et al.The effect of compiler optimizations on high-level synthesis for FPGAs[C] //Proc of the 21st Int Symp on Field Programmable Custom Computing Machines.Piscataway,NJ:IEEE,2013:89- 96
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title="Ballal P A,Sarojadevi H,Harsha P S.Compiler optimization:A genetic algorithm approach[J].International Journal of Computer Applications,2015,112(10):9- 13" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Compiler optimization:A genetic algorithm approach">
                                        <b>[13]</b>
                                        Ballal P A,Sarojadevi H,Harsha P S.Compiler optimization:A genetic algorithm approach[J].International Journal of Computer Applications,2015,112(10):9- 13
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_14" title="Liu Hui,Zhao Rongcai,Wang Qi.Function level compiler optimization parameters selection method based on supervised learning model[J].Computer Engineering and Science,2018,40(6):957- 968 (in Chinese)(刘慧,赵荣彩,王琦.监督学习模型指导的函数级编译优化参数选择方法研究[J].计算机工程与科学,2018,40(6):957- 968)" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJK201806001&amp;v=MTQ0ODlqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSc0Z5L2dWTDNLTHo3QlpiRzRIOW5NcVk5RlpZUUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[14]</b>
                                        Liu Hui,Zhao Rongcai,Wang Qi.Function level compiler optimization parameters selection method based on supervised learning model[J].Computer Engineering and Science,2018,40(6):957- 968 (in Chinese)(刘慧,赵荣彩,王琦.监督学习模型指导的函数级编译优化参数选择方法研究[J].计算机工程与科学,2018,40(6):957- 968)
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_15" title="Ashouri A H.Compiler autotuning using machine learning techniques[D].Toronto,Canada:University of Toronto,2016" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Compiler autotuning using machine learning techniques">
                                        <b>[15]</b>
                                        Ashouri A H.Compiler autotuning using machine learning techniques[D].Toronto,Canada:University of Toronto,2016
                                    </a>
                                </li>
                                <li id="33">


                                    <a id="bibliography_16" title="Park E,Kulkarni S,Cavazos J.An evaluation of different modeling techniques for iterative compilation[C] //Proc of the 14th Int Conf on Compilers,Architectures and Synthesis for Embedded Systems.Piscataway,NJ:IEEE,2011:65- 74" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An evaluation of different modeling techniques for iterative compilation">
                                        <b>[16]</b>
                                        Park E,Kulkarni S,Cavazos J.An evaluation of different modeling techniques for iterative compilation[C] //Proc of the 14th Int Conf on Compilers,Architectures and Synthesis for Embedded Systems.Piscataway,NJ:IEEE,2011:65- 74
                                    </a>
                                </li>
                                <li id="35">


                                    <a id="bibliography_17" title="Agakov F,Bonilla E,Cavazos J,et al.Using machine learning to focus iterative optimization[C] //Proc of the 4th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2006:295- 305" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Using machine learning to focus iterative optimization">
                                        <b>[17]</b>
                                        Agakov F,Bonilla E,Cavazos J,et al.Using machine learning to focus iterative optimization[C] //Proc of the 4th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2006:295- 305
                                    </a>
                                </li>
                                <li id="37">


                                    <a id="bibliography_18" title="Fursin G,Kashnikov Y,Wahid A,et al.Milepost GCC:Machine learning enabled self-tuning compiler[J].International Journal of Parallel Programming,2011,39(3):296- 327" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Milepost GCC:Machine learning enabled self-tuning compiler">
                                        <b>[18]</b>
                                        Fursin G,Kashnikov Y,Wahid A,et al.Milepost GCC:Machine learning enabled self-tuning compiler[J].International Journal of Parallel Programming,2011,39(3):296- 327
                                    </a>
                                </li>
                                <li id="39">


                                    <a id="bibliography_19" title="Cavazos J,Fursin G,Agakov F,et al.Rapidly selecting good compiler optimizations using performance counters[C] //Proc of the 5th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2007:185- 197" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Rapidly selec-ting good compiler optimizations using performancecounters">
                                        <b>[19]</b>
                                        Cavazos J,Fursin G,Agakov F,et al.Rapidly selecting good compiler optimizations using performance counters[C] //Proc of the 5th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2007:185- 197
                                    </a>
                                </li>
                                <li id="41">


                                    <a id="bibliography_20" title="Dubach C,Jones T M,Bonilla E V,et al.Portable compiler optimization across embedded programs and microarchi-tectures using machine learning[C] //Proc of the 42nd Int Symp on Microarchitecture.New York:ACM,2009:78- 88" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Portable compiler optimization across embedded programs and microarchi-tectures using machine learning">
                                        <b>[20]</b>
                                        Dubach C,Jones T M,Bonilla E V,et al.Portable compiler optimization across embedded programs and microarchi-tectures using machine learning[C] //Proc of the 42nd Int Symp on Microarchitecture.New York:ACM,2009:78- 88
                                    </a>
                                </li>
                                <li id="43">


                                    <a id="bibliography_21" title="Hoste K,Eeckhout L.Cole:Compiler optimization level exploration[C] //Proc of the 6th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2008:165- 174" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Cole:Compiler optimization level exploration">
                                        <b>[21]</b>
                                        Hoste K,Eeckhout L.Cole:Compiler optimization level exploration[C] //Proc of the 6th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2008:165- 174
                                    </a>
                                </li>
                                <li id="45">


                                    <a id="bibliography_22" title="Kumar T S.Optimizing code by selecting compiler flags using parallel genetic algorithm on Multicore CPUs[J].International Journal of Engineering and Technology,2014,6(2):544- 551" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Optimizing code by selecting compiler flags using parallel genetic algorithm on multicore CPUs">
                                        <b>[22]</b>
                                        Kumar T S.Optimizing code by selecting compiler flags using parallel genetic algorithm on Multicore CPUs[J].International Journal of Engineering and Technology,2014,6(2):544- 551
                                    </a>
                                </li>
                                <li id="47">


                                    <a id="bibliography_23" title="Jantz M R,Kulkarni P A.Exploiting phase inter-dependencies for faster iterative compiler optimization phase order searches[C] //Proc of the 2013 Int Conf on Compilers,Architectures and Synthesis for Embedded Systems.Piscataway,NJ:IEEE,2013:No.7" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Exploiting phase inter-dependencies for faster iterative compiler optimization phase order searches">
                                        <b>[23]</b>
                                        Jantz M R,Kulkarni P A.Exploiting phase inter-dependencies for faster iterative compiler optimization phase order searches[C] //Proc of the 2013 Int Conf on Compilers,Architectures and Synthesis for Embedded Systems.Piscataway,NJ:IEEE,2013:No.7
                                    </a>
                                </li>
                                <li id="49">


                                    <a id="bibliography_24" title="Ashouri A H,Mariani G,Palermo G,et al.COBAYN:Compiler autotuning framework using Bayesian networks[J].ACM Transactions on Architecture and Code Optimization,2016,13(2):No.21" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM96750623003FCB5BCA873324A142C726&amp;v=MTczMjRtemQ2UzN6Z3FHTTBmYkRuUXJpWkNPTnZGU2lXV3I3SklGcG1hQnVIWWZPR1FsZkNwYlEzNU5waHc3MjR3cW89TmlmSVk3cStHZFRNcVkxR1pPc01lZzlMeW1SZw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[24]</b>
                                        Ashouri A H,Mariani G,Palermo G,et al.COBAYN:Compiler autotuning framework using Bayesian networks[J].ACM Transactions on Architecture and Code Optimization,2016,13(2):No.21
                                    </a>
                                </li>
                                <li id="51">


                                    <a id="bibliography_25" title="Park E,Cavazos J,Pouchet L N,et al.Predictive modeling in a polyhedral optimization space[J].International Journal of Parallel Programming,2013,41(5):704- 750" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD13062800015635&amp;v=MTY3NDdLQ244OG9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUwzSUoxc1RhQkE9Tmo3QmFySzdIdGZPcDQ5RlpPbw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[25]</b>
                                        Park E,Cavazos J,Pouchet L N,et al.Predictive modeling in a polyhedral optimization space[J].International Journal of Parallel Programming,2013,41(5):704- 750
                                    </a>
                                </li>
                                <li id="53">


                                    <a id="bibliography_26" title="Wang Guochang,Cheng Guojian,Carra T.The application of improved neuroevolution of augmenting topologies neural network in marcellus shale lithofacies prediction[J].Computers &amp;amp; Geosciences,2013,54:50- 65" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13050900204141&amp;v=MTU5MjY5Rlp1c0xEWGc0b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VTDNJSjFzVGFCQT1OaWZPZmJLN0h0VE1wbw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[26]</b>
                                        Wang Guochang,Cheng Guojian,Carra T.The application of improved neuroevolution of augmenting topologies neural network in marcellus shale lithofacies prediction[J].Computers &amp;amp; Geosciences,2013,54:50- 65
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(09),2012-2026 DOI:10.7544/issn1000-1239.2019.20180789            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>学习模型指导的编译器优化顺序选择方法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%88%98%E6%85%A7&amp;code=10509801&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">刘慧</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BE%90%E9%87%91%E9%BE%99&amp;code=41795819&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">徐金龙</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%B5%B5%E8%8D%A3%E5%BD%A9&amp;code=39547379&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">赵荣彩</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%A7%9A%E9%87%91%E9%98%B3&amp;code=42841770&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">姚金阳</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B2%B3%E5%8D%97%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2&amp;code=0109057&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">河南师范大学计算机与信息工程学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%95%B0%E5%AD%A6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%85%88%E8%BF%9B%E8%AE%A1%E7%AE%97%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4(%E6%88%98%E7%95%A5%E6%94%AF%E6%8F%B4%E9%83%A8%E9%98%9F%E4%BF%A1%E6%81%AF%E5%B7%A5%E7%A8%8B%E5%A4%A7%E5%AD%A6)&amp;code=1702647&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">数学工程与先进计算国家重点实验室(战略支援部队信息工程大学)</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B2%B3%E5%8D%97%E7%9C%81%E9%AB%98%E6%A0%A1%22%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%22%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%B8%AD%E5%BF%83(%E6%B2%B3%E5%8D%97%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6)&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">河南省高校&quot;计算智能与数据挖掘&quot;工程技术研究中心(河南师范大学)</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>针对新的应用程序和目标平台通常需要使用编译器进行程序优化顺序选择,以提升目标代码性能.迭代编译可使优化顺序选择过程自动进行,在允许的时间空间范围内尽可能多地执行程序的不同版本,但该方法是一种机械式搜索,缺少对先前获得经验的利用,需要较大的执行开销.因此,需要能自动预测变换后目标程序性能而不必实际运行程序的优化编译方法.提出一种编译器优化顺序选择方法:Features ANN.该方法首先采用动静结合的程序特征表示技术,对程序特征进行抽取;然后基于程序特征对编译优化空间进行搜索,找到当前程序版本的最佳优化;最后,由程序特征和最佳优化形成训练样本,基于人工神经网络(artificial neural network, ANN)形成监督学习模型,对新程序的最佳编译优化顺序进行预测.实验结果表明,Features ANN与2种现有迭代编译方法GraphDSE和ClusterDSE比较时,在2种平台上相对于编译器标准优化级别-O3分别获得1.49x,1.25x,1.38x和1.41x,1.16x,1.22x的执行时间加速比.此外,与现有非迭代编译方法相比时,Features ANN也获得了有效的性能提升.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">编译优化;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BC%98%E5%8C%96%E9%A1%BA%E5%BA%8F&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">优化顺序;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">监督学习;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%89%B9%E5%BE%81%E6%8A%BD%E5%8F%96&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">特征抽取;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">人工神经网络;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    *徐金龙,xujinlong_pla@126.com;
                                </span>
                                <span>
                                    刘慧,liuhui806@126.com;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-11-26</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家重点研发计划项目(2016YFB0200503);</span>
                                <span>河南师范大学青年科学基金项目(2015QK21);</span>
                                <span>河南省高等学校重点科研项目(20A520018);</span>
                    </p>
            </div>
                    <h1><b>Compiler Optimization Sequence Selection Method Based on Learning Model</b></h1>
                    <h2>
                    <span>Liu Hui</span>
                    <span>Xu Jinlong</span>
                    <span>Zhao Rongcai</span>
                    <span>Yao Jinyang</span>
            </h2>
                    <h2>
                    <span>College of Computer and Information Engineering, Henan Normal University</span>
                    <span>State Key Laboratory of Mathematical Engineering and Advanced Computing(Strategic Support Force Information Engineering University)</span>
                    <span>Engineering Technology Research Center for Computing Intelligence&amp;Data Mining in Henan Province (Henan Normal University)</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>For new applications and target platforms, it is often necessary to use the compiler for optimization sequence selection to improve the performance of target code. Iterative compilation enables the optimization sequence selection process automatically, with as many different versions of the program as possible within the allowable time and space range. However, iterative compilation method is a mechanical search that lacks the utilization of previous experience and requires large execution overheads. Therefore, an optimized compilation method is needed to automatically predict the performance of the transformed program without actually running. This paper presents Features ANN to select the optimization sequence of compiler. Features ANN is based on the supervised learning model. Firstly, the program feature is extracted by the program feature representation technique through a combination of dynamic and static feature. Then, the compiler optimization space is searched based on the program features, and it finds the best optimization of the current version of the program. Finally, training samples are formed by program features and optimal optimization, and an artificial neural network(ANN) is used to construct a learning model to predict the optimal optimization sequence of the new program. Experimental results show that, Features ANN can get the best performance compared with the existing iterative compilation and non-iterative compilation methods.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=compile%20optimization&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">compile optimization;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=optimization%20sequence&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">optimization sequence;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=supervise%20learning&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">supervise learning;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=features%20extraction&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">features extraction;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=artificial%20neural%20network(ANN)&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">artificial neural network(ANN);</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Liu Hui,born in 1982.PhD,lecturer.Her main research interests include high performance computing,compiler optimi-zation,machine learning.&lt;image id="220" type="formula" href="images/JFYZ201909022_22000.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Xu Jinlong,born in 1985.PhD,lecturer. His main research interests include high performance computing,compiler optimi-zation,machine learning.&lt;image id="222" type="formula" href="images/JFYZ201909022_22200.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Zhao Rongcai, born in 1957. PhD, professor,PhD supervisor.Senior member of CCF. His main research interests include high  performance computing, compiler optimization, program perfor-mance optimization.&lt;image id="224" type="formula" href="images/JFYZ201909022_22400.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                                <span>
                                    Yao Jinyang,born in 1992.Master.His main research interests include high per-formance computing,compiler optimization.&lt;image id="226" type="formula" href="images/JFYZ201909022_22600.jpg" display="inline" placement="inline"&gt;&lt;alt&gt;&lt;/alt&gt;&lt;/image&gt;;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2018-11-26</p>
                                    <p>
                            <b>Fund：</b>
                                                        <span>supported by the National Key Research and Development Program of China(2016YFB0200503);</span>
                                <span>the Youth Science Fund Project of Henan Normal University(2015QK21);</span>
                                <span>the Key Scientific Research Project of Henan Province Colleges(20A520018);</span>
                    </p>
            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="55">为应用程序选择最佳编译优化顺序是编译优化领域历久弥新的问题,而且是NP完全问题,编译器研究人员依靠他们对编译器后端的理解提出一些预定义的优化顺序.大型应用程序编译优化方案的提出需要研究人员花费很长的时间运行程序的不同优化版本,远不及体系结构和应用软件的更新速度.GCC(GNU compiler collection)编译器有超过200个的编译优化遍(pass),LLVM(low level virtual machine)编译器有超过100个的编译优化遍,并且这些优化在不同的应用层上工作,如分析遍、循环嵌套遍等.通常情况下,大多数编译优化是默认关闭的,编译器开发人员期望软件开发人员知道哪些优化对其代码是有益的,而软件开发人员可能并不熟悉编译优化相关知识.目前,大多商用编译器使用标准优化级别-O1,-O2,-O3等为应用程序执行固定顺序的优化,对于大多数应用程序可以带来“平均良好性能”.然而,由于应用程序具有不同程序特征,为产生最佳性能提升,必须采用更有程序针对性的编译优化顺序<citation id="180" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>.特别是针对嵌入式系统的编译器更加依赖于代码优化,因为使用的体系结构更加受限于内存大小、处理器速度等.如何为目标程序实施更有针对性的优化顺序,最大化程序性能仍然是一个亟需解决的关键问题.</p>
                </div>
                <div class="p1">
                    <p id="56">在高性能计算领域中,并行计算机系统日益复杂.为了降低系统功耗,开发人员应用了不同的硬件和软件技术.目前主流的P级高性能计算机系统大多使用了GPU<citation id="181" type="reference"><link href="5" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>和MIC(many integrated core architecture)<citation id="182" type="reference"><link href="7" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>等众核处理器作为加速器或协处理器.在2017年6月的TOP榜单中,排名前十的机器中有5台使用了GPU或者MIC处理器作为加速器和协处理器<citation id="183" type="reference"><link href="9" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>.计算密集型应用程序将大部分的执行时间花费在适合于高级编译优化的循环嵌套中,例如稠密线性代数代码等.近年来提出的多面体编译优化技术亦致力于将数学表示集中在多面体模型的循环嵌套中<citation id="184" type="reference"><link href="11" rel="bibliography" /><link href="13" rel="bibliography" /><sup>[<a class="sup">5</a>,<a class="sup">6</a>]</sup></citation>.因此,复杂体系结构下为应用程序特定循环结构选择更有针对应的优化顺序,对程序性能提升至关重要.目前,通常使用迭代编译方法和基于机器学习的方法解决编译器优化顺序的选择问题.</p>
                </div>
                <div class="p1">
                    <p id="57">迭代编译(iterative compilation)是一种针对通用程序的优化方法,该方法可有效集成不同的优化技术,适用于不同的体系结构<citation id="185" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>.Chen等人<citation id="186" type="reference"><link href="17" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>提出基于数据中心的迭代编译方法,通过在主服务器上收集性能统计数据,选择最佳编译优化及进行收益分析.Purini等人<citation id="187" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>使用下采样技术减少优化搜索空间,为应用程序选择最佳编译器优化顺序.Nobre等人<citation id="188" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>提出将编译器优化遍之间的变换用图形进行表示,然后通过图形采样的方式确定目标程序的优化顺序,能够有效减小搜索空间和提升收敛速度.Martins等人<citation id="189" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>基于遗传算法,采用聚类技术实施应用程序特定的优化顺序选择.在面向FPGAs的硬件编译环境下,Huang等人<citation id="190" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>分析了2种基于顺序插入的迭代方法,用于可变序列长度的编译优化顺序选择.采用迭代编译获取的程序性能加速明显好于静态编译,但在程序的迭代编译过程中会产生庞大的编译优化空间.此外,迭代编译是一种“无记忆”的优化搜索方法,不能利用已经获取的编译优化经验.</p>
                </div>
                <div class="p1">
                    <p id="58">因此,编译优化人员提出将机器学习技术加入传统迭代编译优化过程,逐步形成基于机器学习的迭代编译方法<citation id="194" type="reference"><link href="27" rel="bibliography" /><link href="29" rel="bibliography" /><link href="31" rel="bibliography" /><sup>[<a class="sup">13</a>,<a class="sup">14</a>,<a class="sup">15</a>]</sup></citation>.优化预测模型的输入为程序特征,输出为特定性能目标,如程序运行时间、优化选择和优化顺序等.理想情况下,预测模型独立于应用程序,能对不同程序版本进行快速评估,显著减少迭代编译代价<citation id="191" type="reference"><link href="33" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>.Agakov等人<citation id="192" type="reference"><link href="35" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>提出2种优化顺序预测模型:独立同分布模型和马尔可夫模型,以提升应用程序性能.预测模型在迭代编译过程中利用机器学习算法寻找更好的优化顺序,取得了一定的程序性能提升.但Agakov等人<citation id="193" type="reference"><link href="35" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>提出的模型仅使用源代码程序特征,不能体现程序的当前版本优化状态,而程序的当前优化状态对接下来将使用的优化具有重要的影响.</p>
                </div>
                <div class="p1">
                    <p id="59">Fursin等人<citation id="195" type="reference"><link href="37" rel="bibliography" /><sup>[<a class="sup">18</a>]</sup></citation>提出基于GCC编译器的Milepost GCC,将机器学习算法集成于GCC编译框架.Milepost GCC基于源代码及程序中间表示抽取程序特征,统计不同指令和函数控制流图信息,使用机器学习技术自动调整程序优化变换.但Milepost GCC主要解决的是优化选择问题,基于固定的优化顺序从中选择能最有效提升代码性能的优化,而且其使用的是固定长度的特征向量.Cavazos等人<citation id="196" type="reference"><link href="39" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>提出一种基于机器学习的编译优化顺序预测方法,该方法使用性能计数器构建程序特征向量,并用于预测编译优化顺序.Dubach等人<citation id="197" type="reference"><link href="41" rel="bibliography" /><sup>[<a class="sup">20</a>]</sup></citation>提出使用机器学习在嵌入式程序和微体系结构之间进行可移植的编译器优化.Hoste等人<citation id="198" type="reference"><link href="43" rel="bibliography" /><sup>[<a class="sup">21</a>]</sup></citation>提出使用多目标进化算法为程序选择最佳编译优化.Kumar<citation id="199" type="reference"><link href="45" rel="bibliography" /><sup>[<a class="sup">22</a>]</sup></citation>提出通过在多核CPU上使用并行遗传算法选择最佳编译优化.Jantz等人<citation id="200" type="reference"><link href="47" rel="bibliography" /><sup>[<a class="sup">23</a>]</sup></citation>采用修剪设计空间搜索技术,在较小的非联合优化子集上进行多阶段的优化顺序搜索.Ashouri等人<citation id="201" type="reference"><link href="49" rel="bibliography" /><sup>[<a class="sup">24</a>]</sup></citation>提出优化顺序预测模型COBAYN,基于贝叶斯网络将程序特征表示与编译优化遍相关联,以最大化程序性能.Park等人<citation id="202" type="reference"><link href="51" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>将基于多面体模型的迭代编译与机器学习相结合用以解决编译优化顺序问题,取得了较好的预测效果.现有基于机器学习的迭代编译方法大多数使用单独的静态程序特征或单独的动态程序特征进行优化预测模型的构建,如何采用更有效的程序特征表示方法需要进一步进行研究.此外,为了进一步降低编译器优化顺序选择过程中的迭代编译开销,如何构建更有效的优化预测模型,也亟需进行更深入的研究.</p>
                </div>
                <div class="p1">
                    <p id="60">人工神经网络(artificial neural network, ANN)是一种模拟人脑功能对数据信息进行加工处理的系统化方法.本文提出基于机器学习的编译器优化顺序选择方法Features ANN,通过ANN基于监督学习模型进行编译器优化顺序选择.主要贡献有3个方面:</p>
                </div>
                <div class="p1">
                    <p id="61">1) 使用动静结合的程序特征表示方法,通过主成分分析技术将高维程序特征降维为低维程序特征,在不降低程序表示性的基础上,为优化顺序预测模型选择最佳程序特征表示.</p>
                </div>
                <div class="p1">
                    <p id="62">2) 优化顺序选择模型Features ANN的样本为由降维后的程序特征和当前最佳优化构成的二元组,利用人工神经网络建立统计模型并集成于编译器框架,为目标程序选择当前优化状态下的最佳优化及进行编译过程驱动.面对新的应用程序,Features ANN将新程序特征作为其输入,并预测最佳优化,从而生成新程序的最佳优化顺序.</p>
                </div>
                <div class="p1">
                    <p id="63">3) 在2种平台上采用动静结合特征作为Features ANN预测模型输入时,相对于GCC 8.1.0编译器标准优化级别-O3分别获得1.49x和1.41x的程序执行时间加速.此外,与现有迭代编译方法和非迭代编译方法相比时,均获得了最佳的程序性能提升.</p>
                </div>
                <h3 id="64" name="64" class="anchor-tag"><b>1 学习模型指导的优化顺序选择模型</b></h3>
                <h4 class="anchor-tag" id="65" name="65"><b>1.1 优化顺序问题的形式化描述</b></h4>
                <div class="p1">
                    <p id="66">为了对优化顺序选择问题有更直观的认识,我们首先对编译优化的选择空间进行形式化描述.定义布尔向量<i><b>o</b></i>,元素<i>o</i><sub><i>i</i></sub>表示不同的编译优化,每个优化可以被启用(<i>o</i><sub><i>i</i></sub>=1)或禁用(<i>o</i><sub><i>i</i></sub>=0).编译优化的选择空间属于<i>n</i>维布尔空间,由向量空间<i><b>o</b></i><sub>selection</sub>表示为</p>
                </div>
                <div class="p1">
                    <p id="67"><i><b>o</b></i><sub>selection</sub>=(0,1)<sup><i>n</i></sup>.(1)</p>
                </div>
                <div class="p1">
                    <p id="68">当对应用程序<i>a</i><sub><i>i</i></sub>进行优化时,<i>n</i>表示编译优化总数,由一个指数空间作为其上限.例如,当<i>n</i>=10时,目标应用程序<i>a</i><sub><i>i</i></sub>有1 024种可选择的优化方式.当应用程序有<i>N</i>个不同的优化版本<i>A</i>={<i>a</i><sub>0</sub>,<i>a</i><sub>1</sub>,…,<i>a</i><sub><i>n</i></sub>}时,将产生更大的优化空间.</p>
                </div>
                <div class="p1">
                    <p id="69">当使用固定优化序列长度且不重复使用优化时,定义编译优化顺序为<i>n</i>维向量空间为<i>o</i><sub>phase</sub>=<i>n</i>!,其中,<i>n</i>表示编译优化总数.当使用动态优化序列长度且可重复使用优化时,优化顺序空间扩展为</p>
                </div>
                <div class="p1">
                    <p id="70"><mathml id="170"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi mathvariant="bold-italic">o</mi><msub><mrow></mrow><mrow><mtext>p</mtext><mtext>h</mtext><mtext>a</mtext><mtext>s</mtext><mtext>e</mtext><mo>_</mo><mtext>r</mtext><mtext>e</mtext><mtext>p</mtext><mtext>e</mtext><mtext>t</mtext><mtext>i</mtext><mtext>t</mtext><mtext>i</mtext><mtext>o</mtext><mtext>n</mtext></mrow></msub></mrow><mo>|</mo></mrow><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></munderover><mi>n</mi></mstyle><msup><mrow></mrow><mi>i</mi></msup></mrow></math></mathml>,(2)</p>
                </div>
                <div class="p1">
                    <p id="71">其中,<i>m</i>表示优化序列最大期望长度.假设<i>n</i>和<i>m</i>均为10,将产生高达110亿种不同的编译优化顺序.当优化序列最大期望长度<i>m</i>没有固定值时,编译优化顺序问题没有上界.</p>
                </div>
                <h4 class="anchor-tag" id="72" name="72"><b>1.2 监督学习模型指导的优化顺序选择模型</b></h4>
                <div class="p1">
                    <p id="73">监督学习模型指导的编译器优化顺序预测模型框架如图1所示,包括数据收集、模型训练和模型预测阶段.在数据采集阶段,首先根据程序特征表示方法,使用设计空间探索引擎(design space exploration, DSE)抽取程序特征{<i>F</i><sub>1</sub>,<i>F</i><sub>2</sub>,…,<i>F</i><sub><i>n</i></sub>},提取目标程序特征值{<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>}.然后,使用DSE将优化集合{<i>o</i><sub>1</sub>,<i>o</i><sub>2</sub>,…,<i>o</i><sub><i>m</i></sub>}中的优化<i>o</i><sub><i>i</i></sub>分别应用于目标程序.DSE通过启用和禁用优化实施不同的优化、优化顺序及测试应用程序运行时间.由于程序在每应用一次优化后,特征值将会发生相应的改变,需要根据更新后的特征值确定下一阶段应使用的优化.因此,我们设定DSE在每应用一次优化后重新提取特征值{<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>},以表示程序的当前优化状态.并根据程序的当前优化状态再次选择优化集合{<i>o</i><sub>1</sub>,<i>o</i><sub>2</sub>,…,<i>o</i><sub><i>m</i></sub>}中的优化<i>o</i><sub><i>i</i></sub>和测试运行时间.数据收集阶段收集的训练数据由{<i>o</i><sub><i>i</i></sub>,<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>,<i>s</i><sub><i>i</i></sub>}构成.其中,<i>o</i><sub><i>i</i></sub>表示优化变换,{<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>}表示程序特征值,<i>s</i><sub><i>i</i></sub>表示特征值为{<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>}时程序实施优化<i>o</i><sub><i>i</i></sub>可获得的加速比.当产生最大加速比<i>s</i><sub>max</sub>时,对应的优化<i>o</i><sub><i>i</i></sub>即为程序当前状态下可使用的最佳优化.</p>
                </div>
                <div class="area_img" id="74">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 编译优化顺序预测模型" src="Detail/GetImg?filename=images/JFYZ201909022_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 编译优化顺序预测模型  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 Compile optimization sequence prediction model</p>

                </div>
                <div class="p1">
                    <p id="75">在模型训练阶段,基于收集到的训练数据,采用ANN进行模型训练,构建程序优化及优化顺序预测模型Features ANN.在模型预测即使用阶段,基于程序在当前优化状态下的特征值,通过存储在预测模型中的知识为新程序预测当前状态下应用不同优化时的加速比,实现最大加速比对应的优化即为程序在当前状态下应使用的最佳优化,从而生成新程序的最佳优化顺序.优化终止条件为达到预先设定的最大优化序列长度,或连续为程序当前状态预测相同的优化.</p>
                </div>
                <h3 id="76" name="76" class="anchor-tag"><b>2 程序特征表示</b></h3>
                <h4 class="anchor-tag" id="77" name="77"><b>2.1 程序特征</b></h4>
                <div class="p1">
                    <p id="78">现有程序特征表示方法包括:</p>
                </div>
                <div class="p1">
                    <p id="79">1) 静态程序特征表示.静态特征通常在语法分析过程中、编译过程中提取.</p>
                </div>
                <div class="p1">
                    <p id="80">2) 动态程序特征表示.动态特征在程序运行过程中提取,通常具有更好的程序表示性,但为获取动态特征往往需要反复执行程序的运行.</p>
                </div>
                <div class="p1">
                    <p id="81">Features ANN优化顺序预测模型使用动静结合的特征表示方法(dynamic static features combination, DSFC),为预测模型提供更细粒度的输入.静态和动态特征列表如表1和表2所示<citation id="203" type="reference"><link href="29" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>.</p>
                </div>
                <div class="area_img" id="82">
                    <p class="img_tit"><b>表1 静态特征列表</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 1 List of Static Features</b></p>
                    <p class="img_note"></p>
                    <table id="82" border="1"><tr><td><br />Serial Number</td><td>Program Feature</td></tr><tr><td><br />1</td><td>Number of basic blocks in the function</td></tr><tr><td><br />2</td><td>Number of basic blocks with a single successor</td></tr><tr><td><br />3</td><td>Number of basic blocks with two successors</td></tr><tr><td><br />4</td><td>Number of basic blocks with more than two successors</td></tr><tr><td><br />5</td><td>Number of basic blocks with a single predecessor</td></tr><tr><td><br />6</td><td>Number of basic blocks with two predecessors</td></tr><tr><td><br />7</td><td>Number of basic blocks with more than two predecessors</td></tr><tr><td><br />8</td><td>Number of basic blocks with a single predecessor and successor</td></tr><tr><td><br />9</td><td>Number of basic blocks with a single predecessor and two successors</td></tr><tr><td><br />10</td><td>Number of basic blocks with two predecessors and one successor</td></tr><tr><td><br />11</td><td>Number of basic blocks with two successors and two predecessors</td></tr><tr><td><br />12</td><td>Number of basic blocks with more than two successors and more than two predecessors</td></tr><tr><td><br />13</td><td>Number of instructions less than 15</td></tr><tr><td><br />14</td><td>Number of instructions in [15, 500]</td></tr><tr><td><br />15</td><td>Number of basic blocks with instructions greater than 500</td></tr><tr><td><br />16</td><td>Number of edges in the control flow graph</td></tr><tr><td><br />17</td><td>Number of critical edges in the control flow graph</td></tr><tr><td><br />18</td><td>Number of abnormal edges in the control flow graph</td></tr><tr><td><br />19</td><td>Number of direct calls in the function</td></tr><tr><td><br />20</td><td>Number of conditional branches in the function</td></tr><tr><td><br />21</td><td>Number of assignment instructions in the function</td></tr><tr><td><br />22</td><td>Number of binary integer operations in the function</td></tr><tr><td><br />23</td><td>Number of binary floating point operations in function</td></tr><tr><td><br />24</td><td>Number of instructions in the function</td></tr><tr><td><br />25</td><td>Average of number of instructions in basic blocks</td></tr><tr><td><br />26</td><td>Average number of phi-nodes at the beginning of a block</td></tr><tr><td><br />27</td><td>Average of arguments for a phi-node</td></tr><tr><td><br />28</td><td>Number of basic blocks with no phi nodes</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="83">
                    <p class="img_tit"><b>表2 动态特征列表</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 2 List of Dynamic Features</b></p>
                    <p class="img_note"></p>
                    <table id="83" border="1"><tr><td><br />Category</td><td>Performance Counter Selection</td></tr><tr><td><br />Cache Line Access</td><td>CA-CLN, CA-ITV, CA-SHR</td></tr><tr><td><br />Level 1 Cache</td><td>L1-DCA, L1-DCH, L1-DCM, L1-ICA, L1-ICH, L1-ICM, L1-LDM, L1-STM, L1-TCA, L1-TCM</td></tr><tr><td><br />Level 2 &amp; 3 Cache</td><td>L2-DCA, L2-DCM, L2-DCR, L2-DCW, L2-ICA, L2-ICH, L2-ICM, L2-LDM, L2-STM, L2-TCH, <br />L2-TCR, L2-TCW, L2/L3-TCA, L2/L3-TCM</td></tr><tr><td><br />Branch Related</td><td>BR-CN, BR-INS, BR-MSP, BR-NTK,BR-PRC</td></tr><tr><td><br />Interrupt/Stall</td><td>HW-INT, RES-STL</td></tr><tr><td><br />TLB</td><td>TLB-DM, TLB-IM, TLB-SD, TLB-TL</td></tr><tr><td><br />Total Cycle/Instructions</td><td>TOT-CYC, TOT-IIS, TOT-INS</td></tr><tr><td><br />Load/Store Instructions</td><td>LD-INS, SR-INS</td></tr><tr><td><br />SIMD Instructions</td><td>VEC-DP, VEC-INS, VEC-SP</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="84" name="84"><b>2.2 特征降维技术</b></h4>
                <div class="p1">
                    <p id="85">程序特征的选择是构建优化顺序预测模型的关键,本文采用主成分分析法(principal component analysis, PCA)为目标程序选择最主要的静态特征和动态特征.当数据空间维度大于3维时,将无法在空间坐标系下用图形(如点、线、面)表示样本点.程序特征高维空间的多变量数据不能以图形化方式直观展示其空间特征分布规律,如样本相似度、样本中的异常点等信息.PCA的核心思想是通过正交变换,将一个变量维数较高而且变量之间存在相互关联的数据矩阵映射到一个较低维数的主成分空间.程序特征的PCA计算过程为:</p>
                </div>
                <div class="p1">
                    <p id="86">Step1. 假定程序特征中有<i>p</i>个样本,每个样本共有<i>n</i>个变量,样本数据可构成一个<i>p</i>×<i>n</i>阶矩阵:</p>
                </div>
                <div class="area_img" id="87">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JFYZ201909022_08700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="89">对样本矩阵进行标准化变换,得到标准化阵<i><b>Z</b></i>:</p>
                </div>
                <div class="p1">
                    <p id="90"><mathml id="171"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ζ</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>-</mo><mover accent="true"><mi>x</mi><mo>¯</mo></mover><msub><mrow></mrow><mi>j</mi></msub></mrow><mrow><mi>s</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></mfrac><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>⋯</mo><mo>,</mo><mi>p</mi><mo>,</mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>⋯</mo><mo>,</mo><mi>n</mi></mrow></math></mathml>,(4)</p>
                </div>
                <div class="p1">
                    <p id="91">其中,</p>
                </div>
                <div class="p1">
                    <p id="92"><mathml id="172"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi>x</mi><mo>¯</mo></mover><msub><mrow></mrow><mi>j</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>p</mi></mfrac><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></munderover><mi>x</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow></math></mathml>,(5)</p>
                </div>
                <div class="p1">
                    <p id="93"><mathml id="173"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>s</mi><msubsup><mrow></mrow><mi>j</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mrow><mi>p</mi><mo>-</mo><mn>1</mn></mrow></mfrac><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>p</mi></munderover><mrow><mo stretchy="false">(</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>-</mo><mover accent="true"><mi>x</mi><mo>¯</mo></mover><msub><mrow></mrow><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mstyle><msup><mrow></mrow><mn>2</mn></msup></mrow></math></mathml>.(6)</p>
                </div>
                <div class="p1">
                    <p id="94">Step2. 对标准化阵<i><b>Z</b></i>求相关系数矩阵:</p>
                </div>
                <div class="p1">
                    <p id="95"><mathml id="174"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">R</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><mi>r</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><msub><mrow></mrow><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi mathvariant="bold-italic">Ζ</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mi mathvariant="bold-italic">Ζ</mi></mrow><mrow><mi>p</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math></mathml>.(7)</p>
                </div>
                <div class="p1">
                    <p id="96">Step3. 解样本相关阵<i><b>R</b></i>的特征方程|<i>λ</i><i><b>I</b></i>-<i><b>R</b></i>|=0,求出<i>n</i>个特征根,按照特征值的大小倒序排列.对于每一个特征值<i>λ</i><sub><i>i</i></sub>求出其所对应的特征向量<i><b>e</b></i><sub><i>i</i></sub>(<i>i</i>=1,2,…,<i>n</i>).</p>
                </div>
                <div class="p1">
                    <p id="97">Step4. 主成分的选取规则:</p>
                </div>
                <div class="p1">
                    <p id="98"><mathml id="175"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ι</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mi>λ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>k</mi></msub></mrow></mfrac><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>⋯</mo><mo>,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math></mathml>,(8)</p>
                </div>
                <div class="p1">
                    <p id="99"><mathml id="176"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>i</mi></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>k</mi></msub></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>λ</mi></mstyle><msub><mrow></mrow><mi>k</mi></msub></mrow></mfrac><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>⋯</mo><mo>,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></math></mathml>,(9)</p>
                </div>
                <div class="p1">
                    <p id="100">其中,统计量<i>I</i><sub><i>i</i></sub>代表某一主成分<i>λ</i><sub><i>i</i></sub>的贡献率,统计量<i>S</i><sub><i>i</i></sub>代表某一主成分<i>λ</i><sub><i>i</i></sub>的累积贡献率.<i>k</i>的选择原则是取累计贡献率90%,保证主成分变量包括原始数据的大多数信息,即求得<i>S</i><sub><i>i</i></sub>≈0.9的所有<i>λ</i><sub><i>i</i></sub>所对应的主成分<i>f</i><sub><i>i</i></sub>.</p>
                </div>
                <div class="p1">
                    <p id="101">Step5. 载荷系数的计算.观测值<i>x</i><sub><i>i</i></sub>(<i>i</i>=1,2,…,<i>n</i>)在主成分<i>f</i><sub><i>i</i></sub>上的得分为</p>
                </div>
                <div class="p1">
                    <p id="102"><mathml id="177"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ι</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msqrt><mrow><mi>λ</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msqrt><mi>e</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mo>⋯</mo><mo>,</mo><mi>n</mi></mrow></math></mathml>;<i>j</i>=1,2,…,<i>m</i>).(10)</p>
                </div>
                <div class="p1">
                    <p id="103">Step6. 根据程序特征,对程序特征主成分进行命名,对主成分及其荷载进行相关解释.</p>
                </div>
                <div class="p1">
                    <p id="104">主成分提取原则一般选取主成分累计贡献率超过90%的前<i>m</i>个主成分,经过实验分析表明,由于程序特征值的冗余和协方差,程序特征可以降维至5维特征向量,此时仍能保持99%的数据差异性.</p>
                </div>
                <h3 id="105" name="105" class="anchor-tag"><b>3 ANN构建</b></h3>
                <h4 class="anchor-tag" id="106" name="106"><b>3.1 基于ANN的优化顺序预测</b></h4>
                <div class="p1">
                    <p id="107">在编译器中确定合适的优化顺序是一个十分复杂的问题,我们可以将优化顺序问题定义为马尔可夫过程(Markov process, MP),即基于当前程序版本状态做出接下来应用何种优化的决定.本文以ANN为基础构造程序变换优化顺序预测模型Features ANN.Features ANN的基本思想是持续询问ANN预计使用何种优化可为当前状态下的程序产生最佳性能.ANN使用当前状态下的代码特征作为输入,利用网络层次表示特征之间复杂的非线性关系,并与优化过程中特定点的最佳优化相关联.Features ANN模型框架如图2所示:</p>
                </div>
                <div class="area_img" id="108">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 Features ANN编译优化选择过程" src="Detail/GetImg?filename=images/JFYZ201909022_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 Features ANN编译优化选择过程  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 Process of Features ANN compile optimization 
 selection</p>

                </div>
                <div class="p1">
                    <p id="109">在模型训练阶段,采用扩张拓扑的神经进化算法(neuro-evolution for augmenting topologies, NEAT)生成用来控制优化顺序的ANN,通过对每个函数应用不同的优化,并记录程序运行时间进行ANN评估.Features ANN迭代输出优化<i>o</i><sub><i>i</i></sub>的过程如图3所示.ANN的输入为当前状态下的代码特征{<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>},输出为应用不同优化<i>o</i><sub><i>i</i></sub>后的收益概率<i>P</i>,选择最大概率<i>P</i>对应的优化<i>o</i><sub>best</sub>作为当前状态下应使用的优化.应用优化<i>o</i><sub>best</sub>后将形成一个新的程序版本,特征值发生改变,将更新后的特征值重新输入Features ANN,使其输出下一个要应用的优化<i>o</i><sub><i>i</i></sub><sub>+1</sub>.当ANN达到最大代数或连续若干代性能没有变化时,停止使用优化,生成目标程序优化顺序{<i>o</i><sub>1</sub>,<i>o</i><sub>2</sub>,…,<i>o</i><sub><i>m</i></sub>}.模型预测阶段将ANN集成于编译器,并作为新程序优化顺序的启发式规则进行使用.Features ANN优化顺序选择算法如算法1所示.</p>
                </div>
                <div class="area_img" id="110">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_110.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 Features ANN迭代输出优化oi过程" src="Detail/GetImg?filename=images/JFYZ201909022_110.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 Features ANN迭代输出优化<i>o</i><sub><i>i</i></sub>过程  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_110.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 Process of Features ANN output optimization <i>o</i><sub><i>i</i></sub> 
 iteratively</p>

                </div>
                <div class="p1">
                    <p id="111"><b>算法1</b>. 基于ANN的优化顺序选择算法.</p>
                </div>
                <div class="p1">
                    <p id="112">输入:程序特征值<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>,优化{<i>o</i><sub>1</sub>,<i>o</i><sub>2</sub>,…,<i>o</i><sub><i>m</i></sub>};</p>
                </div>
                <div class="p1">
                    <p id="113">输出:最佳优化序<i>o</i><sup>*</sup>={<i>o</i><sub>1</sub>,<i>o</i><sub>2</sub>,…,<i>o</i><sub><i>m</i></sub>}及其对应的程序运行时间<i>T</i><sup>*</sup>.</p>
                </div>
                <div class="p1">
                    <p id="114">Step1. 初始化:设置每代神经网络个数<i>N</i>、网络代数<i>M</i>,并随机生成第1代网络.</p>
                </div>
                <div class="p1">
                    <p id="115">Step2. 输入程序<i>C</i>当前状态特征值<i>f</i><sub>1</sub>,<i>f</i><sub>2</sub>,…,<i>f</i><sub><i>n</i></sub>作为当前代网络输入层神经元的输入.</p>
                </div>
                <div class="p1">
                    <p id="116">Step3. 计算每个网络的适应度<i>Fitness</i>(<i>T</i>),选择前10个具有最大适应度值的网络传播到下一代产生新的网络</p>
                </div>
                <div class="p1">
                    <p id="117" class="code-formula">
                        <mathml id="117"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mi>i</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>Τ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>R</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>.</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="118">Step4. 交叉和变异产生新一代网络.变异包括在网络隐藏层现有边上增加一个神经元(概率设置为0.1%)、增加一个新边(概率设置为0.5%)或删除一个现有边(概率设置为0.9%).</p>
                </div>
                <div class="p1">
                    <p id="119">Step5. 当网络到达最大代数<i>M</i>或连续若干代性能没有变化,将具有最大适应度的优化作为当前程序版本状态下的最佳优化<i>o</i><sub>best</sub>.</p>
                </div>
                <div class="p1">
                    <p id="120">Step6. 算法终止条件:当达到最大优化个数或重复使用优化没有性能提升时,算法终止,转至Step7,否则更新函数特征,转至Step2.</p>
                </div>
                <div class="p1">
                    <p id="121">Step7. 输出最佳优化序<i>o</i><sup>*</sup>={<i>o</i><sub>1</sub>,<i>o</i><sub>2</sub>,…,<i>o</i><sub><i>m</i></sub>}及其对应的函数执行时间<i>T</i><sup>*</sup>.</p>
                </div>
                <h4 class="anchor-tag" id="122" name="122"><b>3.2 NEAT</b></h4>
                <div class="p1">
                    <p id="123">由于优化顺序预测模型Features ANN处于动态编译环境中,因此ANN及特征抽取过程的开销要小,否则应用该网络进行优化顺序选择的代价会高于调整优化顺序带来的收益.本文采用NEAT算法<citation id="204" type="reference"><link href="53" rel="bibliography" /><sup>[<a class="sup">26</a>]</sup></citation>为程序变换优化顺序选择模型构建ANN.NEAT算法开始于若干没有隐结点的最小网络,在进化的实施过程中通过变异引入新结构,从而进行网络扩张.并通过适应度评估网络优劣,淘汰适应度较低的个体.由于种群从最小结构开始,优化搜索空间的维度也将是最小的.因此,NEAT算法总是搜索比其他进化神经网络算法更低的维度空间,网络构建开销小于其他同类算法.</p>
                </div>
                <div class="p1">
                    <p id="124">NEAT进化神经网络的过程是从只有输入输出结点的简单网络开始逐步增加网络复杂程度,具有较大的结点连接自由度.如图4所示,NEAT采用结点基因编码进行网络结构和连接权值的描述.当创建新的结点和连接时,借助于所产生的历史标记,从而避免竞争约定问题.NEAT尝试将构成的网络尺寸最小化,在进化开始时让群体中每个神经网络都具有最小的拓扑结构,在进化过程中始终保持在网络中随机逐个添加神经元和连接.该过程和自然界生物体的生长过程一样,随着时间的推移,不断进化、不断增加复杂性,从而试图构建最小化的最优网络.</p>
                </div>
                <div class="area_img" id="125">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_125.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 NEAT基因映射" src="Detail/GetImg?filename=images/JFYZ201909022_125.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 NEAT基因映射  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_125.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 NEAT gene mapping</p>

                </div>
                <div class="p1">
                    <p id="126">NEAT算法的适应度值为训练集中测试集性能的几何平均值:</p>
                </div>
                <div class="p1">
                    <p id="127"><mathml id="178"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mi>i</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>s</mi><mo>∈</mo><mi>S</mi></mrow></munder><mi>S</mi></mstyle><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>p</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><mrow><mrow><mo>|</mo><mi>S</mi><mo>|</mo></mrow></mrow></mfrac></mrow></math></mathml>,(11)</p>
                </div>
                <div class="p1">
                    <p id="128">其中,|<i>S</i>| 表示训练集个数,<i>Speedup</i>(<i>s</i>)表示程序运行时间加速比:</p>
                </div>
                <div class="p1">
                    <p id="129"><mathml id="179"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>p</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>R</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy="false">(</mo><mi>s</mi><msub><mrow></mrow><mrow><mtext>d</mtext><mtext>e</mtext><mtext>f</mtext></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><mi>R</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow></math></mathml>,(12)</p>
                </div>
                <div class="p1">
                    <p id="130">其中,<i>Runtime</i>(<i>s</i><sub>def</sub>)表示测试集<i>s</i>使用默认优化顺序时的运行时间,<i>Runtime</i>(<i>s</i>)表示使用预测模型预测的优化顺序时测试集<i>s</i>的运行时间.</p>
                </div>
                <h3 id="131" name="131" class="anchor-tag"><b>4 实  验</b></h3>
                <div class="p1">
                    <p id="132">我们在2种平台上进行Features ANN优化顺序预测模型的训练和评估,模型输入为程序热点函数特征,输出为相应的最佳优化顺序.</p>
                </div>
                <div class="p1">
                    <p id="133">1) 平台1.实验编译环境为Linux操作系统,版本为Readhat Enterprise AS 5.0,实验平台为国产处理器申威26 010,CPU主频为 2.5 GHz,L1数据cache为 32 KB,L2 cache为256 KB,向量寄存器宽度为256 b,可同时处理4个浮点型数据或8个整型数据.</p>
                </div>
                <div class="p1">
                    <p id="135">2) 平台2.实验编译环境为Linux操作系统,版本为Readhat Enterprise AS5.0,实验平台为Intel Xeon E5520处理器,CPU主频为2.26 GHz,L1数据cache 为32 KB,L2 cache为1 MB,二级Smart cache 8 MB.</p>
                </div>
                <div class="p1">
                    <p id="137">实验中训练集测试用例为SPEC CPU2006测试集中的2 000个热点循环,测试集用例为NPB测试集和表3所示大型科学计算程序中的热点函数.实验将标准优化级别-O2及图5所示优化作为优化空间,将新的优化顺序与标准优化级别-O3的默认优化顺序进行性能对比,优化的启用/禁用通过使用GCC8.1.0编译优化选项完成.对程序热点函数特征采用动静结合特征表示方法DSFC,将抽取的特征作为PCA过程的输入.我们分别比较了采用Features ANN和现有迭代编译方法、非迭代编译方法时测试集用例的程序性能.当现有方法使用的优化和测试集与本文不同时,我们采用本文的优化和测试集重新进行实验.对抽取的每个热点函数采用添加时间戳的方式进行运行时间计时,为减少噪声影响,每个样本运行10次,取执行时间平均值.</p>
                </div>
                <div class="area_img" id="138">
                    <p class="img_tit"><b>表3 大型科学计算程序</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 3 Large Scientific Calculation Programs</b></p>
                    <p class="img_note"></p>
                    <table id="138" border="1"><tr><td><br />Program</td><td>Description</td></tr><tr><td><br />SWE</td><td>Explicit solution of the global shallow atmospheric water wave equation</td></tr><tr><td><br />OpenCFD</td><td>Fluid mechanics</td></tr><tr><td><br />FDM</td><td>The forward modeling program of 3D seismic wave equation</td></tr><tr><td><br />WRF</td><td>Weather forecast</td></tr><tr><td><br />GKUA</td><td>The solution of complex hypersonic flow around each watershed</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="227">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_22700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 优化列表（GCC8.1.0)" src="Detail/GetImg?filename=images/JFYZ201909022_22700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 优化列表（GCC8.1.0)  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_22700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.5 List of Optimization(GCC8.1.0)</p>

                </div>
                <div class="p1">
                    <p id="141">本文实验主要从4个方面进行:1)Features ANN采用不同特征时的性能比较.分别采用静态程序特征表示、动态程序特征表示和动静结合程序特征表示作为优化顺序预测模型Features ANN的输入,对比分析模型的预测性能.2)Features ANN与迭代编译方法的性能比较.比较测试集程序采用Features ANN与2种现有迭代编译方法时的程序性能.3)Features ANN与非迭代编译方法的性能比较.比较测试集程序采用Features ANN和3种现有非迭代编译方法时的程序性能.4)离线学习和在线预测时间开销比较.对比分析Features ANN和现有迭代编译、非迭代编译方法在训练数据收集、模型构建、特征抽取和模型预测上的时间开销.</p>
                </div>
                <h3 id="142" name="142" class="anchor-tag"><b>5 实验结果分析</b></h3>
                <h4 class="anchor-tag" id="143" name="143"><b>5.1 采用不同特征时的预测模型性能</b></h4>
                <div class="p1">
                    <p id="144">基于现有程序特征表示技术,我们对比分析3类程序特征表示方法对优化顺序预测模型的影响:静态程序特征表示、动态程序特征表示和动静结合程序特征表示.其中,静态程序特征采用Milepost GCC静态程序,包括以固定长度特征向量表示的静态源代码及中间表示特征<citation id="205" type="reference"><link href="37" rel="bibliography" /><sup>[<a class="sup">18</a>]</sup></citation>.动态程序特征采用基于性能计数器的动态特征表示(performance counter, PC),PC能实时采集、分析系统内的应用程序、服务等性能数据,以此来分析系统瓶颈、监视组件表现<citation id="206" type="reference"><link href="39" rel="bibliography" /><sup>[<a class="sup">19</a>]</sup></citation>.动静结合特征表示我们的程序特征表示方法DSFC.</p>
                </div>
                <div class="p1">
                    <p id="145">Features ANN分别采用不同特征表示方法,为NPB测试集和表3所示科学计算程序在平台1和平台2上预测优化顺序时,预测模型性能如图6和图7所示.其中,Milepost GCC表示静态程序特征,PC表示动态程序特征,DSFC表示本文提出的动静结合程序特征表示.Speedup表示相对于GCC 8.1.0标准优化级别-O3产生的性能加速比.</p>
                </div>
                <div class="area_img" id="146">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_146.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 采用不同特征时平台1上测试程序加速比" src="Detail/GetImg?filename=images/JFYZ201909022_146.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 采用不同特征时平台1上测试程序加速比  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_146.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 Speedup on platform 1 when adapting different features</p>

                </div>
                <div class="area_img" id="147">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 采用不同特征时平台2上测试程序加速比" src="Detail/GetImg?filename=images/JFYZ201909022_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 采用不同特征时平台2上测试程序加速比  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_147.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 Speedup on platform 2 when adapting different features</p>

                </div>
                <div class="p1">
                    <p id="148">实验结果表明,平台1上基于Milepost GCC静态程序特征、PC动态特征和DSFC动静结合特征为NPB测试集和大型科学计算程序预测优化顺序时,Features ANN相对于GCC标准优化级别-O3产生的平均加速比分别为1.19,1.23,1.49.平台2上产生的平均加速比分别为1.16,1.20,1.41.总体来说,对当前测试用例而言,采用DSFC动静结合特征可以产生最好的预测性能,PC动态特征次之,Milepost GCC静态特征具有相对较低的预测性能.</p>
                </div>
                <div class="p1">
                    <p id="149">经程序分析可知,测试集LU的主要热点函数为rhs,占程序执行时间的24.98%.采用DSFC动静结合特征时,Features ANN为rhs预测的优化顺序为{-O2,-fpeel-loops,-funroll-loops,-fprefetch-loop-arrays,-fgcse-after-reload,-ffast-math}.采用Milepost GCC静态特征时,Features ANN为rhs预测的优化顺序为{-O2,-fpeel-loops,-funroll-loops,-fprefetch-loop-arrays,-fgcse-after-reload,-ftree-vectorize,-ffast-math}.采用PC动态特征时,Features ANN为rhs预测优化顺序为{-O2,-fpeel-loops,-fprefetch-loop-arrays,-funroll-loops,-ffast-math}.采用GCC-O3默认优化、DSFC动静结合特征、Milepost GCC静态程序特征和PC动态特征时对应的函数执行时间分别为:45.975 s,37.364 s,41.864 s,40.376 s.采用DSFC动静结合特征预测的优化顺序除使用标准优化级别-O2外,首先对该热点循环进行循环剥离,然后进行循环展开,循环展开可以将迭代次数少的循环进行展开以充分利用寄存器.循环中含有大量的3维数组和4维数组引用,使用-fprefetch-loop-arrays可以对数据预取,对含有大数组的程序可以产生较好的性能提升.此外,由于循环中含有大量的变量引用,在计算时会被重复使用,使用-fgcse-after-reload优化可以消除重复性的访存.采用Milepost GCC静态特征预测的优化顺序会对rhs 函数进行向量化处理,但该程序含有间接访存,且语句间含有阻止向量化的依赖环,内层循环迭代次数小,循环多为不完美循环嵌套,若对其进行向量化,将会引入一些数据整理指令,增大开销,性能反而会下降.采用PC动态特征预测的优化顺序在数据预取之后进行循环展开,会增加预取次数,且预测的优化中没有使用-fgcse-after-reload,获得的程序执行时间加速比小于采用DSFC动静结合特征产生的加速比.</p>
                </div>
                <div class="p1">
                    <p id="150">DSFC动静结合特征表示优于Milepost GCC静态特征表示,原因在于Milepost GCC特征主要包括基本块和边的信息,这些信息是以整个程序为单位的固定长度的特征表示,而DSFC采用动静结合特征表示方法,而且程序特征是采用PCA方法选择的,不是固定不变的,更能表示出不同程序的主要信息.但是有一些程序如MG采用Milepost GCC特征时性能优于DSFC,原因是Milepost GCC有一些静态特征没有包括在在基于DSFC的特征中,这可能对特定程序有影响.DSFC动静结合特征表示也优于单独使用PC动态特征表示获得的性能.因此,在Features ANN预测模型中使用动静结合程序特征DSFC有利于进一步提升模型的优化顺序预测性能.</p>
                </div>
                <h4 class="anchor-tag" id="151" name="151"><b>5.2 Features ANN与迭代编译方法的比较</b></h4>
                <div class="p1">
                    <p id="152">为将Features ANN与现有迭代编译方法进行比较,我们选择与Nobre<citation id="207" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>和Martins<citation id="208" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>的研究进行对比分析.Nobre等人<citation id="209" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>提出一种基于迭代编译的优化顺序搜索方法,该方法首先将编译优化变换用图形方式进行表示,然后通过图形采样确定程序的优化顺序,能够有效减小优化搜索空间和提升收敛速度.Martins等人<citation id="210" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>基于聚类方法,采用遗传算法指导的设计空间探索技术选择应用特定的优化顺序,该方法是最近的基于迭代编译方法进行优化顺序搜索的典型代表.采用Features ANN和现有迭代编译方法为NPB测试集、大型科学计算程序在平台1和平台2上预测优化顺序时,预测模型性能如图8和图9所示.其中,GraphDSE表示Nobre等人<citation id="211" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>提出的基于图形的优化顺序预测模型,ClusterDSE表示Martins等人<citation id="212" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>提出的基于聚类的预测模型,Features ANN表示本文提出的预测模型.</p>
                </div>
                <div class="area_img" id="153">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_153.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 Features ANN与迭代编译方法的性能比较(平台1)" src="Detail/GetImg?filename=images/JFYZ201909022_153.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图8 Features ANN与迭代编译方法的性能比较(平台1)  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_153.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 8 Comparison with iterative compilation (platform 1)</p>

                </div>
                <div class="area_img" id="154">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_154.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 Features ANN与迭代编译方法的性能比较(平台2)" src="Detail/GetImg?filename=images/JFYZ201909022_154.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图9 Features ANN与迭代编译方法的性能比较(平台2)  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_154.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 9 Comparison with iterative compilation (platform 2)</p>

                </div>
                <div class="p1">
                    <p id="155">从图8可以看出,平台1上基于迭代编译方法为测试集预测优化顺序时,Features ANN,GraphDSE,ClusterDSE相对于GCC标准优化级别-O3的平均加速比分别为1.49,1.25,1.38.对当前测试用例而言,Features ANN具有最好的预测性能,ClusterDSE次之,GraphDSE具有相对较低的预测性能.经程序分析可知,测试集UA的主要热点函数为laplacian,占程序执行时间的40%.Features ANN为laplacian函数预测的优化顺序为{O2,-fpredictive-commoning,-funswitch-loops,-fpeel-loops,-ftree-loop-distribution,-ftree-vectorize,-ffast-math}.GraphDSE为laplacian预测的优化顺序为{-O2,-fpredictive-commoning,-funswitch-loops,-ftree-loop-distribution,-ftree-vectorize,-fpeel-loops}.ClusterDSE为laplacian预测的优化顺序为{-O2,-fpredictive-commoning,-funswitch-loops,-fpeel-loop,-ftree-loop-distribution,-ftree-vectorize}.采用GCC-O3默认优化、Features ANN、GraphDSE、ClusterDSE时对应的函数执行时间分别为43.87 s,38.57 s,43.19 s,42.50 s.由于函数laplacian中含有多个完美嵌套循环,且不含阻止向量化的依赖环,适合做向量化处理.Features ANN预测的优化顺序除使用标准优化级别-O2外,在为函数进行向量化处理前使用预测常见优化、分支外提,循环剥离与分布等优化.在进行向量化处理后调用快速数学库优化,打开-ffast-math,实验表明在精度要求不苛刻的情况下使用这种激进的优化方式可以获得较大的性能提升.而ClusterDSE预测的优化顺序没有使用-ffast-math,程序性能略差于Features ANN.GraphDSE预测的优化顺序在优化选择上与ClusterDSE相同,但优化顺序不同,即在向量化后进行循环剥离,从而导致一些可以使用循环剥离的循环体失去了向量化的机会.</p>
                </div>
                <div class="p1">
                    <p id="156">从图9可以看出,平台2 Features ANN,GraphDSE,ClusterDSE相对于GCC标准优化级别-O3的平均加速比分别为1.41,1.16,1.22.Features ANN获得了最好的预测性能.因此,Features ANN优化顺序预测模型在2种平台上都获得了平均最佳的预测性能.Features ANN能够获得较好程序性能的原因在于模型基于机器学习算法构建,能在较短的时间内生成新程序的最佳优化顺序.而使用现有迭代编译方法为新程序搜索最佳优化顺序时,虽然现有方法在优化搜索性能和搜索时间上具有较大的改进,但仍需要进行多次迭代才能获得局部最佳程序性能.</p>
                </div>
                <h4 class="anchor-tag" id="157" name="157"><b>5.3 Features ANN与非迭代编译方法的比较</b></h4>
                <div class="p1">
                    <p id="158">非迭代编译方法的典型代表是基于机器学习的编译优化方法和基于多面体模型的编译优化方法,本文选择与Ashouri等人<citation id="213" type="reference"><link href="49" rel="bibliography" /><sup>[<a class="sup">24</a>]</sup></citation>和Park等人<citation id="214" type="reference"><link href="51" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>的研究进行对比分析.Ashouri等人<citation id="215" type="reference"><link href="49" rel="bibliography" /><sup>[<a class="sup">24</a>]</sup></citation>提出COBAYN优化顺序预测模型,COBAYN是基于贝叶斯网络构建的优化顺序预测模型.Park等人<citation id="216" type="reference"><link href="51" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>基于多面体编译框架,采用静态程序特征和几种不同的机器学习算法构建优化顺序预测模型.采用Features ANN和现有非迭代编译方法预测优化顺序时,预测模型性能如图10和图11所示.其中,COBAYN表示Ashouri等人<citation id="217" type="reference"><link href="49" rel="bibliography" /><sup>[<a class="sup">24</a>]</sup></citation>提出的优化顺序预测模型,LR和SVM表示Park等人<citation id="218" type="reference"><link href="51" rel="bibliography" /><sup>[<a class="sup">25</a>]</sup></citation>基于多面体框架通过逻辑回归和支持向量机构建的预测模型,Features ANN表示本文提出的优化顺序预测模型.</p>
                </div>
                <div class="area_img" id="159">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_159.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图10 Features ANN与非迭代编译方法的性能比较(平台1)" src="Detail/GetImg?filename=images/JFYZ201909022_159.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图10 Features ANN与非迭代编译方法的性能比较(平台1)  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_159.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 10 Comparison with non-iterative compilation (platform 1)</p>

                </div>
                <div class="area_img" id="160">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201909022_160.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图11 Features ANN与非迭代编译方法的性能比较(平台2)" src="Detail/GetImg?filename=images/JFYZ201909022_160.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图11 Features ANN与非迭代编译方法的性能比较(平台2)  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201909022_160.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig.11 Comparison with non-iterative compilation (platform 2)</p>

                </div>
                <div class="p1">
                    <p id="161">从图10可以看出,平台1上基于非迭代编译方法为NPB测试集和大型科学计算程序预测优化顺序时,Features ANN相对于GCC标准优化级别-O3的平均加速比分别为1.51和1.45,COBAYN的平均加速比分别为1.40和1.34,LR的平均加速比分别为1.11和1.06,SVM的平均加速比分别为1.32和1.28.从图11可以看出,平台2上基于非迭代编译方法为NPB测试集和大型科学计算程序预测优化顺序时,Features ANN相对于GCC标准优化级别-O3的平均加速比分别为1.39和1.43,COBAYN的平均加速比分别为1.30和1.32,LR的平均加速比分别为1.03和1.05,SVM的平均加速比分别为1.24和1.23.对当前测试用例而言,Features ANN具有最好的预测性能,COBAYN次之,SVM的预测性能低于COBAYN,LR具有相对较低的预测性能.Features ANN能够获得较好预测性能的原因在于模型采用PCA特征降维技术,选择最主要的程序特征作为预测模型的输入.COBAYN采用探索性因子分析法选择程序特征,然而在实际应用中探索性因子分析必须和验证性因子分析结合使用,才能更好地进行因子分析.LR和SVM均采用固定的程序特征,缺乏程序特定性.此外,Features ANN基于ANN根据当前状态下的程序特征选择最佳优化,而现有方法对整个程序优化前的特征进行抽取和预测优化,Features ANN的预测精度更高.</p>
                </div>
                <h4 class="anchor-tag" id="162" name="162"><b>5.4 离线学习和在线预测时间开销比较</b></h4>
                <div class="p1">
                    <p id="163">使用Features ANN预测模型为新程序预测优化顺序时的细粒度时间,分为训练阶段(离线完成)和预测阶段(在线完成).训练阶段一次性完成,收集训练数据所需时间,取决于训练集中应用程序数量.表4和表5分别表示平台1和平台2上SPEC CPU作为训练集、WRF作为目标应用程序时不同预测模型每个特定阶段所需时间.采用本文提出的方法虽然需要若干天时间进行数据收集和模型训练,但对于新的目标程序需要很短的时间就可以完成较好的优化参数预测.</p>
                </div>
                <div class="p1">
                    <p id="164">实验结果表明,Features ANN预测模型的离线学习时间略高于现有方法,但在线预测时间低于现有方法.而且从5.1节和5.3节的分析中可以看到,Features ANN在特征选择、预测性能等方面均优于现有方法.因此,Features ANN在特征选择、预测性能和在线预测时间开销等方面均取得了较好的效果.</p>
                </div>
                <div class="area_img" id="165">
                    <p class="img_tit"><b>表4 WRF离线学习和在线预测时间(平台1</b>)  <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 4 Learning and Prediction Time of WRF (Platform 1</b>)</p>
                    <p class="img_note"></p>
                    <table id="165" border="1"><tr><td><br />Method</td><td>Data Collection</td><td>Model Construction</td><td>Feature Extraction</td><td>Model Prediction</td><td>Average Time Cost</td></tr><tr><td>GraphDSE</td><td>9.50×10<sup>5</sup></td><td>676</td><td></td><td>235</td><td>9.50×10<sup>5</sup></td></tr><tr><td><br />ClusterDSE</td><td>10.37×10<sup>5</sup></td><td>548</td><td></td><td>489</td><td>10.38×10<sup>5</sup></td></tr><tr><td><br />LR</td><td>8.64×10<sup>5</sup></td><td>234</td><td>11.5</td><td>0.79</td><td>8.64×10<sup>5</sup></td></tr><tr><td><br />SVM</td><td>9.50×10<sup>5</sup></td><td>456</td><td>12.1</td><td>0.86</td><td>9.50×10<sup>5</sup></td></tr><tr><td><br />COBAYN</td><td>10.37×10<sup>5</sup></td><td>475</td><td>10.7</td><td>0.98</td><td>10.37×10<sup>5</sup></td></tr><tr><td><br />Features ANN</td><td>10.37×10<sup>5</sup></td><td>393</td><td>11.1</td><td>0.45</td><td>10.37×10<sup>5</sup></td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="166">
                    <p class="img_tit"><b>表5 WRF离线学习和在线预测时间(平台2</b>)  <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 5 Learning and Prediction Time of WRF (Platform 2</b>)</p>
                    <p class="img_note"></p>
                    <table id="166" border="1"><tr><td><br />Method</td><td>Data Collection</td><td>Model Construction</td><td>Feature Extraction</td><td>Model Prediction</td><td>Average Time Cost</td></tr><tr><td>GraphDSE</td><td>9.50×10<sup>5</sup></td><td>686</td><td></td><td>246</td><td>9.51×10<sup>5</sup></td></tr><tr><td><br />ClusterDSE</td><td>10.37×10<sup>5</sup></td><td>573</td><td></td><td>491</td><td>10.38×10<sup>5</sup></td></tr><tr><td><br />LR</td><td>8.64×10<sup>5</sup></td><td>249</td><td>11.7</td><td>0.78</td><td>8.64×10<sup>5</sup></td></tr><tr><td><br />SVM</td><td>9.50×10<sup>5</sup></td><td>478</td><td>13.1</td><td>0.83</td><td>9.50×10<sup>5</sup></td></tr><tr><td><br />COBAYN</td><td>10.37×10<sup>5</sup></td><td>493</td><td>15.7</td><td>0.96</td><td>10.38×10<sup>5</sup></td></tr><tr><td><br />Features ANN</td><td>10.37×10<sup>5</sup></td><td>399</td><td>14.1</td><td>0.43</td><td>10.37×10<sup>5</sup></td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h3 id="167" name="167" class="anchor-tag"><b>6 结束语</b></h3>
                <div class="p1">
                    <p id="168">本文提出一种选择编译器优化顺序的新方法:Features ANN,以最大化目标应用程序性能.该方法通过使用动静结合的特征表示方法进行程序表示,在最小均方误差意义下获取对原始特征数据的表示.基于程序特征和当前状态最佳优化构成优化顺序预测模型的样本数据,采用人工神经网络建立统计模型并集成于编译器框架,实施优化顺序选择及进行编译过程驱动.在2种平台上采用动静结合特征作为Features ANN预测模型输入时,相对于GCC 5.4编译器默认标准优化级别-O3分别获得1.49x和1.41x的程序执行时间加速.与现有迭代编译方法GraphDSE和ClusterDSE,及非迭代编译方法COBAYN,LR,SVM比较时,均获得了最佳的性能提升.</p>
                </div>
                <div class="p1">
                    <p id="169">程序优化顺序选择是提升程序性能的关键技术,目前仍有一些后续工作值得研究,具体来说包括:1)我们将考虑增加更多的训练数据集、测试数据集和目标平台,以进一步提升预测准确率和通用性.2)由于不同的程序优化可能需要不同的目标代码特征,我们将研究更多优化变换的相关性特征,进一步提升程序性能.3)尝试人工添加噪声的方法增加预测方法的鲁棒性,研究在负载严重的多用户环境下提升预测性能.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=MiCOMP:Mitigating the compiler phase-ordering problem using optimization sub-sequences and machine learning">

                                <b>[1]</b>Ashouri H A,Bignoli A,Palermo G,et al.MiCOMP:Mitigating the compiler phase-ordering problem using optimization sub-sequences and machine learning[J].ACM Transactions on Architecture and Code Optimization,2017,14(3):No.12
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The GPU computing era">

                                <b>[2]</b>Nickolls J,Dally W J.The GPU computing era[J].IEEE Micro,2010,30(2):56- 69
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The Intel many integrated core architecture">

                                <b>[3]</b>Duran A,Klemm M.The Intel<sup>©</sup> many integrated core architecture[C] //Proc of the 2012 Int Conf on High Performance Computing and Simulation.Piscataway,NJ:IEEE,2012:365- 366
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The TOP500 list of the world&amp;#39;&amp;#39;s supercomputers[OL]">

                                <b>[4]</b>The National Supercomputing Guangzhou Center.The TOP500 list of the world's supercomputers[OL].2017[2017-06-19].http://www.chinastor.com/hpc-top500/201706/0Q43H562017.html
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMEC76FE31126A6A01FC1306280BD27E15&amp;v=MTE1MDBOaWZJWThiTEdkZTYyb3hFWmVrSmZYcEl6eGRsbVQ1K1NIbmdwQkpIRGJDVE1MdWFDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVOcGh3NzI0d3FvPQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b>Rajam A S,Clauss P.The polyhedral model of nonlinear loops[J].ACM Transactions on Architecture and Code Optimization,2015,12(4):No.48
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Optimized two-level parallelization for GPU accelerators using the polyhedral model">

                                <b>[6]</b>Shirako J,Hayashi A,Sarkar V.Optimized two-level parallelization for GPU accelerators using the polyhedral model[C] //Proc of the 26th Int Conf on Compiler Construction.New York:ACM,2017:22- 33
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=2010271309.nh&amp;v=MDcxNTViUElRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJzRnkvZ1ZMM0tWMTI2SHJHL0g5TE1wcEU=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b>Lu Pingjing.Research on key techniques in low-cost iterative compilation optimization[D].Changsha:National University of Defense Technology,2010 (in Chinese)(陆平静.低开销的迭代编译优化关键技术研究[D].长沙:国防科技大学,2010)
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Practical iterative optimization for the data center">

                                <b>[8]</b>Chen Yang,Fang Shuangde,Eeckhout L,et al.Practical iterative optimization for the data center[J].ACM SIGARCH Computer Architecture News,2012,40(1):49- 60
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000011838&amp;v=MDc3MDJvT0JIOHhvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVVMM0lKMXNUYUJBPU5pZklZN0s3SHRqTnI0OUZaTw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[9]</b>Purini S,Jain L.Finding good optimization sequences covering program space[J].ACM Transactions on Architecture and Code Optimization,2013,9(4):No.56
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A graph-based iterative compiler pass selection and phase ordering approach">

                                <b>[10]</b>Nobre R,Martins L G A,Cardoso J M P.A graph-based iterative compiler pass selection and phase ordering approach[C] //Proc of the 17th ACM SIGPLAN/SIGBED Conf on Languages,Compilers,Tools,and Theory for Embedded Systems.New York:ACM,2016:21- 30
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM1437793C1F18BF6E9DB99F1E5013CB2B&amp;v=MjY2MTZuazEwUVFuajJSYzFlTEhuTjdqdENPTnZGU2lXV3I3SklGcG1hQnVIWWZPR1FsZkNwYlEzNU5waHc3MjR3cW89TmlmSVk3SzhIZGJMcG93MlpaME9CQTVQeVdNYQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b>Martins L G A,Nobre R,Cardoso J M P,et al.Clustering-based selection for the exploration of compiler optimization sequences[J].ACM Transactions on Architecture and Code Optimization,2016,13(1):No.8
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The effect of compiler optimizations on high-level synthesis for FPGAs">

                                <b>[12]</b>Huang Qijing,Lian Ruolong,Canis A,et al.The effect of compiler optimizations on high-level synthesis for FPGAs[C] //Proc of the 21st Int Symp on Field Programmable Custom Computing Machines.Piscataway,NJ:IEEE,2013:89- 96
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Compiler optimization:A genetic algorithm approach">

                                <b>[13]</b>Ballal P A,Sarojadevi H,Harsha P S.Compiler optimization:A genetic algorithm approach[J].International Journal of Computer Applications,2015,112(10):9- 13
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_14" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJK201806001&amp;v=MDgwOTQvZ1ZMM0tMejdCWmJHNEg5bk1xWTlGWllRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJzRnk=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[14]</b>Liu Hui,Zhao Rongcai,Wang Qi.Function level compiler optimization parameters selection method based on supervised learning model[J].Computer Engineering and Science,2018,40(6):957- 968 (in Chinese)(刘慧,赵荣彩,王琦.监督学习模型指导的函数级编译优化参数选择方法研究[J].计算机工程与科学,2018,40(6):957- 968)
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Compiler autotuning using machine learning techniques">

                                <b>[15]</b>Ashouri A H.Compiler autotuning using machine learning techniques[D].Toronto,Canada:University of Toronto,2016
                            </a>
                        </p>
                        <p id="33">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An evaluation of different modeling techniques for iterative compilation">

                                <b>[16]</b>Park E,Kulkarni S,Cavazos J.An evaluation of different modeling techniques for iterative compilation[C] //Proc of the 14th Int Conf on Compilers,Architectures and Synthesis for Embedded Systems.Piscataway,NJ:IEEE,2011:65- 74
                            </a>
                        </p>
                        <p id="35">
                            <a id="bibliography_17" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Using machine learning to focus iterative optimization">

                                <b>[17]</b>Agakov F,Bonilla E,Cavazos J,et al.Using machine learning to focus iterative optimization[C] //Proc of the 4th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2006:295- 305
                            </a>
                        </p>
                        <p id="37">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Milepost GCC:Machine learning enabled self-tuning compiler">

                                <b>[18]</b>Fursin G,Kashnikov Y,Wahid A,et al.Milepost GCC:Machine learning enabled self-tuning compiler[J].International Journal of Parallel Programming,2011,39(3):296- 327
                            </a>
                        </p>
                        <p id="39">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Rapidly selec-ting good compiler optimizations using performancecounters">

                                <b>[19]</b>Cavazos J,Fursin G,Agakov F,et al.Rapidly selecting good compiler optimizations using performance counters[C] //Proc of the 5th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2007:185- 197
                            </a>
                        </p>
                        <p id="41">
                            <a id="bibliography_20" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Portable compiler optimization across embedded programs and microarchi-tectures using machine learning">

                                <b>[20]</b>Dubach C,Jones T M,Bonilla E V,et al.Portable compiler optimization across embedded programs and microarchi-tectures using machine learning[C] //Proc of the 42nd Int Symp on Microarchitecture.New York:ACM,2009:78- 88
                            </a>
                        </p>
                        <p id="43">
                            <a id="bibliography_21" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Cole:Compiler optimization level exploration">

                                <b>[21]</b>Hoste K,Eeckhout L.Cole:Compiler optimization level exploration[C] //Proc of the 6th Int Symp on Code Generation and Optimization.Piscataway,NJ:IEEE,2008:165- 174
                            </a>
                        </p>
                        <p id="45">
                            <a id="bibliography_22" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Optimizing code by selecting compiler flags using parallel genetic algorithm on multicore CPUs">

                                <b>[22]</b>Kumar T S.Optimizing code by selecting compiler flags using parallel genetic algorithm on Multicore CPUs[J].International Journal of Engineering and Technology,2014,6(2):544- 551
                            </a>
                        </p>
                        <p id="47">
                            <a id="bibliography_23" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Exploiting phase inter-dependencies for faster iterative compiler optimization phase order searches">

                                <b>[23]</b>Jantz M R,Kulkarni P A.Exploiting phase inter-dependencies for faster iterative compiler optimization phase order searches[C] //Proc of the 2013 Int Conf on Compilers,Architectures and Synthesis for Embedded Systems.Piscataway,NJ:IEEE,2013:No.7
                            </a>
                        </p>
                        <p id="49">
                            <a id="bibliography_24" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM96750623003FCB5BCA873324A142C726&amp;v=MjYxNjcwZmJEblFyaVpDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVOcGh3NzI0d3FvPU5pZklZN3ErR2RUTXFZMUdaT3NNZWc5THltUmdtemQ2UzN6Z3FHTQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[24]</b>Ashouri A H,Mariani G,Palermo G,et al.COBAYN:Compiler autotuning framework using Bayesian networks[J].ACM Transactions on Architecture and Code Optimization,2016,13(2):No.21
                            </a>
                        </p>
                        <p id="51">
                            <a id="bibliography_25" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD13062800015635&amp;v=MDAzODFycVFUTW53WmVadUh5am1VTDNJSjFzVGFCQT1OajdCYXJLN0h0Zk9wNDlGWk9vS0NuODhvQk1UNlQ0UFFIL2lyUmRHZQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[25]</b>Park E,Cavazos J,Pouchet L N,et al.Predictive modeling in a polyhedral optimization space[J].International Journal of Parallel Programming,2013,41(5):704- 750
                            </a>
                        </p>
                        <p id="53">
                            <a id="bibliography_26" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13050900204141&amp;v=MzE1OTFHZXJxUVRNbndaZVp1SHlqbVVMM0lKMXNUYUJBPU5pZk9mYks3SHRUTXBvOUZadXNMRFhnNG9CTVQ2VDRQUUgvaXJSZA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[26]</b>Wang Guochang,Cheng Guojian,Carra T.The application of improved neuroevolution of augmenting topologies neural network in marcellus shale lithofacies prediction[J].Computers &amp; Geosciences,2013,54:50- 65
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201909022" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201909022&amp;v=Mjc2ODg2ajU0TzN6cXFCdEdGckNVUkxPZVplUnNGeS9nVkwzS0x5dlNkTEc0SDlqTXBvOUhab1FLREg4NHZSNFQ=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVDZ3NE9QMDdqU1E0SnB1TXd6Z3pyZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>


    <link href="/kxreader/Content/css/LeftDetail?v=NLcKG8I1SJUaVFrQ0iGpF2klAT0OsmHRaVSZ1rKb5xg1" rel="stylesheet"/>

</body>
</html>

