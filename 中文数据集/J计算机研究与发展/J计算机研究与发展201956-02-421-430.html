<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637133243914971250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJFYZ201902017%26RESULT%3d1%26SIGN%3dpS4D%252b8NWK%252fYBdhaQ2SQAmDmtle8%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201902017&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JFYZ201902017&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201902017&amp;v=MDA2ODM0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N25XN3ZKTHl2U2RMRzRIOWpNclk5RVk0UUtESDg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#256" data-title="&lt;b&gt;1&lt;/b&gt;&lt;b&gt;基于动态二进制翻译和代码插桩的函数调用跟踪框架&lt;/b&gt; "><b>1</b><b>基于动态二进制翻译和代码插桩的函数调用跟踪框架</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#257" data-title="&lt;b&gt;1.1&lt;/b&gt;&lt;b&gt;动态二进制翻译&lt;/b&gt;"><b>1.1</b><b>动态二进制翻译</b></a></li>
                                                <li><a href="#263" data-title="&lt;b&gt;1.2&lt;/b&gt;&lt;b&gt;代码插桩&lt;/b&gt;"><b>1.2</b><b>代码插桩</b></a></li>
                                                <li><a href="#267" data-title="&lt;b&gt;1.3&lt;/b&gt;&lt;b&gt;框架设计思路&lt;/b&gt;"><b>1.3</b><b>框架设计思路</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#274" data-title="&lt;b&gt;2&lt;/b&gt;&lt;b&gt;基于QEMU和代码插桩的函数调用跟踪系统实现&lt;/b&gt; "><b>2</b><b>基于QEMU和代码插桩的函数调用跟踪系统实现</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#276" data-title="&lt;b&gt;2.1&lt;/b&gt;&lt;b&gt;快速的处理器模拟器QEMU&lt;/b&gt;"><b>2.1</b><b>快速的处理器模拟器QEMU</b></a></li>
                                                <li><a href="#281" data-title="&lt;b&gt;2.2&lt;/b&gt;&lt;b&gt;函数调用指令翻译&lt;/b&gt;"><b>2.2</b><b>函数调用指令翻译</b></a></li>
                                                <li><a href="#292" data-title="&lt;b&gt;2.3&lt;/b&gt;&lt;b&gt;桩代码设计&lt;/b&gt;"><b>2.3</b><b>桩代码设计</b></a></li>
                                                <li><a href="#296" data-title="&lt;b&gt;2.4&lt;/b&gt;&lt;b&gt;针对x86指令集的桩代码设计&lt;/b&gt;"><b>2.4</b><b>针对x86指令集的桩代码设计</b></a></li>
                                                <li><a href="#310" data-title="&lt;b&gt;2.5&lt;/b&gt;&lt;b&gt;针对ARM指令集的桩代码设计&lt;/b&gt;"><b>2.5</b><b>针对ARM指令集的桩代码设计</b></a></li>
                                                <li><a href="#336" data-title="&lt;b&gt;2.6&lt;/b&gt;&lt;b&gt;针对MIPS指令集的桩代码设计&lt;/b&gt;"><b>2.6</b><b>针对MIPS指令集的桩代码设计</b></a></li>
                                                <li><a href="#355" data-title="&lt;b&gt;2.7&lt;/b&gt;&lt;b&gt;日志记录与函数调用图&lt;/b&gt;"><b>2.7</b><b>日志记录与函数调用图</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#367" data-title="&lt;b&gt;3&lt;/b&gt;&lt;b&gt;与现有工作的比较&lt;/b&gt; "><b>3</b><b>与现有工作的比较</b></a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#369" data-title="&lt;b&gt;3.1&lt;/b&gt;&lt;b&gt;与S2E对比&lt;/b&gt;"><b>3.1</b><b>与S2E对比</b></a></li>
                                                <li><a href="#375" data-title="&lt;b&gt;3.2&lt;/b&gt;&lt;b&gt;与QEMU-DFCT对比&lt;/b&gt;"><b>3.2</b><b>与QEMU-DFCT对比</b></a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#379" data-title="&lt;b&gt;4&lt;/b&gt;&lt;b&gt;实&lt;/b&gt;&lt;b&gt;验&lt;/b&gt; "><b>4</b><b>实</b><b>验</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#387" data-title="&lt;b&gt;5&lt;/b&gt;&lt;b&gt;总&lt;/b&gt;&lt;b&gt;结&lt;/b&gt; "><b>5</b><b>总</b><b>结</b></a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#259" data-title="图1 动态二进制翻译">图1 动态二进制翻译</a></li>
                                                <li><a href="#260" data-title="图2 基于动态二进制翻译和代码插桩的函数调用跟踪框架">图2 基于动态二进制翻译和代码插桩的函数调用跟踪框架</a></li>
                                                <li><a href="#279" data-title="图3 QEMU框架结构">图3 QEMU框架结构</a></li>
                                                <li><a href="#291" data-title="图4 插桩后的call指令翻译过程">图4 插桩后的call指令翻译过程</a></li>
                                                <li><a href="#309" data-title="图5 针对x86平台的桩代码">图5 针对x86平台的桩代码</a></li>
                                                <li><a href="#335" data-title="图6 针对ARM平台的桩代码">图6 针对ARM平台的桩代码</a></li>
                                                <li><a href="#352" data-title="图7 针对MIPS平台的桩代码">图7 针对MIPS平台的桩代码</a></li>
                                                <li><a href="#353" data-title="图9 函数调用跟踪Linux 4.9内核绘图示例">图9 函数调用跟踪Linux 4.9内核绘图示例</a></li>
                                                <li><a href="#365" data-title="图8 日志记录示例">图8 日志记录示例</a></li>
                                                <li><a href="#381" data-title="&lt;b&gt;表1&lt;/b&gt;&lt;b&gt;实验环境&lt;/b&gt;"><b>表1</b><b>实验环境</b></a></li>
                                                <li><a href="#383" data-title="图10 QHS, DFCT的性能比较">图10 QHS, DFCT的性能比较</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="421">


                                    <a id="bibliography_1" title="Pfoh J, Schneider C, Eckert C.Nitro:Hardware-based system call tracing for virtual machines[C]Proc of the Advances in Information and Computer Security.Berlin:Springer, 2011:96-112" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Nitro:Hardware-based system call tracing for virtual machines">
                                        <b>[1]</b>
                                        Pfoh J, Schneider C, Eckert C.Nitro:Hardware-based system call tracing for virtual machines[C]Proc of the Advances in Information and Computer Security.Berlin:Springer, 2011:96-112
                                    </a>
                                </li>
                                <li id="423">


                                    <a id="bibliography_2" title="Hibbeler J D, Wang Jhychun.Dynamic CPU usage profiling and function call tracing:US, Patent 7093234[P/OL]. (2006-08-15) [2018-05-16].http:www.freepatentsonline.com/7093234.html" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Dynamic CPU usage profiling and function call tracing">
                                        <b>[2]</b>
                                        Hibbeler J D, Wang Jhychun.Dynamic CPU usage profiling and function call tracing:US, Patent 7093234[P/OL]. (2006-08-15) [2018-05-16].http:www.freepatentsonline.com/7093234.html
                                    </a>
                                </li>
                                <li id="425">


                                    <a id="bibliography_3" title="Pappas V, Polychronakis M, Keromytis A D.Transparent ROP exploit mitigation using indirect branch tracing[C]Proc of the 22nd USENIX Conf on Security.Berkeley, CA:USENIX Association, 2013:447-462" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Transparent ROP exploit mitigation using indirect branch tracing">
                                        <b>[3]</b>
                                        Pappas V, Polychronakis M, Keromytis A D.Transparent ROP exploit mitigation using indirect branch tracing[C]Proc of the 22nd USENIX Conf on Security.Berkeley, CA:USENIX Association, 2013:447-462
                                    </a>
                                </li>
                                <li id="427">


                                    <a id="bibliography_4" title="Zheng Yuhui, Mu Yongmin, Zhang Zhihua.Research on the static function call path generating automatically[C]Proc of the 2nd IEEE Int Conf on Information Management and Engineering.Piscataway, NJ:IEEE, 2010:405-409" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Research on the static function call path generating automatically">
                                        <b>[4]</b>
                                        Zheng Yuhui, Mu Yongmin, Zhang Zhihua.Research on the static function call path generating automatically[C]Proc of the 2nd IEEE Int Conf on Information Management and Engineering.Piscataway, NJ:IEEE, 2010:405-409
                                    </a>
                                </li>
                                <li id="429">


                                    <a id="bibliography_5" title="Graham S L, Kessler P B, McKusick M K.Gprof:A call graph execution profiler[J].ACM SIGPLAN Notices, 2004, 39 (4) :49-57" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000081109&amp;v=MDIxNzlJWTdLN0h0ak5yNDlGWk9NT0RYd3dvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVViN0lKbHdjYmhNPU5pZg==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                        Graham S L, Kessler P B, McKusick M K.Gprof:A call graph execution profiler[J].ACM SIGPLAN Notices, 2004, 39 (4) :49-57
                                    </a>
                                </li>
                                <li id="431">


                                    <a id="bibliography_6" title="Chipounov V, Kuznetsov V, Candea G.The S2Eplatform:Design, implementation, and applications[J].ACMTransactions on Computer Systems, 2012, 30 (1) :1-49" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The S2E platform: Design, implementation, and applications">
                                        <b>[6]</b>
                                        Chipounov V, Kuznetsov V, Candea G.The S2Eplatform:Design, implementation, and applications[J].ACMTransactions on Computer Systems, 2012, 30 (1) :1-49
                                    </a>
                                </li>
                                <li id="433">


                                    <a id="bibliography_7" title="Bellard F.QEMU, a fast and portable dynamic translator[C]Proc of the Annual Conf on USENIX Annual Technical Conf.Berkeley, CA:USENIX Association, 2005:41-46" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Qemu,a fast and portable dynamic translator">
                                        <b>[7]</b>
                                        Bellard F.QEMU, a fast and portable dynamic translator[C]Proc of the Annual Conf on USENIX Annual Technical Conf.Berkeley, CA:USENIX Association, 2005:41-46
                                    </a>
                                </li>
                                <li id="435">


                                    <a id="bibliography_8" title="Xiang Yong, Cao Ruidong, Mao Yingming.QEMU-based dynamic function call tracing[J].Journal of Computer Research and Development, 2017, 54 (7) :1569-1576 (in Chinese) (向勇, 曹睿东, 毛英明.基于QEMU的动态函数调用跟踪[J].计算机研究与发展, 2017, 54 (7) :1569-1576) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201707015&amp;v=MTc0NDVMT2VaZVZ2Rnk3blc3dkpMeXZTZExHNEg5Yk1xSTlFWVlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[8]</b>
                                        Xiang Yong, Cao Ruidong, Mao Yingming.QEMU-based dynamic function call tracing[J].Journal of Computer Research and Development, 2017, 54 (7) :1569-1576 (in Chinese) (向勇, 曹睿东, 毛英明.基于QEMU的动态函数调用跟踪[J].计算机研究与发展, 2017, 54 (7) :1569-1576) 
                                    </a>
                                </li>
                                <li id="437">


                                    <a id="bibliography_9" title="Guo Haoran, Pang Jianmin, Zhang Yichi, et al.Hero:Anovel malware detection framework based on binary translation[C]Proc of the IEEE Int Conf on Intelligent Computing and Intelligent Systems.Piscataway, NJ:IEEE, 2010:411-415" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Hero:Anovel malware detection framework based on binary translation">
                                        <b>[9]</b>
                                        Guo Haoran, Pang Jianmin, Zhang Yichi, et al.Hero:Anovel malware detection framework based on binary translation[C]Proc of the IEEE Int Conf on Intelligent Computing and Intelligent Systems.Piscataway, NJ:IEEE, 2010:411-415
                                    </a>
                                </li>
                                <li id="439">


                                    <a id="bibliography_10" title="Feiner P, Brown A D, Goel A.Comprehensive kernel instrumentation via dynamic binary translation[C]Proc of the 17th Int Conf on Architectural Support for Programming Languages and Operating Systems.New York:ACM, 2012:135-146" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Comprehensive kernel instrumentation via dynamic binary translation">
                                        <b>[10]</b>
                                        Feiner P, Brown A D, Goel A.Comprehensive kernel instrumentation via dynamic binary translation[C]Proc of the 17th Int Conf on Architectural Support for Programming Languages and Operating Systems.New York:ACM, 2012:135-146
                                    </a>
                                </li>
                                <li id="441">


                                    <a id="bibliography_11" title="Chylek S.Collecting program execution statistics with QEMU processor emulator[C]Proc of the Int Multi Conf on Computer Science and Information Technology.Piscataway, NJ:IEEE, 2009:555-558" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Collecting program execution statistics with Qemu processor emulator">
                                        <b>[11]</b>
                                        Chylek S.Collecting program execution statistics with QEMU processor emulator[C]Proc of the Int Multi Conf on Computer Science and Information Technology.Piscataway, NJ:IEEE, 2009:555-558
                                    </a>
                                </li>
                                <li id="443">


                                    <a id="bibliography_12" title="Shah H, Coombes A, Raabe A, et al.Measurement based WCET analysis for multi-core architectures[C]Proc of the22nd Int Conf on Real-Time Networks and Systems.New York:ACM, 2014:257-266" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Measurement based WCET analysis for multi-core architectures">
                                        <b>[12]</b>
                                        Shah H, Coombes A, Raabe A, et al.Measurement based WCET analysis for multi-core architectures[C]Proc of the22nd Int Conf on Real-Time Networks and Systems.New York:ACM, 2014:257-266
                                    </a>
                                </li>
                                <li id="445">


                                    <a id="bibliography_13" title="Ofuonye E, Miller J.Securing web-clients with instrumented code and dynamic runtime monitoring[J].Journal of Systems and Software, 2013, 86 (6) :1689-1711" target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13050900082711&amp;v=MDQ5MTA5RlpPTU5DMzA0b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VYjdJSmx3Y2JoTT1OaWZPZmJLN0h0VE1wbw==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                        Ofuonye E, Miller J.Securing web-clients with instrumented code and dynamic runtime monitoring[J].Journal of Systems and Software, 2013, 86 (6) :1689-1711
                                    </a>
                                </li>
                                <li id="447">


                                    <a id="bibliography_14" title="Bartholomew D.Qemu:A multihost multitarget emulator[J].Linux Journal, 2006, 2006 (145) :68-71" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=QEMU: a multihost, multitarget emulator">
                                        <b>[14]</b>
                                        Bartholomew D.Qemu:A multihost multitarget emulator[J].Linux Journal, 2006, 2006 (145) :68-71
                                    </a>
                                </li>
                                <li id="449">


                                    <a id="bibliography_15" title="Ellson J, Gansner E R, Koutsofios E, et al.Graphviz and Dynagraph-Static and Dynamic Graph Drawing Tools[M].Berlin:Springer, 2003:127-148" target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Graphviz and Dynagraph-Static and Dynamic Graph Drawing Tools">
                                        <b>[15]</b>
                                        Ellson J, Gansner E R, Koutsofios E, et al.Graphviz and Dynagraph-Static and Dynamic Graph Drawing Tools[M].Berlin:Springer, 2003:127-148
                                    </a>
                                </li>
                                <li id="451">


                                    <a id="bibliography_16" title="Jia Di, Xiang Yong, Sun Weizhen, et al.Database-based online call graph tool applications[J].Journal of Chinese Computer Systems, 2016, 37 (3) :422-427 (in Chinese) (贾荻, 向勇, 孙卫真, 等.基于数据库的在线函数调用图工具[J].小型微型计算机系统, 2016, 37 (3) :422-427) " target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXWX201603005&amp;v=MDkyMTE0TzN6cXFCdEdGckNVUkxPZVplVnZGeTduVzd2SlBUWGNkckc0SDlmTXJJOUZZWVFLREg4NHZSNFQ2ajU=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                        Jia Di, Xiang Yong, Sun Weizhen, et al.Database-based online call graph tool applications[J].Journal of Chinese Computer Systems, 2016, 37 (3) :422-427 (in Chinese) (贾荻, 向勇, 孙卫真, 等.基于数据库的在线函数调用图工具[J].小型微型计算机系统, 2016, 37 (3) :422-427) 
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JFYZ" target="_blank">计算机研究与发展</a>
                2019,56(02),421-430 DOI:10.7544/issn1000-1239.2019.20170657            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于动态二进制翻译和插桩的函数调用跟踪</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%8D%A2%E5%B8%85%E5%85%B5&amp;code=41255391&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">卢帅兵</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BC%A0%E6%98%8E&amp;code=41255392&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张明</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9E%97%E5%93%B2%E8%B6%85&amp;code=41255393&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">林哲超</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9D%8E%E8%99%8E&amp;code=41255394&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">李虎</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%86%B5%E6%99%93%E8%BE%89&amp;code=40585241&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">况晓辉</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%B5%B5%E5%88%9A&amp;code=38189230&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">赵刚</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4(%E5%86%9B%E4%BA%8B%E7%A7%91%E5%AD%A6%E9%99%A2)&amp;code=1019233&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">信息系统安全技术国家重点实验室(军事科学院)</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>动态函数调用跟踪技术是调试Linux内核的重要手段.针对现有动态跟踪工具存在支持平台有限、运行效率低的问题, 基于二进制翻译, 设计并实现支持多种指令集的动态函数调用跟踪工具.首先, 使用二进制翻译进行系统加载、分析内核镜像, 识别基本块的分支指令类型.然后, 根据不同平台指令集, 设计桩代码并在函数调用与返回指令翻译时插入桩指令, 进而在程序执行和内核启动时实时获取时间戳、进程标识、线程标识、函数地址等信息.最后, 内核加载完毕后, 处理获取的信息, 生成过程函数调用图.只需要根据平台指令集特点设计对应的信息获取桩代码并插入到函数调用指令翻译代码中, 实现简单, 易于移植支持多种平台.该方法基于二进制翻译, 直接对程序或内核镜像中的指令段、代码段、符号表进行分析, 不依赖源码.拓展的中间代码和额外的目标码, 不影响基本块连接、冗余代码消除、热路径分析等二进制翻译的优化方法, 降低了开销.基于QEMU的实验结果表明:跟踪分析结果与源代码行为一致, 桩代码执行信息记录产生了15.24%的时间开销, 而信息处理并输出到磁盘文件产生了165.59%的时间开销, 与现有工具相比, 性能有较大提升.</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%8A%A8%E6%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BF%BB%E8%AF%91&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">动态二进制翻译;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BB%A3%E7%A0%81%E6%8F%92%E6%A1%A9&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">代码插桩;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%B7%9F%E8%B8%AA&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">函数调用跟踪;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Linux内核分析;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B7%A8%E5%B9%B3%E5%8F%B0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">跨平台;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    *李虎 (lihu_nudt@163.com) ;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2017-09-08</p>

            </div>
                    <h1><b>Dynamic Binary Translation and Instrumentation Based Function Call Tracing</b></h1>
                    <h2>
                    <span>Lu Shuaibing</span>
                    <span>Zhang Ming</span>
                    <span>Lin Zhechao</span>
                    <span>Li Hu</span>
                    <span>Kuang Xiaohui</span>
                    <span>Zhao Gang</span>
            </h2>
                    <h2>
                    <span>National Key Laboratory of Science and Technology on Information System Security (Academy of Military Sciences)</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Dynamic function call tracing is one of the most important techniques for Linux kernel analysis. Existing tools suffer from the problems of insufficiently supporting instruction set architectures (ISA) and low efficiency. We design and implement a function call tracing tool to support multiple ISAs with high efficiency. Firstly, we use the binary translation system to load the kernel image and recognize the branch instruction types. Secondly, we design different instrumentation code based on different kinds of ISAs and insert instrumentation code during the translation stage to get timestamps, process IDs, thread IDs and function addresses during the kernel booting and runtime. Finally, when the kernel boots up and the shell appears, we process all the information and generate function call maps. Based on binary translation, we analyze the text, symbol and string sections of the binary image, without any source code. Enriched intermediate code and extra target code are compatible with optimization algorithms like block chain, redundant code elimination and hot path optimization, which reduces the performance overhead. The core algorithm is to design the instrumentation code and get corresponding information based on different ISAs. It is easy to implement and to migrate to multiple ISAs. Experiments on QEMU and Linux 4.9 kernel show that the traced information is accordance with the source code while instrumentation code brings about 15.24% and information processing generates 165.59% overhead of original QEMU, which is much faster than existing tools.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=dynamic%20binary%20translation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">dynamic binary translation;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=instrumentation%20code&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">instrumentation code;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=function%20call%20tracing&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">function call tracing;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Linux%20kernel%20analysis&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Linux kernel analysis;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=cross%20platform&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">cross platform;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                            <b>Author：</b>
                                                        <span>
                                    Lu Shuaibing, born in 1990.Master and research assistant.His main research interests include operation system, binary translation.<image id="410" type="formula" href="images/JFYZ201902017_41000.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Zhang Ming, born in 1990.Master and research assistant.His main research interests include artificial intelligence, machine learning and network security.<image id="412" type="formula" href="images/JFYZ201902017_41200.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Lin Zhechao, born in 1990.Master and research assistant.His main research interests include software validation and operating system.<image id="414" type="formula" href="images/JFYZ201902017_41400.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Li Hu, born in 1987.PhD and engineer.His main research interests include information system security, machine learning and data mining.<image id="416" type="formula" href="images/JFYZ201902017_41600.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Kuang Xiaohui, born in 1975.PhD and professor in the National Key Laboratory of Science and Technology on Infomations System Security.His main research interests include wireless network, and information security.<image id="418" type="formula" href="images/JFYZ201902017_41800.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                                <span>
                                    Zhao Gang, born in 1969.Received his PhD degree from the Department of Computer Science and Technology, Tsinghua University in 2009.Professor in the National Key Laboratory of Science and Technology on Information System Security.His main research interests include computer network and information security.<image id="420" type="formula" href="images/JFYZ201902017_42000.jpg" display="inline" placement="inline"><alt></alt></image>;
                                </span>
                    </p>
                                    <p><b>Received：</b> 2017-09-08</p>
                            </div>


        <!--brief start-->
                        <div class="p1">
                    <p id="245">函数调用分析在软件安全<sup><a class="sup">[1]</a></sup>、程序逻辑<sup><a class="sup">[2]</a></sup>、漏洞挖掘<sup><a class="sup">[3]</a></sup>等领域有着广泛的应用.特别是Linux内核的开发与调试需要处理大量复杂的函数, 其调用关系对内核分析与调试有很大帮助<sup><a class="sup">[4]</a></sup>.函数调用分析包括静态分析与动态分析2种方法:</p>
                </div>
                <div class="p1">
                    <p id="246">1) 静态分析.根据源代码进行代码审计, 得到从入口函数到退出函数的整个执行路径.静态分析面向特定的编程语言源码, 进行词法语法分析, 技术成熟.但是间接分支指令、间接函数调用和动态生成代码在静态条件下很难获取执行路径, 因此静态调用关系并不能反映出真实的调用序列信息.</p>
                </div>
                <div class="p1">
                    <p id="247">2) 动态分析.为了能获取程序执行时真实的函数调用关系, 需要在程序运行时记录函数调用信息, 动态跟踪函数执行路径.动态分析方法解决了间接分支目标地址的不确定性问题, 可得到软件实时调用序列、各函数的运行时间、调用次数、前后依赖等信息.</p>
                </div>
                <div class="p1">
                    <p id="248">现有函数调用动态分析工具包括GNU binutils工具集的gprof<sup><a class="sup">[5]</a></sup>, ftrace, systemtap, dtrace等.上述工具需要特定的使用条件, 不能完全满足当前的开发调试需要.gprof仅支持启动用户态可执行程序, 不能用于内核分析;ftrace需要编译内核时打开编译选项, 造成多种编译优化手段无法进行;systemtap与dtrace需要操作系统运行时提供接口, 操作系统启动阶段无法使用.</p>
                </div>
                <div class="p1">
                    <p id="249">为弥补上述工具的不足, 基于模拟器的函数跟踪技术直接分析二进制镜像, 不需额外的编译选项, 成为内核分析技术的重要方面.使用模拟器对函数调用关系进行动态跟踪, 避免对内核源码的插桩和编译过程, 减少对内核的影响.S2E (selective symbolic execution) <sup><a class="sup">[6]</a></sup>基于QEMU<sup><a class="sup">[7]</a></sup>和符号执行技术, 提供插件接口获取操作系统运行时状态、函数调用关系等, 支持x86, x86-64, arm平台.但是S2E运行速度慢, 缺乏对其他平台如MIPS, Alpha等的支持.向勇等人<sup><a class="sup">[8]</a></sup>提出基于QEMU的动态函数调用跟踪框架, 通过关闭基本块链接功能, 迫使每个基本块代码执行结束后进行基本块切换操作, 切换过程中统计函数信息, 并写入日志.相比S2E提高了分析性能和支持的CPU平台种类, 但是该方法依赖于QEMU的日志并必须关闭QEMU的基本块链接功能, 造成3.65倍的性能开销.</p>
                </div>
                <div class="p1">
                    <p id="250">上述工具基于QEMU模拟器进行函数调用跟踪, 并实现对系统状态的监测与分析, 但是监测数据获得的方法破坏了QEMU的模拟和加速机制, 造成较大的性能开销.如何精确记录系统的行为并且不破坏QEMU模拟器的加速机制是亟待解决的问题.</p>
                </div>
                <div class="p1">
                    <p id="251">通过分析QEMU的运行机制, 我们发现QEMU使用平台无关的中间表示进行不同平台指令集的支持, 而源指令到中间表示的翻译过程和中间表示到宿主机平台指令的过程都可以在中间表示层进行插桩获取翻译记录.据此, 本文提出基于动态二进制翻译和代码插桩的函数调用跟踪框架, 在二进制翻译的中间代码阶段, 针对特定函数调用和返回指令进行特殊处理, 插入性能分析和信息获取桩指令块, 从而在运行时获取系统启动与函数调用顺序.基于二进制翻译技术, 避免了对源码的依赖, 并提供跨平台支持;在中间代码阶段的代码插入技术, 减少了对源平台和目标平台的依赖, 降低了系统复杂度, 性能开销.</p>
                </div>
                <div class="p1">
                    <p id="252">本文的主要贡献如下:</p>
                </div>
                <div class="p1">
                    <p id="253">1) 提出一种基于二进制翻译的支持多平台的内核函数调用跟踪框架, 在二进制翻译的中间代码阶段, 生成用于特定信息获取的指令, 而不需重编译内核镜像文件;</p>
                </div>
                <div class="p1">
                    <p id="254">2) 基于二进制翻译的方法, 大大扩展了可支持平台的种类, 便于支持新型平台;</p>
                </div>
                <div class="p1">
                    <p id="255">3) 不影响二进制翻译技术中基本块链接、冗余代码消除、热路径分析等优化技术, 运行效率高.</p>
                </div>
                <h3 id="256" name="256" class="anchor-tag"><b>1</b><b>基于动态二进制翻译和代码插桩的函数调用跟踪框架</b></h3>
                <h4 class="anchor-tag" id="257" name="257"><b>1.1</b><b>动态二进制翻译</b></h4>
                <div class="p1">
                    <p id="258">二进制翻译是软件安全分析<sup><a class="sup">[9]</a></sup>、系统分析<sup><a class="sup">[10]</a></sup>、软件优化<sup><a class="sup">[11]</a></sup>等领域的关键技术.主流的二进制翻译分为静态二进制翻译和动态二进制翻译.动态二进制翻译在执行时根据程序执行路径以基本块为单位进行实时加载、翻译、生成目标代码、执行、缓存管理、代码优化等任务, 解决了间接分支指令目的地址不确定性、动态生成代码的翻译问题, 具有较好的完备性, 是二进制翻译的主流技术, 其工作原理如图1所示:</p>
                </div>
                <div class="area_img" id="259">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_259.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 动态二进制翻译" src="Detail/GetImg?filename=images/JFYZ201902017_259.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图1 动态二进制翻译  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_259.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 1 Dynamic binary translation</p>

                </div>
                <div class="area_img" id="260">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_260.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 基于动态二进制翻译和代码插桩的函数调用跟踪框架" src="Detail/GetImg?filename=images/JFYZ201902017_260.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图2 基于动态二进制翻译和代码插桩的函数调用跟踪框架  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_260.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 2 Dynamic binary translation and code instrumentation based function call tracing framework</p>

                </div>
                <div class="p1">
                    <p id="261">首先, 加载二进制镜像文件, 二进制文件通常为ELF, PE或者Linux内核格式, 分析指令入口点PC (program counter) , 完成内存映射、CPU初始化、虚拟设备创建等工作, 并进入翻译过程.由于程序运行的局部性, 对已翻译的基本块进行缓存可大大节省翻译开销.动态二进制翻译在执行某一基本块前, 首先从缓存中查找, 若该基本块已经翻译, 则切换环境后进入执行阶段;否则, 需要根据当前指令基本块首地址读取指令直到下一条分支指令, 转化为中间代码 (intermediate representation, IR) , 最后生成目标指令集 (instruction set architecture, ISA) 代码并执行.执行完当前基本块后进入下一个基本块并重复上述查找、翻译、执行过程, 直到程序结束.从动态二进制翻译的翻译执行流程可以看出, 以基本块为单位, 翻译过程与执行过程交替进行, 能够对不同平台的代码进行翻译转换, 解决了多平台指令集支持的问题, 极大地增大了软件的适用性.</p>
                </div>
                <div class="p1">
                    <p id="262">本文基于动态二进制翻译的系统调用跟踪, 方便地支持多种指令集, 并提供了指令和基本块粒度的信息统计和代码插入方法, 可获取的信息量大大增加.</p>
                </div>
                <h4 class="anchor-tag" id="263" name="263"><b>1.2</b><b>代码插桩</b></h4>
                <div class="p1">
                    <p id="264">代码插桩技术是软件调试中采用的代码修改机值, 包括目标代码插桩和源代码插桩, 通过插桩点实时获取程序状态, 广泛应用于性能分析、覆盖测试、软件调试等领域<sup>[<a class="sup">12</a>,<a class="sup">13</a>]</sup>.</p>
                </div>
                <div class="p1">
                    <p id="265">源代码插桩技术通过对程序源代码的词法分析、语法分析、语义分析等, 确定插桩位置, 依赖于特定的编程语言, 工作量大.例如gprof, ftrace, systemtap都使用到了源代码插桩技术.</p>
                </div>
                <div class="p1">
                    <p id="266">目标代码插桩技术通过对目标代码进行相应的分析, 分析确定插桩点, 与具体的指令集相关, 不依赖程序源码, 与具体的编程语言和版本无关.本文针对目标代码, 在指令粒度进行插桩, 提升了检测信息的精确度.</p>
                </div>
                <h4 class="anchor-tag" id="267" name="267"><b>1.3</b><b>框架设计思路</b></h4>
                <div class="p1">
                    <p id="268">为支持多种平台二进制镜像, 实现指令粒度的代码插桩, 实时获取执行信息、内核加载过程信息、函数调用关系信息等, 提出基于动态二进制翻译和代码插桩的函数调用跟踪框架, 框架模块如图2所示.</p>
                </div>
                <div class="p1">
                    <p id="269">1) 通过二进制翻译系统, 载入内核镜像;</p>
                </div>
                <div class="p1">
                    <p id="270">2) 对操作系统内核进行分析并确定指令集类型、入口点;</p>
                </div>
                <div class="p1">
                    <p id="271">3) 对需要执行的基本块进行二进制翻译, 在中间代码阶段, 针对特殊的函数调用与返回指令插入桩指令;</p>
                </div>
                <div class="p1">
                    <p id="272">4) 最后在执行阶段, 每次执行函数调用和返回指令, 都会执行插入的桩代码, 获取模拟时钟、进程地址、函数地址等.</p>
                </div>
                <div class="p1">
                    <p id="273">该框架充分利用了动态二进制翻译系统的整体流程, 以指令粒度分析插桩点, 动态将桩代码插入到生成的目标码中, 实现了实时信息获取功能.</p>
                </div>
                <h3 id="274" name="274" class="anchor-tag"><b>2</b><b>基于QEMU和代码插桩的函数调用跟踪系统实现</b></h3>
                <div class="p1">
                    <p id="275">根据第1节函数调用跟踪框架的原理, 基于开源的二进制翻译系统QEMU, 进行桩代码设计、中间代码桩标记码和目标代码的进入桩插入、监测信息处理等开发工作, 实现了基于QEMU和代码插桩的函数调用跟踪系统.</p>
                </div>
                <h4 class="anchor-tag" id="276" name="276"><b>2.1</b><b>快速的处理器模拟器QEMU</b></h4>
                <div class="p1">
                    <p id="277">QEMU是一个快速的处理器模拟器, 支持多种源平台和多种目标平台<sup><a class="sup">[14]</a></sup>.利用平台无关的中间表示形式TCG (tiny code generator) , 实现将x86, arm, Alpha, PowerPC等指令集转换为TCG中间表示, 然后翻译为宿主机的指令集, 具备快速模拟和跨平台支持特性.作为模拟器可模拟多种设备、硬件, 支持全系统运行, 可在宿主机运行不同指令集的客户机.</p>
                </div>
                <div class="p1">
                    <p id="278">QEMU以基本块为单位对源指令进行翻译, 提供了代码缓存管理、基本块链接、冗余代码消除等优化, 提升了模拟器速度.QEMU的执行流程如图3所示.首先, QEMU加载源指令集的可执行文件或者内核镜像, 完成空间申请、地址映射、入口点分析等工作后从第1条指令开始进入翻译执行的过程.以基本块为单位, 读取源指令集的指令序列, 生成对应的TCG中间表示, 然后分析优化后生产宿主机指令集的代码, 并将动态生成的代码存入缓存, 实现一次翻译多次使用.在基本块执行完毕后, 模拟器试图查找下一个基本块对应的代码, 如果在缓存代码区找到需要的代码块, 则直接跳转执行, 否则需要启动翻译过程.由于每次基本块执行完毕后进行查找下一个基本块引起较大开销, QEMU实现基本块链接功能, 把下一个基本块和当前块直接使用跳转指令连接起来, 避免了查找消耗.基本块链接技术极大地提高了模拟器的运行效率, 是QEMU模拟器的高效率关键技术.</p>
                </div>
                <div class="area_img" id="279">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_279.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 QEMU框架结构" src="Detail/GetImg?filename=images/JFYZ201902017_279.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图3 QEMU框架结构  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_279.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 3 Framework of QEMU</p>

                </div>
                <div class="p1">
                    <p id="280">从QEMU的运行原理可以看出, QEMU使用了平台无关中间表示TCG, 是典型的动态二进制翻译系统.可在TCG阶段对需要检测的指令进行操作, 插入所需统计信息桩代码, 在运行时获取函数调用信息.</p>
                </div>
                <h4 class="anchor-tag" id="281" name="281"><b>2.2</b><b>函数调用指令翻译</b></h4>
                <div class="p1">
                    <p id="282">QEMU进行二进制翻译采用的平台无关中间表示是TCG, 曾作为支持多平台的C语言交叉编译器的后端, 是一种类似于RISC的指令集.TCG仅支持32 b和64 b整型, 指针类型是根据宿主机的位数按照32 b或64 b整型定义的.QEMU把源指令变换为TCG操作, 进行活性分析、常量计算优化, 然后变换为对应宿主机指令集的指令序列.例如指令add_i32 <i>t</i><sub>0</sub>, <i>t</i><sub>1</sub>, <i>t</i><sub>2</sub>表示<i>t</i><sub>1</sub>+<i>t</i><sub>2</sub>的和放到<i>t</i><sub>0</sub>寄存器中, 操作数<i>t</i><sub>0</sub>, <i>t</i><sub>1</sub>, <i>t</i><sub>2</sub>都是32 b整型.</p>
                </div>
                <div class="p1">
                    <p id="283">函数调用指令会更改程序执行顺序, 并修改栈内容, TCG针对函数调用遵循以下规则:</p>
                </div>
                <div class="p1">
                    <p id="284">1) 参数和返回值的类型仅支持32 b, 64 b整型和指针.</p>
                </div>
                <div class="p1">
                    <p id="285">2) 栈向下填充.</p>
                </div>
                <div class="p1">
                    <p id="286">3) 前<i>N</i>个参数通过寄存器传递, 超过<i>N</i>个参数的以字为单位放入栈传递.<i>N</i>在文件中可根据具体平台自定义.</p>
                </div>
                <div class="p1">
                    <p id="287">4) 一些寄存器在函数调用过程中会被重复使用.</p>
                </div>
                <div class="p1">
                    <p id="288">5) 函数可以使用寄存器返回0或1.在32 b宿主机上运行64 b系统时, 为了能够返回64 b值, 必须使用寄存器返回2个32 b值.</p>
                </div>
                <div class="p1">
                    <p id="289">这些规则限定了函数调用指令处理的方法, 一条函数调用指令会被分解为参数传递操作、栈修改操作、分支跳转操作3部分.</p>
                </div>
                <div class="p1">
                    <p id="290">为了插入用于信息统计的桩代码, 添加新的TCG中间表示, 在分支跳转操作前插入gen_stubc TCG指令, 用以生成调用桩代码的指令序列.例如指令call 0x7fac6ee插入gen_stubc后的翻译过程如图4所示, 可以看到生成了call stubc的中间代码指令和对应的目标平台指令“mov $0x56333978b660, %r10;callq*%r10”, 其中地址$0x56333978b660为桩代码helper_stubc在内存中的位置.</p>
                </div>
                <div class="area_img" id="291">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_291.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 插桩后的call指令翻译过程" src="Detail/GetImg?filename=images/JFYZ201902017_291.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图4 插桩后的call指令翻译过程  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_291.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 4 Translation of call instruction with instrumentation code</p>

                </div>
                <h4 class="anchor-tag" id="292" name="292"><b>2.3</b><b>桩代码设计</b></h4>
                <div class="p1">
                    <p id="293">桩代码是在动态翻译的过程中, 插入到函数调用和返回指令对应目标代码中, 完成信息获取的代码段.桩代码需要完成信息监测功能, 同时不能对原有代码的语义造成影响.</p>
                </div>
                <div class="p1">
                    <p id="294">每次函数调用和函数返回都调用桩代码, 记录实时操作信息, 使得获取从第1条指令到最后启动完成全局的调用信息;需要完成信息监测功能, 同时不能对原有代码的语义造成影响;执行的次数非常多, 尽量保持简短.</p>
                </div>
                <div class="p1">
                    <p id="295">考虑以上因素, 结合QEMU具体实现, 采用helper机制调用桩代码.QEMU在进行指令翻译的过程中, 会遇到语义复杂的指令, 例如, 这类指令如果使用宿主平台汇编指令实现其功能非常复杂, 以至于生成的目标代码极其庞大, 易出错.为了兼顾效率与灵活性, QEMU使用特定的helper函数实现此类功能复杂型指令的模拟操作.例如使用<i>tcg</i>_<i>gen</i>_<i>helper</i>_<i>x</i>_<i>y</i>可以生成调用参数为32 b, 64 b或指针的函数.默认情况下, 在调用helper函数时, 所有的全局变量将会保存到对应<i>env</i>的位置, 以防helper修改某些寄存器的值.一个helper函数是可以访问模拟器CPU状态变量<i>env</i>的.利用helper机制, 可方便的在函数调用和返回处调用helper的stub桩代码, 访问全局CPU状态变量env, 完成信息记录功能.</p>
                </div>
                <h4 class="anchor-tag" id="296" name="296"><b>2.4</b><b>针对x86指令集的桩代码设计</b></h4>
                <div class="p1">
                    <p id="297">使用QEMU的helper机制, 针对x86指令集进行代码插桩的方法如下, 首先在target/i386/helper.h中添加定义<i>DEF</i>_<i>HELPER</i>_2 (<i>stub</i>_<i>call</i>, void, <i>env</i>, <i>tl</i>) 其中<i>stub</i>_<i>call</i>是helper函数名, void是返回值, <i>env</i>, <i>tl</i>是参数类型, 表示函数void <i>helper</i>_<i>stub</i>_<i>call</i> (<i>CPUx</i>86<i>State</i>*<i>env</i>, target_ulong <i>val</i>) 的声明, 类似的<i>DEF</i>_<i>HELPER</i>_2 (<i>stub</i>_<i>ret</i>, void, <i>env</i>, <i>tl</i>) 表示ret指令的返回嵌入桩代码.然后, 在translate.c中对call, ret指令翻译的响应位置, 插入<i>gen</i>_<i>helper</i>生成调用<i>helper</i>_<i>stub</i>_<i>call</i>, <i>helper</i>_<i>stub</i>_<i>ret</i>的TCG指令, 其中使用<i>gen</i>_<i>helper</i>在翻译时首先会把模拟CPU的寄存器值保存到内存中, 防止内部代码执行影响寄存器内容;最后, 在target/i386/misc_helper.c中实现2个函数.桩代码的功能如图5所示, 使用全局的信息结构体env保存包括时间戳、进程ID、调用地址、当前函数地址、函数名称等信息, 并使用全局的<i>call</i>_<i>info</i>_<i>arr</i>数组把所有函数调用和返回的信息进行保存.然后调用QEMU内置函数<i>QEMU</i>_<i>clock</i>_<i>get</i>_<i>ns</i> () 获取模拟时钟, 通过<i>CPUx</i>86<i>State</i>结构体的寄存器值, 分别获取ESP值、进程ID、调用函数地址、当前函数地址并存入全局数组;最后桩代码执行完毕, 回到基本块, 继续执行后续代码.</p>
                </div>
                <div class="area_img" id="309">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_30900.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 针对x86平台的桩代码" src="Detail/GetImg?filename=images/JFYZ201902017_30900.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图5 针对x86平台的桩代码  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_30900.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 5 Instrumentation code of x86</p>

                </div>
                <h4 class="anchor-tag" id="310" name="310"><b>2.5</b><b>针对ARM指令集的桩代码设计</b></h4>
                <div class="p1">
                    <p id="311">ARM指令集是目前移动平台使用最广泛的指令集, ARM属于精简指令集, 有31个32 b的通用寄存器, 其中有3个寄存器SP (stack pointer) 、LR (link register) 、PC有特殊的用途.</p>
                </div>
                <div class="p1">
                    <p id="312">通常R13作为栈指针寄存器存储栈指针SP, pop和push指令使用R13的值访问栈空间.</p>
                </div>
                <div class="p1">
                    <p id="313">R14作为链接寄存器LR.当使用分支链接指令 (BL, BLX) 指令时, 该寄存器保存当前分支链接指令的下一条指令的地址.在函数调用结束返回时, R14作为返回的地址, 其他时候R14可作为通用寄存器使用.因此在进行函数调用跟踪时, 可通过访问R14获得返回地址.</p>
                </div>
                <div class="p1">
                    <p id="314">R15作为程序计数器PC, 由于ARM体系结构采用了多级流水线技术, 对于ARM指令集而言, PC总是指向当前指令的下2条指令的地址, 即PC的值为当前指令的地址值加8 B程序状态寄存器.</p>
                </div>
                <div class="p1">
                    <p id="315">页表转换基寄存器 (TTBR) , <i>CP</i>15的第2个寄存器存放当前进程的物理基地址, 在QEMU模拟ARM类型的CPU时使用<i>CP</i>15.<i>ttbr</i>0_<i>el</i>[2]表示该值.</p>
                </div>
                <div class="p1">
                    <p id="316">ARM指令集使用BL, BLX进行子程序调用时, 把返回地址存储到LR, 但是没有专门的返回指令, 而是通过把LR的值传入PC寄存器中的方法.通常使用如下4种函数返回方法:</p>
                </div>
                <div class="p1">
                    <p id="317">MOV PC, LR或BX LR</p>
                </div>
                <div class="p1">
                    <p id="318">该MOV指令直接把LR寄存器的值复制到PC寄存器, 更改程序执行流程, 使函数返回到LR存储的地址处.同样BX LR直接把LR寄存器中的返回地址作为无条件跳转目的地址, 完成函数返回操作.</p>
                </div>
                <div class="p1">
                    <p id="319">或者stmfd与ldmfd, push, pop指令在函数入口处执行入栈并在函数结束时执行出栈操作来更改程序执行流程.使用在函数入口处使用如下指令保存寄存器状态:</p>
                </div>
                <div class="p1">
                    <p id="320">stmfd SP!, {&lt;registers&gt;, LR}或push{&lt;registers&gt;, LR}, </p>
                </div>
                <div class="p1">
                    <p id="321">即保存通用寄存器和LR的值到栈中, 函数体执行完毕需要返回时, 恢复CPU状态, </p>
                </div>
                <div class="p1">
                    <p id="322">ldmfd SP!, {&lt;registers&gt;, PC}或pop{&lt;registers&gt;, PC}.</p>
                </div>
                <div class="p1">
                    <p id="323">以上4种方式是常用的函数返回方法, 在进行函数调用跟踪时, 需要在翻译阶段判断这4种情况, 并生成调用的桩代码的TCG指令.</p>
                </div>
                <div class="p1">
                    <p id="324">根据ARM指令的函数调用和返回方法以及特殊寄存器的使用方式, 设计ARM平台的桩代码如图6所示:</p>
                </div>
                <div class="area_img" id="335">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_33500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 针对ARM平台的桩代码" src="Detail/GetImg?filename=images/JFYZ201902017_33500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图6 针对ARM平台的桩代码  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_33500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 6 Instrumentation code of ARM</p>

                </div>
                <h4 class="anchor-tag" id="336" name="336"><b>2.6</b><b>针对MIPS指令集的桩代码设计</b></h4>
                <div class="p1">
                    <p id="337">MIPS指令集广泛应用在交换设备、移动设备、嵌入式微控制器等产品, 属于精简指令集, 有32个通用寄存器, 其中寄存器$29用作栈寄存器$sp, $31寄存器用作返回地址寄存器$ra.函数调用指令使用Motorala命名法, 子程序调用成为跳转并链接, 助记符以al结尾, 例如jal imm或jalr $reg该指令首先把C寄存器保存到$ra, 然后跳转到立即数imm或$reg指向的指令块.函数返回时, 使用jr $ra跳转到保存的指令地址$ra, 完成函数返回操作.若被调用函数再次调用其他函数, 那么$ra的值会先存入栈空间, 子函数执行结束后, 重新载入$ra的值, 进行返回.类似的, 使用bal, bgezal, bltzal进行相对PC偏移的函数调用, 返回值会存储到$ra中.在翻译阶段对上述子程序调用指令和函数返回指令生成调用桩代码的TCG指令, 实现函数调用跟踪.</p>
                </div>
                <div class="p1">
                    <p id="338">我们使用当前进程的物理地址作为唯一标识, 以区分不同的进程.MIPS为每个进程分配了地址空间ID, 称为ASID (address space id) , 在进行TLB转换时, 使用ASID和虚拟页号 (virtual page number, VPN) 拼接成唯一的页地址, 映射到物理地址, 因此可以使用ASID拼接VPN作为当前进程的标识.QEMU实现了MIPS的ASID, VPN保存在<i>env</i>→<i>CP</i>0_<i>EntryHi</i>中.根据MIPS指令集和寄存器特点, 针对MIPS指令集的桩代码设计如图7所示:</p>
                </div>
                <div class="area_img" id="352">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_35200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 针对MIPS平台的桩代码" src="Detail/GetImg?filename=images/JFYZ201902017_35200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图7 针对MIPS平台的桩代码  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_35200.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 7 Instrumentation code of MIPS</p>

                </div>
                <div class="area_img" id="353">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_353.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 函数调用跟踪Linux 4.9内核绘图示例" src="Detail/GetImg?filename=images/JFYZ201902017_353.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图9 函数调用跟踪Linux 4.9内核绘图示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_353.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 9 Example of function call map of Linux 4.9 kernel</p>

                </div>
                <div class="p1">
                    <p id="354">以上给出了x86, ARM, MIPS指令集的桩代码设计方法, 可以看出桩代码从全局环境结构体env中直接读取相应信息, 代码简短、直接, 可很快根据具体平台要求, 具有多平台支持的特点, 其他平台可根据寄存器的使用特点, 很方便地移植到需要支持的指令集构架平台上.</p>
                </div>
                <h4 class="anchor-tag" id="355" name="355"><b>2.7</b><b>日志记录与函数调用图</b></h4>
                <div class="p1">
                    <p id="356">日志记录包括call记录和ret记录, call记录需保存调用时间、进程标识、线程标识、被调用函数地址、被调用函数名称;而ret记录包括调用时间、进程标识、线程标识即可.例如在时刻592092451ns函数<i>start</i>_<i>kernel</i>被调用, 接着函数<i>start</i>_<i>kernel</i>调用了<i>set</i>_<i>task</i>_<i>stack</i>_<i>end</i>_<i>magic</i>, <i>smp</i>_<i>setup</i>_<i>processor</i>_<i>id</i>记录如图8所示:</p>
                </div>
                <div class="area_img" id="365">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_36500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 日志记录示例" src="Detail/GetImg?filename=images/JFYZ201902017_36500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图8 日志记录示例  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_36500.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 8 Example of the logs</p>

                </div>
                <div class="p1">
                    <p id="366">通过桩代码的统计, 获取了对应信息, 需结合分析二进制镜像获取符号表中函数名称, 即可把call_info结构体中的<i>function</i>_<i>name</i>确定, 从而形成完整的统计, 按照相关工具进行输出, 生成函数调用图, 本文使用graphviz<sup><a class="sup">[15]</a></sup>工具生成函数调用图, 如图9所示start_kernel执行时的函数调用关系.该可视化工作已有相关研究, 可结合已有相关解析工具和算法<sup><a class="sup">[16]</a></sup>, 不作为本文的主要工作.</p>
                </div>
                <h3 id="367" name="367" class="anchor-tag"><b>3</b><b>与现有工作的比较</b></h3>
                <div class="p1">
                    <p id="368">现有的基于模拟器的函数调用跟踪工具有S2E和向勇所提出的基于QEMU的动态函数调用跟踪框架不妨记为QEMU-DFCT (QEMU-based dynamic function call tracing) .下面将本文所提出的方案分别与S2E, QEMU-DFCT进行对比.</p>
                </div>
                <h4 class="anchor-tag" id="369" name="369"><b>3.1</b><b>与S2E对比</b></h4>
                <h4 class="anchor-tag" id="370" name="370">3.1.1 功能性比较</h4>
                <div class="p1">
                    <p id="371">S2E结合了符号执行和QEMU, 并提供插件发布、订阅、处理事件.可通过编写回调函数, 注册某类型事件即可完成订阅.当所注册时间类型触发如函数调用, 则回调函数会接收到调用信息、执行回调函数定义的功能.</p>
                </div>
                <div class="p1">
                    <p id="372">由于S2E对QEMU本身做了较大量的修改, 目前可支持x86, ARM指令集, 未能对QEMU所支持的多种平台进行继承, 丢弃原始QEMU的诸多特性.</p>
                </div>
                <h4 class="anchor-tag" id="373" name="373">3.1.2 性能比较</h4>
                <div class="p1">
                    <p id="374">S2E的符号执行模块会对分析对象的每一个执行路径进行分析, 对指定模块的路径属性、条件进行监测和操纵, 功能复杂, 导致性能很低.本文提出的方案直接对QEMU的中间表示TCG, helper机制进行利用, 实现了函数调用与返回跟踪技术, 继承了QEMU原生的多平台、速度快的特性.</p>
                </div>
                <h4 class="anchor-tag" id="375" name="375"><b>3.2</b><b>与QEMU-DFCT对比</b></h4>
                <div class="p1">
                    <p id="376">本文提出的方法所实现的函数调用记录的功能与QEMU-DFCT一致.</p>
                </div>
                <div class="p1">
                    <p id="377">QEMU-DFCT继承了原生QEMU的诸多优点, 如跨平台、易拓展, 同时以很小的修改代码实现了函数调用跟踪技术.QEMU-DFCT直接读取QEMU原始数据结构, 并并行解析, 提高了处理速度.</p>
                </div>
                <div class="p1">
                    <p id="378">但是, QEMU-DFCT必须强制关闭基本块链接功能, 在每一个基本块执行结束后进行基本块切换操作, 都必须检查是否为函数调用或返回基本块, 造成了3.65倍的性能开销.本文提出的方案不是在基本块切换阶段记录信息, 而是将以桩代码的形式, 插入到函数调用和返回指令生成的宿主机代码中, 支持基本块链接功能, 降低了性能开销.</p>
                </div>
                <h3 id="379" name="379" class="anchor-tag"><b>4</b><b>实</b><b>验</b></h3>
                <div class="p1">
                    <p id="380">本文在QEMU 2.9.92版本进行实验, 相关实验环境如表1所示.其中Linux 内核是使用QEMU加载分析的内核, 文件系统是使用QEMU加载时指定的文件系统.宿主机是指运行QEMU的计算机.</p>
                </div>
                <div class="area_img" id="381">
                    <p class="img_tit"><b>表1</b><b>实验环境</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"><b>Table 1</b><b>Experiment Setup</b></p>
                    <p class="img_note"></p>
                    <table id="381" border="1"><tr><td><br />Hardware &amp; Software</td><td>Version</td></tr><tr><td><br />QEMU</td><td>2.9.92</td></tr><tr><td><br />S2E</td><td>2.0</td></tr><tr><td><br />Linux Kernel</td><td>4.9</td></tr><tr><td><br />File System</td><td>Busybox 1.27.0</td></tr><tr><td><br />CPU of Host</td><td>Intel Core i7-6500U<br />CPU @ 2.50 GHz×4</td></tr><tr><td><br />Memory of Host/GB</td><td>7.7</td></tr><tr><td><br />Operation Systme of Host<br />Hard Disk of Host/GB</td><td>Ubuntu 16.04 LTS<br />SSD 128</td></tr><tr><td><br />Machine Type of ARM</td><td>vexpress-a9</td></tr><tr><td><br />Machine Type of MIPS</td><td>malta</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="382">本文实现了所提出的插桩算法 (QEMU helper stub, QHS) 和QEMU-DFCT算法的记录函数调用信息和输出部分, 并在x86, ARM, MIPS平台进行了性能对比实验, 实验结果如图10所示:</p>
                </div>
                <div class="area_img" id="383">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JFYZ201902017_383.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图10 QHS, DFCT的性能比较" src="Detail/GetImg?filename=images/JFYZ201902017_383.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit">图10 QHS, DFCT的性能比较  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JFYZ201902017_383.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit">Fig. 10 Performance comparison of QHS and DFCT</p>

                </div>
                <div class="p1">
                    <p id="384">以QHS-x86为例, 使用未修改的QEMU加载x86指令集Linux 4.9内核、busybox 1.27.0文件系统, 从启动到出现shell提示符时间消耗是4.33 s.使用修改后的用于函数调用跟踪的版本, 从启动到出现shell提示符, 同时完成函数调用信息记录, 并将信息处理并输出到磁盘文件中, 所用时间是12.16 s, 其中, 桩代码执行总时间是0.66 s, 信息处理并输出使用时间是7.17 s.桩代码执行信息记录增加了15.24%的开销, 而信息处理并输出到磁盘文件增加了165.59%的开销;DFCT-x86信息记录增加了210.62%的开销, 记录输出开销是166.51%.由于ARM和MIPS平台寄存器数目多, DFCT进行基本块切换操作需要保存或恢复的寄存器数目多, 造成调用记录开销高于x86平台, 而寄存器数目并不影响QHS算法的性能.</p>
                </div>
                <div class="p1">
                    <p id="385">而使用S2E对x86指令集的内核进行加载分析, 总时长达3 429.34 s, 是因为S2E会对内核使用KLEE模块进行符号分析, 对内核的海量的执行路径进行路径属性、执行条件分析, 并在每个路径和函数调用部分保存并检查系统状态、反馈插件调用等任务.所以造成内核启动很慢.</p>
                </div>
                <div class="p1">
                    <p id="386">从实验结果可以看出, 本文实现的基于动态二进制翻译和代码插桩的函数调用跟踪工具的开销要远远优于现有的S2E, QEMU-DFCT跟踪工具.</p>
                </div>
                <h3 id="387" name="387" class="anchor-tag"><b>5</b><b>总</b><b>结</b></h3>
                <div class="p1">
                    <p id="388">本文提出了基于动态二进制翻译和代码插桩的函数调用跟踪, 给出了系统框架设计并基于QEMU开发了函数调用跟踪系统, 可针对Linux内核跟踪所有函数调用, 并在x86, ARM, MIPS平台进行了实现, 验证了系统框架的有效性并评估了系统性能.针对QEMU二进制翻译过程的中间表示进行设计, 插入信息搜集桩代码而不影响基本块链接、活性分析、常量计算等优化技术, 以尽可能小的性能开销达到了动态函数跟踪的目的.</p>
                </div>
                <div class="p1">
                    <p id="389">本工作还有一些可改进的地方, 例如桩代码的实现可以使用嵌入式汇编或者不使用helper机制, 直接生成完成信息记录功能的宿主机指令, 进一步提高速度, 降低开销.实现插件机制, 例如注册指定函数调用事件的回调函数, 在桩代码进行记录时, 若被调用函数是指定的监测函数, 调用回调函数.</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="421">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Nitro:Hardware-based system call tracing for virtual machines">

                                <b>[1]</b>Pfoh J, Schneider C, Eckert C.Nitro:Hardware-based system call tracing for virtual machines[C]Proc of the Advances in Information and Computer Security.Berlin:Springer, 2011:96-112
                            </a>
                        </p>
                        <p id="423">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Dynamic CPU usage profiling and function call tracing">

                                <b>[2]</b>Hibbeler J D, Wang Jhychun.Dynamic CPU usage profiling and function call tracing:US, Patent 7093234[P/OL]. (2006-08-15) [2018-05-16].http:www.freepatentsonline.com/7093234.html
                            </a>
                        </p>
                        <p id="425">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Transparent ROP exploit mitigation using indirect branch tracing">

                                <b>[3]</b>Pappas V, Polychronakis M, Keromytis A D.Transparent ROP exploit mitigation using indirect branch tracing[C]Proc of the 22nd USENIX Conf on Security.Berkeley, CA:USENIX Association, 2013:447-462
                            </a>
                        </p>
                        <p id="427">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Research on the static function call path generating automatically">

                                <b>[4]</b>Zheng Yuhui, Mu Yongmin, Zhang Zhihua.Research on the static function call path generating automatically[C]Proc of the 2nd IEEE Int Conf on Information Management and Engineering.Piscataway, NJ:IEEE, 2010:405-409
                            </a>
                        </p>
                        <p id="429">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000081109&amp;v=MTE0NjVycVFUTW53WmVadUh5am1VYjdJSmx3Y2JoTT1OaWZJWTdLN0h0ak5yNDlGWk9NT0RYd3dvQk1UNlQ0UFFIL2lyUmRHZQ==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b>Graham S L, Kessler P B, McKusick M K.Gprof:A call graph execution profiler[J].ACM SIGPLAN Notices, 2004, 39 (4) :49-57
                            </a>
                        </p>
                        <p id="431">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The S2E platform: Design, implementation, and applications">

                                <b>[6]</b>Chipounov V, Kuznetsov V, Candea G.The S2Eplatform:Design, implementation, and applications[J].ACMTransactions on Computer Systems, 2012, 30 (1) :1-49
                            </a>
                        </p>
                        <p id="433">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Qemu,a fast and portable dynamic translator">

                                <b>[7]</b>Bellard F.QEMU, a fast and portable dynamic translator[C]Proc of the Annual Conf on USENIX Annual Technical Conf.Berkeley, CA:USENIX Association, 2005:41-46
                            </a>
                        </p>
                        <p id="435">
                            <a id="bibliography_8" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201707015&amp;v=MDA0OTFNcUk5RVlZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N25XN3ZKTHl2U2RMRzRIOWI=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[8]</b>Xiang Yong, Cao Ruidong, Mao Yingming.QEMU-based dynamic function call tracing[J].Journal of Computer Research and Development, 2017, 54 (7) :1569-1576 (in Chinese) (向勇, 曹睿东, 毛英明.基于QEMU的动态函数调用跟踪[J].计算机研究与发展, 2017, 54 (7) :1569-1576) 
                            </a>
                        </p>
                        <p id="437">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Hero:Anovel malware detection framework based on binary translation">

                                <b>[9]</b>Guo Haoran, Pang Jianmin, Zhang Yichi, et al.Hero:Anovel malware detection framework based on binary translation[C]Proc of the IEEE Int Conf on Intelligent Computing and Intelligent Systems.Piscataway, NJ:IEEE, 2010:411-415
                            </a>
                        </p>
                        <p id="439">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Comprehensive kernel instrumentation via dynamic binary translation">

                                <b>[10]</b>Feiner P, Brown A D, Goel A.Comprehensive kernel instrumentation via dynamic binary translation[C]Proc of the 17th Int Conf on Architectural Support for Programming Languages and Operating Systems.New York:ACM, 2012:135-146
                            </a>
                        </p>
                        <p id="441">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Collecting program execution statistics with Qemu processor emulator">

                                <b>[11]</b>Chylek S.Collecting program execution statistics with QEMU processor emulator[C]Proc of the Int Multi Conf on Computer Science and Information Technology.Piscataway, NJ:IEEE, 2009:555-558
                            </a>
                        </p>
                        <p id="443">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Measurement based WCET analysis for multi-core architectures">

                                <b>[12]</b>Shah H, Coombes A, Raabe A, et al.Measurement based WCET analysis for multi-core architectures[C]Proc of the22nd Int Conf on Real-Time Networks and Systems.New York:ACM, 2014:257-266
                            </a>
                        </p>
                        <p id="445">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13050900082711&amp;v=MDQxNzg0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbVViN0lKbHdjYmhNPU5pZk9mYks3SHRUTXBvOUZaT01OQzMwNG9CTVQ2VA==&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b>Ofuonye E, Miller J.Securing web-clients with instrumented code and dynamic runtime monitoring[J].Journal of Systems and Software, 2013, 86 (6) :1689-1711
                            </a>
                        </p>
                        <p id="447">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=QEMU: a multihost, multitarget emulator">

                                <b>[14]</b>Bartholomew D.Qemu:A multihost multitarget emulator[J].Linux Journal, 2006, 2006 (145) :68-71
                            </a>
                        </p>
                        <p id="449">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Graphviz and Dynagraph-Static and Dynamic Graph Drawing Tools">

                                <b>[15]</b>Ellson J, Gansner E R, Koutsofios E, et al.Graphviz and Dynagraph-Static and Dynamic Graph Drawing Tools[M].Berlin:Springer, 2003:127-148
                            </a>
                        </p>
                        <p id="451">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XXWX201603005&amp;v=MjYyMjBQVFhjZHJHNEg5Zk1ySTlGWVlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVZ2Rnk3blc3dko=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b>Jia Di, Xiang Yong, Sun Weizhen, et al.Database-based online call graph tool applications[J].Journal of Chinese Computer Systems, 2016, 37 (3) :422-427 (in Chinese) (贾荻, 向勇, 孙卫真, 等.基于数据库的在线函数调用图工具[J].小型微型计算机系统, 2016, 37 (3) :422-427) 
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JFYZ201902017" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ201902017&amp;v=MDA2ODM0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVWdkZ5N25XN3ZKTHl2U2RMRzRIOWpNclk5RVk0UUtESDg=&amp;uid=WEEvREcwSlJHSldRa1FhdkJkVG5hVC9sR01QWmh5WWp6SmI1Z2pYeEdIOD0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
