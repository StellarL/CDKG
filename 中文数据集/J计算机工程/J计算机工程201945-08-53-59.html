<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637128889747488750%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201908010%26RESULT%3d1%26SIGN%3dDLCvqB27MY%252foDv7Y%252f0XUTcgVpqc%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201908010&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201908010&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201908010&amp;v=MTk5OThRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJxRnkvZ1VMdk1MejdCYmJHNEg5ak1wNDlFWkk=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#39" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#43" data-title="1 聚类模型的三维数据可视化算法流程 ">1 聚类模型的三维数据可视化算法流程</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#46" data-title="2 基于CURE聚类的三维Hilbert R-tree索引 ">2 基于CURE聚类的三维Hilbert R-tree索引</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#48" data-title="2.1 CURE聚类算法">2.1 CURE聚类算法</a></li>
                                                <li><a href="#58" data-title="2.2 基于CURE聚类Hilbert R-tree索引的构建">2.2 基于CURE聚类Hilbert R-tree索引的构建</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#84" data-title="3 数据预加载算法 ">3 数据预加载算法</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#90" data-title="3.1 视点预测算法">3.1 视点预测算法</a></li>
                                                <li><a href="#113" data-title="3.2 步长的选取及调整">3.2 步长的选取及调整</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#120" data-title="4 实验结果与分析 ">4 实验结果与分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#124" data-title="4.1 Hilbert R-tree索引的结果分析">4.1 Hilbert R-tree索引的结果分析</a></li>
                                                <li><a href="#128" data-title="4.2 可视化区域预测模型">4.2 可视化区域预测模型</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#136" data-title="5 结束语 ">5 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#45" data-title="&lt;b&gt;图1 聚类模型的三维数据可视化算法流程&lt;/b&gt;"><b>图1 聚类模型的三维数据可视化算法流程</b></a></li>
                                                <li><a href="#83" data-title="&lt;b&gt;图2 基于CURE聚类的三维Hilbert R-tree&lt;/b&gt;"><b>图2 基于CURE聚类的三维Hilbert R-tree</b></a></li>
                                                <li><a href="#86" data-title="&lt;b&gt;图3 数据预加载算法流程&lt;/b&gt;"><b>图3 数据预加载算法流程</b></a></li>
                                                <li><a href="#89" data-title="&lt;b&gt;图4 数据划分示意图&lt;/b&gt;"><b>图4 数据划分示意图</b></a></li>
                                                <li><a href="#115" data-title="&lt;b&gt;表1 预测错误率统计&lt;/b&gt;"><b>表1 预测错误率统计</b></a></li>
                                                <li><a href="#123" data-title="&lt;b&gt;图5 软件运行界面示意图&lt;/b&gt;"><b>图5 软件运行界面示意图</b></a></li>
                                                <li><a href="#127" data-title="&lt;b&gt;表2 不同算法对多组数据的查询时间对比&lt;/b&gt;"><b>表2 不同算法对多组数据的查询时间对比</b></a></li>
                                                <li><a href="#132" data-title="&lt;b&gt;表3 不同算法渲染速度的对比&lt;/b&gt;"><b>表3 不同算法渲染速度的对比</b></a></li>
                                                <li><a href="#133" data-title="&lt;b&gt;表4 本文算法渲染速度提高的百分比&lt;/b&gt;"><b>表4 本文算法渲染速度提高的百分比</b></a></li>
                                                <li><a href="#134" data-title="&lt;b&gt;表5 不同算法预测区域正确率的对比&lt;/b&gt;"><b>表5 不同算法预测区域正确率的对比</b></a></li>
                                                <li><a href="#135" data-title="&lt;b&gt;表6 本文算法预测正确度提高的百分比&lt;/b&gt;"><b>表6 本文算法预测正确度提高的百分比</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="151">


                                    <a id="bibliography_1" title=" 冯莎, 卢选民, 陶旺林, 等.基于高斯金字塔的海量超大图像快速漫游算法[J].计算机应用研究, 2012, 29 (3) :1141-1142." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSYJ201203094&amp;v=MjUzNjZPZVplUnFGeS9nVUx2TUx6N1NaTEc0SDlQTXJJOU1ZSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkw=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         冯莎, 卢选民, 陶旺林, 等.基于高斯金字塔的海量超大图像快速漫游算法[J].计算机应用研究, 2012, 29 (3) :1141-1142.
                                    </a>
                                </li>
                                <li id="153">


                                    <a id="bibliography_2" title=" 撖志恒, 芮小平, 宋现锋, 等.利用双重索引快速构建道路网络连通拓扑[J].地球信息科学学报, 2013, 15 (4) :498-504." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DQXX201304005&amp;v=MDcwMDJDVVJMT2VaZVJxRnkvZ1VMdk1JVHpUZHJHNEg5TE1xNDlGWVlRS0RIODR2UjRUNmo1NE8zenFxQnRHRnI=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         撖志恒, 芮小平, 宋现锋, 等.利用双重索引快速构建道路网络连通拓扑[J].地球信息科学学报, 2013, 15 (4) :498-504.
                                    </a>
                                </li>
                                <li id="155">


                                    <a id="bibliography_3" title=" ROUSSOPOULOS N, LEIFKER D.Direct spatial search on pictorial databases using packed R-trees[J].ACM SIGMOD Record, 1985, 14 (4) :17-31." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000067724&amp;v=MTYzMTB2SUoxc1hiaFk9TmlmSVk3SzdIdGpOcjQ5RlpPMElDMzQ5b0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VTA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         ROUSSOPOULOS N, LEIFKER D.Direct spatial search on pictorial databases using packed R-trees[J].ACM SIGMOD Record, 1985, 14 (4) :17-31.
                                    </a>
                                </li>
                                <li id="157">


                                    <a id="bibliography_4" title=" DU Qinsheng, LI Xiaongfei.Efficient k-nearest neighbor join algorithms for high dimensional sparse data[J].Journal of Computational Information Systems, 2014, 5:925-932." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient k-nearest neighbor join algorithms for high dimensional sparse data">
                                        <b>[4]</b>
                                         DU Qinsheng, LI Xiaongfei.Efficient k-nearest neighbor join algorithms for high dimensional sparse data[J].Journal of Computational Information Systems, 2014, 5:925-932.
                                    </a>
                                </li>
                                <li id="159">


                                    <a id="bibliography_5" title=" 吕闽晖, 吕敏蓉.基于R树的空间查询连接处理优化与实现[J].微型机与应用, 2011, 30 (13) :66-68." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXJY201113023&amp;v=MDQ4ODY0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVScUZ5L2dVTHZNTWpYQmQ3RzRIOUROckk5SFo0UUtESDg0dlI=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         吕闽晖, 吕敏蓉.基于R树的空间查询连接处理优化与实现[J].微型机与应用, 2011, 30 (13) :66-68.
                                    </a>
                                </li>
                                <li id="161">


                                    <a id="bibliography_6" title=" 石源, 莫蓉, 常智勇, 等.基于聚类的模型数据集可视化与检索[J].计算机辅助设计与图形学学报, 2010, 22 (11) :1918-1924." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJF201011012&amp;v=MDgxMzdCdEdGckNVUkxPZVplUnFGeS9nVUx2TUx6N0JhTEc0SDlITnJvOUVab1FLREg4NHZSNFQ2ajU0TzN6cXE=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         石源, 莫蓉, 常智勇, 等.基于聚类的模型数据集可视化与检索[J].计算机辅助设计与图形学学报, 2010, 22 (11) :1918-1924.
                                    </a>
                                </li>
                                <li id="163">


                                    <a id="bibliography_7" title=" BERRUT J P, TREFETHEN L N.Barycentric Lagrange interpolation[J].SIAM Review, 2004, 46 (3) :501-517." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJST&amp;filename=SJST14120403053788&amp;v=MTk2MjNHZXJxUVRNbndaZVp1SHlqbVVMdklKMXNYYmhZPU5pZlllcks4SDlQTXE0OUdaTzRNQzNReG9CTVQ2VDRQUUgvaXJSZA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                         BERRUT J P, TREFETHEN L N.Barycentric Lagrange interpolation[J].SIAM Review, 2004, 46 (3) :501-517.
                                    </a>
                                </li>
                                <li id="165">


                                    <a id="bibliography_8" title=" RACK H J, VAJDA R.On optimal quadratic Lagrange interpolation:extremal node systems with minimal lebesgue constant via symbolic computation[J].Publications of the Research Institute for Mathematical Sciences, 2014, 30:111-138." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On optimal quadratic Lagrange interpolation:extremal node systems with minimal lebesgue constant via symbolic computation">
                                        <b>[8]</b>
                                         RACK H J, VAJDA R.On optimal quadratic Lagrange interpolation:extremal node systems with minimal lebesgue constant via symbolic computation[J].Publications of the Research Institute for Mathematical Sciences, 2014, 30:111-138.
                                    </a>
                                </li>
                                <li id="167">


                                    <a id="bibliography_9" title=" 汪璟玢.一种结合空间聚类算法的R树优化算法[J].计算机工程与应用, 2014, 50 (5) :112-115." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSGG201405025&amp;v=MjIyMzVxcUJ0R0ZyQ1VSTE9lWmVScUZ5L2dVTHZNTHo3TWFiRzRIOVhNcW85SFlZUUtESDg0dlI0VDZqNTRPM3o=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[9]</b>
                                         汪璟玢.一种结合空间聚类算法的R树优化算法[J].计算机工程与应用, 2014, 50 (5) :112-115.
                                    </a>
                                </li>
                                <li id="169">


                                    <a id="bibliography_10" title=" CHENG Dongdong, ZHU Qingsheng, HUANG Jinlong, et al.Natural neighbor-based clustering algorithm with local representatives[J].Knowledge-Based Systems, 2017, 123 (C) :238-253." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJESE61CAAF17318017B7DB22225AC99E873&amp;v=MTA0NDNjQ09OdkZTaVdXcjdKSUZwbWFCdUhZZk9HUWxmQ3BiUTM1TnhodzcyOHhLdz1OaWZPZmNhK0g2SzkzdmxFWStnT0JIdzR5R1FVbmsxL1NuM2dxV05HY0x2aFRiMg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                         CHENG Dongdong, ZHU Qingsheng, HUANG Jinlong, et al.Natural neighbor-based clustering algorithm with local representatives[J].Knowledge-Based Systems, 2017, 123 (C) :238-253.
                                    </a>
                                </li>
                                <li id="171">


                                    <a id="bibliography_11" title=" SONG LI, CUI Huanyu, ZHANG Liping, et al.Static R-tree building method based on cure clustering algorithm[J].Computer Science, 2015, 42 (10) :193-197." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201510040&amp;v=MTQ0Njk5VE5yNDlCWklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJxRnkvZ1VMdk1MejdCYjdHNEg=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                         SONG LI, CUI Huanyu, ZHANG Liping, et al.Static R-tree building method based on cure clustering algorithm[J].Computer Science, 2015, 42 (10) :193-197.
                                    </a>
                                </li>
                                <li id="173">


                                    <a id="bibliography_12" title=" CAPO M, PEREZ A, LOZANO J A.An efficient approximation to the K-means clustering for massive data[J].Knowledge-Based Systems, 2017, 117:56-69." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An efficient approximation to the K-means clustering for massive data">
                                        <b>[12]</b>
                                         CAPO M, PEREZ A, LOZANO J A.An efficient approximation to the K-means clustering for massive data[J].Knowledge-Based Systems, 2017, 117:56-69.
                                    </a>
                                </li>
                                <li id="175">


                                    <a id="bibliography_13" title=" HAN Xuli.Piecewise trigonometric Hermite interpolation[J].Applied Mathematics and Computation, 2015, 268 (C) :616-627." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES15122300093266&amp;v=MTMwOTNSZEdlcnFRVE1ud1plWnVIeWptVUx2SUoxc1hiaFk9TmlmT2ZiSzlIOVBPckk5RlpPSU1Ebm8vb0JNVDZUNFBRSC9pcg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                         HAN Xuli.Piecewise trigonometric Hermite interpolation[J].Applied Mathematics and Computation, 2015, 268 (C) :616-627.
                                    </a>
                                </li>
                                <li id="177">


                                    <a id="bibliography_14" title=" BIEDL T, THIELE T, WOOD D R.Three-dimensional orthogonal graph drawing with optimal volume[J].Algorithmica, 2006, 44 (3) :233-255." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD15103100101876&amp;v=MjIxNTh2SUoxc1hiaFk9Tmo3QmFySzlIOUhQcm85Rlplc09CSHMvb0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VTA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[14]</b>
                                         BIEDL T, THIELE T, WOOD D R.Three-dimensional orthogonal graph drawing with optimal volume[J].Algorithmica, 2006, 44 (3) :233-255.
                                    </a>
                                </li>
                                <li id="179">


                                    <a id="bibliography_15" title=" CAPOBIANCO M R, CRISUUOLO G.Weighted Lagrange interpolation with preassigned nodes on the real line[M].[S.1.]:Elsevier Science Publishers, 2014:124-132." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES14032300082189&amp;v=MTY0ODJNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VTHZJSjFzWGJoWT1OaWZPZmJLOEh0TE9ySTlGWk9NTkRYUXdvQg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                         CAPOBIANCO M R, CRISUUOLO G.Weighted Lagrange interpolation with preassigned nodes on the real line[M].[S.1.]:Elsevier Science Publishers, 2014:124-132.
                                    </a>
                                </li>
                                <li id="181">


                                    <a id="bibliography_16" title=" BERRIOCHOA E, CACHAFEIRO A, AMOR J M G.An interpolation problem on the circle between Lagrange and Hermite problems[J].Journal of Approximation Theory, 2017, 215:118-144." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES9CB758487863F57DE00498704FB1C6FD&amp;v=MDczOTlEQzdQblE4enJDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVOeGh3NzI4eEt3PU5pZk9mYnJMYk5iSnA0dE5ZK01KRHdvOHlHSm02ajk1UVhmbHJCWg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                         BERRIOCHOA E, CACHAFEIRO A, AMOR J M G.An interpolation problem on the circle between Lagrange and Hermite problems[J].Journal of Approximation Theory, 2017, 215:118-144.
                                    </a>
                                </li>
                                <li id="183">


                                    <a id="bibliography_17" title=" GONG Kangyi, XIE Kai, HU Yu, et al.Out-of-core data fast display method based on the viewpoint movement research[J].Bulletin of Science and Technology, 2017, 33 (9) :215-225." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=KJTB201709020&amp;v=MTQwMjNVUkxPZVplUnFGeS9nVUx2TUxpZmZiTEc0SDliTXBvOUhaSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckM=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                         GONG Kangyi, XIE Kai, HU Yu, et al.Out-of-core data fast display method based on the viewpoint movement research[J].Bulletin of Science and Technology, 2017, 33 (9) :215-225.
                                    </a>
                                </li>
                                <li id="185">


                                    <a id="bibliography_18" title=" XIE K, WU P, YANG S.GPU and CPU cooperation parallel visualization for large seismic data[J].Electronics Letters, 2010, 46 (17) :1196-1197." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=GPU and CPU cooperation parallel visualisation for large seismic data">
                                        <b>[18]</b>
                                         XIE K, WU P, YANG S.GPU and CPU cooperation parallel visualization for large seismic data[J].Electronics Letters, 2010, 46 (17) :1196-1197.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(08),53-59 DOI:10.19678/j.issn.1000-3428.0052493            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于智能聚类模型的海量数据快速显示方法</b></span>
 <span class="shoufa"></span>                                     </h1>

                <div class="btn-downloads  btn-downloads-new">

                        <a class="read read-btn-special" target="_blank" href=http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908010&amp;filesourcetype=1><i class="i-btn i-care"></i>精读</a>
                    <div class="read-btn-l">
                        <a class="caj" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=XVTUPl3RORTOyE1NEZHZYlHShZFNPl3azo0Z0gWOn9WMvZ3VLtSbwpkaRJ3Q3NVQx4EbvxmTY5US3R2Q4MUVEhWV44marMlSPV0LSR0MuZmSCh2NYhWT3Z2UjVGTJ9mW2onQHJmdCFld3M0ViNHNYZzLrNlezR3a&tablename=CJFDLAST2019"><i class="i-btn i-caj"></i> CAJ下载</a>
                        <a class="pdf" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=XVTUPl3RORTOyE1NEZHZYlHShZFNPl3azo0Z0gWOn9WMvZ3VLtSbwpkaRJ3Q3NVQx4EbvxmTY5US3R2Q4MUVEhWV44marMlSPV0LSR0MuZmSCh2NYhWT3Z2UjVGTJ9mW2onQHJmdCFld3M0ViNHNYZzLrNlezR3a&tablename=CJFDLAST2019&dflag=pdfdown"><i class="i-btn i-pdf"></i>PDF下载</a>

                        <p>永久保存本文,请下载至本地</p>
                    </div>

                </div>
            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%94%90%E9%B8%BF%E6%88%90&amp;code=40587912&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">唐鸿成</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%96%87%E7%95%85&amp;code=11192061&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">文畅</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%86%AF%E6%96%87%E7%A5%A5&amp;code=37988087&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">冯文祥</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%B0%A2%E5%87%AF&amp;code=24384852&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">谢凯</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%96%B9%E6%96%87%E9%9D%92&amp;code=42444617&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">方文青</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E9%95%BF%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A2&amp;code=0112354&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">长江大学计算机科学学院</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E9%95%BF%E6%B1%9F%E5%A4%A7%E5%AD%A6%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%99%A2&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">长江大学电子信息学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>为实时显示三维数据体的海量数据, 提出一种改进的海量数据快速显示算法。利用CURE聚类算法对数据进行整理, 通过Hilbert R-tree对数据建立索引, 根据可视化区域预测模型预测下一时刻的可视区域, 以实现大量数据的快速可视化。实验结果表明, 与基于视点运动的快速显示算法和基于可见性判断的可视化算法相比, 该算法在不降低渲染质量的前提下, 渲染速度分别提高18.27%和67.06%, 预测区域错误率分别降低9.73%和22.37%, 能够快速加载数据并且准确绘制大量三维数据体。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">海量数据;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9R%E6%A0%91&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">希尔伯特R树;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">预测模型;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">聚类算法;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%A2%84%E5%8A%A0%E8%BD%BD%E7%AE%97%E6%B3%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">预加载算法;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    唐鸿成 (1997—) , 男, 硕士研究生, 主研方向为大数据技术、三维建模、图形图像处理;;
                                </span>
                                <span>
                                    *文畅 (通信作者) , 讲师、硕士;E-mail: wenchang2016paper@ 163. com;
                                </span>
                                <span>
                                    冯文祥, 硕士研究生;;
                                </span>
                                <span>
                                    谢凯, 教授、博士;;
                                </span>
                                <span>
                                    方文青, 讲师、博士。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-08-27</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金 (61701046);</span>
                    </p>
            </div>
                    <h1><b>Rapid Display Method of Massive Data Based on Intelligent Clustering Model</b></h1>
                    <h2>
                    <span>TANG Hongcheng</span>
                    <span>WEN Chang</span>
                    <span>FENG Wenxiang</span>
                    <span>XIE Kai</span>
                    <span>FANG Wenqing</span>
            </h2>
                    <h2>
                    <span>School of Computer Science, Yangtze University</span>
                    <span>School of Electronic Information, Yangtze University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>In order to display three-dimensional massive data in real time, this paper proposes an improved rapid display algorithm for massive data.The CURE clustering algorithm is used to sort the data, and the data is indexed by Hilbert R-tree.The visual area prediction model predicts the next time visible area to realize rapid visualization of large amounts of data.Experimental results show that compared with the Visualization algorithm based on Motion of Viewpoint (VMV) and the Visualization algorithm based on Testing of Visibility (VTV) , the rendering speed is 18.27% higher than the VMV algorithm without reducing the rendering quality.Compared with the VTV algorithm, the increase is 67.06%, the prediction area error rate is reduced by 9.73% compared with the VMV algorithm, and the VTV algorithm is reduced by 22.37%, which can quickly load data and accurately draw three-dimensional large data volume.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=massive%20data&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">massive data;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Hilbert%20R-tree&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Hilbert R-tree;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=forecasting%20model&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">forecasting model;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=clustering%20algorithm&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">clustering algorithm;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=load%20in%20advance%20algorithm&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">load in advance algorithm;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-08-27</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="39" name="39" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="40">三维可视化技术对于医学、遥感、地质勘探等方面的研究人员来讲是一种可直观分析数据的有效手段, 能够对数据作出快速且准确的判断。然而, 随着数据采集技术的不断提高, CPU已经不能满足对数据处理的需求, 尽管GPU的出现缓解了CPU在处理3D几何运算时的压力, 但是GPU受到显存大小的限制, 不能直接处理超过显存规模的海量数据。因为三维数据体中的数据只有一部分是有意义的或可见的, 所以在显示过程中仅需对部分可视区域数据进行绘制, 这就有可能实现海量数据的快速可视化。</p>
                </div>
                <div class="p1">
                    <p id="41">为实时显示三维的海量数据, 目前使用较多的方案包括:基于金字塔模型的数据分配方案<citation id="187" type="reference"><link href="151" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation> (划分三维数据体, 在显示期间根据请求调用子块) , 数据压缩方案 (减少三维数据体的数据量) 等, 这些方案旨在不降低渲染质量的前提下, 减少加载到内存中的数据量, 但不能有效提高数据交互速度。另外一些采用空间索引技术 (如R树、Hilbert R-tree<citation id="188" type="reference"><link href="153" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>) 以提高查询速度的算法有以下缺点:在R树空间索引中, 空间对象和每个层节点由最小包围盒表示, 数据矩形的重叠不可避免地会影响查询的效率, Hilbert R-tree虽然能够获得近100%的存储利用率<citation id="189" type="reference"><link href="155" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>, 但节点空间过大, 当空间数据分布不均匀时, 重叠增加, 检索性能随之明显下降, 无法达到实时显示海量三维数据的目的<citation id="191" type="reference"><link href="157" rel="bibliography" /><link href="159" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>]</sup></citation>, 聚类模型在数据可视化的应用<citation id="190" type="reference"><link href="161" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>虽然能够较好地提高检索效率, 但是存储利用率较低。</p>
                </div>
                <div class="p1">
                    <p id="42">针对上述方法中存在的问题, 本文提出一种智能聚类模型下的海量数据快速显示算法。该算法对数据进行聚类, 采用Hilbert R-tree构建索引, 提高查询效率。在此基础上, 通过建立可视化区域预测模型进行数据的预加载, 并运用基于分段二次重心Lagrange插值的视点运动预测算法, 在降低运算复杂度的同时减小预测错误率, 以提高数据交互的效率和质量。</p>
                </div>
                <h3 id="43" name="43" class="anchor-tag">1 聚类模型的三维数据可视化算法流程</h3>
                <div class="p1">
                    <p id="44">基于可视化区域预测的海量三维数据实时绘制方法主要由2个部分构成:基于CURE聚类的Hilbert R-tree索引和基于分段二次拉格朗日插值<citation id="192" type="reference"><link href="163" rel="bibliography" /><link href="165" rel="bibliography" /><sup>[<a class="sup">7</a>,<a class="sup">8</a>]</sup></citation>的可视化区域预测模型。图1给出算法的具体流程, 该算法首先在CURE聚类的基础上使用Hilbert R-tree对载入数据建立快速索引, 其次结合视点运动速度及位置判断视点是否规则运动, 若视点规则运动, 则结合相应的约束条件, 建立可视化区域预测模型, 将数据划分为可见域、预测域、非加载域, 然后将预测域和可见域数据导入GPU, GPU对可见域数据进行渲染、显示, 随着视点坐标的变化, GPU直接加载位于显存缓存区的预测域中的数据块, 并将非加载域数据块从显存中卸载。如果判断视点不移动或随机移动, 则不执行预预加载操作, 直接将当前视点对应的可视区域导入内存供GPU加载显示。</p>
                </div>
                <div class="area_img" id="45">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908010_045.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 聚类模型的三维数据可视化算法流程" src="Detail/GetImg?filename=images/JSJC201908010_045.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 聚类模型的三维数据可视化算法流程</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908010_045.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="46" name="46" class="anchor-tag">2 基于CURE聚类的三维Hilbert R-tree索引</h3>
                <div class="p1">
                    <p id="47">Hilbert R-tree空间索引性能的关键在于如何提高将相同的空间数据放在同一个子树下, 这是一个常见的聚类问题, 即对不规则空间数据进行分类。根据这一理论, 在构建Hilbert R-tree的过程中如果加入聚类技术<citation id="193" type="reference"><link href="167" rel="bibliography" /><link href="169" rel="bibliography" /><link href="171" rel="bibliography" /><sup>[<a class="sup">9</a>,<a class="sup">10</a>,<a class="sup">11</a>]</sup></citation>, 就可以使Hilbert R-tree的构造更加紧密, 在避免其因为机械式的填充各叶子节点造成重叠问题的同时, 又发挥其接近百分之百的空间利用率, 有效提高了子块查询效率, 从而达到快速索引的目的, 降低了系统显示时间。</p>
                </div>
                <h4 class="anchor-tag" id="48" name="48">2.1 CURE聚类算法</h4>
                <div class="p1">
                    <p id="49">相比于k-means聚类方法<citation id="194" type="reference"><link href="173" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>, CURE聚类算法通过对类的表示方法, 将每一个类中提取指定数量且均匀分散的点作为代表点, 把这些点乘以适当的缩减因子, 使它们更接近类的中间点。用代表点表示类, 使类可以通过非球面拓展来表达。</p>
                </div>
                <div class="p1">
                    <p id="50">CURE聚类算法预处理是将随机取样得到的每个点或者数据集都视为一个聚类, 然后将最近距离的聚类联合, 直到聚类的个数满足指定的<i>k</i>。具体流程如下:</p>
                </div>
                <div class="p1">
                    <p id="51">1) 对于原数据集<i>X</i>={<i>x</i><sub><i>i</i></sub>|<i>i</i>=1, 2, …, <i>m</i>}随机抽取<i>n</i>个样本, <i>S</i>={<i>x</i><sub>0</sub>, <i>x</i><sub>1</sub>, …, <i>x</i><sub><i>n</i>-1</sub>}。这里采用切诺夫边界来确定最小取样数据量:</p>
                </div>
                <div class="p1">
                    <p id="52" class="code-formula">
                        <mathml id="52"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><msub><mrow></mrow><mrow><mi>min</mi></mrow></msub><mo>=</mo><mi>ζ</mi><mi>k</mi><mo>+</mo><mi>k</mi><mtext> </mtext><mrow><mi>log</mi></mrow><msub><mrow></mrow><mi>a</mi></msub><mo stretchy="false"> (</mo><mn>1</mn><mo>/</mo><mi>δ</mi><mo stretchy="false">) </mo><mo>+</mo><msqrt><mrow><mi>log</mi><msub><mrow></mrow><mi>a</mi></msub><mo stretchy="false"> (</mo><mn>1</mn><mo>/</mo><mi>δ</mi><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>ζ</mi><mtext> </mtext><mi>log</mi><msub><mrow></mrow><mi>a</mi></msub><mo stretchy="false"> (</mo><mn>1</mn><mo>/</mo><mi>δ</mi><mo stretchy="false">) </mo></mrow></msqrt><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="53">其中, <i>ζ</i>为最小聚类包含的数据点数, <i>δ</i>为属于聚类的数据点的个数小于<i>n</i>/<i>p</i>的概率。</p>
                </div>
                <div class="p1">
                    <p id="54">2) 将样本<i>S</i>划分为<i>P</i>个分区, 每个分区大小为<i>n</i>/<i>p</i>, 并对每个分区进行聚类直到分区内聚类的个数为<i>n</i>/<i>p</i>×<i>q</i>为止, 取<i>q</i>=1且尽量保证<i>n</i>/<i>p</i>×<i>q</i>是<i>k</i>的2倍～3倍。</p>
                </div>
                <div class="p1">
                    <p id="55">3) 删除离群点 (聚类过程中增长缓慢的聚类) 。</p>
                </div>
                <div class="p1">
                    <p id="56">4) 对于新生成的聚类求取其聚类中心, 用聚类中心代表相应的簇再次进行聚类操作, 并删除第2次聚类过程中离群点。</p>
                </div>
                <div class="p1">
                    <p id="57">5) 通过计算剩余数据距离各个聚类中心的距离, 将各数据归到与其距离最近的聚类中, 从而实现全局聚类。</p>
                </div>
                <h4 class="anchor-tag" id="58" name="58">2.2 基于CURE聚类Hilbert R-tree索引的构建</h4>
                <div class="p1">
                    <p id="59">结合CURE聚类的Hilbert R-tree构建算法步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="60"><b>步骤1</b> 构建三维Hilbert空间填充曲线。</p>
                </div>
                <div class="p1">
                    <p id="61"><b>步骤2</b> 从空间集<i>S</i>中取<i>n</i>个样本的数据对象, <i>n</i>的取值如式 (1) 所示, 计算每个对象的最小包围盒 (MBB) 边界坐标及其中心点坐标。</p>
                </div>
                <div class="p1">
                    <p id="62"><b>步骤3</b> 将这<i>n</i>个数据对象划分为<i>P</i>个分区, 对每个分区执行聚类操作。</p>
                </div>
                <div class="p1">
                    <p id="63"><b>步骤4</b> 删除第1次聚类过程中的离群点后, 在新生成的簇上执行聚类操作, 然后移除第二聚类过程中的异常点, 并获得最终的聚类结果。</p>
                </div>
                <div class="p1">
                    <p id="64"><b>步骤5</b> 计算剩余MBB的中心与每个现有聚类中心之间的距离, 并按距离最近准则将剩余数据合并到相应的聚类中, 完成全局的聚类操作。</p>
                </div>
                <div class="p1">
                    <p id="65"><b>步骤6</b> 对各聚类按其聚类中心的Hilbert码值进行升序排列, 当聚类中的数据量小于等于Hilbert R-tree节点的最大容量时, 则将其构成一个叶节点, 否则将聚类中的对象按Hilbert码值进行升序排列, 顺序构成若干个叶节点。最后按生成叶节点的时间顺序自下而上构成各层的中间节点和根节点, 最终生成一棵高效的Hilbert R-tree。</p>
                </div>
                <div class="p1">
                    <p id="66">具体的聚类操作方法如下:</p>
                </div>
                <div class="p1">
                    <p id="67">1) 将每个对象看作一个独立的聚类, 该聚类的中心点就是对应MBB的中心点, 设为<i>center Mi</i> (<i>a</i><sub><i>i</i></sub>, <i>b</i><sub><i>i</i></sub>, <i>c</i><sub><i>i</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="68">2) 依次计算两两MBB之间的距离:</p>
                </div>
                <div class="p1">
                    <p id="69" class="code-formula">
                        <mathml id="69"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>h</mi><mo>=</mo><msqrt><mrow><mo stretchy="false"> (</mo><mi>a</mi><msub><mrow></mrow><mn>1</mn></msub><mo>-</mo><mi>a</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mo stretchy="false"> (</mo><mi>b</mi><msub><mrow></mrow><mn>1</mn></msub><mo>-</mo><mi>b</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mo stretchy="false"> (</mo><mi>c</mi><msub><mrow></mrow><mn>1</mn></msub><mo>-</mo><mi>c</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msqrt><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="70">其中, 最短距离<i>h</i>=<i>h</i><sub>min</sub>。</p>
                </div>
                <div class="p1">
                    <p id="71">3) 如果2个MBB之间的距离<i>h</i>小于等于<i>h</i><sub>min</sub>, 则将其对应数据对象合并为一个聚类。</p>
                </div>
                <div class="p1">
                    <p id="72">4) 如果该合成聚类的数据量达到Hilbert R-tree节点的最大容量, 则结束该聚类并返回步骤2, 否则以其新的聚类中心作为中心点计算该聚类与其他聚类之间的距离, 如果距离小于等于<i>h</i><sub>min</sub>, 则将它们再进行合并。重复这一步骤直至在该分区完成聚类。</p>
                </div>
                <div class="p1">
                    <p id="73">在聚类过程中, 由于参加聚类的数据对象的形式不同, 在计算新聚类的聚类中心时会出现以下3种情况:</p>
                </div>
                <div class="p1">
                    <p id="74">1) 聚类对象包含<i>n</i>个数据点对象, 这时聚类中心定义为:</p>
                </div>
                <div class="p1">
                    <p id="75" class="code-formula">
                        <mathml id="75"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext> </mtext><mi>R</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mo stretchy="false"> (</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>x</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo>/</mo><mi>n</mi><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>y</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo>/</mo><mi>n</mi><mo>, </mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>z</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo>/</mo><mi>n</mi><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="76">其中, <i>x</i><sub><i>j</i></sub>、<i>y</i><sub><i>j</i></sub>、<i>z</i><sub><i>j</i></sub>分别为聚类对象的三维坐标值。</p>
                </div>
                <div class="p1">
                    <p id="77">2) 聚类对象包含<i>m</i>个线、面对象 (由若干点对象经过一次聚类合成的聚类对象) , 这时聚类中心定义为:</p>
                </div>
                <div class="p1">
                    <p id="78" class="code-formula">
                        <mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mtext> </mtext><mtext> </mtext><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext> </mtext><mi>R</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mrow><mo> (</mo><mrow><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mfrac><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mo>_</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>a</mi><mi>r</mi><mi>d</mi><mo>_</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mn>2</mn></mfrac></mrow></mstyle><mo>×</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>V</mi></mstyle><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>, </mo><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mfrac><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mo>_</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>a</mi><mi>r</mi><mi>d</mi><mo>_</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mn>2</mn></mfrac></mrow></mstyle><mo>×</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>V</mi></mstyle><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>, </mo><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mfrac><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mo>_</mo><mi>z</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>a</mi><mi>r</mi><mi>d</mi><mo>_</mo><mi>z</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mn>2</mn></mfrac></mrow></mstyle><mo>×</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>V</mi></mstyle><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></mfrac></mrow><mo>) </mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="79">其中, <i>blu</i>_<i>x</i> (<i>yz</i>) <sub><i>i</i></sub>为第<i>i</i>个对象对应MBB的正面左上角坐标值, <i>ard</i>_<i>x</i> (<i>yz</i>) <sub><i>i</i></sub>为第<i>i</i>个对象对应MBB的后面左下角坐标值, <i>V</i> (<i>R</i><sub><i>i</i></sub>) 是第<i>i</i>个对象对应MBB的体积。</p>
                </div>
                <div class="p1">
                    <p id="80">3) 聚类对象包含<i>n</i>个点对象和<i>m</i>个线、面对象, 这时聚类中心定义为:</p>
                </div>
                <div class="p1">
                    <p id="81" class="code-formula">
                        <mathml id="81"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mtext> </mtext><mtext> </mtext><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext> </mtext><mi>R</mi><msub><mrow></mrow><mn>3</mn></msub><mo>=</mo><mrow><mo> (</mo><mrow><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>x</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo>+</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mrow><mfrac><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mo>_</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>a</mi><mi>r</mi><mi>d</mi><mo>_</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mn>2</mn></mfrac></mrow></mstyle><mo>×</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>V</mi></mstyle><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>, </mo><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>y</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo>+</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mrow><mfrac><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mo>_</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>a</mi><mi>r</mi><mi>d</mi><mo>_</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mn>2</mn></mfrac></mrow></mstyle><mo>×</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>V</mi></mstyle><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>, </mo><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>z</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo>+</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mrow><mfrac><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mo>_</mo><mi>z</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>a</mi><mi>r</mi><mi>d</mi><mo>_</mo><mi>z</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mn>2</mn></mfrac></mrow></mstyle><mo>×</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>V</mi></mstyle><mo stretchy="false"> (</mo><mi>R</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></mfrac></mrow><mo>) </mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>5</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="82">由图2可以看出, 原始方法构建的Hilbert R-tree会机械式填充叶结点, 其结果就是导致空间重叠, 进而影响查询效率, 而采用基于CURE聚类的方法构建Hilbert R-tree索引使得空间分配更加合理, 减少了空间重叠的情况, 从而有效地降低了访问磁盘的I/O次数, 提高了查询效率。</p>
                </div>
                <div class="area_img" id="83">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908010_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 基于CURE聚类的三维Hilbert R-tree" src="Detail/GetImg?filename=images/JSJC201908010_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 基于CURE聚类的三维Hilbert R-tree</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908010_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="84" name="84" class="anchor-tag">3 数据预加载算法</h3>
                <div class="p1">
                    <p id="85">对于大型三维数据, 其最基本的用途就是供用户对海量数据进行有目的的选取浏览, 因此, 在计算机中显示的数据只是整体数据的一部分。当用户对三维数据进行浏览时, 若浏览方式是规律的, 则可以通过预测下次视点坐标来对预测区域数据进行预加载, 以实现流畅显示海量三维数据的目的。针对这一特点, 本文提出一种基于可视化区域预测模型的数据预加载方法, 以提高海量三维数据显示的质量和效率, 算法流程如图3所示。</p>
                </div>
                <div class="area_img" id="86">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908010_086.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 数据预加载算法流程" src="Detail/GetImg?filename=images/JSJC201908010_086.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 数据预加载算法流程</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908010_086.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="87">该模型将数据体划分为可见域、预测域和非加载域。定义当前视点的视角内数据为可见域数据块, 直接导入显存中的缓存区进行渲染显示;通过分段二次重心拉格朗日插值结合外插步长推算下一时刻视点坐标, 并将其视角内除可见域数据以外的数据块定义为预测域, 载入内存, 待视点坐标变化时供GPU加载显示, 随着视点的移动, 已经显示过的区域定义为非加载域。区域划分随视点运动而变化, 实时预加载下一时刻可能出现的区域数据, 能够有效地减少加载数据时卡顿的现象。</p>
                </div>
                <div class="p1">
                    <p id="88">数据划分方法如图4所示, 当视点从A移动到B时, 此模型会动态地将所有数据块划分为可见域、预测域和非加载域。可见域是此刻视点中的数据 (区域1、2) , 需要即刻显示供用户浏览的区域;预测域是预测下一时刻的区域 (区域2、3) , 该区域的数据块必须预先加载到存储器中以供后续显示;非加载域是预测域与可见域的重叠部分 (区域2) , 在GPU加载预测域的同时, 卸载位于非加载域的数据。</p>
                </div>
                <div class="area_img" id="89">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908010_089.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 数据划分示意图" src="Detail/GetImg?filename=images/JSJC201908010_089.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 数据划分示意图</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908010_089.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="90" name="90">3.1 视点预测算法</h4>
                <div class="p1">
                    <p id="91">常用于视点轨迹预测的插值算法包括分段线性插值、文献<citation id="195" type="reference">[<a class="sup">13</a>]</citation>提出的分段Hermite插值和文献<citation id="196" type="reference">[<a class="sup">14</a>]</citation>提出的基于外插步长的Lagrange插值等, 但是由于分段线性插值法在结点处不光滑、Hermite插值需要的一阶倒数信息在实际应用中很难获取、Lagrange插值在高次情况下会产生Runge现象 (用高阶多项式进行多项式插值时区间边缘会出现误差无穷大的现象) , 因此这些方法都不是十分实用<citation id="197" type="reference"><link href="179" rel="bibliography" /><link href="181" rel="bibliography" /><sup>[<a class="sup">15</a>,<a class="sup">16</a>]</sup></citation>。为解决上述问题, 本文提出分段二次重心拉格朗日插值算法。</p>
                </div>
                <div class="p1">
                    <p id="92">以<i>X</i>方向为例, 首先给出重心拉格朗日插值公式:</p>
                </div>
                <div class="p1">
                    <p id="93" class="code-formula">
                        <mathml id="93"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mi>a</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext> </mtext><mi>L</mi><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><mrow><mfrac><mrow><mi>w</mi><msub><mrow></mrow><mi>j</mi></msub></mrow><mrow><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></mfrac></mrow></mstyle><mi>x</mi><msub><mrow></mrow><mi>j</mi></msub><mo>/</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>k</mi></munderover><mrow><mfrac><mrow><mi>w</mi><msub><mrow></mrow><mi>j</mi></msub></mrow><mrow><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></mfrac></mrow></mstyle><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>6</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="94">其中, <i>x</i><sub><i>j</i></sub>表示<i>t</i><sub><i>j</i></sub>时刻视点的<i>X</i>轴坐标值, <i>W</i><sub><i>j</i></sub>定义为重心权。</p>
                </div>
                <div class="p1">
                    <p id="95" class="code-formula">
                        <mathml id="95"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>w</mi><msub><mrow></mrow><mi>j</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn><mo>, </mo><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><mi>k</mi></munderover><mo stretchy="false"> (</mo></mstyle><mi>t</mi><msub><mrow></mrow><mi>j</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>7</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="96">重心拉格朗日插值相比于传统Lagrange插值, 在插值点增大或减小时, 不需要重新计算其基本多项式, 算法复杂度降低了一个量级, 因此, 能够提高在大数据环境下预测视点坐标的速度, 但该方法仍然无法解决拉格朗日插值算法本身在高次情况下存在Runge现象的问题。因此, 本文将该方法与分段二次插值相结合, 并引入一个外插步长以回避该问题, 从而提高预测准确率。</p>
                </div>
                <div class="p1">
                    <p id="97">对于地震数据, 只选取一个方向观测可得到较好的显示速度, 且满足对大量数据可视化的需求, 所以只选取一个方向进行预测。以<i>X</i>方向为例, 设插值节点为<i>t</i><sub><i>i</i></sub>, 函数值为<i>x</i><sub><i>i</i></sub>, <i>i</i>=0, 1, …, <i>n</i>。任取3个相邻节点<i>t</i><sub><i>k</i></sub><sub>-1</sub>、<i>t</i><sub><i>k</i></sub>、<i>t</i><sub><i>k</i></sub><sub>+1</sub>, 以[<i>t</i><sub><i>k</i></sub><sub>-1</sub>, <i>t</i><sub><i>k</i></sub><sub>+1</sub>]为插值区间, 构造分段二次重心Lagrange插值:</p>
                </div>
                <div class="p1">
                    <p id="98"><i>L</i><mathml id="99"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo></mrow></msubsup></mrow></math></mathml> (<i>x</i>) =<i>BaryCenter L</i><sub><i>k</i>-1</sub> (<i>x</i>) +<i>BaryCenter L</i><sub><i>k</i></sub> (<i>x</i>) +</p>
                </div>
                <div class="p1">
                    <p id="100"><i>BaryCenter L</i><sub><i>k</i>+1</sub> (<i>x</i>) , <i>k</i>=1, 2, …, <i>n</i>-1      (8) </p>
                </div>
                <div class="p1">
                    <p id="101">将式 (6) 代入式 (8) , 得到分段二次重心拉格朗日插值公式:</p>
                </div>
                <div class="p1">
                    <p id="102" class="code-formula">
                        <mathml id="102"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>L</mi><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false"> (</mo><mi>k</mi><mo stretchy="false">) </mo></mrow></msubsup><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>=</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>k</mi></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>k</mi></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>x</mi><msub><mrow></mrow><mi>k</mi></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>k</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>k</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>k</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>k</mi></msub><mo stretchy="false">) </mo></mrow></mfrac></mtd></mtr><mtr><mtd><mi>k</mi><mo>=</mo><mn>1</mn><mo>, </mo><mn>2</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>n</mi><mo>-</mo><mn>1</mn><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>9</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="103">以<i>X</i>轴方向为例, 运用等步长分段二次重心Lagrange插值公式得:</p>
                </div>
                <div class="p1">
                    <p id="104" class="code-formula">
                        <mathml id="104"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>L</mi><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msubsup><mo stretchy="false"> (</mo><mi>x</mi><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>x</mi><msub><mrow></mrow><mi>n</mi></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="105">同理得:</p>
                </div>
                <div class="p1">
                    <p id="106" class="code-formula">
                        <mathml id="106"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>L</mi><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msubsup><mo stretchy="false"> (</mo><mi>y</mi><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>y</mi><msub><mrow></mrow><mi>n</mi></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>L</mi><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false"> (</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msubsup><mo stretchy="false"> (</mo><mi>y</mi><mo stretchy="false">) </mo><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo stretchy="false">) </mo></mrow></mfrac><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>z</mi><msub><mrow></mrow><mi>n</mi></msub><mfrac><mrow><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow><mrow><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mo stretchy="false">) </mo><mo stretchy="false"> (</mo><mi>t</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mi>t</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="107">将<i>t</i>=<i>t</i><sub><i>n</i></sub>+ <i>h</i>代入式 (10) 、式 (11) 、式 (12) 得:</p>
                </div>
                <div class="p1">
                    <p id="108" class="code-formula">
                        <mathml id="108"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mfrac><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mfrac><mrow><mn>3</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mo>-</mo><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>x</mi><msub><mrow></mrow><mi>n</mi></msub><mfrac><mrow><mn>6</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mn>3</mn><mi>x</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mn>3</mn><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>3</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mfrac><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mfrac><mrow><mn>3</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mo>-</mo><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>y</mi><msub><mrow></mrow><mi>n</mi></msub><mfrac><mrow><mn>6</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mn>3</mn><mi>y</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mn>3</mn><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>y</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="109" class="code-formula">
                        <mathml id="109"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mfrac><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mfrac><mrow><mn>3</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mo>-</mo><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>z</mi><msub><mrow></mrow><mi>n</mi></msub><mfrac><mrow><mn>6</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mrow><mn>2</mn><mi>h</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mn>3</mn><mi>z</mi><msub><mrow></mrow><mi>n</mi></msub><mo>-</mo><mn>3</mn><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>z</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>2</mn></mrow></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="110">则预测视点坐标为:</p>
                </div>
                <div class="p1">
                    <p id="111"><i>R</i><sub><i>n</i></sub><sub>+1</sub> (3<i>x</i><sub><i>n</i></sub>-3<i>x</i><sub><i>n</i></sub><sub>-1</sub>+<i>x</i><sub><i>n</i></sub><sub>-2</sub>, 3<i>y</i><sub><i>n</i></sub>-3<i>y</i><sub><i>n</i></sub><sub>-1</sub>+</p>
                </div>
                <div class="p1">
                    <p id="112"><i>y</i><sub><i>n</i></sub><sub>-2</sub>, 3<i>z</i><sub><i>n</i></sub>-3<i>z</i><sub><i>n</i></sub><sub>-1</sub>+<i>z</i><sub><i>n</i></sub><sub>-2</sub>) </p>
                </div>
                <h4 class="anchor-tag" id="113" name="113">3.2 步长的选取及调整</h4>
                <div class="p1">
                    <p id="114">实验中使视点保持匀速运动, 取不同步长, 对预测结果进行统计, 其对应的平均错误率如表1所示。</p>
                </div>
                <div class="area_img" id="115">
                    <p class="img_tit"><b>表1 预测错误率统计</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note">%</p>
                    <table id="115" border="1"><tr><td><br />平均帧速率</td><td>步长为96帧</td><td>步长为48帧</td><td>步长为24帧</td></tr><tr><td><br />10帧</td><td>9.58</td><td>4.93</td><td>4.07</td></tr><tr><td><br />20帧</td><td>17.69</td><td>8.37</td><td>6.96</td></tr><tr><td><br />30帧</td><td>28.28</td><td>13.46</td><td>11.54</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="116">当第<i>i</i>帧的预测视点<i>A</i><sub><i>i</i></sub> (<i>ax</i><sub><i>i</i></sub>, <i>ay</i><sub><i>i</i></sub>, <i>az</i><sub><i>i</i></sub>) 与实际视点<i>R</i><sub><i>i</i></sub> (<i>rx</i><sub><i>i</i></sub>, <i>ry</i><sub><i>i</i></sub>, <i>rz</i><sub><i>i</i></sub>) 的欧式距离<i>h</i><sub><i>i</i></sub>满足式 (16) 时, 认为在该帧对视点坐标的预测是错误的。</p>
                </div>
                <div class="p1">
                    <p id="117" class="code-formula">
                        <mathml id="117"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mrow><mo>|</mo><mrow><mi>h</mi><msub><mrow></mrow><mi>i</mi></msub></mrow><mo>|</mo></mrow><mo>&gt;</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow></munderover><mrow><mfrac><mrow><mrow><mo>|</mo><mrow><mi>h</mi><msub><mrow></mrow><mi>k</mi></msub></mrow><mo>|</mo></mrow></mrow><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></mstyle><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>6</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>h</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><msqrt><mrow><mo stretchy="false"> (</mo><mi>a</mi><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>r</mi><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mo stretchy="false"> (</mo><mi>a</mi><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>r</mi><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup><mo>+</mo><mo stretchy="false"> (</mo><mi>a</mi><mi>z</mi><msub><mrow></mrow><mi>i</mi></msub><mo>-</mo><mi>r</mi><mi>z</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><msup><mrow></mrow><mn>2</mn></msup></mrow></msqrt><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>7</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="118">从表1中可以明显看出, 步长取的越短, 错误率越低, 误差会随着步长增加而增大, 但是步长取的越小则预测范围越小, 因此需要选取适当的步长。影响预测视点错误率的因素除了步长之外, 还包括视点运动速度、帧速率等, 因此通过一定的参数调整步长是保持较低预测错误率的一个可行的方法。</p>
                </div>
                <div class="p1">
                    <p id="119">定义视点的运动速度为<i>V</i> MBB/Δ<i>t</i>, 运动方向与<i>x</i>、<i>y</i>和<i>z</i>轴之间的角度为<i>α</i>、<i>β</i>、<i>γ</i>, 则视点移动的每一帧在<i>X</i>、<i>Y</i>、<i>Z</i>方向上的增量为Δ<i>x</i>=<i>v</i>cos <i>α</i>, Δ<i>y</i>=<i>v</i>cos <i>β</i>, Δ<i>z</i>=<i>v</i>cos <i>γ</i>。以<i>X</i>轴方向为例, 当视点速度增加时, 即Δ<i>x</i><sub><i>n</i></sub>-Δ<i>x</i><sub><i>n</i></sub><sub>-1</sub>&gt;0时, 可以通过减小步长, 提升预测精度, 从而降低预测错误率, 反之则增加步长。步长的增量没有统一的标准, 需结合实际系统进行设定。</p>
                </div>
                <h3 id="120" name="120" class="anchor-tag">4 实验结果与分析</h3>
                <div class="p1">
                    <p id="121">实验中使用的软件配置:Win 10 专业中文版;硬件配置为CPU i7-3537U, 图形处理器为NVIDIA GeForce 840M, 主频 2.0 GHz, 内存大小16 GB, 显存大小2 GB;开发工具为QT5;实现语言为C++, OPENGL, 自主开发的三维地质构造可视化系统。</p>
                </div>
                <div class="p1">
                    <p id="122">本文在三维地质构造可视化系统上进行测试, 如图5所示。测试数据是某油田提供的工作区的三维数据。数据A为754.2 MB (835像素×784像素×302像素) , 数据B为4 786.0 MB (2 225像素×2 136像素×264像素) , 数据C为9 148.8 MB (5 086像素×5 024像素×384像素) , 该数据包含地质的埋深、范围、厚度、顶底界面、延展趋势等信息。</p>
                </div>
                <div class="area_img" id="123">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908010_123.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 软件运行界面示意图" src="Detail/GetImg?filename=images/JSJC201908010_123.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 软件运行界面示意图</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908010_123.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="124" name="124">4.1 Hilbert R-tree索引的结果分析</h4>
                <div class="p1">
                    <p id="125">树的访问效率决定了显示过程中数据索引的性能。对3组数据分别采用Hilbert R-tree (HRT) , 基于<i>k</i>-means聚类的Hilbert R-tree (KHRT) 和基于CURE聚类的Hilbert R-tree (CHRT) 建立索引, 从B、C两组地震数据中选取相同比例的数据块, 分别用3种方法进行多次查询, 多次实现记录平均查询时间。</p>
                </div>
                <div class="p1">
                    <p id="126">B组数据为分布较为均匀的三维体数据, 结合表2可以看出, 基于CURE聚类的Hilbert R-tree相比另外2种方法, 其查询子块的时间降低了10%～30%;而对于分布散乱的C组数据, 结合表2可以看出, 其查询时间相比另外2种算法降低了50%～100%。由实验结果可以看出, 本文提出的子块索引方法对原始数据进行了一次CURE聚类, 使得距离较近的数据对象聚集在一起, 生成相邻的叶子节点并存储在邻近的位置, 从而有效地减少了访问磁盘的I/O次数, 提升了索引速度, 尤其在面对分布散乱的三维数据体时, 其空间检索效率提升更为明显。</p>
                </div>
                <div class="area_img" id="127">
                    <p class="img_tit"><b>表2 不同算法对多组数据的查询时间对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note">s</p>
                    <table id="127" border="1"><tr><td rowspan="2"><br />数据</td><td rowspan="2">算法</td><td colspan="3"><br />查询数据块百分比</td></tr><tr><td><br />2%</td><td>4%</td><td>6%</td></tr><tr><td rowspan="3"><br />数据A</td><td>KHRT</td><td>2.95</td><td>7.20</td><td>11.29</td></tr><tr><td><br />HRT</td><td>2.27</td><td>5.49</td><td>9.06</td></tr><tr><td><br />CHRT</td><td>1.57</td><td>3.67</td><td>5.93</td></tr><tr><td rowspan="3"><br />数据B</td><td>KHRT</td><td>33.17</td><td>84.92</td><td>142.33</td></tr><tr><td><br />HRT</td><td>24.40</td><td>66.85</td><td>109.07</td></tr><tr><td><br />CHRT</td><td>15.72</td><td>41.82</td><td>66.03</td></tr><tr><td rowspan="3"><br />数据C</td><td>KHRT</td><td>66.87</td><td>194.36</td><td>311.98</td></tr><tr><td><br />HRT</td><td>51.44</td><td>148.19</td><td>243.74</td></tr><tr><td><br />CHRT</td><td>28.49</td><td>79.20</td><td>136.33</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="128" name="128">4.2 可视化区域预测模型</h4>
                <div class="p1">
                    <p id="129">渲染过程中的帧率和预加载区域的正确率决定了大型三维数据的交互质量。对3组实验数据分别采用基于可视化区域预测模型的三维可视化算法 (Visualization algorithm based on Forecasting Model of visual area, VFM) 、基于视点运动的快速显示算法 (Visualization algorithm based on Motion of Viewpoint, VMV) <citation id="198" type="reference"><link href="183" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>和基于可见性判断的可视化算法 (Visualization algorithm based on Testing of Visibility, VTV) <citation id="199" type="reference"><link href="185" rel="bibliography" /><sup>[<a class="sup">18</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="130">为了使海量三维数据的流畅显示, 一般要求渲染时帧率保持在24帧以上。从表3可以看出, 在处理数据较小时, VMV算法和VTV算法能够保持较高的帧率, 而面对数据量超过内存大小的数据C时, 上述2种算法的性能急剧下降至24帧以下, 从而导致浏览时出现卡顿现象, 从表4可以看出, 本文提出的VFM算法比VTV算法渲染速度最高提高77%, 比VMV算法最高提高10%, 并且在10G的数据量下, 在渲染时仍能保持26帧的帧率, 能够实现对海量三维数据的流畅显示。</p>
                </div>
                <div class="p1">
                    <p id="131">从表5和表6的结果可以看出, 本文算法比VTV算法预测错误率要低22.37%左右, 比VMV算法错误率要低9.73%左右, 并且当视点处于静止或者跳动状态时, VMV及VTV算法仍然在进行错误视点的预测, 而本文算法在此时已经不进行视点的预测, 减少了系统资源的消耗。</p>
                </div>
                <div class="area_img" id="132">
                    <p class="img_tit"><b>表3 不同算法渲染速度的对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"> (frames·s<sup>-1</sup>) </p>
                    <table id="132" border="1"><tr><td rowspan="2">数据</td><td rowspan="2">算法</td><td colspan="3"><br />次数</td><td rowspan="2">平均</td></tr><tr><td><br />1</td><td>2</td><td>3</td></tr><tr><td rowspan="3"><br />数据A</td><td><br />VTV</td><td>31.79</td><td>33.32</td><td>31.76</td><td>32.29</td></tr><tr><td><br />VMV</td><td>42.28</td><td>40.83</td><td>41.92</td><td>41.68</td></tr><tr><td><br />VFM</td><td>52.36</td><td>51.78</td><td>51.09</td><td>51.74</td></tr><tr><td rowspan="3"><br />数据B</td><td><br />VTV</td><td>29.67</td><td>30.07</td><td>28.89</td><td>29.54</td></tr><tr><td><br />VMV</td><td>40.38</td><td>39.55</td><td>40.26</td><td>40.06</td></tr><tr><td><br />VFM</td><td>49.79</td><td>47.69</td><td>47.53</td><td>48.37</td></tr><tr><td rowspan="3"><br />数据C</td><td><br />VTV</td><td>14.87</td><td>14.34</td><td>15.57</td><td>14.93</td></tr><tr><td><br />VMV</td><td>24.43</td><td>23.39</td><td>23.74</td><td>23.85</td></tr><tr><td><br />VFM</td><td>27.09</td><td>25.83</td><td>26.47</td><td>26.46</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="133">
                    <p class="img_tit"><b>表4 本文算法渲染速度提高的百分比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note">%</p>
                    <table id="133" border="1"><tr><td><br />数据</td><td>渲染速度比例</td><td>平均</td></tr><tr><td rowspan="2"><br />数据A</td><td><br />VFM/VTV</td><td>60.23</td></tr><tr><td><br />VFM/VMV</td><td>23.13</td></tr><tr><td rowspan="2"><br />数据B</td><td><br />VFM/VTV</td><td>63.74</td></tr><tr><td><br />VFM/VMV</td><td>20.74</td></tr><tr><td rowspan="2"><br />数据C</td><td><br />VFM/VTV</td><td>77.22</td></tr><tr><td><br />VFM/VMV</td><td>10.94</td></tr><tr><td rowspan="2"><br />平均</td><td><br />VFM/VTV</td><td>67.06</td></tr><tr><td><br />VFM/VMV</td><td>18.27</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="134">
                    <p class="img_tit"><b>表5 不同算法预测区域正确率的对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note">%</p>
                    <table id="134" border="1"><tr><td rowspan="2"><br />数据</td><td rowspan="2">算法</td><td colspan="3"><br />预测时间</td></tr><tr><td><br />1 min</td><td>5 min</td><td>10 min</td></tr><tr><td rowspan="3"><br />数据A</td><td><br />VTV</td><td>71.23</td><td>60.41</td><td>55.98</td></tr><tr><td><br />VMV</td><td>78.53</td><td>69.44</td><td>65.81</td></tr><tr><td><br />VFM</td><td>89.16</td><td>79.96</td><td>77.57</td></tr><tr><td rowspan="3"><br />数据B</td><td><br />VTV</td><td>65.09</td><td>57.21</td><td>51.03</td></tr><tr><td><br />VMV</td><td>76.49</td><td>67.10</td><td>65.63</td></tr><tr><td><br />VFM</td><td>88.24</td><td>79.41</td><td>73.71</td></tr><tr><td rowspan="3"><br />数据C</td><td><br />VTV</td><td>61.83</td><td>53.51</td><td>50.17</td></tr><tr><td><br />VMV</td><td>73.33</td><td>65.97</td><td>63.66</td></tr><tr><td><br />VFM</td><td>84.55</td><td>76.67</td><td>73.02</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="135">
                    <p class="img_tit"><b>表6 本文算法预测正确度提高的百分比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note">%</p>
                    <table id="135" border="1"><tr><td>数据</td><td>正确度比例</td><td>平均</td></tr><tr><td rowspan="2"><br />数据A</td><td><br />VFM/VTV</td><td>21.59</td></tr><tr><td><br />VFM/VMV</td><td>11.76</td></tr><tr><td rowspan="2"><br />数据B</td><td><br />VFM/VTV</td><td>22.68</td></tr><tr><td><br />VFM/VMV</td><td>8.08</td></tr><tr><td rowspan="2"><br />数据C</td><td><br />VFM/VTV</td><td>22.85</td></tr><tr><td><br />VFM/VMV</td><td>9.36</td></tr><tr><td rowspan="2"><br />平均</td><td><br />VFM/VTV</td><td>22.37</td></tr><tr><td><br />VFM/VMV</td><td>9.73</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h3 id="136" name="136" class="anchor-tag">5 结束语</h3>
                <div class="p1">
                    <p id="137">本文提出海量三维数据实时绘制方法, 运用基于CURE聚类的Hilbert R-tree索引策略对数据进行聚类, 从而构建出一棵高效Hilbert R-tree。实验结果表明, 相比于传统的索引方法, 该方法可避免叶子节点数据重叠的现象, 在显示过程中减少了内存与硬盘之间频繁的I/O操作, 实现提高绘制效率的目标。另外运用视点相关的预加载策略, 采用分段二次重心Lagrange插值算法结合视点运动速度对视点进行预测, 保证选取最优预加载区域, 减小预加载区域的错误率, 完成对海量三维数据快速且精准的显示。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="151">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSYJ201203094&amp;v=MDg4NDVSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnFGeS9nVUx2TUx6N1NaTEc0SDlQTXJJOU1ZSVFLREg4NHY=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 冯莎, 卢选民, 陶旺林, 等.基于高斯金字塔的海量超大图像快速漫游算法[J].计算机应用研究, 2012, 29 (3) :1141-1142.
                            </a>
                        </p>
                        <p id="153">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DQXX201304005&amp;v=MDcxNjI4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnFGeS9nVUx2TUlUelRkckc0SDlMTXE0OUZZWVFLREg=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 撖志恒, 芮小平, 宋现锋, 等.利用双重索引快速构建道路网络连通拓扑[J].地球信息科学学报, 2013, 15 (4) :498-504.
                            </a>
                        </p>
                        <p id="155">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000067724&amp;v=MzI0MjF5am1VTHZJSjFzWGJoWT1OaWZJWTdLN0h0ak5yNDlGWk8wSUMzNDlvQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> ROUSSOPOULOS N, LEIFKER D.Direct spatial search on pictorial databases using packed R-trees[J].ACM SIGMOD Record, 1985, 14 (4) :17-31.
                            </a>
                        </p>
                        <p id="157">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient k-nearest neighbor join algorithms for high dimensional sparse data">

                                <b>[4]</b> DU Qinsheng, LI Xiaongfei.Efficient k-nearest neighbor join algorithms for high dimensional sparse data[J].Journal of Computational Information Systems, 2014, 5:925-932.
                            </a>
                        </p>
                        <p id="159">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXJY201113023&amp;v=MDY3MjFqWEJkN0c0SDlETnJJOUhaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnFGeS9nVUx2TU0=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> 吕闽晖, 吕敏蓉.基于R树的空间查询连接处理优化与实现[J].微型机与应用, 2011, 30 (13) :66-68.
                            </a>
                        </p>
                        <p id="161">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJF201011012&amp;v=MTEwODBGckNVUkxPZVplUnFGeS9nVUx2TUx6N0JhTEc0SDlITnJvOUVab1FLREg4NHZSNFQ2ajU0TzN6cXFCdEc=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> 石源, 莫蓉, 常智勇, 等.基于聚类的模型数据集可视化与检索[J].计算机辅助设计与图形学学报, 2010, 22 (11) :1918-1924.
                            </a>
                        </p>
                        <p id="163">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJST&amp;filename=SJST14120403053788&amp;v=MDAxNDM4SDlQTXE0OUdaTzRNQzNReG9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUx2SUoxc1hiaFk9TmlmWWVySw==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b> BERRUT J P, TREFETHEN L N.Barycentric Lagrange interpolation[J].SIAM Review, 2004, 46 (3) :501-517.
                            </a>
                        </p>
                        <p id="165">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On optimal quadratic Lagrange interpolation:extremal node systems with minimal lebesgue constant via symbolic computation">

                                <b>[8]</b> RACK H J, VAJDA R.On optimal quadratic Lagrange interpolation:extremal node systems with minimal lebesgue constant via symbolic computation[J].Publications of the Research Institute for Mathematical Sciences, 2014, 30:111-138.
                            </a>
                        </p>
                        <p id="167">
                            <a id="bibliography_9" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSGG201405025&amp;v=MDMwMzMzenFxQnRHRnJDVVJMT2VaZVJxRnkvZ1VMdk1MejdNYWJHNEg5WE1xbzlIWVlRS0RIODR2UjRUNmo1NE8=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[9]</b> 汪璟玢.一种结合空间聚类算法的R树优化算法[J].计算机工程与应用, 2014, 50 (5) :112-115.
                            </a>
                        </p>
                        <p id="169">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJESE61CAAF17318017B7DB22225AC99E873&amp;v=MDcxODRINks5M3ZsRVkrZ09CSHc0eUdRVW5rMS9TbjNncVdOR2NMdmhUYjJjQ09OdkZTaVdXcjdKSUZwbWFCdUhZZk9HUWxmQ3BiUTM1TnhodzcyOHhLdz1OaWZPZmNhKw==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b> CHENG Dongdong, ZHU Qingsheng, HUANG Jinlong, et al.Natural neighbor-based clustering algorithm with local representatives[J].Knowledge-Based Systems, 2017, 123 (C) :238-253.
                            </a>
                        </p>
                        <p id="171">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201510040&amp;v=MDY4NzR6cXFCdEdGckNVUkxPZVplUnFGeS9nVUx2TUx6N0JiN0c0SDlUTnI0OUJaSVFLREg4NHZSNFQ2ajU0TzM=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b> SONG LI, CUI Huanyu, ZHANG Liping, et al.Static R-tree building method based on cure clustering algorithm[J].Computer Science, 2015, 42 (10) :193-197.
                            </a>
                        </p>
                        <p id="173">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An efficient approximation to the K-means clustering for massive data">

                                <b>[12]</b> CAPO M, PEREZ A, LOZANO J A.An efficient approximation to the K-means clustering for massive data[J].Knowledge-Based Systems, 2017, 117:56-69.
                            </a>
                        </p>
                        <p id="175">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES15122300093266&amp;v=MzI1NDFSZEdlcnFRVE1ud1plWnVIeWptVUx2SUoxc1hiaFk9TmlmT2ZiSzlIOVBPckk5RlpPSU1Ebm8vb0JNVDZUNFBRSC9pcg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b> HAN Xuli.Piecewise trigonometric Hermite interpolation[J].Applied Mathematics and Computation, 2015, 268 (C) :616-627.
                            </a>
                        </p>
                        <p id="177">
                            <a id="bibliography_14" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD15103100101876&amp;v=MDkxMTZhcks5SDlIUHJvOUZaZXNPQkhzL29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUx2SUoxc1hiaFk9Tmo3Qg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[14]</b> BIEDL T, THIELE T, WOOD D R.Three-dimensional orthogonal graph drawing with optimal volume[J].Algorithmica, 2006, 44 (3) :233-255.
                            </a>
                        </p>
                        <p id="179">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES14032300082189&amp;v=MTA0MjZRd29CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUx2SUoxc1hiaFk9TmlmT2ZiSzhIdExPckk5RlpPTU5EWA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b> CAPOBIANCO M R, CRISUUOLO G.Weighted Lagrange interpolation with preassigned nodes on the real line[M].[S.1.]:Elsevier Science Publishers, 2014:124-132.
                            </a>
                        </p>
                        <p id="181">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES9CB758487863F57DE00498704FB1C6FD&amp;v=MjAwMzB1SFlmT0dRbGZDcGJRMzVOeGh3NzI4eEt3PU5pZk9mYnJMYk5iSnA0dE5ZK01KRHdvOHlHSm02ajk1UVhmbHJCWkRDN1BuUTh6ckNPTnZGU2lXV3I3SklGcG1hQg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b> BERRIOCHOA E, CACHAFEIRO A, AMOR J M G.An interpolation problem on the circle between Lagrange and Hermite problems[J].Journal of Approximation Theory, 2017, 215:118-144.
                            </a>
                        </p>
                        <p id="183">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=KJTB201709020&amp;v=MjI3OTJGeS9nVUx2TUxpZmZiTEc0SDliTXBvOUhaSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnE=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b> GONG Kangyi, XIE Kai, HU Yu, et al.Out-of-core data fast display method based on the viewpoint movement research[J].Bulletin of Science and Technology, 2017, 33 (9) :215-225.
                            </a>
                        </p>
                        <p id="185">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=GPU and CPU cooperation parallel visualisation for large seismic data">

                                <b>[18]</b> XIE K, WU P, YANG S.GPU and CPU cooperation parallel visualization for large seismic data[J].Electronics Letters, 2010, 46 (17) :1196-1197.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->

            <div class="btn-downloads">
                <span>
                    <a class="caj" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=XVTUPl3RORTOyE1NEZHZYlHShZFNPl3azo0Z0gWOn9WMvZ3VLtSbwpkaRJ3Q3NVQx4EbvxmTY5US3R2Q4MUVEhWV44marMlSPV0LSR0MuZmSCh2NYhWT3Z2UjVGTJ9mW2onQHJmdCFld3M0ViNHNYZzLrNlezR3a&tablename=CJFDLAST2019">CAJ下载</a>
                    <a class="pdf" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=XVTUPl3RORTOyE1NEZHZYlHShZFNPl3azo0Z0gWOn9WMvZ3VLtSbwpkaRJ3Q3NVQx4EbvxmTY5US3R2Q4MUVEhWV44marMlSPV0LSR0MuZmSCh2NYhWT3Z2UjVGTJ9mW2onQHJmdCFld3M0ViNHNYZzLrNlezR3a&tablename=CJFDLAST2019&dflag=pdfdown">PDF下载</a>
                </span>
                <p>永久保存本文,请下载至本地</p>
            </div>


    </div>

        <input id="fileid" type="hidden" value="JSJC201908010" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201908010&amp;v=MTk5OThRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJxRnkvZ1VMdk1MejdCYmJHNEg5ak1wNDlFWkk=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
            <a class="icon" id="copytext" target="_blank" href="http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908010&amp;filesourcetype=1">划线</a>
            <a class="icon" id="copytext" target="_blank" href="http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908010&amp;filesourcetype=1">笔记</a>
            <a class="icon" id="copytext" target="_blank" href="http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908010&amp;filesourcetype=1">文摘</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
