<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637128889364676250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201908002%26RESULT%3d1%26SIGN%3dZVW3JfIhhPWGcAhi8P1HzGhs2zk%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201908002&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201908002&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201908002&amp;v=MTUxNDlqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVScUZ5L2dVTC9PTHo3QmJiRzRIOWpNcDQ5RlpvUUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#33" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#37" data-title="1 相关理论与技术 ">1 相关理论与技术</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#38" data-title="1.1 SIMECK算法">1.1 SIMECK算法</a></li>
                                                <li><a href="#55" data-title="1.2 攻击原理">1.2 攻击原理</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#58" data-title="2 SIMECK加密故障扩散分析 ">2 SIMECK加密故障扩散分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#60" data-title="2.1 单比特故障扩散路径">2.1 单比特故障扩散路径</a></li>
                                                <li><a href="#79" data-title="2.2 故障扩散失效情况">2.2 故障扩散失效情况</a></li>
                                                <li><a href="#115" data-title="2.3 故障确定扩散的情况">2.3 故障确定扩散的情况</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#136" data-title="3 改进的&lt;i&gt;SIMECK&lt;/i&gt;32/64代数故障攻击 ">3 改进的<i>SIMECK</i>32/64代数故障攻击</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#138" data-title="3.1 故障注入位置计算">3.1 故障注入位置计算</a></li>
                                                <li><a href="#207" data-title="3.2 故障注入位置判定">3.2 故障注入位置判定</a></li>
                                                <li><a href="#220" data-title="3.3 故障注入位置融合判定">3.3 故障注入位置融合判定</a></li>
                                                <li><a href="#268" data-title="3.4 等效代数方程自动化创建">3.4 等效代数方程自动化创建</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#296" data-title="4 实验与结果分析 ">4 实验与结果分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#298" data-title="4.1 改进的SIMECK32/64代数故障攻击实例">4.1 改进的SIMECK32/64代数故障攻击实例</a></li>
                                                <li><a href="#303" data-title="4.2 结果分析">4.2 结果分析</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#310" data-title="5 结束语 ">5 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#40" data-title="&lt;b&gt;表1 本文使用符号及其含义&lt;/b&gt;"><b>表1 本文使用符号及其含义</b></a></li>
                                                <li><a href="#43" data-title="&lt;b&gt;图1 SIMECK系列算法加密过程&lt;/b&gt;"><b>图1 SIMECK系列算法加密过程</b></a></li>
                                                <li><a href="#57" data-title="&lt;b&gt;图2 代数故障攻击框架&lt;/b&gt;"><b>图2 代数故障攻击框架</b></a></li>
                                                <li><a href="#75" data-title="&lt;b&gt;图3 单比特故障向下一轮扩散的情况&lt;/b&gt;"><b>图3 单比特故障向下一轮扩散的情况</b></a></li>
                                                <li><a href="#83" data-title="&lt;b&gt;图4 故障碰撞导致故障传播失效的情况&lt;/b&gt;"><b>图4 故障碰撞导致故障传播失效的情况</b></a></li>
                                                <li><a href="#110" data-title="&lt;b&gt;表2&lt;/b&gt; “&amp;amp;”&lt;b&gt;运算导致故障失效的情况&lt;/b&gt;"><b>表2</b> “&amp;”<b>运算导致故障失效的情况</b></a></li>
                                                <li><a href="#130" data-title="&lt;b&gt;图5 故障确定扩散的情况&lt;/b&gt;"><b>图5 故障确定扩散的情况</b></a></li>
                                                <li><a href="#135" data-title="&lt;b&gt;表3 左寄存器内确定不会发生故障的状态&lt;/b&gt;"><b>表3 左寄存器内确定不会发生故障的状态</b></a></li>
                                                <li><a href="#216" data-title="&lt;b&gt;表4 故障注入在第29轮时正确/故障密文差分特性表&lt;/b&gt;"><b>表4 故障注入在第29轮时正确/故障密文差分特性表</b></a></li>
                                                <li><a href="#231" data-title="&lt;b&gt;表5 第30轮中间状态差分特性表&lt;/b&gt;"><b>表5 第30轮中间状态差分特性表</b></a></li>
                                                <li><a href="#305" data-title="&lt;b&gt;图6 故障样本量&lt;i&gt;N&lt;/i&gt;=8时100组实验攻击结果&lt;/b&gt;"><b>图6 故障样本量<i>N</i>=8时100组实验攻击结果</b></a></li>
                                                <li><a href="#308" data-title="&lt;b&gt;图7 密钥求解时间随故障注入数量的变化情况&lt;/b&gt;"><b>图7 密钥求解时间随故障注入数量的变化情况</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="331">


                                    <a id="bibliography_1" title=" COURTOIS N, WARE D, JACKSON K.Fault-algebraic attacks on inner rounds of DES[EB/OL].[2018-06-05].https://www.researchgate.net/publication/264885998_Fault-Algebraic_Attacks_on_Inner_Rounds_of_DES." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Fault-algebraic attacks on inner rounds of DES">
                                        <b>[1]</b>
                                         COURTOIS N, WARE D, JACKSON K.Fault-algebraic attacks on inner rounds of DES[EB/OL].[2018-06-05].https://www.researchgate.net/publication/264885998_Fault-Algebraic_Attacks_on_Inner_Rounds_of_DES.
                                    </a>
                                </li>
                                <li id="333">


                                    <a id="bibliography_2" title=" BIHAM E, SHAMIR A.Differential fault analysis of secret key cryptosystems[C]//Proceedings of the 17th Annual International Cryptology Conference on Advances in Cryptology.New York, USA:ACM Press, 1997:513-525." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Defferential fault analysis of secret key cryptosytems">
                                        <b>[2]</b>
                                         BIHAM E, SHAMIR A.Differential fault analysis of secret key cryptosystems[C]//Proceedings of the 17th Annual International Cryptology Conference on Advances in Cryptology.New York, USA:ACM Press, 1997:513-525.
                                    </a>
                                </li>
                                <li id="335">


                                    <a id="bibliography_3" title=" 吴克辉, 赵新杰, 王韬, 等.PRESENT密码代数故障攻击[J].通信学报, 2012, 33 (8) :85-92." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TXXB201208009&amp;v=Mjk2MTZxQnRHRnJDVVJMT2VaZVJxRnkvZ1VML0JNVFhUYkxHNEg5UE1wNDlGYllRS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         吴克辉, 赵新杰, 王韬, 等.PRESENT密码代数故障攻击[J].通信学报, 2012, 33 (8) :85-92.
                                    </a>
                                </li>
                                <li id="337">


                                    <a id="bibliography_4" title=" 赵新杰, 郭世泽, 王韬, 等.Piccolo密码代数故障分析研究[J].计算机学报, 2013, 36 (4) :882-894." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201304019&amp;v=MTI2MjM0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVScUZ5L2dVTC9CTHo3QmRyRzRIOUxNcTQ5RWJZUUtESDg=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[4]</b>
                                         赵新杰, 郭世泽, 王韬, 等.Piccolo密码代数故障分析研究[J].计算机学报, 2013, 36 (4) :882-894.
                                    </a>
                                </li>
                                <li id="339">


                                    <a id="bibliography_5" title=" HAO Ronglin, LI Bao, MA Bingke, et al.Algebraic fault attack on the SHA-256 compression function[J].International Journal of Research in Computer Science, 2014, 4 (2) :1-7." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Algebraic fault attack on the SHA-256 compression function">
                                        <b>[5]</b>
                                         HAO Ronglin, LI Bao, MA Bingke, et al.Algebraic fault attack on the SHA-256 compression function[J].International Journal of Research in Computer Science, 2014, 4 (2) :1-7.
                                    </a>
                                </li>
                                <li id="341">


                                    <a id="bibliography_6" title=" YANG Gangqiang, ZHU Bo, SUDER V, et al.The SIMECK family of lightweight block ciphers[C]//Proceedings of International Workshop on Cryptographic Hardware and Embedded Systems.Berlin, Germany:Springer, 2015:307-329." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The simeck family of lightweight block ciphers">
                                        <b>[6]</b>
                                         YANG Gangqiang, ZHU Bo, SUDER V, et al.The SIMECK family of lightweight block ciphers[C]//Proceedings of International Workshop on Cryptographic Hardware and Embedded Systems.Berlin, Germany:Springer, 2015:307-329.
                                    </a>
                                </li>
                                <li id="343">


                                    <a id="bibliography_7" title=" BIRYUKOV A, PERRIN L P.State of the art in lightweight symmetric cryptography[EB/OL].[2018-06-05].https://eprint.iacr.org/2017/511." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=State of the art in lightweight symmetric cryptography">
                                        <b>[7]</b>
                                         BIRYUKOV A, PERRIN L P.State of the art in lightweight symmetric cryptography[EB/OL].[2018-06-05].https://eprint.iacr.org/2017/511.
                                    </a>
                                </li>
                                <li id="345">


                                    <a id="bibliography_8" title=" BOGDANOV A, KNUDSEN L R, LEANDER G, et al.PRESENT:an ultra-lightweight block cipher[C]//Proceedings of International Workshop on Cryptographic Hardware and Embedded Systems.Berlin, Germany:Springer, 2007:450-466." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=PRESENT:an ultra-lightweight block cipher">
                                        <b>[8]</b>
                                         BOGDANOV A, KNUDSEN L R, LEANDER G, et al.PRESENT:an ultra-lightweight block cipher[C]//Proceedings of International Workshop on Cryptographic Hardware and Embedded Systems.Berlin, Germany:Springer, 2007:450-466.
                                    </a>
                                </li>
                                <li id="347">


                                    <a id="bibliography_9" title=" QIAO Kexin, HU Lei, SUN Siwei.Differential security evaluation of SIMECK with dynamic key-guessing techniques[C]//Proceedings of International Conference on Information Systems Security and Privacy.Berlin, Germany:Springer, 2015:74-84." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Differential security evaluation of SIMECK with dynamic key-guessing techniques">
                                        <b>[9]</b>
                                         QIAO Kexin, HU Lei, SUN Siwei.Differential security evaluation of SIMECK with dynamic key-guessing techniques[C]//Proceedings of International Conference on Information Systems Security and Privacy.Berlin, Germany:Springer, 2015:74-84.
                                    </a>
                                </li>
                                <li id="349">


                                    <a id="bibliography_10" title=" 陈彦琴, 张文英.SIMECK32/64算法的不可能差分分析[J].计算机工程, 2017, 43 (4) :141-144." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201704024&amp;v=MTQ2MzZVTC9CTHo3QmJiRzRIOWJNcTQ5SFlJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVScUZ5L2c=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                         陈彦琴, 张文英.SIMECK32/64算法的不可能差分分析[J].计算机工程, 2017, 43 (4) :141-144.
                                    </a>
                                </li>
                                <li id="351">


                                    <a id="bibliography_11" title=" ZHANG Kai, GUAN Jie, HU Bin, et al.Security evaluation on SIMECK against zero-correlation linear cryptanalysis[EB/OL].[2018-06-05].https://eprint.iacr.org/2015/911." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Security evaluation on SIMECK against zero-correlation linear cryptanalysis">
                                        <b>[11]</b>
                                         ZHANG Kai, GUAN Jie, HU Bin, et al.Security evaluation on SIMECK against zero-correlation linear cryptanalysis[EB/OL].[2018-06-05].https://eprint.iacr.org/2015/911.
                                    </a>
                                </li>
                                <li id="353">


                                    <a id="bibliography_12" title=" BAGHERI N.Linear cryptanalysis of reduced-round SIMECK variants[C]//Proceedings of INDOCRYPT’15.Berlin, Germany:Springer, 2015:140-152." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Linear cryptanalysis of reduced-round SIMECK variants">
                                        <b>[12]</b>
                                         BAGHERI N.Linear cryptanalysis of reduced-round SIMECK variants[C]//Proceedings of INDOCRYPT’15.Berlin, Germany:Springer, 2015:140-152.
                                    </a>
                                </li>
                                <li id="355">


                                    <a id="bibliography_13" title=" SARASWAT V.Differential fault attack on SIMECK[C]//Proceedings of Workshop on Cryptography and Security in Computing Systems.New York, USA:ACM Press, 2016:45-48." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Differential fault attack on SIMECK">
                                        <b>[13]</b>
                                         SARASWAT V.Differential fault attack on SIMECK[C]//Proceedings of Workshop on Cryptography and Security in Computing Systems.New York, USA:ACM Press, 2016:45-48.
                                    </a>
                                </li>
                                <li id="357">


                                    <a id="bibliography_14" title=" NALLA V, SAHU, R A, SARASWAT V.Differential fault attack on SIMECK[C]//Proceedings of Workshop on Cryptography and Security in Computing Systems.New York, USA:ACM Press, 2016:45-48." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Differential fault attack on SIMECK">
                                        <b>[14]</b>
                                         NALLA V, SAHU, R A, SARASWAT V.Differential fault attack on SIMECK[C]//Proceedings of Workshop on Cryptography and Security in Computing Systems.New York, USA:ACM Press, 2016:45-48.
                                    </a>
                                </li>
                                <li id="359">


                                    <a id="bibliography_15" title=" JOYE M, TUNSTALL M.密码故障分析与防护[M].赵新杰, 郭世泽, 张帆, 等译.北京:科学出版社, 2015." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787030450227000&amp;v=MTU1Nzd4VVNtRGQ5U0g3bjN4RTlmYnZuS3JpZlp1OXVGQ3ZoVTdqTkkxNGRYRnF6R2JPN0h0WEpyNDFIWStzUERCTTh6&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                         JOYE M, TUNSTALL M.密码故障分析与防护[M].赵新杰, 郭世泽, 张帆, 等译.北京:科学出版社, 2015.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(08),7-13+21 DOI:10.19678/j.issn.1000-3428.0051747            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于优化故障定位的SIMECK密码代数故障攻击</b></span>
 <span class="shoufa"></span>                                     </h1>

                <div class="btn-downloads  btn-downloads-new">

                        <a class="read read-btn-special" target="_blank" href=http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908002&amp;filesourcetype=1><i class="i-btn i-care"></i>精读</a>
                    <div class="read-btn-l">
                        <a class="caj" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=D1GbEh2UOJEMalTMyRDNzs0SORzLX5mZvEWYiZ2ZqR0LxtWWoRzTxJmRnlDUiV1cSd3RmZVTqJWbklXaVNEUxwGaMtkZ5MWTv4mZ2FGZuR0TzM1dVFkelx0aTh0crZVdOdlb59yaUJVTyVnV4YmViBjNXNWeFtCZ&tablename=CJFDLAST2019"><i class="i-btn i-caj"></i> CAJ下载</a>
                        <a class="pdf" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=D1GbEh2UOJEMalTMyRDNzs0SORzLX5mZvEWYiZ2ZqR0LxtWWoRzTxJmRnlDUiV1cSd3RmZVTqJWbklXaVNEUxwGaMtkZ5MWTv4mZ2FGZuR0TzM1dVFkelx0aTh0crZVdOdlb59yaUJVTyVnV4YmViBjNXNWeFtCZ&tablename=CJFDLAST2019&dflag=pdfdown"><i class="i-btn i-pdf"></i>PDF下载</a>

                        <p>永久保存本文,请下载至本地</p>
                    </div>

                </div>
            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%BB%84%E9%95%BF%E9%98%B3&amp;code=40329685&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">黄长阳</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%8B%E9%9F%AC&amp;code=40329686&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">王韬</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%8B%E6%99%93%E6%99%97&amp;code=40329687&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">王晓晗</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%99%88%E5%BA%86%E8%B6%85&amp;code=40329688&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">陈庆超</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%B0%B9%E4%B8%96%E5%BA%84&amp;code=40329689&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">尹世庄</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E9%99%86%E5%86%9B%E5%B7%A5%E7%A8%8B%E5%A4%A7%E5%AD%A6%E8%A3%85%E5%A4%87%E6%A8%A1%E6%8B%9F%E8%AE%AD%E7%BB%83%E4%B8%AD%E5%BF%83&amp;code=1701801&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">陆军工程大学装备模拟训练中心</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>针对SIMECK密码, 提出一种优化故障定位的代数故障攻击方法。通过分析SIMECK轮函数加密扩散缺陷及故障失效原因, 提取故障确定性传播特征并构建确定性故障差分特性表, 实现故障的精确定位。创建加密过程和故障信息等效方程组, 将方程组转化为SAT问题并求解密钥。实验结果表明, 该方法在SIMECK32/64第28轮左寄存器中注入随机单比特故障, 仅需8次故障注入即可恢复完整64 bit主密钥, 攻击成功率高达99.61%, 相比已有故障攻击方法所需故障样本量更少, 攻击成功率及创建方程自动化程度更高。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=SIMECK%E5%AF%86%E7%A0%81&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">SIMECK密码;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BB%A3%E6%95%B0%E6%95%85%E9%9A%9C%E6%94%BB%E5%87%BB&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">代数故障攻击;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%95%85%E9%9A%9C%E5%A4%B1%E6%95%88&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">故障失效;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%BD%AE%E5%87%BD%E6%95%B0%E7%BC%BA%E9%99%B7&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">轮函数缺陷;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%95%85%E9%9A%9C%E6%A8%A1%E5%9E%8B&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">故障模型;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=CryptoMiniSat%E8%A7%A3%E6%9E%90%E5%99%A8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">CryptoMiniSat解析器;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    黄长阳 (1994—) , 男, 硕士研究生, 主研方向为网络信息安全、代数故障攻击;;
                                </span>
                                <span>
                                    王韬, 教授、博士、博士生导师;;
                                </span>
                                <span>
                                    王晓晗, 博士研究生;;
                                </span>
                                <span>
                                    陈庆超, 硕士研究生。;
                                </span>
                                <span>
                                    尹世庄, 硕士研究生。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-06-06</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金 (61272491, 61309021, 61402528);</span>
                    </p>
            </div>
                    <h1><b>Algebraic Fault Attack Against SIMECK Cipher Based on Optimized Fault Location</b></h1>
                    <h2>
                    <span>HUANG Changyang</span>
                    <span>WANG Tao</span>
                    <span>WANG Xiaohan</span>
                    <span>CHEN Qingchao</span>
                    <span>YIN Shizhuang</span>
            </h2>
                    <h2>
                    <span>Center of Equipment Simulation Training, Army Engineering University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>This paper proposes a algebraic fault attack method based on optimized fault location against SIMECK cipher.By analyzing encryption diffusion defect of the SIMECK round function and the failure cause, the deterministic propagation characteristics of faults are extracted, and the differential characteristic table of deterministic faults is constructed to achieve accurate fault location.It creates an equivalent equation set for the encryption process and fault information, and converts the equations into SAT problems and solve the key.Experimental results show that the method can inject a random single-bit fault into the left register in the 28 th round of SIMECK32/64, and only need 8 fault injections to recover the complete 64 bit master key.The attack success rate is 99.61%.Compared with the existing fault attack method, the proposed method requires fewer fault samples and has a higher attack success rate, creation of equations more automated.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=SIMECK%20cipher&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">SIMECK cipher;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=algebraic%20fault%20attack&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">algebraic fault attack;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=fault%20failure&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">fault failure;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=round%20function%20defect&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">round function defect;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=fault%20model&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">fault model;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=CryptoMiniSat%20parser&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">CryptoMiniSat parser;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-06-06</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="33" name="33" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="34">代数故障攻击<citation id="361" type="reference"><link href="331" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>是一种兼顾代数分析和故障攻击<citation id="362" type="reference"><link href="333" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>优势的密码分析方法, 并通过1 bit故障注入穷举24 bit密钥即可恢复DES全部密钥。代数故障攻击能够解决代数分析复杂度过高及故障攻击中故障信息利用率较低的问题, 以其高有效性受到密码学专家的广泛关注, 利用代数故障攻击成功破解PRESENT<citation id="363" type="reference"><link href="335" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>、Piccolo<citation id="364" type="reference"><link href="337" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>和SHA-256<citation id="365" type="reference"><link href="339" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>等密码算法。</p>
                </div>
                <div class="p1">
                    <p id="35">SIMECK<citation id="366" type="reference"><link href="341" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>算法是一种专门运行于无源RFID标签等硬件资源有限设备的轻量级分组密码, 其轮函数采用按位“与”“异或”和循环移位操作组合进行加密运算, 并且重用轮函数进行密钥扩展, 更符合分组密码轻量化设计的要求<citation id="367" type="reference"><link href="343" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>, 其中SIMECK32/64硬件实现仅需549GE, 优于ISO标准算法PRESENT的1 570GE<citation id="368" type="reference"><link href="345" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>, 因此对其安全性分析具有重要意义。现阶段针对SIMECK密码的分析主要集中于差分分析<citation id="373" type="reference"><link href="347" rel="bibliography" /><link href="349" rel="bibliography" /><sup>[<a class="sup">9</a>,<a class="sup">10</a>]</sup></citation>和线性分析<citation id="374" type="reference"><link href="351" rel="bibliography" /><link href="353" rel="bibliography" /><sup>[<a class="sup">11</a>,<a class="sup">12</a>]</sup></citation>, 最优能将密钥搜索空间降至2<sup>29</sup>, 难以对其实际安全性构成威胁。在故障攻击方面, 文献<citation id="369" type="reference">[<a class="sup">13</a>]</citation>对SIMECK进行差分故障攻击, 平均28.32个故障能够恢复末轮16 bit密钥;文献<citation id="370" type="reference">[<a class="sup">14</a>]</citation>利用代数故障攻击在故障未知模型下需9次故障注入即可恢复完整主密钥。但是, 文献<citation id="371" type="reference">[<a class="sup">13</a>]</citation>仅能恢复末轮16 bit密钥, 无法恢复全部主密钥信息, 对密码安全性威胁较小;文献<citation id="372" type="reference">[<a class="sup">14</a>]</citation>对故障传播特征分析不深入, 无法提取故障确定性传播信息, 导致故障确定准确率仅为82.9%, 故障信息利用率较低。</p>
                </div>
                <div class="p1">
                    <p id="36">本文对SIMECK32/64提出一种改进的代数故障攻击, 在第28轮左寄存器任意状态注入随机单比特故障, 通过分析故障失效情况, 提取故障确定传播信息构建差分特性表, 并阐述SIMECK轮函数设计缺陷判断故障注入位置。</p>
                </div>
                <h3 id="37" name="37" class="anchor-tag">1 相关理论与技术</h3>
                <h4 class="anchor-tag" id="38" name="38">1.1 SIMECK算法</h4>
                <div class="p1">
                    <p id="39">本文所使用符号及其含义说明如表1所示。</p>
                </div>
                <div class="area_img" id="40">
                    <p class="img_tit"><b>表1 本文使用符号及其含义</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="40" border="1"><tr><td><br />符号</td><td>含义     </td></tr><tr><td><br /><i>X</i>&lt;&lt;<i>a</i></td><td>密码状态<i>X</i>循环左移<i>a</i> bit</td></tr><tr><td><br />&amp;</td><td>按位“与”运算</td></tr><tr><td><br />♁</td><td>按位“异或”运算</td></tr><tr><td><br /><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>密码正确加密第r轮左寄存器的第i比特</td></tr><tr><td><br />xR<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>密码正确加密第r轮右寄存器的第i比特</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></td><td>故障加密第r轮左寄存器的第i比特</td></tr><tr><td><br />xR<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></td><td>故障加密第r轮右寄存器的第i比特</td></tr><tr><td><br />SK<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>第r轮加密轮子密钥的第i比特</td></tr><tr><td><br />n</td><td><i>SIMECK</i>加密字长度, n=16, 24, 48</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="41" name="41">1.1.1 加密轮函数</h4>
                <div class="p1">
                    <p id="42">SIMECK系列算法加密整体采用平衡型Feistel结构, 由轮加密函数和密钥扩展策略构成。其中轮函数包括负责增强加密算法非线性的按位“&amp;”运算, 提供加密扩散性的“♁”运算和循环移位操作组合而成, 迭代加密结构如图1所示。</p>
                </div>
                <div class="area_img" id="43">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908002_043.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 SIMECK系列算法加密过程" src="Detail/GetImg?filename=images/JSJC201908002_043.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 SIMECK系列算法加密过程</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908002_043.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="44">以SIMECK32/64算法为例, 其一轮加密流程如下:首先将32 bit明文均分成2个加密字, 其中, 低位16 bit送入加密左寄存器, 高位16 bit送入加密右寄存器。启动加密算法, 将两寄存器内部状态送入加密轮函数, 当32轮迭代加密运算后寄存器内部状态即为加密密文。两寄存器内部状态更新方法如式 (1) 所示。</p>
                </div>
                <div class="p1">
                    <p id="45" class="code-formula">
                        <mathml id="45"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mo>=</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mo>=</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="46">其中, <i>f</i>函数运算表达式如式 (2) 所示。</p>
                </div>
                <div class="p1">
                    <p id="47"><i>f</i> (<i>x</i><sup><i>i</i></sup>) = (<i>x</i><sup><i>i</i></sup>&amp; (<i>x</i><sup><i>i</i></sup>&lt;&lt;5) ) ♁ (<i>x</i><sup><i>i</i></sup>&lt;&lt;1)      (2) </p>
                </div>
                <h4 class="anchor-tag" id="48" name="48">1.1.2 密钥扩展算法</h4>
                <div class="p1">
                    <p id="49">SIMECK系列密码采用重用轮函数并引入加密参数计算轮密钥的密钥扩展策略。该设计优势在于能够使用已有的轮函数硬件加载密钥扩展算法, 无需设计额外的硬件电路, 减少资源消耗的同时能利用轮函数的非线性提高密钥扩展算法的安全性, 更符合分组密码轻量化设计的要求。</p>
                </div>
                <div class="p1">
                    <p id="50">以SIMECK32/64算法为例, 其轮密钥扩展算法如下:</p>
                </div>
                <div class="p1">
                    <p id="51">1) 将64 bit主密钥 (<i>MK</i>) 均分成4个加密字长度, 记为 (<i>t</i><sub>2</sub>, <i>t</i><sub>1</sub>, <i>t</i><sub>0</sub>, <i>k</i><sub>0</sub>) , 其中, <i>k</i><sub>0</sub>为主密钥的最低16 bit, <i>t</i><sub>2</sub>为主密钥的最高16 bit, 分别作为密钥扩展寄存器<i>T</i><sub>2</sub>、<i>T</i><sub>1</sub>、<i>T</i><sub>0</sub>、<i>K</i><sub>0</sub>的初始状态。</p>
                </div>
                <div class="p1">
                    <p id="52">2) 将寄存器<i>T</i><sub>0</sub>和<i>K</i><sub>0</sub>分别作为加密的左寄存器和右寄存器送入加密轮函数, 同时引入加密常量<i>C</i>和LFSR生成的<i>m</i>-序列增强算法安全性。在每轮运算结束后, 将寄存器<i>K</i><sub>0</sub>中的结果作为下一轮加密的轮子密钥, 更新如式 (3) 所示。</p>
                </div>
                <div class="p1">
                    <p id="53" class="code-formula">
                        <mathml id="53"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>0</mn><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mo>=</mo><mi>Τ</mi><msubsup><mrow></mrow><mrow><mn>0</mn><mi>r</mi></mrow><mi>i</mi></msubsup></mtd></mtr><mtr><mtd columnalign="left"><mi>Τ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mo>=</mo><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>0</mn><mi>r</mi></mrow><mi>i</mi></msubsup><mo>⊕</mo><mi>f</mi><mo stretchy="false"> (</mo><mi>Τ</mi><msubsup><mrow></mrow><mrow><mn>0</mn><mi>r</mi></mrow><mi>i</mi></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>C</mi><mo>⊕</mo><mo stretchy="false"> (</mo><mi>Ζ</mi><msub><mrow></mrow><mi>j</mi></msub><mo stretchy="false">) </mo><msub><mrow></mrow><mi>r</mi></msub></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="54">在每轮运算后, 密钥反馈移位寄存器右移<i>n</i>位。在式 (3) 中, <i>r</i>为加密轮数, <i>C</i>为加密常量, <i>C</i>=2<sup><i>n</i></sup>-4, (<i>Z</i><sub><i>j</i></sub>) <sub><i>r</i></sub>为<i>m</i>-序列<i>Z</i><sub><i>j</i></sub>的第<i>r</i>比特, 各版本密码所用<i>Z</i><sub><i>j</i></sub>序列的初始状态及反馈特征多项式详见文献<citation id="375" type="reference">[<a class="sup">6</a>]</citation>。</p>
                </div>
                <h4 class="anchor-tag" id="55" name="55">1.2 攻击原理</h4>
                <div class="p1">
                    <p id="56">代数故障攻击融合典型代数攻击和故障攻击各自的优势, 首先构建正确加密过程等效代数方程组, 通过激光束照射等方式诱导加密寄存器内部状态发生故障<citation id="376" type="reference"><link href="359" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>, 将提取的故障信息并创建其等效方程, 最终同正确加密方程联立进行密钥求解。代数故障攻击框架如图2所示。本文采用更适合密码方程求解的可满足性 (Satisfiability, SAT) 问题进行密钥方程求解。</p>
                </div>
                <div class="area_img" id="57">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908002_057.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 代数故障攻击框架" src="Detail/GetImg?filename=images/JSJC201908002_057.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 代数故障攻击框架</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908002_057.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="58" name="58" class="anchor-tag">2 SIMECK加密故障扩散分析</h3>
                <div class="p1">
                    <p id="59">本文采用单比特翻转故障模型, 即诱导故障后密码中间状态由1跳变为0跳或由0跳变为1跳。下文分析故障随迭代加密传播过程中可能出现的失效情况及确定能够扩散的情况。</p>
                </div>
                <h4 class="anchor-tag" id="60" name="60">2.1 单比特故障扩散路径</h4>
                <div class="p1">
                    <p id="61">当诱导左寄存器第<i>i</i>比特即<i>xL</i><mathml id="62"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>发生单比特翻转故障时, 根据<i>SIMECK</i>32/64算法轮函数能够计算出第r+1轮受xL<mathml id="63"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>故障影响的密码状态, 如式 (4) 所示。</p>
                </div>
                <div class="p1">
                    <p id="64" class="code-formula">
                        <mathml id="64"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>=</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>=</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>=</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>4</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>=</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="65">因此, 当故障诱导在xL<mathml id="66"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>时, 影响下一轮中间状态为xR<mathml id="67"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>、xL<mathml id="68"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>、xL<mathml id="69"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>和xL<mathml id="70"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>。同理, 当故障诱导在右寄存器第i比特xR<mathml id="71"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>时, 影响下一轮中间状态为xL<mathml id="72"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>。以注入在xL<mathml id="73"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>4</mn></msubsup></mrow></math></mathml>和xR<mathml id="74"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>7</mn></msubsup></mrow></math></mathml>位置为例, 故障向下一轮扩散的情况如图3所示。</p>
                </div>
                <div class="area_img" id="75">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908002_075.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 单比特故障向下一轮扩散的情况" src="Detail/GetImg?filename=images/JSJC201908002_075.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 单比特故障向下一轮扩散的情况</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908002_075.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="76">由上述分析可得, 左寄存器内故障可影响下一轮较多状态, 但同时在右寄存器第<i>i</i>比特<i>xR</i><mathml id="77"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>注入故障等效于在左寄存器xL<mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>注入故障。</p>
                </div>
                <h4 class="anchor-tag" id="79" name="79">2.2 故障扩散失效情况</h4>
                <div class="p1">
                    <p id="80">故障实际传播过程与理论扩散路径并不完全相同, 这是因为故障在随SIMECK算法迭代加密扩散过程中可能出现故障失效情况。</p>
                </div>
                <h4 class="anchor-tag" id="81" name="81">2.2.1 多个故障碰撞导致故障失效的情况</h4>
                <div class="p1">
                    <p id="82">当多个故障同时扩散到密码中间状态同一比特位即多个故障发生碰撞时, 可能会出现多个故障效果相互抵消的情况, 导致故障加密结果与正确加密结果相同即故障扩散失效, 如图4所示。</p>
                </div>
                <div class="area_img" id="83">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908002_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 故障碰撞导致故障传播失效的情况" src="Detail/GetImg?filename=images/JSJC201908002_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 故障碰撞导致故障传播失效的情况</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908002_083.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="84">当第<i>r</i>轮中间状态发生故障位置为<i>xL</i><mathml id="85"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mn>4</mn></mrow></msubsup></mrow></math></mathml>和xL<mathml id="86"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>时, 经过一轮加密后2个故障同时影响到xL<mathml id="87"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>位置, 根据轮函数计算可得:</p>
                </div>
                <div class="p1">
                    <p id="88">xL<mathml id="89"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>= (xL<mathml id="90"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>3</mn></msubsup></mrow></math></mathml>&amp; xL<mathml id="91"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>8</mn></msubsup></mrow></math></mathml>) ♁xL<mathml id="92"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mn>4</mn></mrow></msubsup></mrow></math></mathml>♁xR<mathml id="93"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>♁SK<mathml id="94"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>3</mn></msubsup></mrow></math></mathml>=</p>
                </div>
                <div class="p1">
                    <p id="95"> (xL<mathml id="96"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>3</mn></msubsup></mrow></math></mathml>&amp; xL<mathml id="97"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>8</mn></msubsup></mrow></math></mathml>) ♁ (xL<mathml id="98"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>4</mn></msubsup></mrow></math></mathml>♁1) ♁</p>
                </div>
                <div class="p1">
                    <p id="99"> (xR<mathml id="100"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>3</mn></msubsup></mrow></math></mathml>♁1) ♁SK<mathml id="101"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mn>3</mn></msubsup></mrow></math></mathml>=xL<mathml id="102"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mn>3</mn></msubsup></mrow></math></mathml>      (5) </p>
                </div>
                <div class="p1">
                    <p id="103">若故障状态xL<mathml id="104"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>与正确状态xL<mathml id="105"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mn>3</mn></msubsup></mrow></math></mathml>相等, 则故障效果失效。</p>
                </div>
                <h4 class="anchor-tag" id="106" name="106">2.2.2 加密部件数学属性导致故障失效的情况</h4>
                <div class="p1">
                    <p id="107">SIMECK算法轮函数中“&amp;”运算的数学特性可能会导致故障扩散出现失效的情况。假设进行“&amp;”运算的双方为<i>xL</i><mathml id="108"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>和xL<mathml id="109"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>, 经过运算后故障扩散情况如表2所示。</p>
                </div>
                <div class="area_img" id="110">
                    <p class="img_tit"><b>表2</b> “&amp;”<b>运算导致故障失效的情况</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="110" border="1"><tr><td><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></td><td>正确运算<br />结果</td><td>故障<br />位置</td><td>故障加密<br />结果</td><td>故障<br />效果</td></tr><tr><td>0</td><td>0</td><td>0</td><td><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>0</td><td>失效</td></tr><tr><td><br />0</td><td>1</td><td>0</td><td>xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>1</td><td>成功</td></tr><tr><td><br />1</td><td>0</td><td>0</td><td>xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>0</td><td>失效</td></tr><tr><td><br />1</td><td>1</td><td>1</td><td>xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></td><td>0</td><td>成功</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="111">分析表2发现, 当故障注入在xL<mathml id="112"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>时, 经过“&amp;”运算后故障是否失效仅与“&amp;”右侧状态xL<mathml id="113"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>值有关, 即若xL<mathml id="114"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>=0, 则故障扩散失效;否则故障能够成功扩散至下一轮状态。</p>
                </div>
                <h4 class="anchor-tag" id="115" name="115">2.3 故障确定扩散的情况</h4>
                <div class="p1">
                    <p id="116">本节分析故障确定扩散的情况, 包括故障确定能够扩散到的密码状态和故障确定不会影响到的密码状态, 并依此提取故障确定性扩散特征。</p>
                </div>
                <h4 class="anchor-tag" id="117" name="117">2.3.1 故障确定扩散到的中间状态</h4>
                <div class="p1">
                    <p id="118">在故障传播过程中, 既不会发生故障相遇碰撞同时又不涉及“&amp;”运算导致故障失效时, 就能够确定故障扩散具体的比特位, 即当故障仅通过“♁”运算或“=”运算向下一轮扩散, 且不发生故障相遇碰撞时, 故障肯定能够扩散成功。</p>
                </div>
                <div class="p1">
                    <p id="119">假设故障注入在第<i>r</i>轮<i>xL</i><mathml id="120"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>位置, 根据式 (4) 可得故障由xL<mathml id="121"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>分别依靠“♁”运算和“=”运算扩散至xL<mathml id="122"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>和xR<mathml id="123"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>且没有发生故障碰撞, 因此故障确定能够扩散成功。</p>
                </div>
                <div class="p1">
                    <p id="124">同理, 可计算得到第r+2轮故障确定扩散至xL<mathml id="125"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>和xR<mathml id="126"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>, 第r+3轮故障确定传播至xL<mathml id="127"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>3</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>和xR<mathml id="128"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>。以故障注入在xL<mathml id="129"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mn>0</mn></mrow></msubsup></mrow></math></mathml>位置为例, 故障确定扩散情况如图5所示。</p>
                </div>
                <div class="area_img" id="130">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908002_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 故障确定扩散的情况" src="Detail/GetImg?filename=images/JSJC201908002_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 故障确定扩散的情况</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908002_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="131">当故障在第<i>r</i>轮～第<i>r</i>+3轮扩散时, 均有确定故障扩散状态, 但是当传播至第<i>r</i>+4轮时, 所有可能发生故障的状态均有可能因为发生故障碰撞导致故障失效, 因此第<i>r</i>+4轮中没有故障能够确定扩散到的状态。</p>
                </div>
                <h4 class="anchor-tag" id="132" name="132">2.3.2 故障确定不会扩散到的中间状态</h4>
                <div class="p1">
                    <p id="133">在去除2.1节中故障可能扩散的位置和2.3.1节中故障确定扩散成功位置的基础上, 即可分析得出故障确定不会扩散, 即正确/故障加密状态差分为0的位置。假设故障注入在第<i>r</i>轮<i>xL</i><mathml id="134"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>位置, 左寄存器内部故障确定不会扩散至的位置如表3所示。根据式 (4) 可得, 第r+1轮右寄存器内部故障确定不会扩散的状态与第r轮左寄存器情况相同, 不再赘述。</p>
                </div>
                <div class="area_img" id="135">
                    <p class="img_tit"><b>表3 左寄存器内确定不会发生故障的状态</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="135" border="1"><tr><td><br />轮数</td><td>左寄存器内部故障确定不会扩散到的中间状态</td></tr><tr><td><br /><i>r</i>+1</td><td><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>j</mi></msubsup></mrow></math>, 0≤<i>j</i>≤15, <i>j</i>≠<i>i</i>, (<i>i</i>+11) %16, (<i>i</i>+15) %16</td></tr><tr><td><br /><i>r</i>+2</td><td><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>2</mn></mrow><mi>j</mi></msubsup></mrow></math>, 0≤<i>j</i>≤15, <i>j</i>≠<i>i</i>, (<i>i</i>+6) %16, <br /> (<i>i</i>+10) %16, (<i>i</i>+11) %16, (<i>i</i>+14) %16, (<i>i</i>+15) %16</td></tr><tr><td><br /><i>r</i>+3</td><td><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math>, <i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>3</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math>, <i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>4</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math>, <i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>7</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math>4, <br /><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>8</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math>, <i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></td></tr><tr><td><br />r+4</td><td>xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math>, xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>3</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math>, xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>7</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></td></tr><tr><td><br />r+5</td><td>xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h3 id="136" name="136" class="anchor-tag">3 改进的<i>SIMECK</i>32/64代数故障攻击</h3>
                <div class="p1">
                    <p id="137">准确判定发生故障的状态位置是利用故障信息的前提, 如果故障位置判定错误, 则会导致故障信息等效方程创建错误致使故障攻击失败。针对以上故障失效导致故障攻击成功率下降的问题, 本文提出2种方法提高故障定位成功率, 并给出通用的加密等效方程组创建方法。</p>
                </div>
                <h4 class="anchor-tag" id="138" name="138">3.1 故障注入位置计算</h4>
                <div class="p1">
                    <p id="139">分析SIMECK32/64算法轮函数加密扩散缺陷, 根据获取正确密文和故障密文即可确定<i>r</i>-2轮左寄存器故障诱导位置和<i>r</i>-3轮右寄存器故障诱导位置。</p>
                </div>
                <div class="p1">
                    <p id="140">根据式 (1) 和式 (2) 运算可得:</p>
                </div>
                <div class="p1">
                    <p id="141"><i>xL</i><mathml id="142"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>=<i>f</i> (<i>xR</i><mathml id="143"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>) ⊕<i>xL</i><mathml id="144"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>⊕<i>sk</i><mathml id="145"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>      (6) </p>
                </div>
                <div class="p1">
                    <p id="146">即:</p>
                </div>
                <div class="p1">
                    <p id="147">xL<mathml id="148"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>=f (xR<mathml id="149"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>) ⊕xL<mathml id="150"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>⊕sk<mathml id="151"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="152">所以:</p>
                </div>
                <div class="p1">
                    <p id="153">xL<mathml id="154"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>=xL<mathml id="155"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>⊕f (xR<mathml id="156"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>) ⊕sk<mathml id="157"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>      (7) </p>
                </div>
                <div class="p1">
                    <p id="158">假设故障注入在xL<mathml id="159"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>状态, 即xL<mathml id="160"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>=xL<mathml id="161"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>⊕1, 则可得:</p>
                </div>
                <div class="p1">
                    <p id="162">xL<mathml id="163"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>=xL<mathml id="164"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>⊕f (xR<mathml id="165"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>) ⊕sk<mathml id="166"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>      (8) </p>
                </div>
                <div class="p1">
                    <p id="167">根据式 (7) 和式 (8) , 可计算得出r-2轮左寄存器内部正确加密和故障加密状态差分<i>Δ</i>xL<mathml id="168"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>如式 (9) 所示。</p>
                </div>
                <div class="p1">
                    <p id="169"><i>Δ</i>xL<mathml id="170"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>=xL<mathml id="171"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>⊕ xL<mathml id="172"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>=xL<mathml id="173"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>⊕ f (xR<mathml id="174"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>) ⊕</p>
                </div>
                <div class="p1">
                    <p id="175">sk<mathml id="176"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>⊕ xL<mathml id="177"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>⊕ f (xR<mathml id="178"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>) ⊕ sk<mathml id="179"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>=xL<mathml id="180"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>⊕</p>
                </div>
                <div class="p1">
                    <p id="181">xL<mathml id="182"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>⊕ (xR<mathml id="183"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>&amp; (xR<mathml id="184"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>&lt;&lt;5) ) ⊕ (xR<mathml id="185"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>&lt;&lt;1) ⊕</p>
                </div>
                <div class="p1">
                    <p id="186"> (xR<mathml id="187"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>&amp; (xR<sup>*i</sup><sub>r</sub>v5) ) ⊕ (xR<mathml id="188"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>&lt;&lt;1)      (9) </p>
                </div>
                <div class="p1">
                    <p id="189">根据式 (1) 和式 (9) 可计算得第r-3轮右寄存器内部正确加密与故障加密状态差分<i>Δ</i>xL<mathml id="190"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>如式 (10) 所示。</p>
                </div>
                <div class="p1">
                    <p id="191"><i>Δ</i>xR<mathml id="192"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>=xR<mathml id="193"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>⊕xR<mathml id="194"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>1</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>=xL<mathml id="195"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>⊕xL<mathml id="196"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>=<i>Δ</i>xL<mathml id="197"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>      (10) </p>
                </div>
                <div class="p1">
                    <p id="198">当r=32时, xL<mathml id="199"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>和xR<mathml id="200"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>是正确加密密文, xL<mathml id="201"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>和xR<mathml id="202"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>是故障加密密文, 即式 (9) 中等号右边所有变量均为已知, 可准确计算出第30轮左寄存器内故障注入位置。若通过正确密文和故障密文计算得到<i>Δ</i>xL<mathml id="203"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>=1, 则表明<i>Δ</i>xL<mathml id="204"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>为故障注入位置, 若<i>Δ</i>xL<mathml id="205"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>=0, 则<i>Δ</i>xL<mathml id="206"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>不是故障注入位置。同理, 通过正确密文和故障密文能够计算出第31轮右寄存器内故障注入位置。</p>
                </div>
                <h4 class="anchor-tag" id="207" name="207">3.2 故障注入位置判定</h4>
                <div class="p1">
                    <p id="208">根据2.3节分析所得结论, 当故障注入在第29轮<i>xL</i><mathml id="209"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>位置时, 可准确计算得出xL<mathml id="210"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>和xR<mathml id="211"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>, 即故障密文输出中一定不会发生故障的状态位置和确定发生故障的状态位置。通过提取上述故障确定性扩散特征, 构建故障差分特性表判定故障注入位置。</p>
                </div>
                <div class="p1">
                    <p id="212">设正确密文与故障密文差分值为<i>Δ</i>C, 则:</p>
                </div>
                <div class="p1">
                    <p id="213" class="code-formula">
                        <mathml id="213"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Δ</mtext><mi>C</mi><msub><mrow></mrow><mi>j</mi></msub><mo>=</mo><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mi>j</mi></msubsup><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mi>j</mi></mrow></msubsup><mo>, </mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mn>1</mn><mn>6</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mi>j</mi><mo>-</mo><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mi>j</mi><mo>-</mo><mn>1</mn><mn>6</mn></mrow></msubsup><mo>, </mo><mn>1</mn><mn>6</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mn>3</mn><mn>2</mn></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="214">基于上述理论分析, 遍历计算故障注入在xL<mathml id="215"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml> (0≤i&lt;16) 时密文差分<i>Δ</i>C<sub>j</sub> (0≤j&lt;32) 的值, 若故障确定扩散至密文第j比特位, 则<i>Δ</i>C<sub>j</sub>=1;若故障确定没有扩散至密文第j比特位, 则<i>Δ</i>C<sub>j</sub>=0;其余故障不确定扩散情况的位置k时, 令<i>Δ</i>C<sub>k</sub>=x, 0≤k&lt;32, k≠i, j。基于上述理论, 构建故障注入在<i>SIMECK</i>32/64算法第29轮时正确/故障密文差分 (<i>Δ</i>C<sub>j</sub>, j=0, 1, …, 30) 特性, 如表4所示。</p>
                </div>
                <div class="area_img" id="216">
                    <p class="img_tit"><b>表4 故障注入在第29轮时正确/故障密文差分特性表</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="216" border="1"><tr><td><br />故障注入位置</td><td>正确/故障密文差分值</td></tr><tr><td><br /><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>0</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>1</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>2</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>3</mn></mrow></msubsup></mrow></math></td><td>1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>4</mn></mrow></msubsup></mrow></math></td><td>0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>5</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>6</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>7</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>8</mn></mrow></msubsup></mrow></math></td><td>0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>9</mn></mrow></msubsup></mrow></math></td><td>0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>0</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>1</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></td><td>0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>3</mn></mrow></msubsup></mrow></math></td><td>0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>4</mn></mrow></msubsup></mrow></math></td><td>0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>5</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, <i>x</i>, <i>x</i>, <i>x</i>, 0, 1, <i>x</i>, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i></td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="217">在表4中, 第i行表示故障注入在xL<mathml id="218"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>时, 第j列表示正确/故障密文差分第j比特位<i>Δ</i>C<sub>j</sub>。差分特性表中a[i][j]等于“0”或“1”表明当故障注入在xL<mathml id="219"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup></mrow></math></mathml>时, <i>Δ</i>C<sub>j</sub>的值始终为“0”或“1”。基于上述理论, 攻击者通过计算正确/故障密文差分<i>Δ</i>C, 并与表4进行匹配即能够确定故障注入状态位置。为验证上述理论的正确性, 本文进行左寄存器仿真故障注入实验, 共进行10 000次, 其中正确判定故障注入位置10 000次, 成功率为100%。</p>
                </div>
                <h4 class="anchor-tag" id="220" name="220">3.3 故障注入位置融合判定</h4>
                <div class="p1">
                    <p id="221">上述2种方法虽然能够正确计算出故障注入位置, 但是由于故障注入轮数较浅, 没有涉及到全部主密钥信息, 因此仅能够恢复部分密钥。本节将融合2种方法, 利用轮函数加密扩散缺陷加深差分特性表构建深度, 以达到利用更多故障信息恢复全部密钥的目的。</p>
                </div>
                <div class="p1">
                    <p id="222">1) 根据3.1节分析轮函数加密扩散缺陷以及所获正确密文和故障密文, 通过式 (9) 能够遍历计算得出Δ<i>xL</i><mathml id="223"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml> (0≤<i>i</i>&lt;16) 。</p>
                </div>
                <div class="p1">
                    <p id="224">2) 利用3.2节方法能够构建故障注入在第<i>r</i>=27轮左寄存器时, 第30轮中间状态差分特性表, 由于步骤1) 中计算得出16 bit Δ<i>xL</i><mathml id="225"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml> (0≤<i>i</i>&lt;16) , 因此仅需构建第30轮左寄存器内部差分特性表。</p>
                </div>
                <div class="p1">
                    <p id="226">3) 将步骤1) 中所得16 bit Δ<i>xL</i><mathml id="227"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml> (0≤<i>i</i>&lt;16) 与步骤2) 中所构建的第30轮左寄存器内部状态差分特性表匹配, 即能够确定第<i>r</i>=27轮左寄存器内故障注入位置。</p>
                </div>
                <div class="p1">
                    <p id="228">由于差分特性表中的故障确定状态较少, 因此实际攻击中确定故障成功率为89.4%。为能够在差分特性表中有更多确定信息, 将步骤2) 改进为在第28轮左寄存器<i>xL</i><mathml id="229"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>注入单比特随机故障, 通过计算3轮故障确定信息构建第30轮中间状态差分 (xL<mathml id="230"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>, i=0, 1, …, 15) 特性, 如表5所示。</p>
                </div>
                <div class="area_img" id="231">
                    <p class="img_tit"><b>表5 第30轮中间状态差分特性表</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="231" border="1"><tr><td><br />故障注入位置</td><td>第30轮中间状态差分值</td></tr><tr><td><br /><i>xL</i><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>0</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>1</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>2</mn></mrow></msubsup></mrow></math></td><td>1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>3</mn></mrow></msubsup></mrow></math></td><td>0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>4</mn></mrow></msubsup></mrow></math></td><td>0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>5</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>6</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>7</mn></mrow></msubsup></mrow></math></td><td>0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>8</mn></mrow></msubsup></mrow></math></td><td>0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i>, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>9</mn></mrow></msubsup></mrow></math></td><td>0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0, <i>x</i></td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>0</mn></mrow></msubsup></mrow></math></td><td><i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>1</mn></mrow></msubsup></mrow></math></td><td>0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></td><td>0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>3</mn></mrow></msubsup></mrow></math></td><td>0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>4</mn></mrow></msubsup></mrow></math></td><td>0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i>, 0</td></tr><tr><td><br />xL<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mn>1</mn><mn>5</mn></mrow></msubsup></mrow></math></td><td>0, 0, 0, 0, 0, <i>x</i>, 0, 0, 0, <i>x</i>, <i>x</i>, 0, 0, 1, <i>x</i>, <i>x</i></td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="232">在表5中的差分值确定状态较多, 能够有效提高故障注入位置判定准确率。因此, 本文选取第28轮左寄存器注入随机单比特故障, 计算故障注入位置的算法具体如下:</p>
                </div>
                <div class="p1">
                    <p id="233"><b>输入</b> 正确密文<i>C</i>和故障密文<i>C</i><sup>*</sup></p>
                </div>
                <div class="p1">
                    <p id="234"><b>输出</b> 第28轮故障注入索引值<i>index</i></p>
                </div>
                <div class="p1">
                    <p id="235"><b>初始化</b> 加密字<i>n</i>←16;<i>σ</i>[<i>n</i>][<i>n</i>]←0;//<i>n</i>行×<i>n</i>列差分</p>
                </div>
                <div class="p1">
                    <p id="236">//特性表</p>
                </div>
                <div class="p1">
                    <p id="237">1.随机生成明文P和主密钥MK, 正确运行SIMECK32/64算法得到密文C;</p>
                </div>
                <div class="p1">
                    <p id="238">2.在同一明文P和密钥MK下重启加密, 当加密运行至第28轮时, 向左寄存器内部随机注入单比特故障, 加密至故障密文输出C<sup>*</sup>;</p>
                </div>
                <div class="p1">
                    <p id="239">for i=0 to n-1</p>
                </div>
                <div class="p1">
                    <p id="240">for j=0 to n-1</p>
                </div>
                <div class="p1">
                    <p id="241">根据2.3节原理计算xL<mathml id="242"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mtext>j</mtext></msubsup></mrow></math></mathml>是否为故障传播状态</p>
                </div>
                <div class="p1">
                    <p id="243">if  故障确定能传播至xL<mathml id="244"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mtext>j</mtext></msubsup></mrow></math></mathml>then</p>
                </div>
                <div class="p1">
                    <p id="245">σ[i][j]=1;</p>
                </div>
                <div class="p1">
                    <p id="246">else if故障确定不会传播至xL<mathml id="247"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mtext>j</mtext></msubsup></mrow></math></mathml>then</p>
                </div>
                <div class="p1">
                    <p id="248">σ[i][j]=1;</p>
                </div>
                <div class="p1">
                    <p id="249">else</p>
                </div>
                <div class="p1">
                    <p id="250">σ[i][j]=x;</p>
                </div>
                <div class="p1">
                    <p id="251">end if</p>
                </div>
                <div class="p1">
                    <p id="252">end for</p>
                </div>
                <div class="p1">
                    <p id="253">for i=0 to n-1</p>
                </div>
                <div class="p1">
                    <p id="254">ΔxL<sub>30</sub>[i]=xL<mathml id="255"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mtext>i</mtext></msubsup></mrow></math></mathml>⊕xL<mathml id="256"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mtext>i</mtext></mrow></msubsup></mrow></math></mathml>⊕ (xR<mathml id="257"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mtext>i</mtext></msubsup></mrow></math></mathml>&amp; (xR<mathml id="258"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mtext>i</mtext></msubsup></mrow></math></mathml>&lt;&lt;5) ) ⊕ (xR<sup>i</sup><sub>32</sub>&lt;&lt;1) ⊕ (xR<mathml id="259"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mtext>i</mtext></mrow></msubsup></mrow></math></mathml>&amp; (xR<mathml id="260"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mtext>i</mtext></mrow></msubsup></mrow></math></mathml>&lt;&lt;5) ) ⊕ (xR<mathml id="261"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>2</mn></mrow><mrow><mo>*</mo><mtext>i</mtext></mrow></msubsup></mrow></math></mathml>&lt;&lt;1) </p>
                </div>
                <div class="p1">
                    <p id="262">end for</p>
                </div>
                <div class="p1">
                    <p id="263">if ΔxL<mathml id="264"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mtext>i</mtext></msubsup></mrow></math></mathml> (0≤i&lt;16) 中‘0’和‘1’的位置与差分特性表中第i行匹配</p>
                </div>
                <div class="p1">
                    <p id="265">index=i;</p>
                </div>
                <div class="p1">
                    <p id="266">end if</p>
                </div>
                <div class="p1">
                    <p id="267">为充分验证算法的有效性, 进行160 000次仿真随机单比特故障注入实验, 其中正确判定故障注入位置159 368次, 成功率为99.61%。</p>
                </div>
                <h4 class="anchor-tag" id="268" name="268">3.4 等效代数方程自动化创建</h4>
                <h4 class="anchor-tag" id="269" name="269">3.4.1 基于正确加密的等效方程创建</h4>
                <div class="p1">
                    <p id="270">根据式 (1) 和式 (2) 可创建加密轮函数等效方程如式 (12) 所示。</p>
                </div>
                <div class="p1">
                    <p id="271" class="code-formula">
                        <mathml id="271"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><mi>i</mi></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mi>r</mi><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup><mo>=</mo><mn>0</mn></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="272">其中, <i>r</i>为加密轮数, 0≤<i>r</i>&lt;32, <i>i</i>为中间状态位置, 0≤<i>i</i>&lt;16。</p>
                </div>
                <div class="p1">
                    <p id="273">同理, 密钥扩展算法等效代数方程组构建如式 (13) 所示。</p>
                </div>
                <div class="p1">
                    <p id="274"><i>SK</i><mathml id="275"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>i</mi></msubsup></mrow></math></mathml>=<i>SK</i><mathml id="276"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>4</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>⊕ (<i>SK</i><mathml id="277"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>3</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>&amp; <i>SK</i><mathml id="278"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>) ⊕</p>
                </div>
                <div class="p1">
                    <p id="279"><i>SK</i><mathml id="280"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>r</mi><mo>-</mo><mn>3</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup></mrow></math></mathml>⊕<i>C</i>⊕<i>Z</i><sub><i>j</i></sub>      (13) </p>
                </div>
                <div class="p1">
                    <p id="281">由于SIMECK32/64前4轮密钥是由64 bit主密钥<i>MK</i>直接分解而来, 因此只需创建第4轮～第31轮的轮密钥等效方程。其中, <i>r</i>为加密轮数, 4≤<i>r</i>&lt;32, <i>i</i>为<i>SK</i><sub><i>r</i></sub>第<i>i</i>比特, 0≤<i>i</i>&lt;16。</p>
                </div>
                <h4 class="anchor-tag" id="282" name="282">3.4.2 基于故障信息的等效方程创建</h4>
                <div class="p1">
                    <p id="283">故障信息利用可分为故障加密等效方程和故障传播信息等效方程两部分, 其中故障加密等效方程创建原理及形式与式 (12) 类似, 下文主要阐述如何自动化创建故障扩散信息等效方程。</p>
                </div>
                <div class="p1">
                    <p id="284">故障扩散信息等效方程可分为3类:故障确定能扩散到的状态方程, 故障可能扩散到的状态方程以及故障确定不会扩散到的状态方程。</p>
                </div>
                <div class="p1">
                    <p id="285">随机单比特故障注入在左寄存器内<i>xL</i><mathml id="286"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mi>i</mi></msubsup></mrow></math></mathml>状态, 则故障确定能传播至的状态等效方程如式 (14) 所示。</p>
                </div>
                <div class="p1">
                    <p id="287" class="code-formula">
                        <mathml id="287"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mi>j</mi></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mi>j</mi></msubsup><mo>⊕</mo><mn>1</mn><mo>=</mo><mn>0</mn><mo>, </mo><mspace width="0.25em" /><mi>j</mi><mo>=</mo><mi>i</mi></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>j</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>j</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mn>1</mn><mo>=</mo><mn>0</mn><mo>, </mo><mi>j</mi><mo>=</mo><mi>i</mi></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>j</mi><mo>+</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>j</mi><mo>+</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mn>1</mn><mo>=</mo><mn>0</mn><mo>, </mo><mi>j</mi><mo>=</mo><mi>i</mi></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>1</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>j</mi><mo>+</mo><mn>1</mn><mn>3</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>1</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>j</mi><mo>+</mo><mn>1</mn><mn>3</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mn>1</mn><mo>=</mo><mn>0</mn><mo>, </mo><mi>j</mi><mo>=</mo><mi>i</mi></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="288">故障可能扩散至的状态等效方程如式 (15) 所示。</p>
                </div>
                <div class="p1">
                    <p id="289" class="code-formula">
                        <mathml id="289"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>j</mi></mrow></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mi>i</mi></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mi>i</mi></msubsup><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>8</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mi>i</mi></msubsup><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>6</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>6</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>7</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>6</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>6</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>3</mn><mn>0</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo><mo stretchy="false"> (</mo><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>&amp;</mo><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>4</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo stretchy="false">) </mo><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>x</mi><mi>L</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo>*</mo><mi>i</mi></mrow></msubsup><mo>⊕</mo><mi>x</mi><mi>R</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>⊕</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>S</mi><mi>Κ</mi><msubsup><mrow></mrow><mrow><mn>2</mn><mn>9</mn></mrow><mrow><mo stretchy="false"> (</mo><mi>i</mi><mo>+</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo><mi>%</mi><mn>1</mn><mn>6</mn></mrow></msubsup><mo>=</mo><mn>0</mn></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>5</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="290">同理, 可创建后续加密轮等效方程, 不再赘述。</p>
                </div>
                <div class="p1">
                    <p id="291">故障确定不会扩散至状态等效方程, 如式 (16) 所示。</p>
                </div>
                <div class="p1">
                    <p id="292"><i>xL</i><mathml id="293"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mrow><mo>*</mo><mi>j</mi></mrow></msubsup></mrow></math></mathml>⊕<i>xL</i><mathml id="294"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>r</mi><mi>j</mi></msubsup></mrow></math></mathml>=0, 0≤<i>j</i>&lt;16      (16) </p>
                </div>
                <div class="p1">
                    <p id="295">其中, 当<i>r</i>=28时, 0≤<i>j</i>&lt;16且<i>j</i>≠<i>i</i>;当<i>r</i>=29时, 0≤<i>j</i>&lt;16且<i>j</i>≠<i>i</i>, (<i>i</i>+11) %16, (<i>i</i>+15) %16;当<i>r</i>=30时, 0≤<i>j</i>&lt;16且<i>j</i>≠<i>i</i>, (<i>i</i>+6) %16, (<i>i</i>+10) %16, (<i>i</i>+11) %16, (<i>i</i>+14) %16, (<i>i</i>+15) %16;当<i>r</i>=31时, <i>j</i>= (<i>i</i>+2) %16, (<i>i</i>+3) %16, (<i>i</i>+4) %16, (<i>i</i>+7) %16, (<i>i</i>+8) %16, (<i>i</i>+12) %16;当<i>r</i>=32时, <i>j</i>= (<i>i</i>+2) %16, (<i>i</i>+3) %16, (<i>i</i>+7) %16。至此, 所有方程均已创建完毕, 且不需要为<i>i</i>=0, 1, …, 15分别创建方程, 自动化程度更高。</p>
                </div>
                <h3 id="296" name="296" class="anchor-tag">4 实验与结果分析</h3>
                <div class="p1">
                    <p id="297">在普通PC机 (CPU:Intel (R) Core (TM) i7-4790 @3.20 GHz, 内存8 GB, 64位Windows 7系统) 上, 使用C++语言编程仿真故障注入过程, 使用CryptoMinisat解析器 (4.4版本) 求解密钥方程。</p>
                </div>
                <h4 class="anchor-tag" id="298" name="298">4.1 改进的SIMECK32/64代数故障攻击实例</h4>
                <div class="p1">
                    <p id="299">改进的SIMECK32/64代数故障攻击实例具体步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="300">1) 开始随机生成32 bit明文<i>mP</i>为0x a78b 66ae, 64 bit主密钥<i>MK</i>为0x 8df3 629d 2671 cb13, 运行加密算法得到正确密文<i>C</i>为0x ea6f 0387, 并使用3.4.1节方法创建正确加密等效代数方程组。</p>
                </div>
                <div class="p1">
                    <p id="301">2) 同一明文和密钥下重启加密算法, 向加密第28轮左寄存器任意状态注入随机单比特故障, 设定故障样本量为8;利用3.3节原理判定故障注入索引值, 并利用3.4.2节方法创建故障信息方程组。</p>
                </div>
                <div class="p1">
                    <p id="302">3) 使用CryptoMinisat解析器求解步骤1) 和步骤2) 所构建方程组。64 bit主密钥编号为46～109, 其中, 正数表示该编号所代表变量值为1, 负数表示该编号变量所代表的变量值为0。求解出的密钥信息为:1000 1101 1111 0011 0110 0010 1001 1101 0010 0110 0111 0001 1100 1011 0001 0011, 转换为十六进制为0x 8df3 629d 2671 cb13, 与正确密钥信息一致, 攻击成功。</p>
                </div>
                <h4 class="anchor-tag" id="303" name="303">4.2 结果分析</h4>
                <div class="p1">
                    <p id="304">为验证实验结果有效性, 本文在故障样本量<i>N</i>=8下进行100次攻击实验, 结果如图6所示。</p>
                </div>
                <div class="area_img" id="305">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908002_305.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 故障样本量N=8时100组实验攻击结果" src="Detail/GetImg?filename=images/JSJC201908002_305.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图6 故障样本量<i>N</i>=8时100组实验攻击结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908002_305.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="306">从图6发现求解时间具有抖动性, 分析其原因为:1) 不同样本之间故障失效位置和数量有差异, 故障失效状态位置多的样本有效故障信息方程较少, 导致求解时间增加;2) CryptoMinisat解析器自身稳定性不足, 当方程组数量过多时可能导致求解时间具有波动性。因此为减少求解时间抖动性对实验结果的影响, 本文对每种故障样本量下进行100组攻击实验, 取平均值作为对应的密钥求解时间。</p>
                </div>
                <div class="p1">
                    <p id="307">为充分验证本文方法的正确性, 对不同故障样本量<i>N</i>下进行攻击实验, 每个故障样本量均进行100次攻击实验取平均值作为结果。密钥求解时间随故障注入数量的变化情况如图7所示。</p>
                </div>
                <div class="area_img" id="308">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201908002_308.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 密钥求解时间随故障注入数量的变化情况" src="Detail/GetImg?filename=images/JSJC201908002_308.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图7 密钥求解时间随故障注入数量的变化情况</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201908002_308.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="309">最少8次故障注入即可破解完整64 bit主密钥, 平均求解时间约为1 532 s。随着故障样本量增大, 密钥求解时间逐渐减小, 并且故障样本量越少, 求解时间减小趋势越明显;当故障样本量增加至15时, 密钥求解时间最短, 约为18.43 s。文献<citation id="377" type="reference">[<a class="sup">13</a>]</citation>差分故障攻击仅能破解最后一轮16 bit轮密钥, 而本文方法能够将故障注入更深的加密轮, 从而使得故障信息涉及全部主密钥, 并能够恢复完整64 bit主密钥信息, 且所需故障注入数量更少, 对密码安全性威胁更大。与文献<citation id="378" type="reference">[<a class="sup">14</a>]</citation>代数故障攻击相比, 本文通过深入分析故障确定传播状态, 结合SIMECK算法轮函数加密扩散缺陷, 将故障注入位置判定成功率由82.9%提高至99.61%, 并且本文在利用故障信息时, 增加了故障确定状态等效方程, 因此能够创建更多的有效故障信息方程, 将所需故障注入数量由9个减少至8个, 故障信息利用率更高。文献<citation id="379" type="reference">[<a class="sup">14</a>]</citation>需要离线构建故障注入在第0比特～第15比特全部方程组再进行选择, 而本文通过创建通用方程, 判定故障注入位置后进行动态创建方程, 自动化程度更高。</p>
                </div>
                <h3 id="310" name="310" class="anchor-tag">5 结束语</h3>
                <div class="p1">
                    <p id="311">本文针对轻量级分组密码SIMECK32/64提出一种改进的代数故障攻击方法, 通过分析轮函数扩散缺陷和提取故障确定传播状态构建差分特性表, 将故障攻击成功率提高至99.61%, 且仅需8次故障注入即可恢复完整64 bit主密钥信息。下一步可将本文方法扩展至其他轻量级分组密码算法, 并使故障注入更深轮, 提高故障信息利用率。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="331">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Fault-algebraic attacks on inner rounds of DES">

                                <b>[1]</b> COURTOIS N, WARE D, JACKSON K.Fault-algebraic attacks on inner rounds of DES[EB/OL].[2018-06-05].https://www.researchgate.net/publication/264885998_Fault-Algebraic_Attacks_on_Inner_Rounds_of_DES.
                            </a>
                        </p>
                        <p id="333">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Defferential fault analysis of secret key cryptosytems">

                                <b>[2]</b> BIHAM E, SHAMIR A.Differential fault analysis of secret key cryptosystems[C]//Proceedings of the 17th Annual International Cryptology Conference on Advances in Cryptology.New York, USA:ACM Press, 1997:513-525.
                            </a>
                        </p>
                        <p id="335">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=TXXB201208009&amp;v=MDE5NjllUnFGeS9nVUwvQk1UWFRiTEc0SDlQTXA0OUZiWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVo=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> 吴克辉, 赵新杰, 王韬, 等.PRESENT密码代数故障攻击[J].通信学报, 2012, 33 (8) :85-92.
                            </a>
                        </p>
                        <p id="337">
                            <a id="bibliography_4" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201304019&amp;v=MjgyODlqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVScUZ5L2dVTC9CTHo3QmRyRzRIOUxNcTQ5RWJZUUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[4]</b> 赵新杰, 郭世泽, 王韬, 等.Piccolo密码代数故障分析研究[J].计算机学报, 2013, 36 (4) :882-894.
                            </a>
                        </p>
                        <p id="339">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Algebraic fault attack on the SHA-256 compression function">

                                <b>[5]</b> HAO Ronglin, LI Bao, MA Bingke, et al.Algebraic fault attack on the SHA-256 compression function[J].International Journal of Research in Computer Science, 2014, 4 (2) :1-7.
                            </a>
                        </p>
                        <p id="341">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The simeck family of lightweight block ciphers">

                                <b>[6]</b> YANG Gangqiang, ZHU Bo, SUDER V, et al.The SIMECK family of lightweight block ciphers[C]//Proceedings of International Workshop on Cryptographic Hardware and Embedded Systems.Berlin, Germany:Springer, 2015:307-329.
                            </a>
                        </p>
                        <p id="343">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=State of the art in lightweight symmetric cryptography">

                                <b>[7]</b> BIRYUKOV A, PERRIN L P.State of the art in lightweight symmetric cryptography[EB/OL].[2018-06-05].https://eprint.iacr.org/2017/511.
                            </a>
                        </p>
                        <p id="345">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=PRESENT:an ultra-lightweight block cipher">

                                <b>[8]</b> BOGDANOV A, KNUDSEN L R, LEANDER G, et al.PRESENT:an ultra-lightweight block cipher[C]//Proceedings of International Workshop on Cryptographic Hardware and Embedded Systems.Berlin, Germany:Springer, 2007:450-466.
                            </a>
                        </p>
                        <p id="347">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Differential security evaluation of SIMECK with dynamic key-guessing techniques">

                                <b>[9]</b> QIAO Kexin, HU Lei, SUN Siwei.Differential security evaluation of SIMECK with dynamic key-guessing techniques[C]//Proceedings of International Conference on Information Systems Security and Privacy.Berlin, Germany:Springer, 2015:74-84.
                            </a>
                        </p>
                        <p id="349">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201704024&amp;v=MTg3NDdUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJxRnkvZ1VML0JMejdCYmJHNEg5Yk1xNDlIWUlRS0RIODR2UjQ=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b> 陈彦琴, 张文英.SIMECK32/64算法的不可能差分分析[J].计算机工程, 2017, 43 (4) :141-144.
                            </a>
                        </p>
                        <p id="351">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Security evaluation on SIMECK against zero-correlation linear cryptanalysis">

                                <b>[11]</b> ZHANG Kai, GUAN Jie, HU Bin, et al.Security evaluation on SIMECK against zero-correlation linear cryptanalysis[EB/OL].[2018-06-05].https://eprint.iacr.org/2015/911.
                            </a>
                        </p>
                        <p id="353">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Linear cryptanalysis of reduced-round SIMECK variants">

                                <b>[12]</b> BAGHERI N.Linear cryptanalysis of reduced-round SIMECK variants[C]//Proceedings of INDOCRYPT’15.Berlin, Germany:Springer, 2015:140-152.
                            </a>
                        </p>
                        <p id="355">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Differential fault attack on SIMECK">

                                <b>[13]</b> SARASWAT V.Differential fault attack on SIMECK[C]//Proceedings of Workshop on Cryptography and Security in Computing Systems.New York, USA:ACM Press, 2016:45-48.
                            </a>
                        </p>
                        <p id="357">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Differential fault attack on SIMECK">

                                <b>[14]</b> NALLA V, SAHU, R A, SARASWAT V.Differential fault attack on SIMECK[C]//Proceedings of Workshop on Cryptography and Security in Computing Systems.New York, USA:ACM Press, 2016:45-48.
                            </a>
                        </p>
                        <p id="359">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787030450227000&amp;v=MDcxNjhYRnF6R2JPN0h0WEpyNDFIWStzUERCTTh6eFVTbURkOVNIN24zeEU5ZmJ2bktyaWZadTl1RkN2aFU3ak5JMTRk&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b> JOYE M, TUNSTALL M.密码故障分析与防护[M].赵新杰, 郭世泽, 张帆, 等译.北京:科学出版社, 2015.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->

            <div class="btn-downloads">
                <span>
                    <a class="caj" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=D1GbEh2UOJEMalTMyRDNzs0SORzLX5mZvEWYiZ2ZqR0LxtWWoRzTxJmRnlDUiV1cSd3RmZVTqJWbklXaVNEUxwGaMtkZ5MWTv4mZ2FGZuR0TzM1dVFkelx0aTh0crZVdOdlb59yaUJVTyVnV4YmViBjNXNWeFtCZ&tablename=CJFDLAST2019">CAJ下载</a>
                    <a class="pdf" target="_blank" href="http://kns.cnki.net/kns/download.aspx?filename=D1GbEh2UOJEMalTMyRDNzs0SORzLX5mZvEWYiZ2ZqR0LxtWWoRzTxJmRnlDUiV1cSd3RmZVTqJWbklXaVNEUxwGaMtkZ5MWTv4mZ2FGZuR0TzM1dVFkelx0aTh0crZVdOdlb59yaUJVTyVnV4YmViBjNXNWeFtCZ&tablename=CJFDLAST2019&dflag=pdfdown">PDF下载</a>
                </span>
                <p>永久保存本文,请下载至本地</p>
            </div>


    </div>

        <input id="fileid" type="hidden" value="JSJC201908002" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201908002&amp;v=MTUxNDlqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVScUZ5L2dVTC9PTHo3QmJiRzRIOWpNcDQ5RlpvUUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9xck9nSjc1VXR3SDJsaTcyc24rQT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
            <a class="icon" id="copytext" target="_blank" href="http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908002&amp;filesourcetype=1">划线</a>
            <a class="icon" id="copytext" target="_blank" href="http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908002&amp;filesourcetype=1">笔记</a>
            <a class="icon" id="copytext" target="_blank" href="http://x.cnki.net/search/common/testlunbo?dbcode=CJFD&amp;tablename=CJFDLAST2019&amp;filename=JSJC201908002&amp;filesourcetype=1">文摘</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
