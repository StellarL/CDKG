<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637126276176802500%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201909012%26RESULT%3d1%26SIGN%3dMw1jQIOH62hyDF91VFP4%252fpJWGmM%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201909012&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201909012&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201909012&amp;v=MzI2OTN5SGtWcjdNTHo3QmJiRzRIOWpNcG85RVpvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSdEY=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#33" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#40" data-title="1 相关工作 ">1 相关工作</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#41" data-title="1.1 符号说明">1.1 符号说明</a></li>
                                                <li><a href="#57" data-title="1.2 极化码构造">1.2 极化码构造</a></li>
                                                <li><a href="#59" data-title="1.3 树结构SC译码">1.3 树结构SC译码</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#100" data-title="2 GA-DE方法与Tal-Vardy方法 ">2 GA-DE方法与Tal-Vardy方法</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#101" data-title="2.1 GA-DE方法">2.1 GA-DE方法</a></li>
                                                <li><a href="#109" data-title="2.2 &lt;i&gt;Tal&lt;/i&gt;-&lt;i&gt;Vardy&lt;/i&gt;方法">2.2 <i>Tal</i>-<i>Vardy</i>方法</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#118" data-title="3 快速MC构造方法 ">3 快速MC构造方法</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#125" data-title="3.1 TPMC方法">3.1 TPMC方法</a></li>
                                                <li><a href="#143" data-title="3.2 TPMC方法的复杂度分析">3.2 TPMC方法的复杂度分析</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#148" data-title="4 仿真结果与分析 ">4 仿真结果与分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#150" data-title="4.1 最优&lt;i&gt;M&lt;/i&gt;值">4.1 最优<i>M</i>值</a></li>
                                                <li><a href="#152" data-title="4.2 有效性分析">4.2 有效性分析</a></li>
                                                <li><a href="#158" data-title="4.3 高维核矩阵极化码性能分析">4.3 高维核矩阵极化码性能分析</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#164" data-title="5 结束语 ">5 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#62" data-title="&lt;b&gt;图1 树结构SC译码示意图&lt;/b&gt;"><b>图1 树结构SC译码示意图</b></a></li>
                                                <li><a href="#146" data-title="&lt;b&gt;表1 2种方法的复杂度对比情况&lt;/b&gt;"><b>表1 2种方法的复杂度对比情况</b></a></li>
                                                <li><a href="#154" data-title="&lt;b&gt;图2 2种方法构造的极化码在SC译码下的&lt;/b&gt;&lt;i&gt;FER&lt;/i&gt;结果"><b>图2 2种方法构造的极化码在SC译码下的</b><i>FER</i>结果</a></li>
                                                <li><a href="#156" data-title="&lt;b&gt;图3 不同冻结位数的极化码在SC译码下的&lt;/b&gt;&lt;i&gt;FER&lt;/i&gt;结果"><b>图3 不同冻结位数的极化码在SC译码下的</b><i>FER</i>结果</a></li>
                                                <li><a href="#160" data-title="&lt;b&gt;图4 TPMC与GA-DE构造的&lt;/b&gt;&lt;i&gt;&lt;b&gt;G&lt;/b&gt;&lt;/i&gt;&lt;mathml id=&quot;243&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;⊗&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;/math&gt;&lt;/mathml&gt;&lt;b&gt;在&lt;/b&gt;&lt;i&gt;LSC&lt;/i&gt;&lt;b&gt;下的&lt;/b&gt;&lt;i&gt;&lt;b&gt;FER&lt;/b&gt;&lt;/i&gt;&lt;b&gt;结果&lt;/b&gt;"><b>图4 TPMC与GA-DE构造的</b><i><b>G</b></i><mathml id="243"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml><b>在</b><i>LSC</i><b>下的</b><i><b>FER</b></i><b>结果</b></a></li>
                                                <li><a href="#161" data-title="&lt;b&gt;图5 TPMC与GA-DE构造的&lt;/b&gt;&lt;i&gt;&lt;b&gt;G&lt;/b&gt;&lt;/i&gt;&lt;mathml id=&quot;244&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;⊗&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;/math&gt;&lt;/mathml&gt;&lt;b&gt;在&lt;/b&gt;&lt;i&gt;LSC&lt;/i&gt;&lt;b&gt;下的&lt;/b&gt;&lt;i&gt;&lt;b&gt;FER&lt;/b&gt;&lt;/i&gt;&lt;b&gt;结果&lt;/b&gt;"><b>图5 TPMC与GA-DE构造的</b><i><b>G</b></i><mathml id="244"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml><b>在</b><i>LSC</i><b>下的</b><i><b>FER</b></i><b>结果</b></a></li>
                                                <li><a href="#163" data-title="&lt;b&gt;图6 &lt;/b&gt;&lt;i&gt;G&lt;/i&gt;&lt;mathml id=&quot;251&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;⊗&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;/math&gt;&lt;/mathml&gt;&lt;b&gt;和G&lt;/b&gt;&lt;mathml id=&quot;252&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mo&gt;⊗&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;/math&gt;&lt;/mathml&gt;&lt;b&gt;极化码在&lt;/b&gt;&lt;i&gt;LSC&lt;/i&gt;译码下的FER结果"><b>图6 </b><i>G</i><mathml id="251"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml><b>和G</b><mathml id="252"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo>⊗</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></mathml><b>极化码在</b><i>LSC</i>译码下的FER结果</a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="285">


                                    <a id="bibliography_1" >
                                        <b>[1]</b>
                                     ARIKAN E.Channel polarization:a method for constructing capacity-achieving codes for symmetric binary-input memoryless channels[J].IEEE Transactions on Information Theory,2009,55(7):3051-3073.</a>
                                </li>
                                <li id="287">


                                    <a id="bibliography_2" title=" RICHARDSON T J,URBANKE R.Modern coding theory[M].Cambridge,USA:MIT Press,2008." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Modern coding theory">
                                        <b>[2]</b>
                                         RICHARDSON T J,URBANKE R.Modern coding theory[M].Cambridge,USA:MIT Press,2008.
                                    </a>
                                </li>
                                <li id="289">


                                    <a id="bibliography_3" >
                                        <b>[3]</b>
                                     MORI R,TANAKA T.Performance of polar codes with the construction using density evolution[J].IEEE Commu-nications Letters,2009,13(7):519-521.</a>
                                </li>
                                <li id="291">


                                    <a id="bibliography_4" >
                                        <b>[4]</b>
                                     TRIFONOV P.Efficient design and decoding of polar codes[J].IEEE Transactions on Communications,2012,60(11):3221-3227.</a>
                                </li>
                                <li id="293">


                                    <a id="bibliography_5" title=" 刘亚军,李世宝,刘建航,等.一种低时延极化码列表连续删除译码算法[J].计算机工程,2018,44(3):78-81." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201803013&amp;v=MDY0MjViRzRIOW5Nckk5RVo0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSdEZ5SGtWcjdNTHo3QmI=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         刘亚军,李世宝,刘建航,等.一种低时延极化码列表连续删除译码算法[J].计算机工程,2018,44(3):78-81.
                                    </a>
                                </li>
                                <li id="295">


                                    <a id="bibliography_6" title=" TAL I,VARDY A.How to construct polar codes[J].IEEE Transactions on Information Theory,2013,59(10):6562-6582." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=How to construct polar codes">
                                        <b>[6]</b>
                                         TAL I,VARDY A.How to construct polar codes[J].IEEE Transactions on Information Theory,2013,59(10):6562-6582.
                                    </a>
                                </li>
                                <li id="297">


                                    <a id="bibliography_7" title=" CHUNG S Y,RICHARDSON T,URBANKE R.Analysis of sum-product decoding of low-density parity-check codes using a Gaussian approximation[J].IEEE Transactions on Information Theory,2001,47(2):657-670." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Analysis of sum-product decoding of low-density parity-check codes using a Gaussian approximation">
                                        <b>[7]</b>
                                         CHUNG S Y,RICHARDSON T,URBANKE R.Analysis of sum-product decoding of low-density parity-check codes using a Gaussian approximation[J].IEEE Transactions on Information Theory,2001,47(2):657-670.
                                    </a>
                                </li>
                                <li id="299">


                                    <a id="bibliography_8" title=" KORADA S B,SASOGLU E,URBANKE R.Polar codes:characterization of exponent,bounds,and constructions[J].IEEE Transactions on Information Theory,2010,56(12):6253-6264." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Polar codes: Characterization of exponent, bounds, and constructions">
                                        <b>[8]</b>
                                         KORADA S B,SASOGLU E,URBANKE R.Polar codes:characterization of exponent,bounds,and constructions[J].IEEE Transactions on Information Theory,2010,56(12):6253-6264.
                                    </a>
                                </li>
                                <li id="301">


                                    <a id="bibliography_9" title=" PRESMAN N,SHAPIRA O,LITSYN T,et al.Binary polarization kernels from code decompositions[J].IEEE Transactions on Information Theory,2015,61(5):2227-2239." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Binary Polarization Kernels from Code Decompositions">
                                        <b>[9]</b>
                                         PRESMAN N,SHAPIRA O,LITSYN T,et al.Binary polarization kernels from code decompositions[J].IEEE Transactions on Information Theory,2015,61(5):2227-2239.
                                    </a>
                                </li>
                                <li id="303">


                                    <a id="bibliography_10" title=" LIN H P,LIN Shu,ABDEL-GHAFFAR K A S.Linear and nonlinear binary kernels of polar codes of small dimensions with maximum exponents[J].IEEE Transactions on Information Theory,2015,61(10):5253-5270." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Linear and Nonlinear Binary Kernels of Polar Codes of Small Dimensions With Maximum Exponents">
                                        <b>[10]</b>
                                         LIN H P,LIN Shu,ABDEL-GHAFFAR K A S.Linear and nonlinear binary kernels of polar codes of small dimensions with maximum exponents[J].IEEE Transactions on Information Theory,2015,61(10):5253-5270.
                                    </a>
                                </li>
                                <li id="305">


                                    <a id="bibliography_11" >
                                        <b>[11]</b>
                                     WU Dalong,LI Ying,SUN Yue.Construction and block error rate analysis of polar codes over AWGN channel based on Gaussian approximation[J].IEEE Commu-nications Letters,2014,18(7):1099-1102.</a>
                                </li>
                                <li id="307">


                                    <a id="bibliography_12" title=" SUN Shuanghong,ZHANG Zhengya.Designing practical polar codes using simulation-based bit selection[J].IEEE Journal on Emerging and Selected Topics in Circuits and Systems,2017,7(4):594-603." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Designing practical polar codes using simulation-based bit selection">
                                        <b>[12]</b>
                                         SUN Shuanghong,ZHANG Zhengya.Designing practical polar codes using simulation-based bit selection[J].IEEE Journal on Emerging and Selected Topics in Circuits and Systems,2017,7(4):594-603.
                                    </a>
                                </li>
                                <li id="309">


                                    <a id="bibliography_13" title=" ALAMDAR-YAZDI A,KSCHISCHANG F R.A simplied successive cancellation decoder for polar codes[J].IEEE Communications Letters,2011,15(12):1378-1380." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A simplified successive-cancellation decoder for polar codes">
                                        <b>[13]</b>
                                         ALAMDAR-YAZDI A,KSCHISCHANG F R.A simplied successive cancellation decoder for polar codes[J].IEEE Communications Letters,2011,15(12):1378-1380.
                                    </a>
                                </li>
                                <li id="311">


                                    <a id="bibliography_14" title=" HUANG Zhiliang,ZHANG Shiyi,ZHANG Feiyan,et al.On the successive cancellation decoding of polar codes with arbitrary linear binary kernels[EB/OL].[2018-06-20].http://pdfs.semanticscholar.org/ebf7/58e65c95a81c4ab01 494fb70ed535a631846.pdf." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On the successive cancellation decoding of polar codes with arbitrary linear binary kernels">
                                        <b>[14]</b>
                                         HUANG Zhiliang,ZHANG Shiyi,ZHANG Feiyan,et al.On the successive cancellation decoding of polar codes with arbitrary linear binary kernels[EB/OL].[2018-06-20].http://pdfs.semanticscholar.org/ebf7/58e65c95a81c4ab01 494fb70ed535a631846.pdf.
                                    </a>
                                </li>
                                <li id="313">


                                    <a id="bibliography_15" title=" HUANG Zhiliang,ZHANG Shiyi,ZHANG Feiyan,et al.Simplified successive cancellation decoding of polar codes with medium-dimensional binary kernels[J].IEEE Access,2018,6(1):26707-26717." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Simplified Successive Cancellation Decoding of Polar Codes with Medium-dimensional Binary Kernels">
                                        <b>[15]</b>
                                         HUANG Zhiliang,ZHANG Shiyi,ZHANG Feiyan,et al.Simplified successive cancellation decoding of polar codes with medium-dimensional binary kernels[J].IEEE Access,2018,6(1):26707-26717.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(09),76-81 DOI:10.19678/j.issn.1000-3428.0052038            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>一种基于蒙特卡洛的快速极化码构造方法</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BC%A0%E6%96%BD%E6%80%A1&amp;code=37988395&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张施怡</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%BB%84%E5%BF%97%E4%BA%AE&amp;code=22445841&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">黄志亮</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%91%A8%E6%B0%B4%E7%BA%A2&amp;code=22445842&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">周水红</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%92%9F%E5%8F%91%E8%8D%A3&amp;code=09454534&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">钟发荣</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B5%99%E6%B1%9F%E5%B8%88%E8%8C%83%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AD%A6%E9%99%A2&amp;code=0075331&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">浙江师范大学数学与计算机科学学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>为快速构造高维核矩阵极化码,提出一种基于蒙特卡洛(MC)的两阶段极化码构造方法TPMC。在第1阶段,利用具有线性复杂度的高斯近似方法获取最可靠和最不可靠的2种位。在第2阶段,将上述2种位固定为冻结位并执行MC方法,以衡量剩余位信道的差错概率,从剩余位中挑选差错概率较低的位并与第1阶段中最可靠的位组成极化码的信息位集合。仿真结果表明,与MC方法相比,TPMC方法能够降低计算复杂度,提高译码效率。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%B8%A4%E9%98%B6%E6%AE%B5%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">两阶段蒙特卡洛;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%AB%98%E7%BB%B4%E6%A0%B8%E7%9F%A9%E9%98%B5&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">高维核矩阵;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%9E%81%E5%8C%96%E7%A0%81%E6%9E%84%E9%80%A0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">极化码构造;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%BF%9E%E7%BB%AD%E6%B6%88%E5%8E%BB%E8%AF%91%E7%A0%81&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">连续消去译码;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%AB%98%E6%96%AF%E8%BF%91%E4%BC%BC&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">高斯近似;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    张施怡(1996—),女,硕士研究生,主研方向为极化码构造;;
                                </span>
                                <span>
                                    *黄志亮(通信作者),讲师、博士;E-mail:zlhuang@ zjnu. cn;
                                </span>
                                <span>
                                    周水红,实验师、硕士;;
                                </span>
                                <span>
                                    钟发荣,教授、博士。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-07-09</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金(61401399);</span>
                                <span>浙江省自然科学基金(LY18F010017);</span>
                    </p>
            </div>
                    <h1><b>A Fast Polar Code Construction Method Based on Monte Carlo</b></h1>
                    <h2>
                    <span>ZHANG Shiyi</span>
                    <span>HUANG Zhiliang</span>
                    <span>ZHOU Shuihong</span>
                    <span>ZHONG Farong</span>
            </h2>
                    <h2>
                    <span>College of Mathematics and Computer Science,Zhejiang Normal University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>In order to construct high-dimensional core matrix polar codes quickly,a two-stage polar code construction method TPMC based on Monte Carlo(MC) is proposed.In the first stage,the most reliable and unreliable bits are obtained by using the Gauss approximation method with linear complexity.In the second stage,the above bits are fixed as frozen bits and MC method is implemented to measure the error rate of the remaining bit channels.The bits with a lower error rate are selected from the remaining bits,and are combined with most reliable information bits in the first stage to form an information bits set.Simulation results show that compared with MC method,TPMC method can reduce the computational complexity and improve the decoding efficiency.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=two-stage%20Monte%20Carlo(MC)&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">two-stage Monte Carlo(MC);</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=high-dimensional%20core%20matrix&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">high-dimensional core matrix;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=polar%20code%20construction&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">polar code construction;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Successive%20Cancellation(SC)%20decoding&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Successive Cancellation(SC) decoding;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Gauss%20approximation&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Gauss approximation;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-07-09</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="33" name="33" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="34">文献<citation id="315" type="reference">[<a class="sup">1</a>]</citation>提出的极化码被证明在连续消去(Successive Cancellation,SC)译码算法下,可以达到二进制输入对称离散无记忆信道(Binary Discrete Memoryless Channels,B-DMCs)的对称信道容量,并且具有多项式级数的编译码复杂度。尽管极化码的构造方法明确,但其仅能够在二进制删除信道(Binary Erasure Channel,BEC)下实现。文献<citation id="319" type="reference">[<a class="sup">2</a>,<a class="sup">3</a>]</citation>得出在一般信道下,密度进化(Density Evolution,DE)方法是一种构造极化码的有效工具。基于DE方法,文献<citation id="320" type="reference">[<a class="sup">4</a>,<a class="sup">5</a>,<a class="sup">6</a>]</citation>提出2种方法用于2×2维核矩阵极化码的构造:高斯近似DE(GA-DE)<citation id="321" type="reference"><link href="291" rel="bibliography" /><link href="293" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>]</sup></citation>和Tal-Vardy<citation id="316" type="reference"><link href="295" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>。GA-DE方法具备线性的复杂度,且其构造的极化码性能较好<citation id="317" type="reference"><link href="297" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>。Tal-Vardy能够提供信道升级和降级2种近似量化DE方法,原位信道夹在由这2种方法构造的位信道之间。上述2种近似方法构造出的极化码非常接近<citation id="318" type="reference"><link href="295" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>,且Tal-Vardy被认为是较优的极化码构造方法。</p>
                </div>
                <div class="p1">
                    <p id="35">文献<citation id="322" type="reference">[<a class="sup">1</a>]</citation>中的极化码是基于核矩阵<image id="284" type="formula" href="images/JSJC201909012_28400.jpg" display="inline" placement="inline"><alt></alt></image><image id="284" type="formula" href="images/JSJC201909012_28401.jpg" display="inline" placement="inline"><alt></alt></image>。文献<citation id="323" type="reference">[<a class="sup">8</a>]</citation>研究表明,当m≥16时,高维核矩阵<i><b>G</b></i><sub><i>m</i></sub>的极化速率高于原<i><b>G</b></i><sub>2</sub>核矩阵。在相同码长情况下,较高的极化速率表明相应的极化码有较低的译码差错概率。在文献的基础上,许多研究者设计出具有较高极化速率的高维核矩阵,但是仍缺乏有效方法构造出相应的极化码。</p>
                </div>
                <div class="p1">
                    <p id="38">构造高维核矩阵(维数大于等于3)极化码最直接的方式是将GA-DE方法和Tal-Vardy方法从<i><b>G</b></i><sub>2</sub>推广到高维核矩阵,但该方式存在一定局限。GA-DE方法推广至高维核矩阵极化码时会引起一定的译码性能损失。Tal-Vardy方法直接推广至高维核矩阵极化码会导致其复杂度随核矩阵维数呈指数级增加。另一种方式是文献<citation id="324" type="reference">[<a class="sup">1</a>]</citation>提出的基于蒙特卡洛(Monte Carlo,MC)的极化码构造方法,但其在后续研究中未得到广泛应用,仅文献<citation id="325" type="reference">[<a class="sup">11</a>,<a class="sup">12</a>]</citation>利用该方法来构造<i><b>G</b></i><sub>2</sub>核矩阵极化码。</p>
                </div>
                <div class="p1">
                    <p id="39">本文分析基于MC的极化码构造方法,将其推广至高维核矩阵中,提出一种两阶段蒙特卡洛方法(TPMC),以实现高维核矩阵极化码的快速构造。</p>
                </div>
                <h3 id="40" name="40" class="anchor-tag">1 相关工作</h3>
                <h4 class="anchor-tag" id="41" name="41">1.1 符号说明</h4>
                <div class="p1">
                    <p id="42">令<i>W</i>:<i>X</i>→<i>Y</i>为一个B-DMCs信道,其输入字母集为<i>X</i>={0,1},输出字母集为<i>Y</i>,条件转移概率为<i>W</i>(<i>y</i>|<i>x</i>)。符号<i><b>a</b></i><mathml id="166"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>j</mi></msubsup></mrow></math></mathml>表示一个行向量(a<sub>i</sub>,a<sub>i+1</sub>,…,a<sub>j</sub>)。如果i&gt;j,则<i><b>a</b></i><mathml id="167"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>i</mi><mi>j</mi></msubsup></mrow></math></mathml>=Ø。令<i>W</i><sup><i>N</i></sup>:<i>X</i><sup><i>N</i></sup>→<i>Y</i><sup><i>N</i></sup>表示由<i>N</i>个独立<i>W</i>组成的信道。因此,对于每个<i>x</i><mathml id="168"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>∈<i>X</i><mathml id="169"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>和y<mathml id="170"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>∈Y<mathml id="171"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>,转移概率为:</p>
                </div>
                <div class="p1">
                    <p id="43" class="code-formula">
                        <mathml id="43"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>W</mi><msup><mrow></mrow><mi>Ν</mi></msup><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">|</mo><mi>x</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></munderover><mi>W</mi></mstyle><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="44">令<i><b>G</b></i><sub><i>N</i></sub>=<i><b>B</b></i><sub><i>N</i></sub><i><b>G</b></i><mathml id="172"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>m</mi><mrow><mo>⊗</mo><mi>n</mi></mrow></msubsup></mrow></math></mathml>是N×N维的生成矩阵,其中,<i><b>B</b></i><sub><i>N</i></sub>是一个置换矩阵<citation id="326" type="reference"><link href="285" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>,<i><b>G</b></i><sub><i>m</i></sub>是一个<i>m</i>×<i>m</i>维的核矩阵,⨂<i>n</i>表示<i>n</i>倍的克罗内克积。本文使用的所有核矩阵均是线性最优核矩阵<citation id="327" type="reference"><link href="301" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>。向量信道<i>W</i><sub><i>N</i></sub>:<i>X</i><mathml id="173"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>→<i>Y</i><mathml id="174"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>定义为:</p>
                </div>
                <div class="p1">
                    <p id="45">W<sub>N</sub>(y<mathml id="175"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>|u<mathml id="176"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>)=W<sup>N</sup>(y<mathml id="177"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>|u<mathml id="178"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml><i><b>G</b></i><sub><i>N</i></sub>)</p>
                </div>
                <div class="p1">
                    <p id="46">其中,<i>u</i>表示消息序列。</p>
                </div>
                <div class="p1">
                    <p id="47">位信道<i>W</i><mathml id="179"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>:<i>X</i>→<i>Y</i><sup><i>N</i></sup>×<i>X</i><sup><i>i</i></sup>(0≤<i>i</i>≤<i>N</i>-1)定义为:</p>
                </div>
                <div class="p1">
                    <p id="48" class="code-formula">
                        <mathml id="48"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>W</mi><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo>,</mo><mi>u</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>u</mi><msubsup><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></munder><mrow><mfrac><mn>1</mn><mrow><mi>m</mi><msup><mrow></mrow><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></mfrac></mrow></mstyle><mi>W</mi><msub><mrow></mrow><mi>Ν</mi></msub><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">|</mo><mi>u</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="49">对于一个给定的核矩阵<i><b>G</b></i><sub><i>m</i></sub>,<i>W</i><sub><i><b>G</b></i></sub><sub><i>m</i></sub>:{0,1}<sup><i>m</i></sup>→<i>Y</i><sup><i>m</i></sup>定义为:</p>
                </div>
                <div class="p1">
                    <p id="50" class="code-formula">
                        <mathml id="50"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>W</mi><msub><mrow></mrow><mrow><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mi>m</mi></msub></mrow></msub><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">|</mo><mi>u</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">)</mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></munderover><mi>W</mi></mstyle><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">|</mo><mrow><mo stretchy="false">(</mo><mi>u</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false">)</mo></mrow><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="51">其中,(<i>u</i><sup><i>m</i></sup>-1<sub>0</sub><i><b>G</b></i><sub><i>m</i></sub>)<sub><i>i</i></sub>是向量<i>u</i><mathml id="180"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml><i><b>G</b></i><sub><i>m</i></sub>的第<i>i</i>个元素。</p>
                </div>
                <div class="p1">
                    <p id="52">对于SC译码,基本的递归计算公式(单步位信道计算公式)为:</p>
                </div>
                <div class="p1">
                    <p id="53" class="code-formula">
                        <mathml id="53"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>W</mi><msubsup><mrow></mrow><mrow><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mi>m</mi></msub></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo>,</mo><mi>u</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></mfrac><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>u</mi><msubsup><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></munder><mi>W</mi></mstyle><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="54">其中,<i>u</i><sub><i>i</i></sub>∈{0,1},<i>x</i><sub><i>i</i></sub>=(<i>u</i><sup><i>m</i></sup>-1<sub>0</sub><i><b>G</b></i><sub><i>m</i></sub>)<sub><i>i</i></sub>,<i>i</i>=0,1,…,<i>m</i>-1。</p>
                </div>
                <div class="p1">
                    <p id="55">用[<i>N</i>]表示{0,1,…,<i>N</i>-1}。对于2个实数<i>x</i>和<i>y</i>,操作◇定义为:</p>
                </div>
                <div class="p1">
                    <p id="56"><i>x</i>◇<i>y</i>=2atanh(tanh(<i>x</i>/2)tanh(<i>y</i>/2))</p>
                </div>
                <h4 class="anchor-tag" id="57" name="57">1.2 极化码构造</h4>
                <div class="p1">
                    <p id="58">构造一个<i>k</i>维的极化码即找到<i>k</i>个最可靠的位信道。文献<citation id="328" type="reference">[<a class="sup">1</a>]</citation>采用巴氏参数<i>Z</i>(<i>W</i><mathml id="181"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>)来评价位信道,从所有<i>N</i>个位信道中挑选<i>k</i>个具备最小<i>Z</i>(<i>W</i><sup>(</sup><i>i</i>)<sub><i>N</i></sub>)的位信道作为信息位集合。文献<citation id="329" type="reference">[<a class="sup">6</a>]</citation>使用更易操作的<i>Pe</i>(<i>W</i><mathml id="182"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>)对位信道进行排序,其中,<i>Pe</i>(<i>W</i><mathml id="183"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>)表示在最大似然判决下第<i>i</i>个位信道的差错概率。本文同样采用<i>Pe</i>(<i>W</i><mathml id="184"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>)来评价位信道。</p>
                </div>
                <h4 class="anchor-tag" id="59" name="59">1.3 树结构SC译码</h4>
                <div class="p1">
                    <p id="60">文献<citation id="330" type="reference">[<a class="sup">13</a>]</citation>将<i><b>G</b></i><sub>2</sub>核矩阵极化码的SC译码作为一个完全二进制树上的消息传递算法。本文将任意维的<i><b>G</b></i><sub><i>m</i></sub>核矩阵极化码的SC译码推广为一个完全<i>m</i>进制树上的消息传递算法。</p>
                </div>
                <div class="p1">
                    <p id="61">令<i>T</i><sub><i>n</i></sub>(<i>n</i>&gt;0)表示深度为<i>n</i>的完全<i>m</i>进制树,则<i>T</i><sub><i>n</i></sub>有<i>N</i>=<i>m</i><sup><i>n</i></sup>个叶子节点。给定一个节点<i>v</i>,分别用<i>d</i><sub><i>v</i></sub>、<i>p</i><sub><i>v</i></sub>和<i>v</i><sub>0</sub>,<i>v</i><sub>1</sub>,…,<i>v</i><sub><i>m</i></sub>-1表示节点<i>v</i>的深度、父节点和子节点,如图1(a)所示。在一般情况下,树的叶子节点索引集为{0,1,…,<i>N</i>-1}。在图1(b)中,<i>m</i>=3,<i>n</i>=2,信息节点集合<i>A</i>={4,6,7,8}。叶子节点0、1、2、3、5称为冻结节点。令<i>I</i><sub><i>v</i></sub>为节点<i>v</i>的后代中叶子节点所构成的索引集合,如果<i>I</i><sub><i>v</i></sub>中的节点都是冻结节点,则<i>T</i><sub><i>n</i></sub>中的一个中间节点<i>v</i>也称为冻结节点。注意在SC译码过程中,所有冻结节点的计算都可以忽略。</p>
                </div>
                <div class="area_img" id="62">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201909012_062.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 树结构SC译码示意图" src="Detail/GetImg?filename=images/JSJC201909012_062.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 树结构SC译码示意图</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201909012_062.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="63">对于每个节点<i>v</i>,存在一个转移概率二元组<i><b>P</b></i><sub><i>v</i></sub>(每个二元组包括一个概率对<i><b>P</b></i><sub><i>v</i></sub>[<i>i</i>],索引为<i><b>P</b></i><sub><i>v</i></sub>[<i>i</i>][0]和<i><b>P</b></i><sub><i>v</i></sub>[<i>i</i>][1])和二进制值数组<i>β</i><sub><i>v</i></sub>,<i><b>P</b></i><sub><i>v</i></sub>和<i>β</i><sub><i>v</i></sub>的长度都是<i>m</i><sup><i>n</i></sup>-<i>d</i><sub><i>v</i></sub>。SC译码算法首先激活<i>T</i><sub><i>n</i></sub>的根节点,根据接收到的信道输出计算每个节点的转移概率二元组值并赋给<i><b>P</b></i><sub><i>v</i></sub>。广度遍历下一层节点,计算每个节点的<i><b>P</b></i><sub><i>v</i></sub>和<i>β</i><sub><i>v</i></sub>,根据<i>T</i><sub><i>n</i></sub>叶子节点的<i><b>P</b></i><sub><i>v</i></sub>进行译码结果判决。</p>
                </div>
                <div class="p1">
                    <p id="64">令<i>v</i><sub><i>i</i></sub>为<i>v</i>的第<i>i</i>个子节点。给定<i><b>P</b></i><sub><i>v</i></sub>和<i>β</i><sub><i>v</i></sub><sub>0</sub>,<i>β</i><sub><i>v</i></sub><sub>1</sub>,…,<i>β</i><sub><i>vk</i></sub>-1,根据基本递归公式(3)可计算出<i><b>P</b></i><sub><i>vk</i></sub>。令*<i>l</i>表示(<i><b>P</b></i><sub><i>v</i></sub>[<i>ml</i>],<i><b>P</b></i><sub><i>v</i></sub>[<i>ml</i>+1],…,<i><b>P</b></i><sub><i>v</i></sub>[<i>ml</i>+<i>m</i>-1],(<i>β</i><sub><i>v</i></sub><sub>0</sub>[<i>l</i>],<i>β</i><sub><i>v</i></sub><sub>1</sub>[<i>l</i>],…,<i>β</i><sub><i>vi</i></sub>-1[<i>l</i>])),<i>l</i>∈0,1,…,<i>m</i><sup><i>n</i></sup>-<i>d</i><sub><i>v</i></sub>-1-1。令<i>f</i><sub><i>i</i></sub>0(*<i>l</i>)和<i>f</i><sub><i>i</i></sub>1(*<i>l</i>)分别表示任意维极化码在<i>v</i>和<i>v</i><sub><i>i</i></sub>节点之间的基本递归公式。*<i>l</i>作为<i>f</i><sub><i>i</i></sub>0(*<i>l</i>)和<i>f</i><sub><i>i</i></sub>1(*<i>l</i>)的输入,则<i>f</i><sub><i>i</i></sub>0(*<i>l</i>)和<i>f</i><sub><i>i</i></sub>1(*<i>l</i>)的计算步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="65">1)执行以下替换:</p>
                </div>
                <div class="p1">
                    <p id="66"><i><b>P</b></i><sub><i>v</i></sub>[<i>ml</i>+<i>j</i>][0]→<i>W</i>(<i>y</i><sub><i>j</i></sub>|<i>x</i><sub><i>j</i></sub>=0)</p>
                </div>
                <div class="p1">
                    <p id="67"><i><b>P</b></i><sub><i>v</i></sub>[<i>ml</i>+<i>j</i>][1]→<i>W</i>(<i>y</i><sub><i>j</i></sub>|<i>x</i><sub><i>j</i></sub>=1)</p>
                </div>
                <div class="p1">
                    <p id="68">(<i>β</i><sub><i>v</i></sub><sub>0</sub>[<i>l</i>],<i>β</i><sub><i>v</i></sub><sub>1</sub>[<i>l</i>],…,<i>β</i><sub><i>vi</i></sub>-1[<i>l</i>])→<i>u</i><mathml id="185"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="69">其中,l∈0,1,…,m<sup>n-d</sup><sub>v</sub>-1-1,j=0,1,…,m-1。</p>
                </div>
                <div class="p1">
                    <p id="70">2)计算f<sub>i0</sub>(*l):</p>
                </div>
                <div class="p1">
                    <p id="71">f<sub>i0</sub>(*l)=W<mathml id="186"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mi>m</mi></msub></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>(y<mathml id="187"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>,u<mathml id="188"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>|u<sub>i</sub>=0)      (4)</p>
                </div>
                <div class="p1">
                    <p id="72">即:</p>
                </div>
                <div class="p1">
                    <p id="73" class="code-formula">
                        <mathml id="73"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><msub><mrow></mrow><mrow><mi>i</mi><mn>0</mn></mrow></msub><mo stretchy="false">(</mo><mo>*</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></mfrac><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>u</mi><msubsup><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></munder><mi>W</mi></mstyle><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>5</mn><mo stretchy="false">)</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="74">其中,x<sub>j</sub>=(u<sup>m-1</sup><sub>0</sub><i><b>G</b></i><sub><i>m</i></sub>)<sub><i>j</i></sub>,<i>j</i>=0,1,…,<i>m</i>-1。</p>
                </div>
                <div class="p1">
                    <p id="75">对<i>f</i><sub><i>i</i></sub>0(*<i>l</i>)的计算作进一步解释,由于(<i>β</i><sub><i>v</i></sub><sub>0</sub>[<i>l</i>],<i>β</i><sub><i>v</i></sub><sub>1</sub>[<i>l</i>],…,<i>β</i><sub><i>vi</i></sub>-1[<i>l</i>])→<i>u</i><mathml id="189"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>和u<sub>i</sub>=0,则式(4)中u<mathml id="190"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>确定。给定一个u<mathml id="191"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>,式(5)中的每个x<sub>j</sub>=(u<sup>m-1</sup><sub>0</sub><i><b>G</b></i><sub><i>m</i></sub>)<sub><i>j</i></sub>,<i>j</i>∈0,1,…,<i>m</i>-1都可以确定。因此,对于式(5)中的每个<i>W</i>(<i>y</i><sub><i>j</i></sub>|<i>x</i><sub><i>j</i></sub>),<i>j</i>∈0,1,…,<i>m</i>-1可以通过<i><b>P</b></i><sub><i>v</i></sub>[<i>ml</i>+<i>j</i>][0]→<i>W</i>(<i>y</i><sub><i>j</i></sub>|<i>x</i><sub><i>j</i></sub>=0)和<i><b>P</b></i><sub><i>v</i></sub>[<i>ml</i>+<i>j</i>][1]→<i>W</i>(<i>y</i><sub><i>j</i></sub>|<i>x</i><sub><i>j</i></sub>=1)获得。因此,可由式(5)计算出<i>f</i><sub><i>i</i></sub>0(*<i>l</i>)。利用同样的步骤可以计算出<i>f</i><sub><i>i</i></sub>1(*<i>l</i>)。求得<i>f</i><sub><i>i</i></sub>0(*<i>l</i>)和<i>f</i><sub><i>i</i></sub>1(*<i>l</i>)后,可以得到:</p>
                </div>
                <div class="p1">
                    <p id="76"><i><b>P</b></i><sub><i>vi</i></sub>[<i>l</i>][0]=<i>f</i><sub><i>i</i></sub>0(*<i>l</i>),<i><b>P</b></i><sub><i>vi</i></sub>[<i>l</i>][1]=<i>f</i><sub><i>i</i></sub>1(*<i>l</i>)</p>
                </div>
                <div class="p1">
                    <p id="77">其中,<i>l</i>∈0,1,…,<i>m</i><sup><i>n</i></sup>-<i>d</i><sub><i>v</i></sub>-1-1。</p>
                </div>
                <div class="p1">
                    <p id="78">依据以上概念和定义,算法1给出基于消息传递的高维核矩阵<i><b>G</b></i><sub><i>m</i></sub>极化码SC译码过程。</p>
                </div>
                <div class="p1">
                    <p id="79"><b>算法1 </b><i>G</i><sub><i>m</i></sub>极化码的树结构SC译码过程</p>
                </div>
                <div class="p1">
                    <p id="80"><b>输入</b><i>y</i><mathml id="192"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="81"><b>输出</b> 译码码字<mathml id="193"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mstyle mathsize="140%" displaystyle="true"><mi>c</mi></mstyle><mrow><mspace width="0.25em" /><mo>^</mo></mrow></mover><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="82">初始化 激活根节点并将根节点v的P<sub>v</sub>赋值为P<sub>v</sub>=(P<sub>v</sub>[0],P<sub>v</sub>[1],…,P<sub>v</sub>[N-1]),其中,P<sub>v</sub>[i][0]=W(y<sub>i</sub>|x<sub>i</sub>=0),P<sub>v</sub>[i][1]=W(y<sub>i</sub>|x<sub>i</sub>=1),i=0,1,…,N-1</p>
                </div>
                <div class="p1">
                    <p id="83">1)中间节点:</p>
                </div>
                <h4 class="anchor-tag" id="84" name="84">(1)更新P<sub>v</sub></h4>
                <div class="p1">
                    <p id="85">当一个中间节点v被激活时,计算P<sub>v0</sub>:</p>
                </div>
                <div class="p1">
                    <p id="86" class="code-formula">
                        <mathml id="86"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mtext>Ρ</mtext><msub><mrow></mrow><mrow><mtext>v</mtext><msub><mrow></mrow><mn>0</mn></msub></mrow></msub><mo stretchy="false">[</mo><mtext>l</mtext><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mtext>f</mtext><msub><mrow></mrow><mrow><mn>0</mn><mn>0</mn></mrow></msub><mo stretchy="false">(</mo><mo>*</mo><mtext>l</mtext><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext>Ρ</mtext><msub><mrow></mrow><mrow><mtext>v</mtext><msub><mrow></mrow><mn>0</mn></msub></mrow></msub><mo stretchy="false">[</mo><mtext>l</mtext><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mtext>f</mtext><msub><mrow></mrow><mrow><mn>0</mn><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mo>*</mo><mtext>l</mtext><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="87">其中,l=0,1,…,m<sup>n-d</sup><sub>v</sub>-1-1。</p>
                </div>
                <div class="p1">
                    <p id="88">传递P<sub>v0</sub>给v<sub>0</sub>,然后局部译码节点v进入等待,直到从v<sub>0</sub>接收到β<sub>v0</sub>。激活v<sub>1</sub>并计算P<sub>v1</sub>[0]:</p>
                </div>
                <div class="p1">
                    <p id="89" class="code-formula">
                        <mathml id="89"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mtext>Ρ</mtext><msub><mrow></mrow><mrow><mtext>v</mtext><msub><mrow></mrow><mn>1</mn></msub></mrow></msub><mo stretchy="false">[</mo><mtext>l</mtext><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mtext>f</mtext><msub><mrow></mrow><mrow><mn>1</mn><mn>0</mn></mrow></msub><mo stretchy="false">(</mo><mtext>Ρ</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mtext>m</mtext><mtext>l</mtext><mo stretchy="false">]</mo><mo>,</mo><mtext>Ρ</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mtext>m</mtext><mtext>l</mtext><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>,</mo><mo>⋯</mo><mo>,</mo><mtext>Ρ</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mtext>m</mtext><mtext>l</mtext><mo>+</mo><mtext>m</mtext><mo>-</mo><mn>1</mn><mo stretchy="false">]</mo><mo>,</mo><mtext>β</mtext><msub><mrow></mrow><mrow><mtext>v</mtext><msub><mrow></mrow><mn>0</mn></msub></mrow></msub><mo stretchy="false">[</mo><mtext>l</mtext><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd columnalign="left"><mtext>Ρ</mtext><msub><mrow></mrow><mrow><mtext>v</mtext><msub><mrow></mrow><mn>1</mn></msub></mrow></msub><mo stretchy="false">[</mo><mtext>l</mtext><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mtext>f</mtext><msub><mrow></mrow><mrow><mn>1</mn><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mtext>Ρ</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mtext>m</mtext><mtext>l</mtext><mo stretchy="false">]</mo><mo>,</mo><mtext>Ρ</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mtext>m</mtext><mtext>l</mtext><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>,</mo><mo>⋯</mo><mo>,</mo><mtext>Ρ</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mtext>m</mtext><mtext>l</mtext><mo>+</mo><mtext>m</mtext><mo>-</mo><mn>1</mn><mo stretchy="false">]</mo><mo>,</mo><mtext>β</mtext><msub><mrow></mrow><mrow><mtext>v</mtext><msub><mrow></mrow><mn>0</mn></msub></mrow></msub><mo stretchy="false">[</mo><mtext>l</mtext><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="90">其中,l=0,1,…,m<sup>n-d</sup><sub>v</sub>-1-1。</p>
                </div>
                <div class="p1">
                    <p id="91">传递P<sub>v1</sub>给v<sub>1</sub>,然后对v的子节点v<sub>2</sub>,v<sub>3</sub>,…,v<sub>m-1</sub>应用上述同样的步骤。</p>
                </div>
                <h4 class="anchor-tag" id="92" name="92">(2)更新β<sub>v</sub></h4>
                <div class="p1">
                    <p id="93">局部译码节点v等待,直到从v<sub>m-1</sub>接收到β<sub>vm-1</sub>,然后根据下式计算β<sub>v</sub>:</p>
                </div>
                <div class="p1">
                    <p id="94">(β<sub>v</sub>[ml],β<sub>v</sub>[ml+1],…,β<sub>v</sub>[ml+m-1])=</p>
                </div>
                <div class="p1">
                    <p id="95">(β<sub>v0</sub>[l],β<sub>v1</sub>[l],…,β<sub>vm-1</sub>[l])G<sub>m</sub></p>
                </div>
                <div class="p1">
                    <p id="96">其中,l=0,1,…,m<sup>n-d</sup><sub>v</sub>-1-1。</p>
                </div>
                <div class="p1">
                    <p id="97">2)叶子节点:</p>
                </div>
                <div class="p1">
                    <p id="98">当一个叶子节点v被激活时,如果P<sub>v</sub>[0][0]≥P<sub>v</sub>[0][1],则<mathml id="194"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mstyle mathsize="140%" displaystyle="true"><mtext>u</mtext></mstyle><mrow><mspace width="0.25em" /><mo>^</mo></mrow></mover><msub><mrow></mrow><mtext>i</mtext></msub><mo>=</mo><mtext>β</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow></math></mathml>,如果P<sub>v</sub>[0][0]&lt;P<sub>v</sub>[0][1],则<mathml id="195"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mstyle mathsize="140%" displaystyle="true"><mtext>u</mtext></mstyle><mrow><mspace width="0.25em" /><mo>^</mo></mrow></mover><msub><mrow></mrow><mtext>i</mtext></msub><mo>=</mo><mtext>β</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow></math></mathml>,其中,I<sub>v</sub>⊂A。否则,β<sub>v</sub>[0]=0(冻结位)。则<mathml id="196"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mstyle mathsize="140%" displaystyle="true"><mtext>c</mtext></mstyle><mrow><mspace width="0.25em" /><mo>^</mo></mrow></mover><mo stretchy="false">[</mo><mtext>i</mtext><mo stretchy="false">]</mo><mo>=</mo><mtext>β</mtext><msub><mrow></mrow><mtext>v</mtext></msub><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow></math></mathml>,其中,i是v的索引。</p>
                </div>
                <div class="p1">
                    <p id="99">文献<citation id="339" type="reference">[<a class="sup">8</a>]</citation>指出,一个高维核矩阵<i><b>G</b></i><sub><i>m</i></sub>极化码直接SC译码的复杂度为<i>O</i>(2<sup><i>m</i></sup><i>N</i>log<sub><i>m</i></sub><i>N</i>)。文献<citation id="340" type="reference">[<a class="sup">14</a>]</citation>提出一种<i>W</i>-表达式方法来简化递归公式<i>f</i><sub><i>i</i></sub>0(*<i>l</i>)和<i>f</i><sub><i>i</i></sub>1(*<i>l</i>)。当<i>m</i>≤16时,基于<i>W</i>-表达式方法,SC译码复杂度降低为<i>O</i>(<i>mN</i>log<sub><i>m</i></sub><i>N</i>)。因此,本文采用基于<i>W</i>-表达式方法的SC译码。</p>
                </div>
                <h3 id="100" name="100" class="anchor-tag">2 GA-DE方法与Tal-Vardy方法</h3>
                <h4 class="anchor-tag" id="101" name="101">2.1 GA-DE方法</h4>
                <div class="p1">
                    <p id="102">本文通过一个简单的例子,阐述GA-DE方法构造高维核矩阵极化码时存在一定程度的失真。</p>
                </div>
                <div class="p1">
                    <p id="103">设一个<i><b>G</b></i><sub>6</sub>核矩阵的<i>l</i>-表达式为:<citation id="341" type="reference"><link href="313" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation></p>
                </div>
                <div class="p1">
                    <p id="104" class="code-formula">
                        <mathml id="104"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mn>6</mn></msub><mo>=</mo><mrow><mo>(</mo><mrow><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>1</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr></mtable></mrow><mo>)</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="105">基于该核矩阵,<i>l</i><mathml id="197"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>6</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>的l-表达式为:</p>
                </div>
                <div class="p1">
                    <p id="106" class="code-formula">
                        <mathml id="106"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>l</mi><msubsup><mrow></mrow><mn>6</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>l</mi><msub><mrow></mrow><mn>0</mn></msub><mo>⋄</mo><mo stretchy="false">(</mo><mi>l</mi><msub><mrow></mrow><mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mi>l</mi><msub><mrow></mrow><mn>2</mn></msub><mo>+</mo><mi>l</mi><msub><mrow></mrow><mn>4</mn></msub><mo stretchy="false">)</mo><mo>⋄</mo><mo stretchy="false">(</mo><mi>l</mi><msub><mrow></mrow><mn>3</mn></msub><mo>+</mo><mi>l</mi><msub><mrow></mrow><mn>5</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle><mrow><mtext>部</mtext><mtext>分</mtext><mn>1</mn></mrow></munder><mo>+</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>l</mi><msub><mrow></mrow><mn>3</mn></msub><mo>⋄</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>-</mo><mi>l</mi><msub><mrow></mrow><mn>0</mn></msub><mo>+</mo><mi>l</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋄</mo><mo stretchy="false">(</mo><mi>l</mi><msub><mrow></mrow><mn>2</mn></msub><mo>+</mo><mi>l</mi><msub><mrow></mrow><mn>4</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><msub><mrow></mrow><mn>5</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle><mrow><mtext>部</mtext><mtext>分</mtext><mn>2</mn></mrow></munder><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="107">其中,<mathml id="198"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>l</mi><msubsup><mrow></mrow><mn>6</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mrow><mi>log</mi></mrow><msub><mrow></mrow><mi>a</mi></msub><mfrac><mrow><mi>W</mi><msubsup><mrow></mrow><mn>6</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mn>5</mn></msubsup><mo>,</mo><mi>u</mi><msubsup><mrow></mrow><mn>0</mn><mn>2</mn></msubsup><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mn>3</mn></msub><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mi>W</mi><msubsup><mrow></mrow><mn>6</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mn>5</mn></msubsup><mo>,</mo><mi>u</mi><msubsup><mrow></mrow><mn>0</mn><mn>2</mn></msubsup><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mn>3</mn></msub><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow></math></mathml>是位信道对数似然比,<mathml id="199"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>l</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mrow><mi>log</mi></mrow><msub><mrow></mrow><mi>a</mi></msub><mfrac><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mo>,</mo><mi>i</mi><mo>=</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mo>⋯</mo><mo>,</mo><mn>5</mn></mrow></math></mathml>是信道输出对数似然比。文献<citation id="342" type="reference">[<a class="sup">13</a>]</citation>中给出了式(6)的似然比形式,本文将其转化为对数似然比形式。</p>
                </div>
                <div class="p1">
                    <p id="108">l<mathml id="200"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>6</mn><mrow><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>中引入了相同的随机变量,例如部分1和部分2中2个相同的l<sub>i</sub>(i=0,1,…,5)。部分1和部分2显然相关,这违背了高斯假设(多个独立随机变量相加的结果为高斯分布)。因此,<i>GA</i>-<i>DE</i>方法构造出的高维核矩阵极化码会产生一定的失真,这也在下文的实验中得到了验证。</p>
                </div>
                <h4 class="anchor-tag" id="109" name="109">2.2 <i>Tal</i>-<i>Vardy</i>方法</h4>
                <div class="p1">
                    <p id="110">为不失一般性,考虑<i><b>G</b></i><sub>2</sub>核矩阵的递归信道转化如下:</p>
                </div>
                <div class="p1">
                    <p id="111" class="code-formula">
                        <mathml id="111"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>W</mi><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mn>1</mn></msubsup><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></munder><mi>W</mi></mstyle><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mn>0</mn></msub><mo>⊕</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="112"><i>W</i><mathml id="201"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>(<i>y</i><mathml id="202"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>|<i>u</i><sub>0</sub>)可以通过式(7)递归构造。原始信道<i>W</i>的输出字母集大小假定为<i>μ</i>,即|<i>y</i>|=<i>μ</i>。执行式(7),输出字母集大小增大到<i>μ</i><sup>2</sup>,即|<i>y</i><mathml id="203"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mn>1</mn></msubsup></mrow></math></mathml>|=<i>μ</i><sup>2</sup>。因此,信道<i>W</i><mathml id="204"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>(<i>y</i><mathml id="205"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>|<i>u</i><sub>0</sub>)输出字母集大小随码长<i>N</i>呈指数增长,即|<i>y</i><mathml id="206"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>|=<i>μ</i><sup><i>N</i></sup>。Tal-Vardy方法的基本思想是用一个降级或升级的信道近似<i>W</i><mathml id="207"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>(<i>y</i><mathml id="208"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mn>1</mn></msubsup></mrow></math></mathml>|<i>u</i><sub>0</sub>),使得最大输出字母集大小为<i>μ</i>。Tal-Vardy方法可以分解为2步:</p>
                </div>
                <div class="p1">
                    <p id="113">1)构造信道<i>W</i><mathml id="209"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>(<i>y</i><mathml id="210"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mn>1</mn></msubsup></mrow></math></mathml>|<i>u</i><sub>0</sub>)。</p>
                </div>
                <div class="p1">
                    <p id="114">2)输出字母集大小从<i>μ</i><sup>2</sup>减小至<i>μ</i>。</p>
                </div>
                <div class="p1">
                    <p id="115">给定一个<i><b>G</b></i><sub><i>m</i></sub>核矩阵,递归公式(7)转换为:</p>
                </div>
                <div class="p1">
                    <p id="116" class="code-formula">
                        <mathml id="116"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>W</mi><msubsup><mrow></mrow><mrow><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mi>m</mi></msub></mrow><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>y</mi><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">|</mo><mi>u</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><msup><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msup></mrow></mfrac><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>u</mi><msubsup><mrow></mrow><mn>1</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></munder><mi>W</mi></mstyle><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mn>0</mn></msub><mo stretchy="false">)</mo><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋯</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mi>W</mi><mo stretchy="false">(</mo><mi>y</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">|</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="117">式(8)表明<i>W</i><mathml id="211"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mi>m</mi></msub></mrow><mrow><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>(<i>y</i><mathml id="212"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>m</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>|<i>u</i><sub>0</sub>)的输出字母集大小为<i>μ</i><sup><i>m</i></sup>,其随着核矩阵大小<i>m</i>呈指数增长,这对于一个较大维数的核矩阵将不切合实际。因此,Tal-Vardy方法不适用于大维数的核矩阵。</p>
                </div>
                <h3 id="118" name="118" class="anchor-tag">3 快速MC构造方法</h3>
                <div class="p1">
                    <p id="119">由于GA-DE方法和Tal-Vardy方法推广至高维核矩阵时存在局限,本文采用MC构造方法设计高维核矩阵极化码。传统SC译码具有较高延迟,而在实际应用中,利用MC构造方法无需对每一位进行连续译码。因为位信道具有对称性,在用<i>Pe</i>(<i>W</i><mathml id="213"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>)评估位信道<i>W</i><mathml id="214"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>Ν</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></math></mathml>时,假定<i>SC</i>译码过程中<i>β</i>为全0向量,所以当一个节点<i>v</i><sub><i>i</i></sub>被激活时,<i><b>P</b></i><sub><i>vi</i></sub>无需等待<i>β</i>,可以立刻进行计算,且同一层所有节点的<i><b>P</b></i><sub><i>v</i></sub>能够并行计算。因此,利用MC构造方法可以明显缩短SC译码的延迟。</p>
                </div>
                <div class="p1">
                    <p id="120">MC构造方法模拟SC译码的过程如下:</p>
                </div>
                <div class="p1">
                    <p id="121">1)对每一位重复执行SC译码。</p>
                </div>
                <div class="p1">
                    <p id="122">2)通过大量的仿真并基于每一位的差错概率评估每个位信道。</p>
                </div>
                <div class="p1">
                    <p id="123">3)对所有位信道的差错概率排序,选择具有最低差错概率的<i>k</i>个位信道作为信息位集合。</p>
                </div>
                <div class="p1">
                    <p id="124">在MC构造方法的基础上,本文提出一种TPMC方法,以在不损失极化码译码性能的同时降低MC方法的复杂度。</p>
                </div>
                <h4 class="anchor-tag" id="125" name="125">3.1 TPMC方法</h4>
                <div class="p1">
                    <p id="126">GA-DE方法所构造的最可靠和最不可靠的位可信。因此,在本文TPMC方法的第1阶段,利用GA-DE方法获得一些最可靠和最不可靠的位并将这些位固定为冻结位;在第2阶段,利用MC方法衡量剩余位的差错概率,从剩余位中挑选差错概率较低的位,与第1阶段中最可靠的位结合构成信息位集合。</p>
                </div>
                <div class="p1">
                    <p id="127">令<i>A</i><sub><i>m</i></sub>和<i>A</i><sub><i>l</i></sub>分别表示由GA-DE方法产生的最可靠的位集合和最不可靠的位集合。算法2描述了TPMC方法的详细过程,其中,<i>A</i><sub><i>r</i></sub>={<i>r</i><sub>1</sub>,<i>r</i><sub>2</sub>,…,<i>r</i><sub><i>p</i></sub>}为从[<i>N</i>]中移去最可靠的位和最不可靠的位而构成的剩余位集合,<i><b>e</b></i>(<i>A</i><sub><i>r</i></sub>)为向量<i><b>e</b></i><sub><i>r</i></sub><sub>1</sub>,<i><b>e</b></i><sub><i>r</i></sub><sub>2</sub>,…,<i><b>e</b></i><sub><i>rp</i></sub>。</p>
                </div>
                <div class="p1">
                    <p id="128"><b>算法2</b> TPMC方法</p>
                </div>
                <div class="p1">
                    <p id="129"><b>输入</b> 差错向量<i><b>e</b></i>,核矩阵<i><b>G</b></i><sub><i>m</i></sub>,码长<i>N</i>,码率<i>R</i>,信息位<i>u</i><mathml id="215"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>=0<mathml id="216"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mi>Ν</mi><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="130"><b>输出</b> 信息位集合<i>A</i></p>
                </div>
                <div class="p1">
                    <p id="131">1.获得A<sub>m</sub>和A<sub>l</sub>:利用GA-DE方法生成最可靠的位集合A<sub>m</sub>和最不可靠的位集合A<sub>l</sub></p>
                </div>
                <div class="p1">
                    <p id="132">2.令A<sub>r</sub>=[N]-(A<sub>m</sub>∪A<sub>l</sub>),且假定A<sub>r</sub>={r<sub>1</sub>,r<sub>2</sub>,…,r<sub>p</sub>}</p>
                </div>
                <div class="p1">
                    <p id="133">3.for i=0,1,…,p do</p>
                </div>
                <div class="p1">
                    <p id="134">4.e[r<sub>i</sub>]←0</p>
                </div>
                <div class="p1">
                    <p id="135">5.end for</p>
                </div>
                <div class="p1">
                    <p id="136">6.for j=0,1,…,M-1 do</p>
                </div>
                <div class="p1">
                    <p id="137">7.x<mathml id="217"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mtext>Ν</mtext><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>=0<mathml id="218"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mtext>Ν</mtext><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml>进入信道,接收端的信道输出为y<mathml id="219"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>0</mn><mrow><mtext>Ν</mtext><mo>-</mo><mn>1</mn></mrow></msubsup></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="138">8.将集合A<sub>m</sub>和A<sub>l</sub>中的位固定为冻结位并执行SC译码算法1</p>
                </div>
                <div class="p1">
                    <p id="139">9.end for</p>
                </div>
                <div class="p1">
                    <p id="140">10.选择e(A<sub>r</sub>)中「NR<mathml id="220"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>⌉</mo><mo>-</mo><mrow><mo>|</mo><mrow><mrow><mrow><mtext>A</mtext><msub><mrow></mrow><mtext>m</mtext></msub></mrow><mo>|</mo></mrow></mrow></mrow></mrow></math></mathml>个最小的差错概率对应的索引组成A<sub>i</sub></p>
                </div>
                <div class="p1">
                    <p id="141">11.输出A=A<sub>m</sub>∪A<sub>l</sub></p>
                </div>
                <div class="p1">
                    <p id="142">在算法2的SC译码过程中,所有冻结位的计算可以被忽略,因此,在激活节点<i>v</i>时,如果<i>v</i>是一个冻结节点,则可以跳过<i><b>P</b></i><sub><i>v</i></sub>的计算而直接译码下一个节点。</p>
                </div>
                <h4 class="anchor-tag" id="143" name="143">3.2 TPMC方法的复杂度分析</h4>
                <div class="p1">
                    <p id="144">TPMC方法第2阶段确定的冻结位个数决定了方法的复杂度大小,越多的位被固定为冻结位,方法复杂度越低。仿真结果表明,在不损失译码性能的情况下,TPMC方法能将多数位固定为冻结位。例如,一个码长3 375、码率1/2的<i><b>G</b></i><mathml id="221"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码在第2阶段可以固定 3 200位为冻结位,一个码长4 096、码率1/2的<i><b>G</b></i><mathml id="222"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码在第2阶段可以固定3 750位为冻结位。</p>
                </div>
                <div class="p1">
                    <p id="145">假定在<i>SC</i>译码下计算一个节点v的<i><b>P</b></i><sub><i>v</i></sub>需要一个时钟,则TPMC方法所需的时钟数与SC译码树结构中的非冻结节点个数成正比。表1所示为MC方法和TPMC方法的复杂度比较结果,其中,<i>Num</i>-<i>fro</i>表示TPMC方法中第2阶段的冻结位个数,<i>Num</i>-<i>MC</i>表示在MC方法的SC译码过程中需要计算的节点个数,<i>Num</i>-<i>TPMC</i>表示在TPMC方法的SC译码过程中需要计算的节点个数,<i>Rec</i>-<i>times</i>表示TPMC方法相对于MC方法复杂度降低的倍数,其计算公式为<i>Rec</i>-<i>times</i>=<i>Num</i>-<i>MC</i>/<i>Num</i>-<i>TPMC</i>。</p>
                </div>
                <div class="area_img" id="146">
                    <p class="img_tit"><b>表1 2种方法的复杂度对比情况</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="146" border="1"><tr><td>极化码</td><td><i>Num</i>-<i>fro</i></td><td><i>Num</i>-<i>MC</i></td><td><i>Num</i>-<i>TPMC</i></td><td><i>Rec</i>-<i>times</i></td></tr><tr><td rowspan="2"><br /><b><i>G</i></b><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math><br /><b><i>G</i></b><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></td><td>3 000</td><td>3 615</td><td>498</td><td>7.3</td></tr><tr><td><br />3 200</td><td>3 615</td><td>267</td><td>13.5</td></tr><tr><td rowspan="2"><br /><b><i>G</i></b><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math><br /><b><i>G</i></b><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></td><td>3 600</td><td>4 368</td><td>641</td><td>6.8</td></tr><tr><td><br />3 750</td><td>4 368</td><td>478</td><td>9.2</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="147">由表1可以看出,对于一个<i><b>G</b></i><mathml id="223"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码,码长为3 375,利用<i>MC</i>方法构造时,<i>SC</i>译码过程中需要计算3 615个节点,在利用<i>TPMC</i>方法时,先固定3 000位冻结位,仅需计算498个节点,复杂度降低了86%。表1的结果表明,相比MC方法,TPMC方法能够大幅降低复杂度。</p>
                </div>
                <h3 id="148" name="148" class="anchor-tag">4 仿真结果与分析</h3>
                <div class="p1">
                    <p id="149">本节通过仿真验证TPMC方法构造高维核矩阵极化码时的性能。考虑二进制相移键控(Binary Phase Shift Keying,BPSK)调制和一个加性高斯白噪声(Additive White Gaussian Noise,AWGN)信道,二进制码字<i><b>x</b></i>=(<i><b>x</b></i><sub>0</sub>,<i><b>x</b></i><sub>1</sub>,…,<i><b>x</b></i><sub><i>N</i></sub>-1)基于<i><b>s</b></i><sub><i>n</i></sub>=1-2<i><b>x</b></i><sub><i>n</i></sub>映射到一个传输序列<i><b>s</b></i>=(<i><b>s</b></i><sub>0</sub>,<i><b>s</b></i><sub>1</sub>,…,<i><b>s</b></i><sub><i>N</i></sub>-1)上。在接收端,获得接收向量<i><b>y</b></i>=(<i><b>y</b></i><sub>0</sub>,<i><b>y</b></i><sub>1</sub>,…,<i><b>y</b></i><sub><i>N</i></sub>-1),其中,<i><b>y</b></i><sub><i>n</i></sub>=<i><b>s</b></i><sub><i>n</i></sub>+<i><b>z</b></i><sub><i>n</i></sub>、<i><b>z</b></i>=(<i><b>z</b></i><sub>0</sub>,<i><b>z</b></i><sub>1</sub>,…,<i><b>z</b></i><sub><i>N</i></sub>-1)是独立同分布随机变量,都满足均值为0、方差为<i>N</i><sub>0</sub>/2的高斯分布。</p>
                </div>
                <h4 class="anchor-tag" id="150" name="150">4.1 最优<i>M</i>值</h4>
                <div class="p1">
                    <p id="151">最优<i>M</i>值指在保证MC方法所设计极化码取得最佳译码性能的前提下,可以允许的最小<i>M</i>值。最优<i>M</i>值通过以下过程获得:每次10倍地增加<i>M</i>值,当发现增加<i>M</i>值并未提高译码纠错性能时,则将前一个<i>M</i>值作为最优<i>M</i>值。例如,仿真发现用MC方法构造<i><b>G</b></i><mathml id="224"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码时,M=1<i>e</i>5和M=1<i>e</i>6有相同的误帧率(<i>Frame Error Rate</i>,<i>FER</i>),则令M=1<i>e</i>5为该极化码的最优M值。</p>
                </div>
                <h4 class="anchor-tag" id="152" name="152">4.2 有效性分析</h4>
                <div class="p1">
                    <p id="153">图2所示为MC方法和TPMC方法构造的2个极化码(<i><b>G</b></i><mathml id="225"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>和<i><b>G</b></i><mathml id="226"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>)在<i>SC</i>下的FER结果。其中,极化码码率为1/2,所有码在信噪比SNR=2.0 <i>dB</i>下构造。在<i>TPMC</i>方法中,对<i><b>G</b></i><mathml id="227"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码固定N<sub>f</sub>=3 200位,对<i><b>G</b></i><mathml id="228"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码固定N<sub>f</sub>=3 750位。其中,N<sub>f</sub>表示<i>TPMC</i>方法第2阶段中的全部冻结位个数(最可靠的位和最不可靠的位)。由表1可知,相比<i>MC</i>方法构造的<i><b>G</b></i><mathml id="229"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码和<i><b>G</b></i><mathml id="230"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码,<i>TPMC</i>方法复杂度分别降低了92.6%和89.1%。从图2可以看出,TPMC方法和MC方法所构造极化码的<i>FER</i>几乎相同。</p>
                </div>
                <div class="area_img" id="154">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201909012_154.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 2种方法构造的极化码在SC译码下的FER结果" src="Detail/GetImg?filename=images/JSJC201909012_154.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 2种方法构造的极化码在SC译码下的</b><i>FER</i>结果  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201909012_154.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="155">图3所示为TPMC方法分别冻结<i>N</i><sub><i>f</i></sub>=3 200、3 250、3 300、3 350、3 375位后构造的5个极化码以及GA-DE方法构造的极化码在SC下的<i>FER</i>结果。其中,码率为1/2,所有码在<i>SNR</i>=2.0 dB下构造。从图3可以看出,冻结<i>N</i><sub><i>f</i></sub>=3 375位后构造的<i><b>G</b></i><mathml id="231"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码与<i>GA</i>-<i>DE</i>方法构造的<i><b>G</b></i><mathml id="232"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码等价。在<i>TPMC</i>方法中冻结N<sub>f</sub>=3 350位,即仅将剩余的25位作为非冻结位,所构造的<i><b>G</b></i><mathml id="233"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码明显优于<i>GA</i>-<i>DE</i>方法构造的<i><b>G</b></i><mathml id="234"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码,即在<i>TPMC</i>方法中将很少的位作为非冻结位,能够提高译码纠错性能。</p>
                </div>
                <div class="area_img" id="156">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201909012_156.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 不同冻结位数的极化码在SC译码下的FER结果" src="Detail/GetImg?filename=images/JSJC201909012_156.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 不同冻结位数的极化码在SC译码下的</b><i>FER</i>结果  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201909012_156.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="157">在不损失译码性能的情况下,<i>N</i><sub><i>f</i></sub>的值可以非常接近极化码的码长,但目前还没有一个规则可以确定最优的<i>N</i><sub><i>f</i></sub>值,本文通过仿真来选择较优的<i>N</i><sub><i>f</i></sub>值。</p>
                </div>
                <h4 class="anchor-tag" id="158" name="158">4.3 高维核矩阵极化码性能分析</h4>
                <div class="p1">
                    <p id="159">图4所示为TPMC方法和GA-DE方法构造的<i><b>G</b></i><mathml id="235"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>码在<i>LSC</i>下的FER结果。图5所示为<i>TPMC</i>方法和<i>GA</i>-<i>DE</i>方法构造的<i><b>G</b></i><mathml id="236"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>码在<i>LSC</i>下的FER结果。其中,<i><b>G</b></i><mathml id="237"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>、<i><b>G</b></i><mathml id="238"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>的M值分别为1<i>e</i>5和1<i>e</i>6,码长分别为3 375和4 096,码率都为1/2。另外,<i>Tal</i>-<i>Vardy</i>方法构造的<i><b>G</b></i><mathml id="239"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo>⊗</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></mathml>极化码也被引入进行比较。从图4、图5可以看出,在<i>LSC</i>译码下,<i>TPMC</i>方法构造的极化码明显优于<i>GA</i>-<i>DE</i>方法构造的极化码,在<i>SC</i>译码(L=1)下,相比<i><b>G</b></i><mathml id="240"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo>⊗</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></mathml>极化码,用<i>TPMC</i>方法构造的<i><b>G</b></i><mathml id="241"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>和<i><b>G</b></i><mathml id="242"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码的译码性能提升明显,且<i><b>G</b></i><sub>15</sub>核和<i><b>G</b></i><sub>2</sub>核矩阵的极化速率几乎相同。</p>
                </div>
                <div class="area_img" id="160">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201909012_160.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 TPMC与GA-DE构造的G15⊗3在LSC下的FER结果" src="Detail/GetImg?filename=images/JSJC201909012_160.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 TPMC与GA-DE构造的</b><i><b>G</b></i><mathml id="243"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>5</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml><b>在</b><i>LSC</i><b>下的</b><i><b>FER</b></i><b>结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201909012_160.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="161">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201909012_161.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 TPMC与GA-DE构造的G16⊗3在LSC下的FER结果" src="Detail/GetImg?filename=images/JSJC201909012_161.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 TPMC与GA-DE构造的</b><i><b>G</b></i><mathml id="244"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml><b>在</b><i>LSC</i><b>下的</b><i><b>FER</b></i><b>结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201909012_161.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="162">图6所示为<i><b>G</b></i><mathml id="245"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>和<i><b>G</b></i><mathml id="246"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo>⊗</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></mathml>极化码在<i>LSC</i>下的FER比较,<i><b>G</b></i><mathml id="247"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>和<i><b>G</b></i><mathml id="248"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo>⊗</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></mathml>极化码分别通过<i>TPMC</i>方法和<i>Tal</i>-<i>Vardy</i>方法构造,M值为1<i>e</i>6,码长为4 096,码率为1/2。由图6可以看出,在<i>LSC</i>译码下,相比<i>Tal</i>-<i>Vardy</i>方法构造的<i><b>G</b></i><mathml id="249"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo>⊗</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></mathml>极化码,同等码长的<i><b>G</b></i><mathml id="250"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml>极化码性能提升明显。</p>
                </div>
                <div class="area_img" id="163">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201909012_163.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 G16⊗3和G2⊗12极化码在LSC译码下的FER结果" src="Detail/GetImg?filename=images/JSJC201909012_163.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图6 </b><i>G</i><mathml id="251"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mn>1</mn><mn>6</mn></mrow><mrow><mo>⊗</mo><mn>3</mn></mrow></msubsup></mrow></math></mathml><b>和G</b><mathml id="252"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mn>2</mn><mrow><mo>⊗</mo><mn>1</mn><mn>2</mn></mrow></msubsup></mrow></math></mathml><b>极化码在</b><i>LSC</i>译码下的FER结果  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201909012_163.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="164" name="164" class="anchor-tag">5 结束语</h3>
                <div class="p1">
                    <p id="165">本文提出一种基于MC的高维核矩阵极化码构造方法TPMC。利用GA-DE方法获得最可靠的位和最不可靠的位,将这些位固定为冻结位并对剩余位执行MC方法,以构造高维核矩阵极化码。仿真结果表明,与MC方法相比,TPMC方法能够将多数位固定为冻结位而不损失极化码的译码性能,并大幅降低计算复杂度。但TPMC方法主要降低SC译码中冻结位节点的计算复杂度,下一步将研究能够降低其他节点计算复杂度的方法。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="285">
                            <a id="bibliography_1" >
                                    <b>[1]</b>
                                 ARIKAN E.Channel polarization:a method for constructing capacity-achieving codes for symmetric binary-input memoryless channels[J].IEEE Transactions on Information Theory,2009,55(7):3051-3073.
                            </a>
                        </p>
                        <p id="287">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Modern coding theory">

                                <b>[2]</b> RICHARDSON T J,URBANKE R.Modern coding theory[M].Cambridge,USA:MIT Press,2008.
                            </a>
                        </p>
                        <p id="289">
                            <a id="bibliography_3" >
                                    <b>[3]</b>
                                 MORI R,TANAKA T.Performance of polar codes with the construction using density evolution[J].IEEE Commu-nications Letters,2009,13(7):519-521.
                            </a>
                        </p>
                        <p id="291">
                            <a id="bibliography_4" >
                                    <b>[4]</b>
                                 TRIFONOV P.Efficient design and decoding of polar codes[J].IEEE Transactions on Communications,2012,60(11):3221-3227.
                            </a>
                        </p>
                        <p id="293">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201803013&amp;v=Mjk5NjI4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnRGeUhrVnI3TUx6N0JiYkc0SDluTXJJOUVaNFFLREg=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> 刘亚军,李世宝,刘建航,等.一种低时延极化码列表连续删除译码算法[J].计算机工程,2018,44(3):78-81.
                            </a>
                        </p>
                        <p id="295">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=How to construct polar codes">

                                <b>[6]</b> TAL I,VARDY A.How to construct polar codes[J].IEEE Transactions on Information Theory,2013,59(10):6562-6582.
                            </a>
                        </p>
                        <p id="297">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Analysis of sum-product decoding of low-density parity-check codes using a Gaussian approximation">

                                <b>[7]</b> CHUNG S Y,RICHARDSON T,URBANKE R.Analysis of sum-product decoding of low-density parity-check codes using a Gaussian approximation[J].IEEE Transactions on Information Theory,2001,47(2):657-670.
                            </a>
                        </p>
                        <p id="299">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Polar codes: Characterization of exponent, bounds, and constructions">

                                <b>[8]</b> KORADA S B,SASOGLU E,URBANKE R.Polar codes:characterization of exponent,bounds,and constructions[J].IEEE Transactions on Information Theory,2010,56(12):6253-6264.
                            </a>
                        </p>
                        <p id="301">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Binary Polarization Kernels from Code Decompositions">

                                <b>[9]</b> PRESMAN N,SHAPIRA O,LITSYN T,et al.Binary polarization kernels from code decompositions[J].IEEE Transactions on Information Theory,2015,61(5):2227-2239.
                            </a>
                        </p>
                        <p id="303">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Linear and Nonlinear Binary Kernels of Polar Codes of Small Dimensions With Maximum Exponents">

                                <b>[10]</b> LIN H P,LIN Shu,ABDEL-GHAFFAR K A S.Linear and nonlinear binary kernels of polar codes of small dimensions with maximum exponents[J].IEEE Transactions on Information Theory,2015,61(10):5253-5270.
                            </a>
                        </p>
                        <p id="305">
                            <a id="bibliography_11" >
                                    <b>[11]</b>
                                 WU Dalong,LI Ying,SUN Yue.Construction and block error rate analysis of polar codes over AWGN channel based on Gaussian approximation[J].IEEE Commu-nications Letters,2014,18(7):1099-1102.
                            </a>
                        </p>
                        <p id="307">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Designing practical polar codes using simulation-based bit selection">

                                <b>[12]</b> SUN Shuanghong,ZHANG Zhengya.Designing practical polar codes using simulation-based bit selection[J].IEEE Journal on Emerging and Selected Topics in Circuits and Systems,2017,7(4):594-603.
                            </a>
                        </p>
                        <p id="309">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A simplified successive-cancellation decoder for polar codes">

                                <b>[13]</b> ALAMDAR-YAZDI A,KSCHISCHANG F R.A simplied successive cancellation decoder for polar codes[J].IEEE Communications Letters,2011,15(12):1378-1380.
                            </a>
                        </p>
                        <p id="311">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On the successive cancellation decoding of polar codes with arbitrary linear binary kernels">

                                <b>[14]</b> HUANG Zhiliang,ZHANG Shiyi,ZHANG Feiyan,et al.On the successive cancellation decoding of polar codes with arbitrary linear binary kernels[EB/OL].[2018-06-20].http://pdfs.semanticscholar.org/ebf7/58e65c95a81c4ab01 494fb70ed535a631846.pdf.
                            </a>
                        </p>
                        <p id="313">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Simplified Successive Cancellation Decoding of Polar Codes with Medium-dimensional Binary Kernels">

                                <b>[15]</b> HUANG Zhiliang,ZHANG Shiyi,ZHANG Feiyan,et al.Simplified successive cancellation decoding of polar codes with medium-dimensional binary kernels[J].IEEE Access,2018,6(1):26707-26717.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJC201909012" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201909012&amp;v=MzI2OTN5SGtWcjdNTHo3QmJiRzRIOWpNcG85RVpvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSdEY=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU40eEVEZ0hzWGpPUWNRSm92MnoxWT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
