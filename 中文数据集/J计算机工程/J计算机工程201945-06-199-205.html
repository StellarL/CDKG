<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637130386130770000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201906032%26RESULT%3d1%26SIGN%3dDpDiWP0kdoNj%252f9odw%252bxsDpXX2hY%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201906032&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201906032&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201906032&amp;v=MDA1MjJDVVJMT2VaZVJvRnlubFZMdktMejdCYmJHNEg5ak1xWTlHWm9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnI=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#35" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#39" data-title="1 社区发现模块化图模型 ">1 社区发现模块化图模型</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#40" data-title="1.1 模型描述">1.1 模型描述</a></li>
                                                <li><a href="#88" data-title="1.2 整数规划">1.2 整数规划</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#95" data-title="2 社区检测的贪婪随机自适应路径重连 ">2 社区检测的贪婪随机自适应路径重连</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#96" data-title="2.1 算法流程">2.1 算法流程</a></li>
                                                <li><a href="#113" data-title="2.2 聚类构造">2.2 聚类构造</a></li>
                                                <li><a href="#146" data-title="2.3 局部搜索过程">2.3 局部搜索过程</a></li>
                                                <li><a href="#188" data-title="2.4 路径重连过程">2.4 路径重连过程</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#235" data-title="3 实验结果与分析 ">3 实验结果与分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#237" data-title="3.1 人工网络生成">3.1 人工网络生成</a></li>
                                                <li><a href="#249" data-title="3.2 稳健性实验">3.2 稳健性实验</a></li>
                                                <li><a href="#254" data-title="3.3 准确性实验">3.3 准确性实验</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#260" data-title="4 结束语 ">4 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#54" data-title="&lt;b&gt;图1 随机图&lt;i&gt;H&lt;/i&gt;的构造过程示例&lt;/b&gt;"><b>图1 随机图<i>H</i>的构造过程示例</b></a></li>
                                                <li><a href="#74" data-title="&lt;b&gt;图2 随机有向图&lt;i&gt;H&lt;/i&gt;的构造过程示例&lt;/b&gt;"><b>图2 随机有向图<i>H</i>的构造过程示例</b></a></li>
                                                <li><a href="#194" data-title="&lt;b&gt;图3 聚类空间示意图&lt;/b&gt;"><b>图3 聚类空间示意图</b></a></li>
                                                <li><a href="#244" data-title="&lt;b&gt;表1 MMSB生成的实验网络特点&lt;/b&gt;"><b>表1 MMSB生成的实验网络特点</b></a></li>
                                                <li><a href="#246" data-title="&lt;b&gt;表2 LFR生成的实验网络特点&lt;/b&gt;"><b>表2 LFR生成的实验网络特点</b></a></li>
                                                <li><a href="#248" data-title="&lt;b&gt;图4 人工生成网络模型&lt;/b&gt;"><b>图4 人工生成网络模型</b></a></li>
                                                <li><a href="#253" data-title="&lt;b&gt;图5 3种算法的&lt;i&gt;F&lt;/i&gt;&lt;/b&gt;&lt;sub&gt;&lt;b&gt;1&lt;/b&gt;&lt;/sub&gt;&lt;b&gt;值对比结果&lt;/b&gt;"><b>图5 3种算法的<i>F</i></b><sub><b>1</b></sub><b>值对比结果</b></a></li>
                                                <li><a href="#258" data-title="&lt;b&gt;图6 3种算法的&lt;i&gt;NMI&lt;/i&gt;值对比结果&lt;/b&gt;"><b>图6 3种算法的<i>NMI</i>值对比结果</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="5">


                                    <a id="bibliography_1" title=" 陈克寒, 韩盼盼, 吴健.基于用户聚类的异构社交网络推荐算法[J].计算机学报, 2013, 36 (2) :349-358." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201302013&amp;v=MTkzNjNVUkxPZVplUm9GeW5sVkx2S0x6N0Jkckc0SDlMTXJZOUVaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckM=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         陈克寒, 韩盼盼, 吴健.基于用户聚类的异构社交网络推荐算法[J].计算机学报, 2013, 36 (2) :349-358.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_2" title=" 宣善立, 梁栋, 朱明.一种基于修正的最小生成树及其邻接谱的特征匹配算法[J].电子学报, 2010, 38 (2) :269-274." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU201002003&amp;v=MjYwNzZxQnRHRnJDVVJMT2VaZVJvRnlubFZMdktJVGZUZTdHNEg5SE1yWTlGWjRRS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         宣善立, 梁栋, 朱明.一种基于修正的最小生成树及其邻接谱的特征匹配算法[J].电子学报, 2010, 38 (2) :269-274.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_3" title=" SHI Lei, ZHANG Lefei, ZHAO Lingli, et al.Adaptive laplacian eigenmap-based dimension reduction for ocean target discrimination[J].IEEE Geoscience and Remote Sensing Letters, 2016, 13 (7) :902-906." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Adaptive Laplacian eigenmap-based dimension reduction for ocean target discrimination">
                                        <b>[3]</b>
                                         SHI Lei, ZHANG Lefei, ZHAO Lingli, et al.Adaptive laplacian eigenmap-based dimension reduction for ocean target discrimination[J].IEEE Geoscience and Remote Sensing Letters, 2016, 13 (7) :902-906.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_4" title=" VENKATARAMAN A, YANG D Y J, PELPHREY K, et al.Bayesian community detection in the space of group-level functional differences[J].IEEE Transactions on Medical Imaging, 2016, 35 (8) :1862-1866." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Bayesian Community Detection in the Space of Grouplevel Functional Differences">
                                        <b>[4]</b>
                                         VENKATARAMAN A, YANG D Y J, PELPHREY K, et al.Bayesian community detection in the space of group-level functional differences[J].IEEE Transactions on Medical Imaging, 2016, 35 (8) :1862-1866.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_5" title=" SAMMARCO M, CAMPISTA M E M, AMORIM M D D.Scalable wireless traffic capture through community detection and trace similarity[J].IEEE Transactions on Mobile Computing, 2016, 15 (7) :1757-1769." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Scalable Wireless Traffic Capture Through Community Detection and Trace Similarity">
                                        <b>[5]</b>
                                         SAMMARCO M, CAMPISTA M E M, AMORIM M D D.Scalable wireless traffic capture through community detection and trace similarity[J].IEEE Transactions on Mobile Computing, 2016, 15 (7) :1757-1769.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_6" title=" 罗会兰, 万成涛, 孔繁胜.基于KL散度及多尺度融合的显著性区域检测算法[J].电子与信息学报, 2016, 38 (7) :1594-1601." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZYX201607003&amp;v=MDgyNzJGeW5sVkx2S0lUZlNkckc0SDlmTXFJOUZaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm8=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         罗会兰, 万成涛, 孔繁胜.基于KL散度及多尺度融合的显著性区域检测算法[J].电子与信息学报, 2016, 38 (7) :1594-1601.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_7" title=" GUO Tao, ZHANG Guo, GUO Wenjuan.An improved weighted complex network clustering method[J].Computer Science, 2012, 39 (6) :99-102." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA2012S1028&amp;v=MTkyMTBPdnJvOUhiSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeW5sVkx2S0x6N0JiN0c0SDk=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                         GUO Tao, ZHANG Guo, GUO Wenjuan.An improved weighted complex network clustering method[J].Computer Science, 2012, 39 (6) :99-102.
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_8" title=" JIN Di, LIU Jie, YANG Bo.Large scale complex network community detection based on local search and genetic algorithm[J].Journal of Automation, 2011, 37 (7) :873-881." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Large scale complex network community detection based on local search and genetic algorithm">
                                        <b>[8]</b>
                                         JIN Di, LIU Jie, YANG Bo.Large scale complex network community detection based on local search and genetic algorithm[J].Journal of Automation, 2011, 37 (7) :873-881.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_9" title=" WANG Tian, KRIM H, VINIOTIS Y.A generalized Markov graph model:application to social network analysis[J].IEEE Journal of Selected Topics in Signal Processing, 2013, 7 (2) :318-332." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A Generalized Markov Graph Model:Application to Social Network Analysis">
                                        <b>[9]</b>
                                         WANG Tian, KRIM H, VINIOTIS Y.A generalized Markov graph model:application to social network analysis[J].IEEE Journal of Selected Topics in Signal Processing, 2013, 7 (2) :318-332.
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_10" title=" ZHANG Xinmeng, JIANG Shengyi.Complex network parti-tioning algorithm based on incremental clustering of core graph[J].Journal of Automation, 2013, 39 (7) :1117-1124." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Complex network partitioning algorithm based on incremental clustering of core graph">
                                        <b>[10]</b>
                                         ZHANG Xinmeng, JIANG Shengyi.Complex network parti-tioning algorithm based on incremental clustering of core graph[J].Journal of Automation, 2013, 39 (7) :1117-1124.
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_11" title=" YONG-DEOK K, SEUNGJIN C.Variational Bayesian view of weighted trace norm regularization for matrix factorization[J].IEEE Signal Processing Letters, 2013, 20 (3) :261-264." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Variational Bayesian View of Weighted Trace Norm Regularization for Matrix Factorization">
                                        <b>[11]</b>
                                         YONG-DEOK K, SEUNGJIN C.Variational Bayesian view of weighted trace norm regularization for matrix factorization[J].IEEE Signal Processing Letters, 2013, 20 (3) :261-264.
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_12" title=" PARIKSHIT D, ABHISHEK H, RAKTIM B.Nonlinear estimation with Perron-Frobenius operator and Karhunen-Lo&#232;ve expansion[J].IEEE Transactions on Aerospace and Electronic Systems, 2015, 51 (4) :3210-3225." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Nonlinear Estimation with Perron-Frobenius Operator and KarhunenLo&amp;#232;ve Expansion">
                                        <b>[12]</b>
                                         PARIKSHIT D, ABHISHEK H, RAKTIM B.Nonlinear estimation with Perron-Frobenius operator and Karhunen-Lo&#232;ve expansion[J].IEEE Transactions on Aerospace and Electronic Systems, 2015, 51 (4) :3210-3225.
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_13" title=" KARIMI-MAJD A M, FATHIAN M, AMIRI B.A hybrid artificial immune network for detecting communities in complex networks[J].Computing, 2015, 97 (2) :483-507." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A hybrid artificial immune network for detecting communities in complex networks">
                                        <b>[13]</b>
                                         KARIMI-MAJD A M, FATHIAN M, AMIRI B.A hybrid artificial immune network for detecting communities in complex networks[J].Computing, 2015, 97 (2) :483-507.
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_14" title=" XIE Jierui, SZYMANSKI B K.Towards linear time overlapping community detection in social networks[J].Lecture Notes in Computer Science, 2012, 73 (1) :25-36." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Towards Linear Time Overlapping Community Detection in Social Networks">
                                        <b>[14]</b>
                                         XIE Jierui, SZYMANSKI B K.Towards linear time overlapping community detection in social networks[J].Lecture Notes in Computer Science, 2012, 73 (1) :25-36.
                                    </a>
                                </li>
                                <li id="33">


                                    <a id="bibliography_15" title=" CHEN Mingming, NGUYEN T, SZYMANSKI B.On measuring the quality of a network community structure[J].Social Computing, 2013, 52 (3) :122-127." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On measuring the quality of a network community structure">
                                        <b>[15]</b>
                                         CHEN Mingming, NGUYEN T, SZYMANSKI B.On measuring the quality of a network community structure[J].Social Computing, 2013, 52 (3) :122-127.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(06),199-205 DOI:10.19678/j.issn.1000-3428.0051211            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于贪婪局部路径重连的随机并行社区检测</b></span>
 <span class="shoufa"></span>                                     </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%8D%95%E5%BA%B7%E5%BA%B7&amp;code=25623670&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">单康康</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%83%AD%E6%99%94&amp;code=09373136&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">郭晔</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%99%88%E6%96%87%E6%99%BA&amp;code=09369512&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">陈文智</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF%E4%B8%AD%E5%BF%83&amp;code=0157820&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">浙江大学信息技术中心</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A2&amp;code=0157820&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">浙江大学计算机科学与技术学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>为提高社区检测的效率与精度, 提出一种随机并行的局部搜索算法。用图模型结构表示复杂系统, 将顶点划分成簇。构建贪婪随机自适应搜索过程与路径重连过程, 以解决加权图的模块最大化问题。引入一种{0, 1}矩阵类特征并定义聚类的距离函数, 从而进行顶点的邻域搜索, 实现社区的高精度检测识别。实验结果表明, 该算法的<i>F</i><sub>1</sub>值与NMI指标值均较高。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B7%AF%E5%BE%84%E9%87%8D%E8%BF%9E&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">路径重连;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%A8%A1%E5%9D%97%E6%9C%80%E5%A4%A7%E5%8C%96&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">模块最大化;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E9%9A%8F%E6%9C%BA%E5%9B%BE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">随机图;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%B9%B6%E8%A1%8C%E6%90%9C%E7%B4%A2&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">并行搜索;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A4%BE%E5%8C%BA%E6%A3%80%E6%B5%8B&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">社区检测;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    单康康 (1984—) , 男, 工程师、硕士, 主研方向为模式匹配、迁移学习;E-mail: shankk@zju.edu.cn;
                                </span>
                                <span>
                                    郭晔, 教授级高级工程师、博士;;
                                </span>
                                <span>
                                    陈文智, 教授、博士、博士生导师。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-04-16</p>

                    <p>

                            <b>基金：</b>
                                                        <span>浙江省科技计划项目 (2011C23109, 2012R10040-08);</span>
                    </p>
            </div>
                    <h1><b>Random Parallel Community Detection Based on Greedy Local Path Reconnection</b></h1>
                    <h2>
                    <span>SHAN Kangkang</span>
                    <span>GUO Ye</span>
                    <span>CHEN Wenzhi</span>
            </h2>
                    <h2>
                    <span>Information Technology Center, Zhejiang University</span>
                    <span>College of Computer Science and Technology, Zhejiang University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>To improve the efficiency and accuracy of community detection, a random parallel local search algorithm is proposed.The complex system is represented by graph model structure, and vertices are divided into clusters.The greedy stochastic adaptive search process and path reconnection process are constructed to solve the module maximization problem of weighted graph.A {0, 1} matrix class feature is introduced and the distance function of clustering is defined, so that the neighborhood search of vertices can be carried out to achieve high-precision community detection and recognition.Experimental results show that the <i>F</i><sub>1</sub> value and NMI index value of the proposed algorithm are both high.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=path%20reconnection&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">path reconnection;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=module%20maximization&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">module maximization;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=random%20graph&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">random graph;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=parallel%20search&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">parallel search;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=community%20detection&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">community detection;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-04-16</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="35" name="35" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="36">对于一个节点分组网络, 若组内顶点的连接比较稠密, 组间顶点的连接比较稀疏, 则称其为社团结构。在社团中, 顶点可以自然地被分成稠密连接的群<citation id="262" type="reference"><link href="5" rel="bibliography" /><link href="7" rel="bibliography" /><sup>[<a class="sup">1</a>,<a class="sup">2</a>]</sup></citation>。在物理学、社会学等研究领域, 存在较多与社区概念密切相关的理论。例如, 在统计物理学中, 一个重要范畴是相互作用粒子间的动力学。控制单个粒子运动的微观规则已知, 但是粒子具有庞大的数量, 难以将它们作为一个整体进行考虑<citation id="263" type="reference"><link href="9" rel="bibliography" /><link href="11" rel="bibliography" /><sup>[<a class="sup">3</a>,<a class="sup">4</a>]</sup></citation>。此时, 可采用社区发现方法进行分析。</p>
                </div>
                <div class="p1">
                    <p id="37">图的社区检测是一门应用广泛的交叉学科, 近年来引起了研究者的较多关注<citation id="264" type="reference"><link href="13" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>。文献<citation id="265" type="reference">[<a class="sup">6</a>]</citation>利用数据流形式进行大规模网络社区的检测与发现。文献<citation id="266" type="reference">[<a class="sup">7</a>]</citation>采取随机边缘数据采样的方式对大规模网络社区进行简化, 获得具有稀疏特性的网络社区矩阵数据, 从而提升社区检测的效率。上述2种算法虽然可简化社区发现的过程, 但是均对数据进行了压缩, 不可避免地会丢失部分数据, 从而降低了识别精度。文献<citation id="267" type="reference">[<a class="sup">8</a>]</citation>基于Pott算法检测并发现社区结构, 然后利用马尔科夫算法对社区检测过程进行特征谱的定量分析。该方法具有较高的识别精度与分辨率, 但计算复杂度较高。文献<citation id="268" type="reference">[<a class="sup">9</a>]</citation>采用亚稳态方法对社区结构进行定量分析, 其本质是一种二分结构的社区发现过程, 因此, 具有较高的计算效率, 但对于多分的社区类型检测, 其效果不佳。贪婪方法<citation id="269" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>能够处理包含10<sup>6</sup>个顶点的大图, 但其得到的解质量较差。其他模块最大化的社区检测启发式算法<citation id="270" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>主要有模拟退火方法、极值优化、谱聚类方法、混合方法、取整启发式算法、遗传算法以及禁忌搜索等。</p>
                </div>
                <div class="p1">
                    <p id="38">本文提出一种随机并行的局部搜索算法, 以获取最大模块化的聚类图形。引入一种与图中的聚类存在对应关系的{0, 1}矩阵类, 定义聚类的距离函数并构成一个度量空间, 从而有效度量社区检测的结果。</p>
                </div>
                <h3 id="39" name="39" class="anchor-tag">1 社区发现模块化图模型</h3>
                <h4 class="anchor-tag" id="40" name="40">1.1 模型描述</h4>
                <div class="p1">
                    <p id="41">令<i>G</i>= (<i>V</i>, <i>E</i>) 为社区发现图模型<citation id="271" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>, 其中, <i>V</i> (<i>G</i>) 为节点集合, <i>E</i> (<i>G</i>) 为边集合, 且有<mathml id="42"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow><mo>=</mo><mi>n</mi><mo>, </mo><mrow><mo>|</mo><mrow><mi>E</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow><mo>=</mo><mi>m</mi></mrow></math></mathml>。在本文中, 图G的节点可用整数1, 2, …, n表示。每一条边e∈E (G) 可定义为元组形式e:= (i, j) , 其中, i、j表示边e的2个端点。利用聚类C={C<sub>1</sub>, C<sub>2</sub>, …, C<sub>k</sub>}对V (G) 进行定点划分, 即<mathml id="43"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∪</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>C</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo>, </mo><mi>C</mi><msub><mrow></mrow><mi>i</mi></msub><mstyle displaystyle="true"><mo>∩</mo><mi>C</mi></mstyle><msub><mrow></mrow><mi>j</mi></msub><mo>=</mo><mo>∅</mo><mo>, </mo><mo>∀</mo><mi>i</mi><mo>, </mo><mi>j</mi></mrow></math></mathml>。对于给定的聚类C, C<sub>i</sub>∈C是其中的一个分类。聚类C的模块度可由如下的正规化和差进行定义<citation id="272" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>:</p>
                </div>
                <div class="p1">
                    <p id="44">Q (C) :<mathml id="45"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow><mtext> </mtext><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>C</mi></mrow></munder><mrow></mrow></mstyle></mrow><mo stretchy="false"> (</mo><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>-</mo><mi>p</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="46">其中, <i>a</i><sub><i>ij</i></sub>是图<i>G</i>中顶点<i>i</i>和<i>j</i>之间的边缘数量, <i>p</i><sub><i>ij</i></sub>是随机图中顶点<i>i</i>和<i>j</i>之间的期望边数, 其值可指定。随机图<i>H</i>有多种选取方法, 较简单的是伯努利随机图:<mathml id="47"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi>V</mi><mo stretchy="false"> (</mo><mi>Η</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow><mo>=</mo><mrow><mo>|</mo><mrow><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow><mo>=</mo><mi>n</mi></mrow></math></mathml>、<mathml id="48"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mrow><mi>E</mi><mo stretchy="false"> (</mo><mi>Η</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow><mo>=</mo><mrow><mo>|</mo><mrow><mi>E</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow><mo>=</mo><mi>m</mi></mrow></math></mathml>, 其中, <i>H</i>的顶点具有一致的连接概率。由此可得<citation id="273" type="reference"><link href="29" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>:</p>
                </div>
                <div class="p1">
                    <p id="49">Pr[ (<i>i</i>, <i>j</i>) ∈<i>E</i> (<i>H</i>) ]:<mathml id="50"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo stretchy="false"> (</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="51">则顶点<i>i</i>和顶点<i>j</i>之间的期望边数为:</p>
                </div>
                <div class="p1">
                    <p id="52" class="code-formula">
                        <mathml id="52"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mi>m</mi><mrow><mi>n</mi><mo stretchy="false"> (</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></mfrac><mo>, </mo><mo>∀</mo><mi>i</mi><mo>, </mo><mi>j</mi><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="53">由式 (3) 可以看出, <i>H</i>中顶点之间的期望边数不变, 即该图具有泊松分布特征, 这与实际网络中的偏斜分布有较大不同。令<i>d</i><sub><i>G</i></sub> (<i>i</i>) 表示图<i>G</i>中节点<i>i</i>的模块度, 为在随机图<i>H</i>中保持相同的模块度分布, 考虑一个含<i>n</i>个顶点的图, 其中, 每个顶点<i>i</i>与<i>d</i><sub><i>G</i></sub> (<i>i</i>) 的半边连接, 从而产生2<i>m</i>个半边 (此处的半边表示只有一个端点的边) 。随机图<i>H</i>的构造过程示例如图1所示, 其中, <i>n</i>=5, 图1 (c) 中虚线旁的数字表示连接概率。</p>
                </div>
                <div class="area_img" id="54">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201906032_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 随机图H的构造过程示例" src="Detail/GetImg?filename=images/JSJC201906032_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 随机图<i>H</i>的构造过程示例</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201906032_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="55">可利用顶点集<i>V</i> (<i>H</i>) =<i>V</i> (<i>G</i>) 和如下的边集概率对随机图<i>H</i>进行定义。</p>
                </div>
                <div class="p1">
                    <p id="56">Pr[ (<i>i</i>, <i>j</i>) ∈<i>E</i> (<i>H</i>) ]:=Pr[<i>i</i>]×Pr</p>
                </div>
                <div class="p1">
                    <p id="57" class="code-formula">
                        <mathml id="57"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mfrac><mrow><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo></mrow><mrow><mn>2</mn><mi>m</mi></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mrow><mn>2</mn><mi>m</mi></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="58">其中, Pr[<i>i</i>] (Pr[<i>j</i>]) 表示选择靠近节点<i>i</i> (<i>j</i>) 的半边概率。在图1中, 边的值是图中2个顶点之间存在的概率。随机图<i>H</i>的主要特征是其期望模块度序列等于<i>G</i>的模块度序列。对于给定的边缘 (<i>i</i>, <i>j</i>) ∈<i>E</i> (<i>H</i>) 的概率, 顶点<i>i</i>和顶点<i>j</i>之间的期望边数可定义为:</p>
                </div>
                <div class="p1">
                    <p id="59"><i>p</i><sub><i>ij</i></sub>=2<i>m</i>×Pr<mathml id="60"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">[</mo><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo stretchy="false">) </mo><mo>∈</mo><mi>E</mi><mo stretchy="false"> (</mo><mi>Η</mi><mo stretchy="false">) </mo><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mrow><mn>2</mn><mi>m</mi></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>5</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="61">因此, 式 (1) 可改写为:</p>
                </div>
                <div class="p1">
                    <p id="62"><i>Q</i> (<i>C</i>) :<mathml id="63"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow><mtext> </mtext><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>C</mi></mrow></munder><mrow></mrow></mstyle></mrow><mrow><mo> (</mo><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>-</mo><mfrac><mrow><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow><mo>) </mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>6</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="64">在加权图的情况下, 对图的边缘定义权函数<i>w</i>:=<i>E</i> (<i>G</i>) →<i>R</i>, 进而定义顶点<i>i</i>∈<i>V</i> (<i>G</i>) 的强度:</p>
                </div>
                <div class="p1">
                    <p id="65" class="code-formula">
                        <mathml id="65"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>s</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mi>w</mi></mstyle><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>7</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="66">对于给定的加权图<i>G</i>, 可得到聚类<i>C</i>的模块度:</p>
                </div>
                <div class="p1">
                    <p id="67"><i>Q</i><sub><i>w</i></sub> (<i>C</i>) :<mathml id="68"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>e</mi><mo>∈</mo><mi>E</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mi>w</mi></mstyle><mo stretchy="false"> (</mo><mi>e</mi><mo stretchy="false">) </mo></mrow></mfrac><mtext> </mtext><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>C</mi></mrow></munder><mrow></mrow></mstyle></mrow><mrow><mo> (</mo><mrow><mi>w</mi><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo stretchy="false">) </mo><mo>-</mo><mfrac><mrow><mi>s</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>s</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mrow><mn>2</mn><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>e</mi><mo>∈</mo><mi>E</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mi>w</mi></mstyle><mo stretchy="false"> (</mo><mi>e</mi><mo stretchy="false">) </mo></mrow></mfrac></mrow><mo>) </mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>8</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="69">如果存在有向图<i>G</i>, <i>a</i><sub><i>ij</i></sub>表示从顶点<i>i</i>到顶点<i>j</i>的有向边数量, <i>d</i><sup>+</sup><sub><i>G</i></sub> (<i>i</i>) 、<i>d</i><sup>-</sup><sub><i>G</i></sub> (<i>i</i>) 分别表示顶点<i>i</i>的入度和出度, 由此可得:</p>
                </div>
                <div class="p1">
                    <p id="70" class="code-formula">
                        <mathml id="70"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mi>j</mi></munder><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="left"><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>-</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mi>i</mi></munder><mi>a</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>9</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="71">在没有任何社区结构的情况下建立一个随机有向图空模型, 其模型的入度和出度等同于图<i>G</i>, 则可得<i>m</i>个输入边缘和<i>m</i>个输出边缘, 如图2所示。因此, 随机有向图<i>H</i>的边集概率可表示为:</p>
                </div>
                <div class="p1">
                    <p id="72">Pr[ (<i>i</i>, <i>j</i>) ∈<i>E</i> (<i>H</i>) ]:=Pr[<i>i</i>]×Pr<mathml id="73"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mfrac><mrow><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>-</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mrow><mi>m</mi><msup><mrow></mrow><mn>2</mn></msup></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="area_img" id="74">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201906032_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 随机有向图H的构造过程示例" src="Detail/GetImg?filename=images/JSJC201906032_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 随机有向图<i>H</i>的构造过程示例</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201906032_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="75">在随机图<i>H</i>中, 顶点<i>i</i>和顶点<i>j</i>之间的边缘数为:</p>
                </div>
                <div class="p1">
                    <p id="76" class="code-formula">
                        <mathml id="76"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>-</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mi>m</mi></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="77">因此, 有向图<i>G</i>中聚类<i>C</i>的模块度可表示为:</p>
                </div>
                <div class="p1">
                    <p id="78"><i>Q</i><sub><i>d</i></sub> (<i>C</i>) :<mathml id="79"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><mtext> </mtext><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>C</mi></mrow></munder><mrow></mrow></mstyle></mrow><mrow><mo> (</mo><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>-</mo><mfrac><mrow><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>-</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>d</mi><msubsup><mrow></mrow><mi>G</mi><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mi>m</mi></mfrac></mrow><mo>) </mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="80">由此可得, 式 (7) 中顶点<i>i</i>∈<i>V</i> (<i>G</i>) 的强度相对于图<i>G</i>的输入强度和输出强度可分别表示如下:</p>
                </div>
                <div class="p1">
                    <p id="81" class="code-formula">
                        <mathml id="81"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mi>s</mi><msubsup><mrow></mrow><mi>G</mi><mo>-</mo></msubsup><mo>:</mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mi>w</mi></mstyle><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd columnalign="left"><mi>s</mi><msubsup><mrow></mrow><mi>G</mi><mo>+</mo></msubsup><mo>:</mo><mo>=</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mi>w</mi></mstyle><mo stretchy="false"> (</mo><mi>j</mi><mo>, </mo><mi>i</mi><mo stretchy="false">) </mo></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="82">对于加权图, 将式 (8) 和式 (12) 进行综合, 模块度可表示为:</p>
                </div>
                <div class="p1">
                    <p id="83" class="code-formula">
                        <mathml id="83"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>Q</mi><msub><mrow></mrow><mrow><mi>w</mi><mo>, </mo><mi>d</mi></mrow></msub><mo stretchy="false"> (</mo><mi>C</mi><mo stretchy="false">) </mo><mo>:</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mo stretchy="false"> (</mo></mstyle><mi>w</mi><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo stretchy="false">) </mo><mo>+</mo><mi>w</mi><mo stretchy="false"> (</mo><mi>j</mi><mo>, </mo><mi>i</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mrow></mfrac><mo>×</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext></mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>C</mi></mrow></munder><mrow><mrow><mo> (</mo><mrow><mi>w</mi><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo stretchy="false">) </mo><mo>-</mo><mfrac><mrow><mi>s</mi><msubsup><mrow></mrow><mi>G</mi><mo>-</mo></msubsup><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>s</mi><msubsup><mrow></mrow><mi>G</mi><mo>+</mo></msubsup><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mo stretchy="false"> (</mo></mstyle><mi>w</mi><mo stretchy="false"> (</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo stretchy="false">) </mo><mo>+</mo><mi>w</mi><mo stretchy="false"> (</mo><mi>j</mi><mo>, </mo><mi>i</mi><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mrow></mfrac></mrow><mo>) </mo></mrow></mrow></mstyle><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>4</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="84">为简化符号表达, 此处使用<i>n</i>×<i>n</i>大小的矩阵<b><i>M</i></b>= (<i>m</i><sub><i>ij</i></sub>) 作为模块矩阵, 其元素形式为:</p>
                </div>
                <div class="area_img" id="86">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJC201906032_08600.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="87">其中, <i>i</i>, <i>j</i>=1, 2, …, <i>n</i>, <i>G</i>∈<i>unweighted</i>表示图<i>G</i>为无权重图, <i>G</i>∈<i>weighted</i>表示图<i>G</i>为权重图。</p>
                </div>
                <h4 class="anchor-tag" id="88" name="88">1.2 整数规划</h4>
                <div class="p1">
                    <p id="89">给定一个无向图G= (V, E) , 需找到一个聚类划分C来最大化式 (3) 。为将上述问题表示为一个整数{0, 1}问题, 本文定义二进制变量x<sub>ij</sub>来表示每个节点对:</p>
                </div>
                <div class="p1">
                    <p id="90" class="code-formula">
                        <mathml id="90"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mrow><mo>{</mo><mrow><mtable><mtr><mtd columnalign="left"><mn>1</mn><mo>, </mo><mspace width="0.25em" /><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>s</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn><mo>, </mo><mspace width="0.25em" /><mtext>其</mtext><mtext>他</mtext></mtd></mtr></mtable></mrow></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>6</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="91">其中, x<sub>ij</sub>变量定义了V (G) 之间的关系。将线性二元规划与关联矩阵<b><i>A</i></b>= (<i>a</i><sub><i>ij</i></sub>) 相结合, 解决图<i>G</i> (<i>V</i>, <i>E</i>) 聚类中的模块最大化问题:</p>
                </div>
                <div class="p1">
                    <p id="92" class="code-formula">
                        <mathml id="92"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mrow><mi>max</mi></mrow><mrow><mfrac><mn>1</mn><mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow><mtext> </mtext><mrow><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow></munder><mrow></mrow></mstyle></mrow><mrow><mo> (</mo><mrow><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>-</mo><mfrac><mrow><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>d</mi><msub><mrow></mrow><mi>G</mi></msub><mo stretchy="false"> (</mo><mi>j</mi><mo stretchy="false">) </mo></mrow><mrow><mn>2</mn><mi>m</mi></mrow></mfrac></mrow><mo>) </mo></mrow><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>7</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mtext>s</mtext><mo>.</mo><mtext>t</mtext><mo>.</mo></mtd></mtr><mtr><mtd><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><mn>1</mn><mo>, </mo><mo>∀</mo><mi>i</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mo>, </mo><mo>∀</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><mi>x</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi></mrow></msub><mo>≤</mo><mn>2</mn><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>k</mi></mrow></msub><mo>+</mo><mn>1</mn><mo>, </mo><mo>∀</mo><mi>i</mi><mo>, </mo><mi>j</mi><mo>, </mo><mi>k</mi><mo>∈</mo><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="93"><i>x</i><sub><i>ij</i></sub>∈0, 1, ∀<i>i</i>, <i>j</i>∈<i>V</i> (<i>G</i>) </p>
                </div>
                <div class="p1">
                    <p id="94">上述定义的最大模块规划问题是一个NP优化问题, 在多项式时间内较难提供解决方案, 局部搜索算法是解决该问题的最优方法之一。</p>
                </div>
                <h3 id="95" name="95" class="anchor-tag">2 社区检测的贪婪随机自适应路径重连</h3>
                <h4 class="anchor-tag" id="96" name="96">2.1 算法流程</h4>
                <div class="p1">
                    <p id="97"><i>GAP</i>算法是随机并行的局部搜索算法, 已得到广泛的应用。由于<i>GAP</i>算法进行独立迭代, 因此该算法具有无记忆性。为解决该问题, 本文引入路径重连程序, 在当前解集与先前良好解集之间建立关联, 以解决贪婪搜索的独立性问题, 加快算法的收敛。引入路径重连程序的<i>GAP</i>算法伪代码如下:</p>
                </div>
                <div class="p1">
                    <p id="98"><b>算法1</b> 引入路径重连程序的GAP算法</p>
                </div>
                <div class="p1">
                    <p id="99"><b>输入</b> 图<i>G</i> (<i>V</i>, <i>E</i>) , 最大迭代次数<i>iter</i>, 随机数种子<i>seed</i>, 精英集大小<i>elitesize</i>, 贪婪参数<i>α</i>∈ (0, 1) , 邻域大小<i>l</i></p>
                </div>
                <div class="p1">
                    <p id="100"><b>输出</b> 聚类<i>C</i><sup>*</sup>={<i>C</i><sub>1</sub>, <i>C</i><sub>2</sub>, …, <i>C</i><sub><i>k</i></sub>}</p>
                </div>
                <div class="p1">
                    <p id="101">1.C<sup>*</sup>:=Ø, S:=Ø;</p>
                </div>
                <div class="p1">
                    <p id="102">2.for i=1, 2, …, iter do</p>
                </div>
                <div class="p1">
                    <p id="103">3.C<sup>c</sup>:=ConstructClustering (G (V, E) , seed, α) ;</p>
                </div>
                <div class="p1">
                    <p id="104">4.C<sup>l</sup>:=LoadSearch (G (V, E) , C<sup>c</sup>, l) ;</p>
                </div>
                <div class="p1">
                    <p id="105">5.C<sup>p</sup>:=PathRelinking (G (V, E) , S, C<sup>l</sup>, elitesize) ;</p>
                </div>
                <div class="p1">
                    <p id="106">6.UpdateElite (S, C<sup>p</sup>) ;</p>
                </div>
                <div class="p1">
                    <p id="107">7.if Q (C<sup>p</sup>) &gt;Q (C<sup>*</sup>) then</p>
                </div>
                <div class="p1">
                    <p id="108">8.C<sup>*</sup>:=C<sup>p</sup>;</p>
                </div>
                <div class="p1">
                    <p id="109">9.end if</p>
                </div>
                <div class="p1">
                    <p id="110">10.end for</p>
                </div>
                <div class="p1">
                    <p id="111">11.return</p>
                </div>
                <div class="p1">
                    <p id="112">在算法1中, 第1行对最佳聚类<i>C</i><sup>*</sup>进行初始化, 路径重连解集为<i>S</i>。第3行利用空集合构造一个解决方案<i>C</i><sup><i>c</i></sup>的初始化解集, 并将其传递到第4行的本地搜索过程中, 求解<i>l</i>邻域局部最大的解决方案<i>C</i><sup><i>l</i></sup>。第5行对上述求解的局部最大解决方案<i>C</i><sup><i>l</i></sup>进行路径重连。第6行更新所获得的路径。算法最后存储搜索得到的最佳聚类解集<i>C</i><sup>*</sup>。</p>
                </div>
                <h4 class="anchor-tag" id="113" name="113">2.2 聚类构造</h4>
                <div class="p1">
                    <p id="114">在算法1的每次迭代中, 第1步通过贪婪的随机方式从空集开始构建一个聚类。令<mathml id="115"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>=</mo><mo stretchy="false">{</mo><mi>C</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mrow><mi>C</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo></mrow><mi>C</mi><msub><mrow></mrow><mrow><mrow><mo>|</mo><mi>C</mi><mo>|</mo></mrow></mrow></msub><mo stretchy="false">}</mo><mo>⊆</mo><mn>2</mn><msup><mrow></mrow><mrow><mrow><mo>|</mo><mrow><mi>V</mi><mo stretchy="false"> (</mo><mi>G</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow></mrow></msup></mrow></math></mathml>表示顶点G的局部聚类, 其并不包括V (G) 的整体。考虑如下不在C中的顶点集:</p>
                </div>
                <div class="p1">
                    <p id="116">L (C) :={i∈V (G) :i∉C}      (18) </p>
                </div>
                <div class="p1">
                    <p id="117">对于局部分区C, 定义元素L (C) 的增益函数g<sub>C</sub>:V (G) →R, 其表征某些顶点从L (C) 添加到局部聚类C中时其模块度的增加。对于i∈L (C) 有:</p>
                </div>
                <div class="p1">
                    <p id="118">1) 如果i是C中的聚类, 则其增益函数为:</p>
                </div>
                <div class="p1">
                    <p id="119">g<sub>C</sub> (i) :=<i>max</i> (m<sub>ii</sub>)      (19) </p>
                </div>
                <div class="p1">
                    <p id="120">其中, m<sub>ii</sub>是模块化矩阵元素。</p>
                </div>
                <div class="p1">
                    <p id="121">2) 如果i是C中的聚类成员, 则其增益函数为:</p>
                </div>
                <div class="p1">
                    <p id="122">g<sub>C</sub> (i) :<mathml id="123"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mi>max</mi></mrow></mstyle><mi>k</mi></munder><mo stretchy="false"> (</mo><mstyle displaystyle="true"><munder><mo>∑</mo><mrow><mi>j</mi><mo>∈</mo><mi>C</mi><msub><mrow></mrow><mi>k</mi></msub></mrow></munder><mi>m</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo stretchy="false">) </mo><mo>+</mo><mi>m</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>i</mi></mrow></msub><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="124">利用增益函数<i>g</i><sub><i>C</i></sub>可对集合<i>L</i> (<i>C</i>) 进行降序排列:</p>
                </div>
                <div class="p1">
                    <p id="125" class="code-formula"><mathml id="126"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mrow><mi>L</mi><mo stretchy="false"> (</mo><mi>C</mi><mo stretchy="false">) </mo></mrow><mo stretchy="true">→</mo></mover></mrow></math></mathml>:<mathml id="127"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><mo stretchy="false"> (</mo><mi>i</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>, </mo><mi>i</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>i</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mrow><mo>|</mo><mi>C</mi><mo>|</mo></mrow><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="128">其中, <mathml id="129"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><msub><mrow></mrow><mi>C</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false">) </mo><mo>≥</mo><mi>g</mi><msub><mrow></mrow><mi>C</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false">) </mo><mo>≥</mo><mo>⋯</mo><mo>≥</mo><mi>g</mi><msub><mrow></mrow><mi>C</mi></msub><mo stretchy="false"> (</mo><mi>i</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mrow><mo>|</mo><mi>C</mi><mo>|</mo></mrow><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false">) </mo></mrow></math></mathml>。聚类的构造过程如下:</p>
                </div>
                <div class="p1">
                    <p id="130"><b>算法2</b> 聚类构造过程</p>
                </div>
                <div class="p1">
                    <p id="131"><b>输入</b> 图<i>G</i> (<i>V</i>, <i>E</i>) , 随机数种子<i>seed</i>, 贪婪参数<i>α</i>∈ (0, 1) </p>
                </div>
                <div class="p1">
                    <p id="132"><b>输出</b> 聚类<mathml id="133"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><msup><mrow></mrow><mi>c</mi></msup><mo>=</mo><mo stretchy="false">{</mo><mi>C</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>C</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>C</mi><msub><mrow></mrow><mrow><mrow><mo>|</mo><mrow><mi>C</mi><msup><mrow></mrow><mi>c</mi></msup></mrow><mo>|</mo></mrow></mrow></msub><mo stretchy="false">}</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="134">1.C<sup>c</sup>:=Ø, L (C<sup>c</sup>) :=V (G) ;</p>
                </div>
                <div class="p1">
                    <p id="135">2.while L (C<sup>c</sup>) ≠Ø do</p>
                </div>
                <div class="p1">
                    <p id="136">3.Compute<mathml id="137"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false"> (</mo><mover accent="true"><mrow><mtext>L</mtext><mo stretchy="false"> (</mo><mtext>C</mtext><msup><mrow></mrow><mtext>c</mtext></msup><mo stretchy="false">) </mo></mrow><mo stretchy="true">→</mo></mover><mo stretchy="false">) </mo><mo>;</mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="138">4.从<mathml id="139"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mrow><mtext>L</mtext><mo stretchy="false"> (</mo><mtext>C</mtext><msup><mrow></mrow><mtext>c</mtext></msup><mo stretchy="false">) </mo></mrow><mo stretchy="true">→</mo></mover></mrow></math></mathml>的前α个元素中随机选取i;</p>
                </div>
                <div class="p1">
                    <p id="140">5.C<sup>c</sup>:=C∪{i};</p>
                </div>
                <div class="p1">
                    <p id="141">6.L (C<sup>c</sup>) :=L (C<sup>c</sup>) -{i};</p>
                </div>
                <div class="p1">
                    <p id="142">7.end while</p>
                </div>
                <div class="p1">
                    <p id="143">8.return</p>
                </div>
                <div class="p1">
                    <p id="144">在算法2中, 第1行将分区聚类<i>C</i><sup><i>c</i></sup>初始化为空集, 第2行～第7行为算法迭代过程, 首先利用增益函数 (式 (19) 、式 (20) ) 计算候选节点的顺序集, 在该集合中利用最佳<mathml id="145"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>α</mi><mo>×</mo><mrow><mo>|</mo><mrow><mi>C</mi><msup><mrow></mrow><mi>c</mi></msup></mrow><mo>|</mo></mrow></mrow></math></mathml>顶点选取集合中的顶点i并添加到聚类中。区间α∈ (0, 1) 定义了贪婪或随机构造解的度, 如果α值为0, 则算法执行贪婪搜索过程, 如果α值为1, 则算法执行随机搜索过程。第6行通过增益矩阵将所选节点添加到分区聚类中。</p>
                </div>
                <h4 class="anchor-tag" id="146" name="146">2.3 局部搜索过程</h4>
                <div class="p1">
                    <p id="147">对一个优化问题进行局部搜索, 表示在给定解的邻域内进行穷举搜索以得到局部最优解。为指定解的邻域结构, 需定义任意2个解之间的距离。下文给出{0, 1}类别矩阵的定义, 以对图模型的聚类过程进行代数处理, 从而简化评价过程。</p>
                </div>
                <div class="p1">
                    <p id="148"><b>定义1</b> 对于矩阵<b><i>S</i></b>= (<i>s</i><sub><i>ij</i></sub>) ∈{0, 1}<sup><i>k</i>×<i>n</i></sup>, 如果其满足下列条件, 则被称为基本聚类矩阵:</p>
                </div>
                <div class="p1">
                    <p id="149">1) 没有全0行。</p>
                </div>
                <div class="p1">
                    <p id="150">2) 对于所有的<i>j</i>=1, 2, …, <i>n</i>, 存在<mathml id="151"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>s</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow></math></mathml>。</p>
                </div>
                <div class="p1">
                    <p id="152">3) 如果s<sub>ij</sub>是第i行的第一个非零元素, 则对于l=i+1, i+2, …, n和t=1, 2, …, j, 存在s<sub>lt</sub>=0。</p>
                </div>
                <div class="p1">
                    <p id="153">如果只满足上述第1、第2个条件, 则称该矩阵为聚类矩阵。按第3个条件对聚类矩阵的行施加一定次序, 得到基本聚类矩阵。因此, 对于任意的{0, 1}<sup>k×n</sup>聚类矩阵, 存在一个唯一的大小为k的聚类, 而对于大小为k的任何聚类, 都存在k!个聚类矩阵, 由所有关联基本聚类矩阵行的置换生成。对于任意的聚类C, 其对应的基本聚类矩阵可表示为<b><i>S</i></b><sub><i>C</i></sub>, 对应的聚类矩阵可表示为<b><i>C</i></b><sub><i>S</i></sub>。对于基本聚类矩阵<b><i>S</i></b>, 通过置换其行将<i>k</i>!的聚类矩阵表示为<b><i>M</i></b> (<i>S</i>) 。对于给定的2个任意聚类矩阵<b><i>S</i></b>∈{0, 1}<sup><i>k</i><sub>1</sub>×<i>n</i></sup>和<b><i>T</i></b>∈{0, 1}<sup><i>k</i><sub>2</sub>×<i>n</i></sup>, 其差集定义为:</p>
                </div>
                <div class="p1">
                    <p id="154"><i>Δ</i> (<b><i>S</i>, <i>T</i></b>) :={<i>j</i>:<i>S</i><sub><i>ij</i></sub>≠<i>T</i><sub><i>ij</i></sub>}      (22) </p>
                </div>
                <div class="p1">
                    <p id="155">其中, <i>i</i>=1, 2, …, min{<i>k</i><sub>1</sub>, <i>k</i><sub>2</sub>}, <i>j</i>=1, 2, …, <i>n</i>。对于给定的2个任意基本聚类矩阵<b><i>S</i></b><sup>1</sup>∈{0, 1}<sup><i>k</i><sub>1</sub>×<i>n</i></sup>和<b><i>S</i></b><sup>2</sup>∈{0, 1}<sup><i>k</i><sub>2</sub>×<i>n</i></sup>, 其距离指标表示为:</p>
                </div>
                <div class="p1">
                    <p id="156" class="code-formula">
                        <mathml id="156"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>d</mi><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">S</mi><msup><mrow></mrow><mn>1</mn></msup><mo>, </mo><mi mathvariant="bold-italic">S</mi><msup><mrow></mrow><mn>2</mn></msup><mo stretchy="false">) </mo><mo>:</mo><mo>=</mo></mtd></mtr><mtr><mtd><mtext> </mtext><mrow><mi>min</mi></mrow><mo stretchy="false">{</mo><mrow><mo>|</mo><mrow><mi>Δ</mi><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">S</mi><mo>, </mo><mi mathvariant="bold-italic">Τ</mi><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="157">:<b><i>S</i></b>∈<b><i>M</i></b> (<b><i>S</i></b><sup>1</sup>) , <b><i>T</i></b>∈<b><i>M</i></b> (<b><i>S</i></b><sup>2</sup>) }      (23) </p>
                </div>
                <div class="p1">
                    <p id="158">因此, <i>d</i> (<b><i>S</i></b><sup>1</sup>, <b><i>S</i></b><sup>2</sup>) 表示基本聚类矩阵 <b><i>S</i></b><sup>1</sup>和 <b><i>S</i></b><sup>2</sup>的聚类分区之间可实现聚类的距离。<b><i>S</i></b><sup>1</sup>和<b><i>S</i></b><sup>2</sup>之间距离的元素差集定义为最小差集, 表示为<i>Δ</i><sup>*</sup> (<b><i>S</i></b><sup>1</sup>, <b><i>S</i></b><sup>2</sup>) 。</p>
                </div>
                <div class="p1">
                    <p id="159"><b>引理1</b> 对于任意的图<i>G</i> (<i>V</i>, <i>E</i>) 和3个类别<i>C</i><sub>1</sub>、<i>C</i><sub>2</sub>和<i>C</i><sub>3</sub>, 下列情况成立<citation id="274" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>:</p>
                </div>
                <div class="p1">
                    <p id="160">1) <i>d</i> (<b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>) ≥0, if <b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>=<b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>。</p>
                </div>
                <div class="p1">
                    <p id="161">2) <i>d</i> (<b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>) =<i>d</i> (<b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="162">3) <i>d</i> (<b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>) +<i>d</i> (<b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>3</sub></sub>) ≥<i>d</i> (<b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>3</sub></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="163">由引理1可以看出, 式 (23) 中定义的距离函数是正向对称的, 满足三角不等式, 因此, 给定图的所有基本聚类矩阵的集合与距离函数, 能构成一个度量空间。</p>
                </div>
                <div class="p1">
                    <p id="164"><b>定理1</b> 对于给定的任意2个基本聚类矩阵<b><i>S</i></b><sup>1</sup>∈{0, 1}<sup><i>k</i><sub>1</sub>×<i>n</i></sup>和<b><i>S</i></b><sup>2</sup>∈{0, 1}<sup><i>k</i><sub>2</sub>×<i>n</i></sup>, 其距离指标<i>d</i> (<b><i>S</i></b><sup>1</sup>, <b><i>S</i></b><sup>2</sup>) 的计算复杂度为<i>O</i> (<i>k</i><sup>3</sup>) , 其中, <i>k</i>:=min{<i>k</i><sub>1</sub>, <i>k</i><sub>2</sub>}。</p>
                </div>
                <div class="p1">
                    <p id="165"><b>证明</b> 本文将上述距离指标的计算过程简化为线性指派问题。对于给定的2个基本聚类矩阵<b><i>S</i></b><sup>1</sup>= (<i>s</i><mathml id="166"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow><mn>1</mn></msubsup></mrow></math></mathml>) 和<b><i>S</i></b><sup>2</sup>= (<i>s</i><mathml id="167"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup></mrow></math></mathml>) , 构建<i>k</i>×<i>k</i>的成本矩阵, 具体形式为:</p>
                </div>
                <div class="p1">
                    <p id="168"><b><i>c</i></b><sub><i>ij</i></sub>:<mathml id="169"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mrow><mo>|</mo><mrow><mi>s</mi><msubsup><mrow></mrow><mrow><mi>i</mi><mi>l</mi></mrow><mn>1</mn></msubsup><mo>-</mo><mi>s</mi><msubsup><mrow></mrow><mrow><mi>i</mi><mi>l</mi></mrow><mn>2</mn></msubsup></mrow><mo>|</mo></mrow></mrow></mstyle><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="170">其中, <i>i</i>, <i>j</i>=1, 2, …, <i>k</i>。考虑如下的组合优化问题:<mathml id="171"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mtext>m</mtext><mtext>i</mtext><munder><mstyle mathsize="140%" displaystyle="true"><mtext>n</mtext></mstyle><mrow><mi>p</mi><mo>∈</mo><mi>Ρ</mi><msub><mrow></mrow><mi>k</mi></msub></mrow></munder></mrow><mtext> </mtext><mi>C</mi><msub><mrow></mrow><mrow><mi>p</mi><mo stretchy="false"> (</mo><mi>i</mi><mo stretchy="false">) </mo><mi>i</mi></mrow></msub></mrow></math></mathml>, 其中, <i>P</i><sub><i>k</i></sub>是集合{1, 2, …, <i>k</i>}的所有置换集。将式 (24) 的最佳置换对应较小基本聚类矩阵的行置换, 需要生成<b><i>S</i></b><sup>1</sup>和<b><i>S</i></b><sup>2</sup>之间的距离聚类矩阵, 则式 (24) 等价于一个线性分配问题, 其计算复杂度为<i>O</i> (<i>k</i><sup>3</sup>) 。在聚类<i>C</i><sup><i>c</i></sup>的局部搜索过程中, 如果<i>C</i><sup><i>l</i></sup>满足下列条件, 则选取聚类<i>C</i><sup><i>l</i></sup>为局部最优解:</p>
                </div>
                <div class="p1">
                    <p id="172"><i>C</i><sup><i>l</i></sup>=argmax{<i>Q</i> (<i>C</i>) :<i>C</i>∈<i>N</i><sub><i>l</i></sub> (<i>C</i><sup><i>l</i></sup>) }      (25) </p>
                </div>
                <div class="p1">
                    <p id="173">局部搜索过程如算法3所示。在算法的第2行～第11行, 反复执行当前解<i>C</i><sup>*</sup>的<i>l</i>邻域内的局部最优解搜索过程, 当前解是局部最优解时, 算法终止。</p>
                </div>
                <div class="p1">
                    <p id="174"><b>算法3</b> 局部搜索过程</p>
                </div>
                <div class="p1">
                    <p id="175"><b>输入</b> 图<i>G</i> (<i>V</i>, <i>E</i>) , 聚类<i>C</i><sup><i>c</i></sup>, 邻域大小<i>l</i></p>
                </div>
                <div class="p1">
                    <p id="176" class="code-formula">
                        <mathml id="176"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mrow><mspace width="0.25em" /><mtext>输</mtext><mtext>出</mtext><mtext> </mtext></mrow><mtext>聚</mtext><mtext>类</mtext><mi>C</mi><msup><mrow></mrow><mi>l</mi></msup><mo>=</mo><mo stretchy="false">{</mo><mi>C</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>C</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>C</mi><msub><mrow></mrow><mrow><mrow><mo>|</mo><mrow><mi>C</mi><msup><mrow></mrow><mi>l</mi></msup></mrow><mo>|</mo></mrow></mrow></msub><mo stretchy="false">}</mo></mtd></mtr><mtr><mtd><mspace width="0.25em" /><mn>1</mn><mo>.</mo><mtext>C</mtext><msup><mrow></mrow><mtext>l</mtext></msup><mo>=</mo><mtext>C</mtext><msup><mrow></mrow><mtext>c</mtext></msup><mo>;</mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="177">2.repeat</p>
                </div>
                <div class="p1">
                    <p id="178">3.C<sup>*</sup>:=C<sup>l</sup>;</p>
                </div>
                <div class="p1">
                    <p id="179">4.N:=N<sub>l</sub> (C<sup>*</sup>) ;</p>
                </div>
                <div class="p1">
                    <p id="180">5.for all C∈N do</p>
                </div>
                <div class="p1">
                    <p id="181">6.if Q (C) &lt;Q (C<sup>l</sup>) then</p>
                </div>
                <div class="p1">
                    <p id="182">7.C<sup>l</sup>:=C;</p>
                </div>
                <div class="p1">
                    <p id="183">8.end if</p>
                </div>
                <div class="p1">
                    <p id="184">9.N:=N＼{C};</p>
                </div>
                <div class="p1">
                    <p id="185">10.end for</p>
                </div>
                <div class="p1">
                    <p id="186">11.until C<sup>l</sup>≠C<sup>*</sup>;</p>
                </div>
                <div class="p1">
                    <p id="187">12.return C<sup>l</sup>;</p>
                </div>
                <h4 class="anchor-tag" id="188" name="188">2.4 路径重连过程</h4>
                <div class="p1">
                    <p id="189">路径重连过程中2个解<i>C</i><sub>1</sub>和<i>C</i><sub>2</sub>的聚类空间可表示为:</p>
                </div>
                <div class="area_img" id="190">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJC201906032_19000.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="192"><i>Δ</i><sup>*</sup> (<b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>) 的所有<mathml id="193"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>2</mn><msup><mrow></mrow><mrow><mrow><mo>|</mo><mrow><mi>d</mi><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">S</mi><msub><mrow></mrow><mrow><mi>C</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></msub><mo>, </mo><mi mathvariant="bold-italic">S</mi><msub><mrow></mrow><mrow><mi>C</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></msub><mo stretchy="false">) </mo></mrow><mo>|</mo></mrow></mrow></msup></mrow></math></mathml>个子集示例如图3所示。</p>
                </div>
                <div class="area_img" id="194">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201906032_194.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 聚类空间示意图" src="Detail/GetImg?filename=images/JSJC201906032_194.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 聚类空间示意图</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201906032_194.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="195">由于聚类空间的大小与距离指标<i>d</i> (<b><i>S</i></b><sub><i>C</i><sub>1</sub></sub>, <b><i>S</i></b><sub><i>C</i><sub>2</sub></sub>) 呈指数关系, 因此无法在该空间中产生最大模块化问题的解决方案。本文采用一种贪婪的方式对<i>C</i><sub>1</sub>和<i>C</i><sub>2</sub>的空间解路径进行跟踪, 并对每个解执行局部邻域搜索。图3所示为<i>C</i><sub>1</sub>和<i>C</i><sub>2</sub>之间的路径重连过程, 顶点<i>i</i><sub>1</sub>、<i>i</i><sub>2</sub>和<i>i</i><sub>3</sub>可实现从<i>C</i><sub>1</sub>到<i>C</i><sub>2</sub>的跟踪移动。路径重连过程如算法4所示。</p>
                </div>
                <div class="p1">
                    <p id="196"><b>算法4</b> 路径重连过程</p>
                </div>
                <div class="p1">
                    <p id="197"><b>输入</b> 图<i>j</i>, 聚类<i>C</i><sup><i>l</i></sup>, 精英解集<i>S</i></p>
                </div>
                <div class="p1">
                    <p id="278">输出聚类C<sup>p</sup>={C<sub>1</sub>, C<sub>2</sub>, …, C<sub>Cp</sub>}</p>
                </div>
                <div class="p1">
                    <p id="199">1.<image id="279" type="formula" href="images/JSJC201906032_27900.jpg" display="inline" placement="inline"><alt></alt></image>:={C∈S:d (S<sub>C</sub>, S<sub>C</sub>l) ≥4};</p>
                </div>
                <div class="p1">
                    <p id="200">2.if<mathml id="201"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo>|</mo><mtext>S</mtext><mo>|</mo></mrow><mo>&lt;</mo><mtext>e</mtext><mtext>l</mtext><mtext>i</mtext><mtext>t</mtext><mtext>e</mtext><mtext>s</mtext><mtext>i</mtext><mtext>z</mtext><mtext>e</mtext></mrow></math></mathml><mathml id="202"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">∥</mo><mspace width="0.25em" /><mover><mstyle mathsize="140%" displaystyle="true"><mtext>S</mtext></mstyle><mrow><mspace width="0.25em" /><mo>—</mo></mrow></mover><mo>=</mo><mo>∅</mo><mspace width="0.25em" /><mtext>t</mtext><mtext>h</mtext><mtext>e</mtext><mtext>n</mtext></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="203">3.return C<sup>l</sup>;</p>
                </div>
                <div class="p1">
                    <p id="204">4.end if</p>
                </div>
                <div class="p1">
                    <p id="205">5.for all<mathml id="206"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>C</mtext><mo>∈</mo><mover><mstyle mathsize="140%" displaystyle="true"><mtext>S</mtext></mstyle><mrow><mspace width="0.25em" /><mo>—</mo></mrow></mover><mspace width="0.25em" /><mtext>d</mtext><mtext>o</mtext></mrow></math></mathml></p>
                </div>
                <div class="p1">
                    <p id="207">6.S<sup>0</sup>:=S<sub>C</sub>;S<sup>*</sup>:=S<sub>C</sub>;</p>
                </div>
                <div class="p1">
                    <p id="208">7.for k=0, 1, …, d (S<sub>C</sub>, S<sub>C<sup></sup>l</sub>) -2 do</p>
                </div>
                <div class="p1">
                    <p id="209">8.max:=0;</p>
                </div>
                <div class="p1">
                    <p id="210">9.for all C<mathml id="211"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mtext>i</mtext><mtext>l</mtext></msubsup></mrow></math></mathml>∈Δ′ (S<sup>k</sup>, S<sub>C<sup></sup>l</sub>) do</p>
                </div>
                <div class="p1">
                    <p id="212">10.S:=change (S<sup>k</sup>, S<sub>C<sup></sup>l</sub>, C<mathml id="213"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mtext>i</mtext><mtext>l</mtext></msubsup></mrow></math></mathml>) ;</p>
                </div>
                <div class="p1">
                    <p id="214">11.if Q (C<sub>S</sub>) &gt;max then</p>
                </div>
                <div class="p1">
                    <p id="215">12.i<sup>*</sup>:=i;max:=Q (C<sub>S</sub>) ;</p>
                </div>
                <div class="p1">
                    <p id="216">13.end if</p>
                </div>
                <div class="p1">
                    <p id="217">14.end for</p>
                </div>
                <div class="p1">
                    <p id="218">15.S<sup>k+1</sup>:=change (S<sup>k</sup>, S<sub>C<sup></sup>l</sub>, C<mathml id="219"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mrow><mtext>i</mtext><msup><mrow></mrow><mo>*</mo></msup></mrow><mtext>l</mtext></msubsup></mrow></math></mathml>) ;</p>
                </div>
                <div class="p1">
                    <p id="220">16.C:=LocalSearch (G (V, E) , C<sub>S<sup>k+1</sup></sub>) ;</p>
                </div>
                <div class="p1">
                    <p id="221">17.if Q (C) &gt;Q (C<sub>S<sup>*</sup></sub>) then</p>
                </div>
                <div class="p1">
                    <p id="222">18.S<sup>*</sup>:=S<sub>C</sub>;</p>
                </div>
                <div class="p1">
                    <p id="223">19.end if</p>
                </div>
                <div class="p1">
                    <p id="224">20.end for</p>
                </div>
                <div class="p1">
                    <p id="225">21.end for;</p>
                </div>
                <div class="p1">
                    <p id="226">22.return C<sub>S<sup>*</sup></sub>;</p>
                </div>
                <div class="p1">
                    <p id="227">在算法4中, 第1行对集合<mathml id="228"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mstyle mathsize="140%" displaystyle="true"><mi mathvariant="bold-italic">S</mi></mstyle><mrow><mspace width="0.25em" /><mo>—</mo></mrow></mover></mrow></math></mathml>进行初始化, 得到<b><i>S</i></b>与<i>C</i><sup><i>l</i></sup>间的距离足够大的解集。其中, <i>C</i><sup><i>l</i></sup>和每一个<i>C</i>∈<b><i>S</i></b>选取一步邻域的局部最大解集, 因此, 如果<i>d</i> (<i>C</i><sup><i>l</i></sup>, <i>C</i>) ≤3, 则空间<i>span</i> (<i>C</i><sup><i>l</i></sup>, <i>C</i>) - (<i>C</i><sup><i>l</i></sup>, <i>C</i>) 中没有解的模块度高于<i>Q</i> (<i>C</i><sup><i>l</i></sup>) 或者<i>Q</i> (<i>C</i>) 。在第2行～第4行中, 如果精英组规模小于参数<i>elitesize</i>或没有足够的距离, 将返回上述路径重连过程。在第6行～第7行中, 分别初始化启动解决方案和最佳解决方案。对于第8行～第22行循环的第<i>k</i>次迭代, <b><i>S</i></b><sup><i>k</i></sup>生成条件如下:</p>
                </div>
                <div class="area_img" id="230">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJC201906032_23000.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="231">算法直至查找到<b><i>S</i></b><sub><i>C</i><sup></sup><i>l</i></sub>为止。执行局部搜索的目的是确保路径重连程序是一个局部最优解的求解过程。对于任意的2个基本聚类矩阵<b><i>S</i></b><sub>1</sub>和<b><i>S</i></b><sub>2</sub>以及聚类<i>C</i><mathml id="232"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mn>2</mn></msubsup></mrow></math></mathml>∈<i>C</i><sup>2</sup>, 算法4第10行、第15行的函数<i>change</i> (<b><i>S</i></b><sub>1</sub>, <b><i>S</i></b><sub>2</sub>, <i>C</i><mathml id="233"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mn>2</mn></msubsup></mrow></math></mathml>) 将返回基本聚类矩阵<b><i>S</i></b>, 满足<i>Δ</i><sup>*</sup> (<b><i>S</i></b>, <b><i>S</i></b><sub>2</sub>) =<i>Δ</i><sup>*</sup> (<b><i>S</i></b><sub>1</sub>, <b><i>S</i></b><sub>2</sub>) -<i>C</i><mathml id="234"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mrow></mrow><mi>j</mi><mn>2</mn></msubsup></mrow></math></mathml>。</p>
                </div>
                <h3 id="235" name="235" class="anchor-tag">3 实验结果与分析</h3>
                <div class="p1">
                    <p id="236">本文选取F<sub>1</sub>值和归一化互信息 (<i>Normalized Mutual</i><i>Information</i>, <i>NMI</i>) 作为算法性能评价指标, 前者主要评价每个社区的正确分类情况, 后者基于互信息理论度量被检测社区与地面真实社区间的相似性。</p>
                </div>
                <h4 class="anchor-tag" id="237" name="237">3.1 人工网络生成</h4>
                <div class="p1">
                    <p id="238">参照文献<citation id="275" type="reference">[<a class="sup">14</a>]</citation>, 本文选取<i>MMSB</i>和<i>LFR</i>作为人工网络的主要生成方法。生成的模拟测试网络包括稀疏和密集重叠2种社区结构。<i>MMSB</i>和<i>LFR</i>具体介绍如下:</p>
                </div>
                <div class="p1">
                    <p id="239">1) <i>MMSB</i>网络生成程序, 可获得节点p和q之间的网络连接, 表示为Y (p, q) 的分布形式:</p>
                </div>
                <div class="p1">
                    <p id="240">Y (p, q) ～Bernoulli (<b><i>Z</i></b><sup>T</sup><sub><i>p</i>→<i>q</i></sub><i>β</i><b><i>Z</i></b><sub><i>p</i>←<i>q</i></sub>)      (28) </p>
                </div>
                <div class="p1">
                    <p id="241">其中, <i>β</i>是社区交互矩阵, <b><i>Z</i></b>是多项式分布。有:</p>
                </div>
                <div class="p1">
                    <p id="242" class="code-formula">
                        <mathml id="242"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi mathvariant="bold-italic">Ζ</mi><msub><mrow></mrow><mrow><mi>p</mi><mo>→</mo><mi>q</mi></mrow></msub><mo>∼</mo><mi>Μ</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>m</mi><mi>i</mi><mi>a</mi><mi>l</mi><mo stretchy="false"> (</mo><mover><mstyle mathsize="140%" displaystyle="true"><mi>π</mi></mstyle><mrow><mspace width="0.25em" /><mo>→</mo></mrow></mover><msub><mrow></mrow><mi>q</mi></msub><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mn>9</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mover><mstyle mathsize="140%" displaystyle="true"><mi>π</mi></mstyle><mrow><mspace width="0.25em" /><mo>→</mo></mrow></mover><msub><mrow></mrow><mi>q</mi></msub><mo>∼</mo><mi>D</mi><mi>i</mi><mi>r</mi><mi>i</mi><mi>c</mi><mi>h</mi><mi>l</mi><mi>e</mi><mi>t</mi><mo stretchy="false"> (</mo><mover><mstyle mathsize="140%" displaystyle="true"><mi>α</mi></mstyle><mrow><mspace width="0.25em" /><mo>→</mo></mrow></mover><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mn>0</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="243">其中, 参数<i>α</i>可控制社区的重叠行为。根据实践经验可得, 模块化值大于0.5会形成稀疏重叠群落, 模块化值小于0.4会导致群落结构的紧密重叠。表1所示为MMSB生成网络的特点。</p>
                </div>
                <div class="area_img" id="244">
                    <p class="img_tit"><b>表1 MMSB生成的实验网络特点</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="244" border="1"><tr><td>节点数</td><td>连接数</td><td>社区数</td><td>模块度</td><td>超参数</td></tr><tr><td rowspan="2"><br />100</td><td><br />1 023</td><td>5</td><td>0.72</td><td>0.001</td></tr><tr><td><br />1 279</td><td>5</td><td>0.36</td><td>0.040</td></tr><tr><td rowspan="2"><br />200</td><td><br />4 634</td><td>12</td><td>0.25</td><td>0.070</td></tr><tr><td><br />2 223</td><td>12</td><td>0.72</td><td>0.003</td></tr><tr><td rowspan="2"><br />500</td><td><br />6 075</td><td>31</td><td>0.31</td><td>0.020</td></tr><tr><td><br />4 278</td><td>31</td><td>0.82</td><td>0.002</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="245">2) LFR网络生成程序, 可生成社区发现的人工网络基准测试模型, 其与MMSB一样, 都可根据模块度指标将生成网络分为稀疏和密集2种类型。表2所示为LFR生成网络的特点。</p>
                </div>
                <div class="area_img" id="246">
                    <p class="img_tit"><b>表2 LFR生成的实验网络特点</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="246" border="1"><tr><td>节点数</td><td>连接数</td><td>社区数</td><td>模块度</td><td>网络类型</td></tr><tr><td rowspan="2"><br />100</td><td><br /> 964</td><td>6</td><td>0.335</td><td>稀疏</td></tr><tr><td><br />728</td><td>3</td><td>0.604</td><td>密集</td></tr><tr><td rowspan="2"><br />200</td><td><br />1 923</td><td>11</td><td>0.276</td><td>密集</td></tr><tr><td><br />1 504</td><td>10</td><td>0.614</td><td>稀疏</td></tr><tr><td rowspan="2"><br />500</td><td><br />6 125</td><td>15</td><td>0.305</td><td>密集</td></tr><tr><td><br />6 227</td><td>15</td><td>0.618</td><td>稀疏</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="247">图4所示为4种网络模型, 其参数数据分别对应表1中的第1行、第3行, 表2中的第1行、第3行。</p>
                </div>
                <div class="area_img" id="248">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201906032_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 人工生成网络模型" src="Detail/GetImg?filename=images/JSJC201906032_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 人工生成网络模型</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201906032_248.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="249" name="249">3.2 稳健性实验</h4>
                <div class="p1">
                    <p id="250">本节对各社区发现算法的<i>F</i><sub>1</sub>值进行对比测试, <i>F</i><sub>1</sub>值的取值范围是0～1, 其值越大, 表明分类模型的稳健性越高。<i>F</i><sub>1</sub>评价指标定义为:</p>
                </div>
                <div class="p1">
                    <p id="251" class="code-formula">
                        <mathml id="251"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mfrac><mrow><mn>2</mn><mi>Ρ</mi><mi>R</mi></mrow><mrow><mi>Ρ</mi><mo>+</mo><mi>R</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mi>Τ</mi><mi>Ρ</mi><mo>+</mo><mi>F</mi><mi>Ρ</mi><mo>+</mo><mi>F</mi><mi>Ν</mi></mrow><mrow><mi>Τ</mi><mi>Ρ</mi></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="252">其中, <i>FP</i>指实际为正但检测为负的样本, <i>FN</i>指实际为负但检测为正的样本, <i>TP</i>指实际为正且检测为正的样本, <i>P</i>为准确率, <i>R</i>为召回率。本次实验选取的对比算法为文献<citation id="276" type="reference">[<a class="sup">14</a>]</citation>算法和文献<citation id="277" type="reference">[<a class="sup">15</a>]</citation>算法。前者是一种社会网络中线性时间重叠的社区检测方法, 其采用增量式的社区检测算法, 具有较强的社区检测能力和较高的社区检测速度;后者是一种基于社区检测质量的算法, 具有较高的社区检测精度。在图4所示的4种网络模型中, 3种 算法的<i>F</i><sub>1</sub>值对比结果如图5所示。由图5可以看出, 3种算法的<i>F</i><sub>1</sub>值都随着社区数量的增加而降低, 即模型的稳健性降低。其中, 与2种对比算法相比, 本文算法的<i>F</i><sub>1</sub>值均较大, 这体现了其在社区发现稳健性上的优势。</p>
                </div>
                <div class="area_img" id="253">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201906032_253.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 3种算法的F1值对比结果" src="Detail/GetImg?filename=images/JSJC201906032_253.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 3种算法的<i>F</i></b><sub><b>1</b></sub><b>值对比结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201906032_253.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="254" name="254">3.3 准确性实验</h4>
                <div class="p1">
                    <p id="255">本节选取NMI指标度量2个聚类结果的相近程度, 以评价社区发现算法的准确性。NMI的值域是0～1, 值越高代表算法准确性越高。对于2种社区类型<i>A</i>、<i>B</i>, 其NMI指标定义为:</p>
                </div>
                <div class="p1">
                    <p id="256" class="code-formula">
                        <mathml id="256"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ν</mi><mi>Μ</mi><mi>Ι</mi><mo>=</mo><mfrac><mrow><mo>-</mo><mn>2</mn><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>C</mi><msub><mrow></mrow><mi>A</mi></msub></mrow></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>C</mi><msub><mrow></mrow><mi>B</mi></msub></mrow></munderover><mi>C</mi></mstyle></mrow></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>⋅</mo><mtext>l</mtext><mtext>b</mtext><mrow><mo> (</mo><mrow><mfrac><mrow><mi>C</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi>Ν</mi></mrow><mrow><mi>C</mi><msub><mrow></mrow><mi>i</mi></msub><mi>C</mi><msub><mrow></mrow><mi>j</mi></msub></mrow></mfrac></mrow><mo>) </mo></mrow></mrow><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>C</mi><msub><mrow></mrow><mi>A</mi></msub></mrow></munderover><mi>C</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo>⋅</mo><mtext>l</mtext><mtext>b</mtext><mrow><mo> (</mo><mrow><mfrac><mrow><mi>C</mi><msub><mrow></mrow><mrow><mi>i</mi><mo>.</mo></mrow></msub></mrow><mi>Ν</mi></mfrac></mrow><mo>) </mo></mrow><mo>+</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>C</mi><msub><mrow></mrow><mi>B</mi></msub></mrow></munderover><mi>C</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>⋅</mo><mtext>l</mtext><mtext>b</mtext><mrow><mo> (</mo><mrow><mfrac><mrow><mi>C</mi><msub><mrow></mrow><mrow><mo>.</mo><mi>j</mi></mrow></msub></mrow><mi>Ν</mi></mfrac></mrow><mo>) </mo></mrow></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="257">其中, <i>N</i>是节点的总数量, <b><i>C</i></b>是混淆矩阵, <i>C</i><sub><i>ij</i></sub>表示同时属于<i>A</i>类型中社区<i>i</i>和<i>B</i>类型中社区<i>j</i>的节点, <i>C</i><sub><i>A</i></sub> (<i>C</i><sub><i>B</i></sub>) 表示<i>A</i> (<i>B</i>) 类型社区中的社区数量, <i>C</i><sub><i>i</i>.</sub> (<i>C</i><sub>.<i>j</i></sub>) 表示矩阵<b><i>C</i></b>中的元素数量。对于表1、表2所示的人工网络模型, 3种算法的<i>NMI</i>值对比结果如图6所示。</p>
                </div>
                <div class="area_img" id="258">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201906032_258.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 3种算法的NMI值对比结果" src="Detail/GetImg?filename=images/JSJC201906032_258.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图6 3种算法的<i>NMI</i>值对比结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201906032_258.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="259">由图6可以看出, 随着网络节点数量的增加, 3种算法的<i>NMI</i>值整体呈现下降趋势, 这表明节点数量越多, 网络越复杂, 算法的分类精度越低。在相同节点数量的情况下, 网络模型的模块度越大, 即网络越紧密, 模型的分类精度越低。与2种对比算法相比, 本文算法的<i>NMI</i>值均较高, 这体现了其在社区发现精度上的优势。</p>
                </div>
                <h3 id="260" name="260" class="anchor-tag">4 结束语</h3>
                <div class="p1">
                    <p id="261">本文提出一种基于贪婪局部路径重连的随机并行社区检测算法。算法的每次迭代由聚类构建、局部搜索以及路径重连3个阶段组成。在聚类构建阶段, 以贪婪随机的方式从空集合中建立聚类。在局部搜索中采取一步邻域拓展搜索方法, 以提高社区检测的精度。路径重连阶段在当前解集与已有解集之间建立关联, 从而解决贪婪搜索的独立性问题, 提升社区检测的稳健性。下一步将采用更加灵活的数据结构, 以缩短大规模图的社区检测时间。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="5">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX201302013&amp;v=MDcyNDZPZVplUm9GeW5sVkx2S0x6N0Jkckc0SDlMTXJZOUVaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkw=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 陈克寒, 韩盼盼, 吴健.基于用户聚类的异构社交网络推荐算法[J].计算机学报, 2013, 36 (2) :349-358.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZXU201002003&amp;v=MjE3ODNUZTdHNEg5SE1yWTlGWjRRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnlubFZMdktJVGY=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 宣善立, 梁栋, 朱明.一种基于修正的最小生成树及其邻接谱的特征匹配算法[J].电子学报, 2010, 38 (2) :269-274.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Adaptive Laplacian eigenmap-based dimension reduction for ocean target discrimination">

                                <b>[3]</b> SHI Lei, ZHANG Lefei, ZHAO Lingli, et al.Adaptive laplacian eigenmap-based dimension reduction for ocean target discrimination[J].IEEE Geoscience and Remote Sensing Letters, 2016, 13 (7) :902-906.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Bayesian Community Detection in the Space of Grouplevel Functional Differences">

                                <b>[4]</b> VENKATARAMAN A, YANG D Y J, PELPHREY K, et al.Bayesian community detection in the space of group-level functional differences[J].IEEE Transactions on Medical Imaging, 2016, 35 (8) :1862-1866.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Scalable Wireless Traffic Capture Through Community Detection and Trace Similarity">

                                <b>[5]</b> SAMMARCO M, CAMPISTA M E M, AMORIM M D D.Scalable wireless traffic capture through community detection and trace similarity[J].IEEE Transactions on Mobile Computing, 2016, 15 (7) :1757-1769.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=DZYX201607003&amp;v=MDA1NTZaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeW5sVkx2S0lUZlNkckc0SDlmTXFJOUY=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> 罗会兰, 万成涛, 孔繁胜.基于KL散度及多尺度融合的显著性区域检测算法[J].电子与信息学报, 2016, 38 (7) :1594-1601.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA2012S1028&amp;v=MDc0NDBMejdCYjdHNEg5T3ZybzlIYklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnlubFZMdks=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b> GUO Tao, ZHANG Guo, GUO Wenjuan.An improved weighted complex network clustering method[J].Computer Science, 2012, 39 (6) :99-102.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Large scale complex network community detection based on local search and genetic algorithm">

                                <b>[8]</b> JIN Di, LIU Jie, YANG Bo.Large scale complex network community detection based on local search and genetic algorithm[J].Journal of Automation, 2011, 37 (7) :873-881.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A Generalized Markov Graph Model:Application to Social Network Analysis">

                                <b>[9]</b> WANG Tian, KRIM H, VINIOTIS Y.A generalized Markov graph model:application to social network analysis[J].IEEE Journal of Selected Topics in Signal Processing, 2013, 7 (2) :318-332.
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Complex network partitioning algorithm based on incremental clustering of core graph">

                                <b>[10]</b> ZHANG Xinmeng, JIANG Shengyi.Complex network parti-tioning algorithm based on incremental clustering of core graph[J].Journal of Automation, 2013, 39 (7) :1117-1124.
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Variational Bayesian View of Weighted Trace Norm Regularization for Matrix Factorization">

                                <b>[11]</b> YONG-DEOK K, SEUNGJIN C.Variational Bayesian view of weighted trace norm regularization for matrix factorization[J].IEEE Signal Processing Letters, 2013, 20 (3) :261-264.
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Nonlinear Estimation with Perron-Frobenius Operator and KarhunenLo&amp;#232;ve Expansion">

                                <b>[12]</b> PARIKSHIT D, ABHISHEK H, RAKTIM B.Nonlinear estimation with Perron-Frobenius operator and Karhunen-Loève expansion[J].IEEE Transactions on Aerospace and Electronic Systems, 2015, 51 (4) :3210-3225.
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A hybrid artificial immune network for detecting communities in complex networks">

                                <b>[13]</b> KARIMI-MAJD A M, FATHIAN M, AMIRI B.A hybrid artificial immune network for detecting communities in complex networks[J].Computing, 2015, 97 (2) :483-507.
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Towards Linear Time Overlapping Community Detection in Social Networks">

                                <b>[14]</b> XIE Jierui, SZYMANSKI B K.Towards linear time overlapping community detection in social networks[J].Lecture Notes in Computer Science, 2012, 73 (1) :25-36.
                            </a>
                        </p>
                        <p id="33">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On measuring the quality of a network community structure">

                                <b>[15]</b> CHEN Mingming, NGUYEN T, SZYMANSKI B.On measuring the quality of a network community structure[J].Social Computing, 2013, 52 (3) :122-127.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJC201906032" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201906032&amp;v=MDA1MjJDVVJMT2VaZVJvRnlubFZMdktMejdCYmJHNEg5ak1xWTlHWm9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnI=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQxQTZSZWp6VHBWMkMvWVdDaHZmUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
