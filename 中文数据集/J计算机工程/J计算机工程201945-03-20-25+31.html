<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637130624243868750%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201903004%26RESULT%3d1%26SIGN%3dgz616canAryrShu2qvpIYyFNA%252bM%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201903004&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201903004&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201903004&amp;v=MTI0NDBESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5L2hVYnJKTHo3QmJiRzRIOWpNckk5RllJUUs=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#35" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#39" data-title="1 问题定义 ">1 问题定义</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#46" data-title="2 本文解决方案 ">2 本文解决方案</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#47" data-title="2.1 系统框架">2.1 系统框架</a></li>
                                                <li><a href="#60" data-title="2.2 时态连接查询处理">2.2 时态连接查询处理</a></li>
                                                <li><a href="#109" data-title="2.3 Apache Spark的实现">2.3 Apache Spark的实现</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#123" data-title="3 实验结果与分析 ">3 实验结果与分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#124" data-title="3.1 实验设置">3.1 实验设置</a></li>
                                                <li><a href="#129" data-title="3.2 实验结果">3.2 实验结果</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#138" data-title="4 相关工作 ">4 相关工作</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#145" data-title="5 结束语 ">5 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#41" data-title="&lt;b&gt;表1 常用符号&lt;/b&gt;"><b>表1 常用符号</b></a></li>
                                                <li><a href="#52" data-title="&lt;b&gt;图1 多版本B树结构&lt;/b&gt;"><b>图1 多版本B树结构</b></a></li>
                                                <li><a href="#55" data-title="&lt;b&gt;图2 全局索引结构&lt;/b&gt;"><b>图2 全局索引结构</b></a></li>
                                                <li><a href="#59" data-title="&lt;b&gt;图3 时态数据分区方法&lt;/b&gt;"><b>图3 时态数据分区方法</b></a></li>
                                                <li><a href="#132" data-title="&lt;b&gt;图4 真实数据集上时态连接操作的实验结果&lt;/b&gt;"><b>图4 真实数据集上时态连接操作的实验结果</b></a></li>
                                                <li><a href="#135" data-title="&lt;b&gt;图5 本文解决方案和基准方案运行时间对比&lt;/b&gt;"><b>图5 本文解决方案和基准方案运行时间对比</b></a></li>
                                                <li><a href="#137" data-title="&lt;b&gt;图6 分区大小对时态连接操作查询性能的影响&lt;/b&gt;"><b>图6 分区大小对时态连接操作查询性能的影响</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" ZHANG S, YANG Y, FAN W, et al.OceanRT:real-time analytics over large temporal data[C]//Proceedings of 2014 ACM SIGMOD International Conference on Management of Data.New York, USA:ACM Press, 2014:1099-1102." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=OceanRT:real-time analytics over large temporal data">
                                        <b>[1]</b>
                                         ZHANG S, YANG Y, FAN W, et al.OceanRT:real-time analytics over large temporal data[C]//Proceedings of 2014 ACM SIGMOD International Conference on Management of Data.New York, USA:ACM Press, 2014:1099-1102.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title=" 周亮, 李格非, 邰伟鹏, 等:基于Spark的时态查询扩展与时态索引优化研究[J].计算机工程, 2017, 43 (7) :22-28, 37." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201707005&amp;v=MTMzMzhRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnkvaFVickpMejdCYmJHNEg5Yk1xSTlGWVk=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         周亮, 李格非, 邰伟鹏, 等:基于Spark的时态查询扩展与时态索引优化研究[J].计算机工程, 2017, 43 (7) :22-28, 37.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" ZHANG D, TSOTRAS V L.Seeger:efficient temporal join processing using indices[C]//Proceedings of the 18th International Conference on Data Engineering.Washington D.C., USA:IEEE Press, 2002:401-412." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Seeger:efficient temporal join processing using indices">
                                        <b>[3]</b>
                                         ZHANG D, TSOTRAS V L.Seeger:efficient temporal join processing using indices[C]//Proceedings of the 18th International Conference on Data Engineering.Washington D.C., USA:IEEE Press, 2002:401-412.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title=" LU H, YANG B, JENSEN C S.Spatio-temporal joins on symbolic indoor tracking data[C]//Proceedings of the 27th IEEE International Conference on Data Engineering.Washington D.C., USA:IEEE Press, 2011:125-136." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Spatio-Temporal Joins On Symbolic Indoor Tracking Data">
                                        <b>[4]</b>
                                         LU H, YANG B, JENSEN C S.Spatio-temporal joins on symbolic indoor tracking data[C]//Proceedings of the 27th IEEE International Conference on Data Engineering.Washington D.C., USA:IEEE Press, 2011:125-136.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" BECKER B, GSCHWIND S, OHLER T, et al.Widmayer:an asymptotically optimal multiversion B-tree[J].The VLDB Journal, 1996, 5 (4) :264-275." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An asymptotically optimal multiversion B-tree">
                                        <b>[5]</b>
                                         BECKER B, GSCHWIND S, OHLER T, et al.Widmayer:an asymptotically optimal multiversion B-tree[J].The VLDB Journal, 1996, 5 (4) :264-275.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" Block-based join algorithms[EB/OL].[2018-04-01].https://mariadb.com/kb/en/library/block-based-join-algorithms/." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Block-based join algorithms">
                                        <b>[6]</b>
                                         Block-based join algorithms[EB/OL].[2018-04-01].https://mariadb.com/kb/en/library/block-based-join-algorithms/.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title=" LESKOVEC J, KREVL A.SNAP datasets:stanford large network dataset collection[EB/OL].[2018-05-21].http://snap.stanford.edu/data." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Stanford large network dataset collection">
                                        <b>[7]</b>
                                         LESKOVEC J, KREVL A.SNAP datasets:stanford large network dataset collection[EB/OL].[2018-05-21].http://snap.stanford.edu/data.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title=" MAHMOOD A R, PUNNI S, AREF W G.Spatio-temporal access methods:a survey[EB/OL].[2018-05-21].https://link.springer.com." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Spatio-temporal access methods:a survey">
                                        <b>[8]</b>
                                         MAHMOOD A R, PUNNI S, AREF W G.Spatio-temporal access methods:a survey[EB/OL].[2018-05-21].https://link.springer.com.
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title=" CHENG K.On computing temporal aggregates over null time intervals[C]//Proceedings of International Conference on Database and Expert Systems Applications.Washington D.C., USA:IEEE Press, 2017:67-79." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On computing temporal aggregates over null time intervals">
                                        <b>[9]</b>
                                         CHENG K.On computing temporal aggregates over null time intervals[C]//Proceedings of International Conference on Database and Expert Systems Applications.Washington D.C., USA:IEEE Press, 2017:67-79.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title=" KAUFMANN M, FISHHER P M, MAY N, et al.Bi-temporal timeline index:a data structure for processing queries on bi-temporal data[C]//Proceedings of ICDE’15.Washington D.C., USA:IEEE Press, 2015:215-226." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Bi-temporal timeline index:a data structure for processing queries on bi-temporal data">
                                        <b>[10]</b>
                                         KAUFMANN M, FISHHER P M, MAY N, et al.Bi-temporal timeline index:a data structure for processing queries on bi-temporal data[C]//Proceedings of ICDE’15.Washington D.C., USA:IEEE Press, 2015:215-226.
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title=" 周风华, 汤庸, 康向锋.一种有效的双时态索引技术[J].计算机工程与应用, 2005, 41 (13) :231-239." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSGG200513052&amp;v=MDA0NjhaZVJvRnkvaFVickpMejdNYWJHNEh0VE5ySTlBWm9RS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2U=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                         周风华, 汤庸, 康向锋.一种有效的双时态索引技术[J].计算机工程与应用, 2005, 41 (13) :231-239.
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" title=" WANG P, ZHANG P, ZHOU C, et al.Hierarchical evolving dirichlet processes for modeling nonlinear evolutionary traces in temporal data[J].Data Mining and Knowledge Discovery, 2017, 31 (1) :32-64." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Hierarchical evolving dirichlet processes for modeling nonlinear evolutionary traces in temporal data">
                                        <b>[12]</b>
                                         WANG P, ZHANG P, ZHOU C, et al.Hierarchical evolving dirichlet processes for modeling nonlinear evolutionary traces in temporal data[J].Data Mining and Knowledge Discovery, 2017, 31 (1) :32-64.
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title=" LOGLISCI C, CECI M, MALERBA D.A temporal data mining framework for analyzing longitudinal data[C]//Proceedings of International Conference on Database and Expert Systems Applications.Washington D.C., USA:IEEE Press, 2011:154-165." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A temporal data mining framework for analyzing longitudinal data">
                                        <b>[13]</b>
                                         LOGLISCI C, CECI M, MALERBA D.A temporal data mining framework for analyzing longitudinal data[C]//Proceedings of International Conference on Database and Expert Systems Applications.Washington D.C., USA:IEEE Press, 2011:154-165.
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_14" title=" LE W, LI F, TAO Y, et al.Optimal splitters for temporal and multi-version databases[C]//Proceedings of SIGMOD’13.Washington D.C., USA:IEEE Press, 2013:321-329." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Optimal splitters for temporal and multi-version databases">
                                        <b>[14]</b>
                                         LE W, LI F, TAO Y, et al.Optimal splitters for temporal and multi-version databases[C]//Proceedings of SIGMOD’13.Washington D.C., USA:IEEE Press, 2013:321-329.
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_15" title=" KAUFMANN M, MANJILI A, VAGENAS A P, et al.Timeline index:a unified data structure for processing queries on temporal data in SAP HANA[C]//Proceedings of SIGMOD’13.Washington D.C., USA:IEEE Press, 2013:124-132." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Timeline index:a unified data structure for processing queries on temporal data in SAP HANA">
                                        <b>[15]</b>
                                         KAUFMANN M, MANJILI A, VAGENAS A P, et al.Timeline index:a unified data structure for processing queries on temporal data in SAP HANA[C]//Proceedings of SIGMOD’13.Washington D.C., USA:IEEE Press, 2013:124-132.
                                    </a>
                                </li>
                                <li id="33">


                                    <a id="bibliography_16" title=" ELMASRI R, WUU G T, KIM Y J.The time index:an access structure for temporal data[C]//Proceedings of the 16th International Conference on Very Large Data Bases.Washington D.C., USA:IEEE Press, 1990:125-136." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The time index:An access structure for temporal data">
                                        <b>[16]</b>
                                         ELMASRI R, WUU G T, KIM Y J.The time index:an access structure for temporal data[C]//Proceedings of the 16th International Conference on Very Large Data Bases.Washington D.C., USA:IEEE Press, 1990:125-136.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(03),20-25+31 DOI:10.19678/j.issn.1000-3428.0052626            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>分布式环境下时态大数据的连接操作研究</b></span>
 <span class="shoufa"></span>                                     </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%BC%A0%E4%BC%9F&amp;code=08553564&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张伟</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E7%8E%8B%E5%BF%97%E6%9D%B0&amp;code=40118616&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">王志杰</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%8A%E6%B5%B7%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%B3%BB&amp;code=0054402&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">上海交通大学计算机科学与工程系</a>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E9%99%A2&amp;code=0140250&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">中山大学数据科学与计算机学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>目前处理时态大数据连接操作多数运用分布式系统, 但现有的分布式系统尚不能支持原生的时态连接查询, 无法满足时态大数据低延迟和高吞吐量的处理需求。为此, 提出一个基于Spark的二级索引内存解决方案。运用全局索引进行分布式分区的剪枝, 使用局部时态索引进行分区内查询, 提高数据检索效率。针对时态数据设计分区方法, 以对全局剪枝进行优化。基于真实和合成数据集的实验结果表明, 与基准方案相比, 该方案可明显提高时态连接操作的处理效率。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%97%B6%E6%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">时态大数据;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98%E8%AE%A1%E7%AE%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">分布式内存计算;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%97%B6%E6%80%81%E8%BF%9E%E6%8E%A5&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">时态连接;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">二级索引;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%88%86%E5%8C%BA%E6%96%B9%E6%B3%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">分区方法;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Spark%E6%A1%86%E6%9E%B6&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Spark框架;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    张伟 (1990—) , 男, 硕士, 主研方向为大数据分析、分布式计算;;
                                </span>
                                <span>
                                    王志杰, 副研究员、博士。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-09-11</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金 (U1636210, 61729202);</span>
                                <span>广东省科技计划项目 (2015A030401057, 2016B030307002);</span>
                    </p>
            </div>
                    <h1><b>Research on Join Operation of Temporal Big Data in Distributed Environment</b></h1>
                    <h2>
                    <span>ZHANG Wei</span>
                    <span>WANG Zhijie</span>
            </h2>
                    <h2>
                    <span>Department of Computer Science and Engineering, Shanghai Jiaotong University</span>
                    <span>School of Data and Computer Science, Sun Yat-Sen University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Distributed system is an ideal choice for processing temporal large data join operation, but the existing distributed system cannot support the original temporal join query and cannot meet the processing requirements of temporal large data with low latency and high throughput.Therefore, a two-level index memory solution scheme based on Spark is proposed.The global index is used to prune the distributed partitions, and the local temporal index is used to query the partitions in order to improve the efficiency of data retrieval.A partition method is designed for temporal data to optimize global pruning.Experimental results based on real and synthetic datasets show that the scheme can significantly improve the processing efficiency of temporal join operation.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=temporal%20big%20data&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">temporal big data;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=distributed%20memory%20computing&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">distributed memory computing;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=temporal%20join&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">temporal join;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=two-level%20index&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">two-level index;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=partition%20method&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">partition method;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Spark%20framework&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Spark framework;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-09-11</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="35" name="35" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="36">时态数据的管理由于其应用较为广泛, 近年来越来越受到关注<citation id="147" type="reference"><link href="3" rel="bibliography" /><link href="5" rel="bibliography" /><sup>[<a class="sup">1</a>,<a class="sup">2</a>]</sup></citation>。其中, 时态连接是常见的操作, 在通常情况下, 若2条时态记录的时间间隔相互重叠, 则作为时态连接的候选记录, 可以通过记录的关键字和时间间隔值对时态连接操作进行限定。</p>
                </div>
                <div class="p1">
                    <p id="37">目前, 已经有大量的文献讨论了时态连接查询的问题<citation id="148" type="reference"><link href="7" rel="bibliography" /><link href="9" rel="bibliography" /><sup>[<a class="sup">3</a>,<a class="sup">4</a>]</sup></citation>。以前的研究工作大部分都集中在开发基于单机的解决方案上, 较少关注用于开发处理时态连接的分布式解决方案。近年来, 各种应用 (如网络应用和物联网应用) 产生大量的时态数据, 有效处理时态数据成为目前的迫切任务。基于单机的系统计算能力有限, 在传统数据库系统中处理海量的时态数据存在局限性。因此, 使用分布式系统处理大量的时态数据是一个较好的选择。最近, 有学者对大数据的分布式时态分析进行了研究<citation id="149" type="reference"><link href="3" rel="bibliography" /><link href="5" rel="bibliography" /><sup>[<a class="sup">1</a>,<a class="sup">2</a>]</sup></citation>, 这些研究包含如下特征:都是基于磁盘的分布式时态分析系统;没有包括时态连接查询。但随着数据量的激增, 这些解决方案无法较好地满足时态大数据分析的高吞吐量和低延迟需求。</p>
                </div>
                <div class="p1">
                    <p id="38">Spark是一个典型的分布式系统, 它提供对通用数据进行分析的内存分布式引擎。现有的大数据系统 (如Hadoop, Spark) 并没有支持原生的时态连接查询, 对开发基于内存的分布式解决方案来处理时态大数据的时态连接操作也涉及较少。为了支持具有高吞吐量和低延迟的时态大数据连接操作, 本文提出一个基于内存的Spark二级索引解决方案, 以提高时态连接操作效率。</p>
                </div>
                <h3 id="39" name="39" class="anchor-tag">1 问题定义</h3>
                <div class="p1">
                    <p id="40">本文在分布式环境中实现时态数据的代表性操作, 即时态连接操作。为便于参考, 表1列出了常用符号。</p>
                </div>
                <div class="area_img" id="41">
                    <p class="img_tit"><b>表1 常用符号</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="41" border="1"><tr><td><br />符号</td><td>说明</td></tr><tr><td><br /><i>T</i></td><td>时态数据集</td></tr><tr><td><br /><i>r</i><sub><i>i</i></sub></td><td>时态数据集的第<i>i</i>个记录</td></tr><tr><td><br /><i>R</i><sub><i>p</i></sub></td><td>分区间隔</td></tr><tr><td><br /><i>J</i><sub><i>t</i></sub></td><td>时态连接操作</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="42">设时态数据集<i>T</i>包含|<i>T</i>|个时态记录{<i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>, …, <i>r</i><sub>|<i>T</i>|</sub>}。每个记录<i>r</i><sub><i>i</i></sub> ( <i>i</i>∈[1, |<i>T</i>|] ) 是 ( <i>id</i>, <i>value</i>, <i>left</i>, <i>right</i> ) 形式的四元组。其中, <i>id</i>为记录的关键字, <i>left</i>和<i>right</i>是记录<i>r</i><sub><i>i</i></sub>有效时间间隔的开始和结束时间戳。此外, 给定时间戳 (或版本) <i>t</i>和记录<i>r</i><sub><i>i</i></sub>, 当且仅当<i>t</i>∈[ <i>r</i><sub><i>i</i></sub>.<i>left</i>, <i>r</i><sub><i>i</i></sub>.<i>right</i> ) 时, 认为记录<i>r</i><sub><i>i</i></sub>存在于版本<i>t</i>中 (即记录<i>r</i><sub><i>i</i></sub>在版本<i>t</i>中是存活的) 。</p>
                </div>
                <div class="p1">
                    <p id="43"><b>定义</b> (时态连接查询) 给定时态连接查询<i>J</i><sub><i>t</i></sub>={<i>start</i>, <i>end</i>, <i>t</i>}, 其中, [<i>start</i>, <i>end</i>]为给定的关键字范围。假定时态数据集<i>T</i>中存在记录<i>r</i>满足:<mathml id="44"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo>≤</mo><mrow><mi>r</mi><mo>.</mo><mi>i</mi><mi>d</mi></mrow><mo>∧</mo><mi>r</mi><mo>.</mo><mi>i</mi><mi>d</mi><mo>≤</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo>∧</mo><mi>r</mi><mo>.</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>≤</mo><mi>t</mi><mo>∧</mo><mi>t</mi><mo>&lt;</mo><mi>t</mi><mo>.</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>, </mo><mi>r</mi><mo>∈</mo><mover><mstyle mathsize="140%" displaystyle="true"><mi>Τ</mi></mstyle><mo>︿</mo></mover></mrow></math></mathml>, 那么<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>的时态连接定义为:</p>
                </div>
                <div class="p1">
                    <p id="45" class="code-formula">
                        <mathml id="45"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>θ</mi><mo>=</mo><mrow><mo>{</mo><mrow><mi>r</mi><msub><mrow></mrow><mi>i</mi></msub><mo>+</mo><mi>r</mi><msub><mrow></mrow><mi>j</mi></msub><mo>, </mo><mi>r</mi><msub><mrow></mrow><mi>i</mi></msub><mo>∈</mo><mi>Τ</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>r</mi><msub><mrow></mrow><mi>j</mi></msub><mo>∈</mo><mi>Τ</mi><msub><mrow></mrow><mn>2</mn></msub><mo stretchy="false">|</mo><mi>r</mi><msub><mrow></mrow><mi>i</mi></msub><mo>∈</mo><mrow><mover><mstyle mathsize="140%" displaystyle="true"><mi>Τ</mi></mstyle><mo>︿</mo></mover></mrow><msub><mrow></mrow><mn>1</mn></msub><mo>∧</mo><mi>r</mi><msub><mrow></mrow><mi>j</mi></msub><mo>∈</mo><mrow><mover><mstyle mathsize="140%" displaystyle="true"><mi>Τ</mi></mstyle><mo>︿</mo></mover></mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><mo>}</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <h3 id="46" name="46" class="anchor-tag">2 本文解决方案</h3>
                <h4 class="anchor-tag" id="47" name="47">2.1 系统框架</h4>
                <div class="p1">
                    <p id="48">本文系统框架由3个部分组成:1) 分区单元, 负责将所有数据分区到分布式 (从) 节点, 通常应该保证每个节点具有大致相同的数据大小, 以保持负载平衡, 但时态数据对分区方法有更高的要求;2) 局部索引单元, 在每个分区中, 维护局部索引以避免“全盘”扫描, 并基于索引结构实现连接查询的计算, 因此, 可以提高查询效率, 此外, 每个分区还为全局索引的构建维护一个分区间隔<i>R</i><sub><i>p</i></sub>;3) 全局索引单元, 在主节点中, 全局索引被设计为预先修剪查询不会涉及到的分区, 这可以避免检查每个分区, 从而降低CPU成本和/或网络传输成本。</p>
                </div>
                <div class="p1">
                    <p id="49">在实现中, 主节点收集从节点中每个分区的所有分区间隔<i>R</i><sub><i>p</i></sub>, 然后根据收集的分区间隔构建全局索引。通过采用二级索引结构, 尽可能避免访问不相关的候选项 (例如不相关的分区和局部记录) 。</p>
                </div>
                <h4 class="anchor-tag" id="50" name="50">2.1.1 局部索引方法</h4>
                <div class="p1">
                    <p id="51">局部索引用于管理每个分区中的时态数据。目前已经有索引结构来支持时态连接操作, 如多版本B树<citation id="151" type="reference"><link href="11" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>, 本文使用多版本B树作为示例。为了便于理解, 图1给出该索引结构。根的第1个记录指向其孩子节点<i>A</i>, 它包含从版本1～版本7中的所有活动记录。在叶节点中, 每个记录代表一条时态记录, 其中, *表示这个记录是存活的, 即该记录在其所在的节点中未被删除。</p>
                </div>
                <div class="area_img" id="52">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201903004_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 多版本B树结构" src="Detail/GetImg?filename=images/JSJC201903004_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 多版本B树结构</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201903004_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="53" name="53">2.1.2 全局索引方法</h4>
                <div class="p1">
                    <p id="54">如前文所述, 全局索引管理分区间隔。由于每个分区间隔可以通过起始值和间隔长度进行比较, 使用二叉搜索树维护分区的间隔信息, 建立全局索引结构, 如图2所示。为了理解分区间隔的概念, 本文给出一个简单的例子。假设分区中有3条记录, 其时间间隔分别为:[<i>l</i><sub>1</sub>, <i>r</i><sub>1</sub>) , [<i>l</i><sub>2</sub>, <i>r</i><sub>2</sub>) , [<i>l</i><sub>3</sub>, <i>r</i><sub>3</sub>) , 那么分区间隔<i>R</i><sub><i>p</i></sub>即为:[min{<i>l</i><sub>1</sub>, <i>l</i><sub>2</sub>, <i>l</i><sub>3</sub>}, max{<i>r</i><sub>1</sub>, <i>r</i><sub>2</sub>, <i>r</i><sub>3</sub>}) 。这样全局索引中的每个分区间隔对应一个从节点中的分区。在查询处理中, 如果一个分区间隔可以被修剪, 则可以安全地修剪相应的分区。基于这种方法, 在本文的实现中, 全局索引中的每个结点都维护一个键值对&lt; <i>id</i>, <i>R</i><sub><i>p</i></sub>&gt;, 其中<i>id</i>和<i>R</i><sub><i>p</i></sub>分别指分区<i>id</i>及其对应的分区间隔。</p>
                </div>
                <div class="area_img" id="55">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201903004_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 全局索引结构" src="Detail/GetImg?filename=images/JSJC201903004_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 全局索引结构</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201903004_055.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="56" name="56">2.1.3 分区方法</h4>
                <div class="p1">
                    <p id="57">在分区一般数据时, 负载平衡通常是一个理想的目标。而对于时态数据, 另一个期望的目标是最小化分区间隔的重叠。为了实现这些目标, 在本文的设计中, 采用按时间间隔分割时间数据的方法 (称为排序分区方法) 。假设将图3 (a) 所示的5个时态记录分成2个分区<i>P</i><sub>1</sub>和<i>P</i><sub>2</sub>, 可以首先按时间间隔对这些时态记录进行排序, 获得排序记录 (<i>r</i><sub>1</sub>, <i>r</i><sub>4</sub>, <i>r</i><sub>3</sub>, <i>r</i><sub>2</sub>, <i>r</i><sub>5</sub>) 。为了平衡每个分区的大小, 可以将排序后的记录平均分成2个部分, 因此, <i>P</i><sub>1</sub>包含前2个记录 (<i>r</i><sub>1</sub> , <i>r</i><sub>4</sub>) , <i>P</i><sub>2</sub>则包含 (<i>r</i><sub>2</sub>, <i>r</i><sub>3</sub>, <i>r</i><sub>5</sub>) 。此时, <i>P</i><sub>1</sub>的分区间隔<i>R</i><sub><i>p</i><sub>1</sub></sub>=[<i>t</i><sub>1</sub>, <i>t</i><sub>3</sub>) , 而<i>P</i><sub>2</sub>的分区间隔<i>R</i><sub><i>p</i><sub>2</sub></sub>=[<i>t</i><sub>2</sub>, <i>t</i><sub>4</sub>) 。显然, <i>P</i><sub>1</sub>和<i>P</i><sub>2</sub>的分区间隔重叠是<i>t</i><sub>3</sub>-<i>t</i><sub>2</sub>, 这是最小的间隔重叠。</p>
                </div>
                <div class="p1">
                    <p id="58">尽管随机分区方法被广泛用于其他数据类型, 例如流式数据 (因为数据可以通过这种方式均匀分配) , 但它不适合所关注的时态数据。主要原因是以这种方式分区可能会导致很多分区间隔的重叠, 如图3 (b) 所示的时态数据。进行随机分区后, 假使<i>P</i><sub>1</sub>′包含 (<i>r</i><sub>1</sub>, <i>r</i><sub>3</sub>) , <i>P</i><sub>2</sub>′包含 (<i>r</i><sub>2</sub>, <i>r</i><sub>4</sub>, <i>r</i><sub>5</sub>) 。此时<i>P</i><sub>1</sub>′和<i>P</i><sub>2</sub>′的分区间隔重叠是<i>t</i><sub>3</sub>′-<i>t</i><sub>2</sub>′, 这比<i>P</i><sub>1</sub>和<i>P</i><sub>2</sub>的分区间隔重叠大得多。</p>
                </div>
                <div class="area_img" id="59">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201903004_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 时态数据分区方法" src="Detail/GetImg?filename=images/JSJC201903004_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 时态数据分区方法</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201903004_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="60" name="60">2.2 时态连接查询处理</h4>
                <div class="p1">
                    <p id="61">通过使用全局索引和局部索引, 相应的查询处理由2个阶段组成:分区选择和分区内查找。</p>
                </div>
                <div class="p1">
                    <p id="62">第1阶段通过利用全局索引和版本<i>t</i> (查询输入) 来选择相关的分区。为便于理解, 考虑如图2所示的例子。假设想要选择属于版本21的分区, 可以通过遍历全局索引来检查分区间隔。从根节点<i>root</i>开始, 递归查找每一个结点, 在递归过程中只有节点<i>C</i>的分区间隔包含待查询的版本<i>t</i>, 因此, <i>id</i>为1的分区被选中, 并返回该分区的<i>id</i>值。分区选择的完整过程详见算法1。</p>
                </div>
                <div class="p1">
                    <p id="63">为得到所有分区间隔包含查询版本<i>t</i>的分区<i>id</i>, 算法1通过先根遍历的方式依次判断查询版本<i>t</i>是否被包含在节点所表示分区的分区间隔中, 并将符合条件的分区<i>id</i>增加至集合<i>R</i>。由于全局索引中包含所有分区的分区间隔和<i>id</i>信息, 因此算法1可以准确地得到分区选择结果。</p>
                </div>
                <div class="p1">
                    <p id="64"><b>算法1</b> PartitionSelect (<i>t</i>, <i>root</i>) </p>
                </div>
                <div class="area_img" id="166">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903004_16600.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="166">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903004_16601.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="74">假设分区数为<i>n</i>, 由于需要遍历全局索引, 因此该算法的时间复杂度为<i>O</i> (<i>n</i>) 。此外, 由于时态连接操作中<i>n</i>一般较小 (见第3节实验部分) , 主节点查询过程中使用全局索引进行分区选择的时间开销亦较小。</p>
                </div>
                <div class="p1">
                    <p id="75">第2阶段主要根据局部索引和查询输入, 在每个候选分区中检索符合条件的记录。下文将介绍时态连接操作的详细查询算法。</p>
                </div>
                <div class="p1">
                    <p id="76"><b>算法2</b> TemporalJoin (<i>start</i>, <i>end</i>, <i>t</i>, <i>T</i><sub>1</sub>, <i>T</i><sub>2</sub>) </p>
                </div>
                <div class="area_img" id="167">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903004_16700.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="100">在时态连接操作的第1阶段, 分区选择过程涉及连接的2个数据集<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub> (见算法2第1行～第4行) 。其中, <i>root</i><sub><i>g</i></sub><sub>1</sub>和<i>root</i><sub><i>g</i></sub><sub>2</sub>分别为数据集<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>全局索引的根结点。然后, 使用块嵌套循环 (BNL) <citation id="152" type="reference"><link href="13" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>方法生成要连接的分区, 如算法2 (第5行～第17行) 所述。具体地, 首先选择<i>n</i>作为连接分区的数量, 它决定了每个分区的大小。对于左侧数据集中的每个分区, 将右侧数据集分为<i>n</i>个分区以与左侧分区连接。通过该方法将生成<i>n</i>×<i>n</i>个分区, 从而可以在集群分布式地执行连接操作。生成分区后, 使用多版本B树作为连接索引, 并在每个分区中执行连接操作。详细的时态连接操作过程见算法2 (第18行～第24行) 。其中, 使用多版本B树的分区内join过程请参考文献<citation id="153" type="reference">[<a class="sup">3</a>]</citation>。</p>
                </div>
                <div class="p1">
                    <p id="101">上文已证明了算法2的正确性, 其可以选择所有与查询版本<i>t</i>有关的分区<i>id</i>。通过对<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>进行分区选择, <i>D</i>中包含了<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>中所有可能的连接操作的候选记录。通过BNL方法 (其引入和正确性请参考文献<citation id="154" type="reference">[<a class="sup">7</a>]</citation>) , 生成分布式的连接分区<i>PD</i>。由于<i>D</i>中包含<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>中所有可能的连接操作的候选记录, 将<i>PD</i>中每个分区的时态连接计算结果进行并集操作 (算法2第24行) , 则主节点中<i>R</i>即为时态连接查询结果。</p>
                </div>
                <div class="p1">
                    <p id="102">假设数据集<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>均共有<i>N</i>条记录, 分区数为<i>n</i>, 分布式系统的并行度为<i>p</i>。由算法1的分析, 第1阶段分区选择的时间复杂度为<i>O</i> (<i>n</i>) 。由于算法执行时间与时态记录的间隔长度和数据集的时间空间长度之比相关, 为估算算法的时间复杂度, 假设该值的平均值为<i>α</i> (其典型值为1/100～1/10 000, 见文献<citation id="155" type="reference">[<a class="sup">3</a>]</citation>) , 且记录的间隔长度在时间空间内均匀分布, 则分区选择后<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>均产生<i>αN</i>条候选记录。BNL分区过程的基本操作为内侧循环时态记录的复制和编号, 其时间复杂度为<i>O</i> (<i>αnN</i>) 。此时, 每个分区中的记录数为:</p>
                </div>
                <div class="p1">
                    <p id="103" class="code-formula">
                        <mathml id="103"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mo>=</mo><mfrac><mrow><mi>α</mi><mi>Ν</mi></mrow><mi>n</mi></mfrac></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="104">显然, 分区内时态连接操作的时间复杂度最坏情况下为<i>O</i> (<i>m</i><sup>2</sup>) , 那么从节点中分布式时态连接操作的时间复杂度为:</p>
                </div>
                <div class="p1">
                    <p id="105" class="code-formula">
                        <mathml id="105"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ο</mi><mrow><mo> (</mo><mrow><mfrac><mrow><mi>m</mi><msup><mrow></mrow><mn>2</mn></msup><mi>n</mi><msup><mrow></mrow><mn>2</mn></msup></mrow><mi>p</mi></mfrac></mrow><mo>) </mo></mrow><mo>=</mo><mi>Ο</mi><mrow><mo> (</mo><mrow><mfrac><mrow><mrow><mi>α</mi><msup><mrow></mrow><mn>2</mn></msup><mi>Ν</mi></mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><mi>p</mi></mfrac></mrow><mo>) </mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="106">因此, 算法2的时间复杂度为:</p>
                </div>
                <div class="p1">
                    <p id="107" class="code-formula">
                        <mathml id="107"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Τ</mi><mo>=</mo><mi>Ο</mi><mrow><mo> (</mo><mi>n</mi><mo>) </mo></mrow><mo>+</mo><mi>Ο</mi><mrow><mo> (</mo><mrow><mi>α</mi><mi>n</mi><mi>Ν</mi></mrow><mo>) </mo></mrow><mo>+</mo><mi>Ο</mi><mrow><mo> (</mo><mrow><mfrac><mrow><mrow><mi>α</mi><msup><mrow></mrow><mn>2</mn></msup><mi>Ν</mi></mrow><msup><mrow></mrow><mn>2</mn></msup></mrow><mi>p</mi></mfrac></mrow><mo>) </mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="108">需要注意的是, 尽管算法2使用了传统的块嵌套循环 (BNL) 方法生成分区, 但在分区内实现并使用了多版本B树索引进行连接计算, 明显降低了分区内时态连接计算的时间。同时, 根据记录的时态属性设计了时态数据分区方法, 提高了分区剪枝的效率。</p>
                </div>
                <h4 class="anchor-tag" id="109" name="109">2.3 Apache Spark的实现</h4>
                <div class="p1">
                    <p id="110">第2.1节介绍的对时态连接操作进行处理的两级索引框架, 可以在任何主从式、以分区形式存储数据的分布式系统中实现, 如Hadoop和Spark等。Hadoop在Mapper对象中使用分区器 (partitioner) 将数据分区给相应的Reducer, 可以部署本文的分区单元。同时, 对应Hadoop的主从式分布式结构, 可以分别在ResourceManager和NodeManager中部署全局索引和局部索引。本节将介绍该框架在Spark中的实现。Spark作为新一代的分布式内存计算引擎, 具有性能稳定、容错性高和易使用等特点, 为大数据分析的首选工具。</p>
                </div>
                <div class="p1">
                    <p id="111">为了支持第2.1节中设计的分区方法, 本文扩展了Spark的RangePartitioner。注意Spark的RangePartitioner是为通用数据分区开发的, 它不能有效地支持按时间区间划分时态记录。为了实现这个功能, 本文实现了区间数据格式的比较函数, 并将其集成到Spark RangePartitioner中。</p>
                </div>
                <div class="p1">
                    <p id="112">对于Spark中全局索引的实现, 首先在主节点中收集分配于从节点中的所有分区间隔, 然后在主节点上构建一个二叉搜索树作为全局索引, 如图2所示。全局索引在Spark中的构建过程如下:</p>
                </div>
                <div class="area_img" id="168">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903004_16800.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="117">其中, partitions是Spark中弹性分布式数据集的分区。通过map操作, 将从节点中各个分区的分区间隔收集到主节点, 得到versionInterval数组。而后将versionInterval作为二叉搜索树SearchTree的构造参数构建全局索引。需注意的是, 即使是对于大数据而言, 分区数量也是有限的 (小于1 000) 。因此, 将全局索引放入主节点中不会增加其内存压力。</p>
                </div>
                <div class="p1">
                    <p id="118">Spark中的局部索引的实现与上述过程不同, 弹性分布式数据集是Spark中的基本抽象, 它代表了被分区的可以并行操作的元素集合。同时, 分区中的数据集记录是根据分区算法被装入分区的。特别是观察到弹性分布式数据集是为顺序访问而设计的, 使得不能直接在弹性分布式数据集上建立索引。为解决这个问题, 本文设计了IPartition类, 定义如下:</p>
                </div>
                <div class="area_img" id="169">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903004_16900.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="121">其中, data数据成员在内存中存放Spark数据集的一个分区, 而index为该分区对应的局部索引, Index是一个抽象类, 定义所实现局部索引 (如多版本B树) 的公共接口, 如分区内的时态连接过程 (见算法2第23行) 。</p>
                </div>
                <div class="p1">
                    <p id="122">要通过弹性分布式数据集部署局部索引, 首先将一个分区中的所有时态记录加载到data中, 然后构造局部索引结构; 之后, 释放用于存储原始时态数据的内存, 并将IPartition结构保留在内存中以支持后续查询。</p>
                </div>
                <h3 id="123" name="123" class="anchor-tag">3 实验结果与分析</h3>
                <h4 class="anchor-tag" id="124" name="124">3.1 实验设置</h4>
                <div class="p1">
                    <p id="125">在实验中使用如下所述的真实和合成数据集。真实数据集是从网站Stack Overflow<citation id="156" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>中的时态网络中提取的。网络中共有260万个节点, 代表用户, 共有6 300万条边, 每条边以 (<i>s</i>, <i>d</i>, <i>t</i>) 形式表示, 其中, <i>s</i>和<i>d</i>分别是源和目标用户的标识, <i>t</i>为这2个用户的交互时间。本文提取多于一次与其他人进行互动的用户, 并使用其标识作为记录的<i>id</i>值。用户的2个连续交互时间戳被视为记录的间隔, 而记录值是与用户相关的交互的总数。通过该数据集, 提取了约40万条记录。遵循真实数据集的模式还生成了合成数据集。在合成数据集中, 记录的起始时间戳随机生成, 并且间隔的长度在真实数据集中的最小和最大长度之间均匀分布。 合成数据集的大小范围为100万条～1 000万条记录。</p>
                </div>
                <div class="p1">
                    <p id="126">为了衡量系统性能, 本文采用了2个广泛使用的评估指标:运行时间 (即查询延迟) 和吞吐量。为了获得运行时间, 对每个测试用例重复执行20次, 并计算平均值, 吞吐量则为每分钟可以执行的查询次数。</p>
                </div>
                <div class="p1">
                    <p id="127">本文使用基于原生Spark的内存解决方案作为与本文解决方案进行比较的基准。使用Spark中的默认方法随机分配所有时态记录, 并将数据存储在分布式系统的内存中。这些分区是通过弹性分布式数据集收集和管理的, 允许并行处理数据。为了实现时态查询, 基准系统使用Spark SQL提供的谓词 (例如WHERE谓词) 对数据进行扫描。根据查询输入的查询条件检查每条记录, 获取查询结果。</p>
                </div>
                <div class="p1">
                    <p id="128">所有实验均在包含10个节点的集群上进行, 每个节点共有10个物理CPU核心, 128 GB内存。每个节点使用部署Hadoop 2.7和Spark 1.6的Linux操作系统。集群中节点的网络连接速度为1 000 Mb/s, 并采用1主节点和9从节点的配置。通过Spark Standalone进行配置, 共为集群分配720 GB内存和90个虚拟内核。在实验中, HDFS块的默认大小为128 MB, 局部索引的扇出值设置为100。</p>
                </div>
                <h4 class="anchor-tag" id="129" name="129">3.2 实验结果</h4>
                <h4 class="anchor-tag" id="130" name="130">3.2.1 真实数据集实验结果</h4>
                <div class="p1">
                    <p id="131">图4为在真实数据集上时态连接操作的实验结果。从图4可以看出, 在所有的实验设置中分区数对查询性能的影响都很明显。然而, 最佳分区数在本文解决方案和基准系统之间有显著不同。如图4 (a) 所示, 本文解决方案的最佳分区数为6, 而基准系统分区数约为60～80 (见图4 (b) ) , 远大于本文解决方案。这是因为本文解决方案提供了局部索引支持, 分区内计算速度相比基准系统加速明显。同时, 随着分区数量的增加, 在群集中数据复制的开销亦增加。其次, 对应各个实验设置最佳分区数量的性能数据, 从图4可以看出, 本文解决方案比基准系统快约5倍。虽然数据集相对较小, 本文解决方案仍然有明显的性能优势。这主要是因为:1) 时态连接操作有较高的时间复杂度, 在本文解决方案中使用局部索引后, 提高了分区内的计算速度; 2) 本文解决方案在内存中运行, 并采用全局分区修剪, 有效地过滤了不需要参与计算的分区, 因此效率更高。</p>
                </div>
                <div class="area_img" id="132">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201903004_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 真实数据集上时态连接操作的实验结果" src="Detail/GetImg?filename=images/JSJC201903004_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 真实数据集上时态连接操作的实验结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201903004_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="133" name="133">3.2.2 合成数据集实验结果</h4>
                <div class="p1">
                    <p id="134">时态连接操作在合成数据集上的实验结果如图5所示。合成数据集包含1×10<sup>6</sup>个～10×10<sup>6</sup>个数据记录。本文解决方案使用的连接分区数量为6, 基准系统使用的连接分区数量为60。选取的连接分区数量为各个设置的最佳值 (见图4) 。在合成数据集下, 当数据集的大小超过4×10<sup>6</sup>时, 基准系统的计算时间已超过10<sup>4</sup> s。当数据集大于该数值时, 本文解决方案比基准系统快大约2个数量级, 并且随着数据集大小的增长, 本文解决方案的运行时间曲线更加平稳, 增长更慢, 进一步说明了本文方法的有效性和可扩展性。</p>
                </div>
                <div class="area_img" id="135">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201903004_135.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 本文解决方案和基准方案运行时间对比" src="Detail/GetImg?filename=images/JSJC201903004_135.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 本文解决方案和基准方案运行时间对比</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201903004_135.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="136">图6为分区大小对时态连接操作查询性能的影响。从图6 (a) 和图6 (b) 可以看出, 时态连接操作的最佳分区大小约为0.4×10<sup>6</sup>个～1×10<sup>6</sup>个数据记录。另一方面, 在不同的分区大小下, 时态连接操作的性能表现差距很大, 因此在分布式系统中, 应谨慎选择分区大小, 以获得最佳的查询计算性能。</p>
                </div>
                <div class="area_img" id="137">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201903004_137.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 分区大小对时态连接操作查询性能的影响" src="Detail/GetImg?filename=images/JSJC201903004_137.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图6 分区大小对时态连接操作查询性能的影响</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201903004_137.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="138" name="138" class="anchor-tag">4 相关工作</h3>
                <div class="p1">
                    <p id="139">在时态数据库领域, 早期的研究解决了与时态数据有关的各种问题 (见代表性的调查<citation id="157" type="reference"><link href="17" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>) , 另有一部分工作集中研究了时态聚集<citation id="158" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>和双时态数据<citation id="163" type="reference"><link href="21" rel="bibliography" /><link href="23" rel="bibliography" /><sup>[<a class="sup">10</a>,<a class="sup">11</a>]</sup></citation>。另外, 由于时态数据是一个不断发展的过程, 因此研究人员试图对进化轨迹进行建模<citation id="159" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>, 并追踪时间数据库中的各种元素。最近, 有研究人员解决了从时态数据中发现/挖掘有趣信息<citation id="160" type="reference"><link href="27" rel="bibliography" /><sup>[<a class="sup">13</a>]</sup></citation>的问题, 还研究了与时态数据相关的一些最优问题, 例如为时态大数据寻找最优分割器<citation id="161" type="reference"><link href="29" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>。上述工作与本文研究有关 (因为这些工作也对时态数据进行处理) 。然而, 不难看出它们与本文的研究明显不同, 因为本文的工作关注时态连接操作, 如时态聚集查询和轨迹追踪, 但也存在解决时态连接<citation id="164" type="reference"><link href="7" rel="bibliography" /><link href="9" rel="bibliography" /><sup>[<a class="sup">3</a>,<a class="sup">4</a>]</sup></citation>查询问题。例如, 文献<citation id="162" type="reference">[<a class="sup">15</a>]</citation>提出一种称为时间索引的统一数据结构, 用于处理对时态数据的查询, 其中他们使用列存储来管理时态数据, 时态索引结构可以在文献<citation id="165" type="reference">[<a class="sup">8</a>,<a class="sup">16</a>]</citation>中找到。上述研究的一个主要特点是。他们专注于基于单机的解决方案, 而很少关注开发用于处理时态大数据的分布式解决方案。</p>
                </div>
                <div class="p1">
                    <p id="140">本文工作的主要贡献如下:</p>
                </div>
                <div class="p1">
                    <p id="141">1) 实现了一个面向时态连接操作的分布式内存分析框架。</p>
                </div>
                <div class="p1">
                    <p id="142">2) 设计了用于执行时态连接查询的算法。</p>
                </div>
                <div class="p1">
                    <p id="143">3) 在Spark中实现了本文的框架以及相应的执行算法和分区算法, 构建了可用的分布式时态大数据连接操作查询系统。</p>
                </div>
                <div class="p1">
                    <p id="144">通过使用真实和合成时态数据集对本文的解决方案进行全面的评估, 实验结果表明, 该解决方案可以明显提高时态连接操作的执行效率。</p>
                </div>
                <h3 id="145" name="145" class="anchor-tag">5 结束语</h3>
                <div class="p1">
                    <p id="146">本文提出一种适用于高效执行时态连接操作的二级索引框架, 设计了分布式的时态连接操作算法, 并将其在Spark上进行了实现。为使全局索引更有效地实现分区选择功能, 给出了时态数据的分区算法。实验结果表明, 与基准系统进行对比, 该算法可以明显提高时态连接操作的执行效率。下一步将对索引的使用进行优化, 通过加入统计信息, 提高索引的使用效率和时态连接操作的查询速度。同时, 由于在Spark中所有的数据都会被加载至内存, 在数据量较大时需要进行内存管理操作, 因此细粒度的内存管理也是一个重要的研究方向。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=OceanRT:real-time analytics over large temporal data">

                                <b>[1]</b> ZHANG S, YANG Y, FAN W, et al.OceanRT:real-time analytics over large temporal data[C]//Proceedings of 2014 ACM SIGMOD International Conference on Management of Data.New York, USA:ACM Press, 2014:1099-1102.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201707005&amp;v=MTQxMDI3QmJiRzRIOWJNcUk5RllZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5L2hVYnJKTHo=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 周亮, 李格非, 邰伟鹏, 等:基于Spark的时态查询扩展与时态索引优化研究[J].计算机工程, 2017, 43 (7) :22-28, 37.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Seeger:efficient temporal join processing using indices">

                                <b>[3]</b> ZHANG D, TSOTRAS V L.Seeger:efficient temporal join processing using indices[C]//Proceedings of the 18th International Conference on Data Engineering.Washington D.C., USA:IEEE Press, 2002:401-412.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Spatio-Temporal Joins On Symbolic Indoor Tracking Data">

                                <b>[4]</b> LU H, YANG B, JENSEN C S.Spatio-temporal joins on symbolic indoor tracking data[C]//Proceedings of the 27th IEEE International Conference on Data Engineering.Washington D.C., USA:IEEE Press, 2011:125-136.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An asymptotically optimal multiversion B-tree">

                                <b>[5]</b> BECKER B, GSCHWIND S, OHLER T, et al.Widmayer:an asymptotically optimal multiversion B-tree[J].The VLDB Journal, 1996, 5 (4) :264-275.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Block-based join algorithms">

                                <b>[6]</b> Block-based join algorithms[EB/OL].[2018-04-01].https://mariadb.com/kb/en/library/block-based-join-algorithms/.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Stanford large network dataset collection">

                                <b>[7]</b> LESKOVEC J, KREVL A.SNAP datasets:stanford large network dataset collection[EB/OL].[2018-05-21].http://snap.stanford.edu/data.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Spatio-temporal access methods:a survey">

                                <b>[8]</b> MAHMOOD A R, PUNNI S, AREF W G.Spatio-temporal access methods:a survey[EB/OL].[2018-05-21].https://link.springer.com.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On computing temporal aggregates over null time intervals">

                                <b>[9]</b> CHENG K.On computing temporal aggregates over null time intervals[C]//Proceedings of International Conference on Database and Expert Systems Applications.Washington D.C., USA:IEEE Press, 2017:67-79.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Bi-temporal timeline index:a data structure for processing queries on bi-temporal data">

                                <b>[10]</b> KAUFMANN M, FISHHER P M, MAY N, et al.Bi-temporal timeline index:a data structure for processing queries on bi-temporal data[C]//Proceedings of ICDE’15.Washington D.C., USA:IEEE Press, 2015:215-226.
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSGG200513052&amp;v=MDE2NDdUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnkvaFVickpMejdNYWJHNEh0VE5ySTlBWm9RS0RIODR2UjQ=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b> 周风华, 汤庸, 康向锋.一种有效的双时态索引技术[J].计算机工程与应用, 2005, 41 (13) :231-239.
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Hierarchical evolving dirichlet processes for modeling nonlinear evolutionary traces in temporal data">

                                <b>[12]</b> WANG P, ZHANG P, ZHOU C, et al.Hierarchical evolving dirichlet processes for modeling nonlinear evolutionary traces in temporal data[J].Data Mining and Knowledge Discovery, 2017, 31 (1) :32-64.
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A temporal data mining framework for analyzing longitudinal data">

                                <b>[13]</b> LOGLISCI C, CECI M, MALERBA D.A temporal data mining framework for analyzing longitudinal data[C]//Proceedings of International Conference on Database and Expert Systems Applications.Washington D.C., USA:IEEE Press, 2011:154-165.
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Optimal splitters for temporal and multi-version databases">

                                <b>[14]</b> LE W, LI F, TAO Y, et al.Optimal splitters for temporal and multi-version databases[C]//Proceedings of SIGMOD’13.Washington D.C., USA:IEEE Press, 2013:321-329.
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Timeline index:a unified data structure for processing queries on temporal data in SAP HANA">

                                <b>[15]</b> KAUFMANN M, MANJILI A, VAGENAS A P, et al.Timeline index:a unified data structure for processing queries on temporal data in SAP HANA[C]//Proceedings of SIGMOD’13.Washington D.C., USA:IEEE Press, 2013:124-132.
                            </a>
                        </p>
                        <p id="33">
                            <a id="bibliography_16" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The time index:An access structure for temporal data">

                                <b>[16]</b> ELMASRI R, WUU G T, KIM Y J.The time index:an access structure for temporal data[C]//Proceedings of the 16th International Conference on Very Large Data Bases.Washington D.C., USA:IEEE Press, 1990:125-136.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJC201903004" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201903004&amp;v=MTI0NDBESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5L2hVYnJKTHo3QmJiRzRIOWpNckk5RllJUUs=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="2" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
