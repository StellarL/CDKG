<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637130525553780000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201905009%26RESULT%3d1%26SIGN%3dP%252bGBHfnMkZUUbS91MddwNaTMoXg%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201905009&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201905009&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201905009&amp;v=MDk2OTh0R0ZyQ1VSTE9lWmVSb0Z5M2xWcnZLTHo3QmJiRzRIOWpNcW85RmJZUUtESDg0dlI0VDZqNTRPM3pxcUI=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#33" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#36" data-title="1 调度算法模型 ">1 调度算法模型</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#56" data-title="2 TDRECS算法 ">2 TDRECS算法</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#62" data-title="2.1 调度次序">2.1 调度次序</a></li>
                                                <li><a href="#65" data-title="2.2 首次复制阶段">2.2 首次复制阶段</a></li>
                                                <li><a href="#81" data-title="2.3 再次复制阶段">2.3 再次复制阶段</a></li>
                                                <li><a href="#87" data-title="2.4 优化处理器个数阶段">2.4 优化处理器个数阶段</a></li>
                                                <li><a href="#97" data-title="2.5 冗余任务消除阶段">2.5 冗余任务消除阶段</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#120" data-title="3 实验结果与分析 ">3 实验结果与分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#122" data-title="3.1 性能评估参数">3.1 性能评估参数</a></li>
                                                <li><a href="#128" data-title="3.2 任务图实例分析">3.2 任务图实例分析</a></li>
                                                <li><a href="#136" data-title="3.3 随机任务图集测试">3.3 随机任务图集测试</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#143" data-title="4 结束语 ">4 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#72" data-title="&lt;b&gt;图1 &lt;i&gt;n&lt;/i&gt;&lt;/b&gt;&lt;sub&gt;&lt;b&gt;&lt;i&gt;a&lt;/i&gt;&lt;/b&gt;&lt;/sub&gt;&lt;b&gt;前驱任务的复制示意图&lt;/b&gt;"><b>图1 <i>n</i></b><sub><b><i>a</i></b></sub><b>前驱任务的复制示意图</b></a></li>
                                                <li><a href="#84" data-title="&lt;b&gt;图2 簇上空闲时间的减少示意图&lt;/b&gt;"><b>图2 簇上空闲时间的减少示意图</b></a></li>
                                                <li><a href="#89" data-title="&lt;b&gt;图3 冗余簇实例&lt;/b&gt;"><b>图3 冗余簇实例</b></a></li>
                                                <li><a href="#130" data-title="&lt;b&gt;图4 DAG任务图实例&lt;/b&gt;"><b>图4 DAG任务图实例</b></a></li>
                                                <li><a href="#132" data-title="&lt;b&gt;图5 不同算法任务调度分配&lt;/b&gt;"><b>图5 不同算法任务调度分配</b></a></li>
                                                <li><a href="#133" data-title="&lt;b&gt;表1 不同算法调度结果对比&lt;/b&gt;"><b>表1 不同算法调度结果对比</b></a></li>
                                                <li><a href="#138" data-title="&lt;b&gt;图6 不同任务规模下处理器个数比较&lt;/b&gt;"><b>图6 不同任务规模下处理器个数比较</b></a></li>
                                                <li><a href="#140" data-title="&lt;b&gt;图7 不同任务规模下加速比比较&lt;/b&gt;"><b>图7 不同任务规模下加速比比较</b></a></li>
                                                <li><a href="#142" data-title="&lt;b&gt;图8 不同任务规模下冗余计算比率比较&lt;/b&gt;"><b>图8 不同任务规模下冗余计算比率比较</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" 徐成, 赵林祥, 杨志邦.一种基于多处理器任务复制的分簇调度算法[J].计算机应用研究, 2012, 29 (8) :2931-2934." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSYJ201208035&amp;v=MjA4NDdUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnkzbFZydk5MejdTWkxHNEg5UE1wNDlHWVlRS0RIODR2UjQ=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         徐成, 赵林祥, 杨志邦.一种基于多处理器任务复制的分簇调度算法[J].计算机应用研究, 2012, 29 (8) :2931-2934.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title=" BUYYA R.High performance cluster computing:architectures and systems[M].[S.1.]:Prentice-Hall, 2002." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=High performance cluster computing:architectures and systems">
                                        <b>[2]</b>
                                         BUYYA R.High performance cluster computing:architectures and systems[M].[S.1.]:Prentice-Hall, 2002.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" 石威, 郑纬民.相关任务图的均衡动态关键路径调度算法[J].计算机学报, 2001, 24 (9) :991-997." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX200109014&amp;v=MzEyOTVxcUJ0R0ZyQ1VSTE9lWmVSb0Z5M2xWcnZOTHo3QmRyRzRIdERNcG85RVlJUUtESDg0dlI0VDZqNTRPM3o=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         石威, 郑纬民.相关任务图的均衡动态关键路径调度算法[J].计算机学报, 2001, 24 (9) :991-997.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title=" HWANG J J, CHOW Y C, ANGER F D, et al.Scheduling precedence graphs in systems with interprocessor communication times[J].SIAM Journal on Computing, 1989, 18 (2) :244-257." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Scheduling precedence graphs in systems with interprocessor communication times">
                                        <b>[4]</b>
                                         HWANG J J, CHOW Y C, ANGER F D, et al.Scheduling precedence graphs in systems with interprocessor communication times[J].SIAM Journal on Computing, 1989, 18 (2) :244-257.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" WU Minyou, GAJSKI D D.Hypertool:a programming aid for message-passing systems[J].IEEE Transactions on Parallel and Distributed Systems, 1990, 1 (3) :330-343." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Hypertool: A programming aid for message-passing systems">
                                        <b>[5]</b>
                                         WU Minyou, GAJSKI D D.Hypertool:a programming aid for message-passing systems[J].IEEE Transactions on Parallel and Distributed Systems, 1990, 1 (3) :330-343.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" LIU Yuan, JIA Pingui, YANG Yiping.Efficient scheduling of DAG tasks on multi-core processor based parallel systems[C]//Proceedings of TENCON’16.Washington D.C., USA:IEEE Press, 2016:1-6." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient scheduling of DAG tasks on multi-core processor based parallel systems">
                                        <b>[6]</b>
                                         LIU Yuan, JIA Pingui, YANG Yiping.Efficient scheduling of DAG tasks on multi-core processor based parallel systems[C]//Proceedings of TENCON’16.Washington D.C., USA:IEEE Press, 2016:1-6.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title=" DARBHA S, AGRAWAL D P.Optimal scheduling algorithm for distributed-memory machines[J].IEEE Transactions on Parallel and Distributed Systems, 1998, 9 (1) :87-95." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Optimal scheduling algorithm for distributed-memory machines">
                                        <b>[7]</b>
                                         DARBHA S, AGRAWAL D P.Optimal scheduling algorithm for distributed-memory machines[J].IEEE Transactions on Parallel and Distributed Systems, 1998, 9 (1) :87-95.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title=" PARK C I, CHOE T Y.An optimal scheduling algorithm based on task duplication[C]//Proceedings of the 8th International Conference on Parallel and Distributed Systems.Washington D.C., USA:IEEE Press, 2001:9-14." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=An optimal scheduling algorithm based on task duplication">
                                        <b>[8]</b>
                                         PARK C I, CHOE T Y.An optimal scheduling algorithm based on task duplication[C]//Proceedings of the 8th International Conference on Parallel and Distributed Systems.Washington D.C., USA:IEEE Press, 2001:9-14.
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title=" 周双娥, 袁由光, 熊兵周, 等.基于任务复制的处理器预分配算法[J].计算机学报, 2004, 27 (2) :216-223." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX200402009&amp;v=MDExNzZxQnRHRnJDVVJMT2VaZVJvRnkzbFZydk5MejdCZHJHNEh0WE1yWTlGYllRS0RIODR2UjRUNmo1NE8zenE=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[9]</b>
                                         周双娥, 袁由光, 熊兵周, 等.基于任务复制的处理器预分配算法[J].计算机学报, 2004, 27 (2) :216-223.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title=" 叶佳, 周鸣争.一种改进的基于任务复制的多核调度算法[J].计算机工程与应用, 2015, 51 (12) :31-37." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSGG201512007&amp;v=MDA0MjBMejdNYWJHNEg5VE5yWTlGWTRRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnkzbFZydk4=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                         叶佳, 周鸣争.一种改进的基于任务复制的多核调度算法[J].计算机工程与应用, 2015, 51 (12) :31-37.
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title=" BOERES C, FILHO J V, REBELLO V E F.A cluster-based strategy for scheduling task on heterogeneous processors[C]//Proceedings of Symposium on Computer Architecture and High Performance Computing.Washington D.C., USA:IEEE Press, 2004:214-226." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A cluster-based strategy for scheduling task on heterogeneous processors">
                                        <b>[11]</b>
                                         BOERES C, FILHO J V, REBELLO V E F.A cluster-based strategy for scheduling task on heterogeneous processors[C]//Proceedings of Symposium on Computer Architecture and High Performance Computing.Washington D.C., USA:IEEE Press, 2004:214-226.
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" title=" PALIS M A, LIOU J C, WEI D S L.Task clustering and scheduling for distributed memory parallel architectures[J].IEEE Transactions on Parallel and Distributed Systems, 1996, 7 (1) :46-55." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Task clustering and scheduling for distributed memory parallel architectures">
                                        <b>[12]</b>
                                         PALIS M A, LIOU J C, WEI D S L.Task clustering and scheduling for distributed memory parallel architectures[J].IEEE Transactions on Parallel and Distributed Systems, 1996, 7 (1) :46-55.
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title=" 兰舟.分布式系统中的调度算法研究[D].成都:电子科技大学, 2009." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=2009160095.nh&amp;v=MzA0MzlLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeTNsVnJ2TlYxMjdGN0srSHRIRnFwRWJQSVE=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[13]</b>
                                         兰舟.分布式系统中的调度算法研究[D].成都:电子科技大学, 2009.
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_14" title=" GAREY M R, JOHNSON D S.Computers and intractability:a guide to the theory of NP-completeness[M].[S.1.]:W.H.Freeman, 1979." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Computers and intractability: a guide to the theory of NP-completeness">
                                        <b>[14]</b>
                                         GAREY M R, JOHNSON D S.Computers and intractability:a guide to the theory of NP-completeness[M].[S.1.]:W.H.Freeman, 1979.
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_15" title=" XIE Guoqi, LI Renfa, XIAO Xiongren, et al.A high-performance DAG task scheduling algorithm for heterogeneous networked embedded systems[C]//Proceedings of the 28th International Conference on Advanced Information Networking and Applications.Washington D.C., USA:IEEE Press, 2014:1011-1016." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A high-performance DAG task scheduling algorithm for heterogeneous networked embedded systems">
                                        <b>[15]</b>
                                         XIE Guoqi, LI Renfa, XIAO Xiongren, et al.A high-performance DAG task scheduling algorithm for heterogeneous networked embedded systems[C]//Proceedings of the 28th International Conference on Advanced Information Networking and Applications.Washington D.C., USA:IEEE Press, 2014:1011-1016.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(05),59-65 DOI:10.19678/j.issn.1000-3428.0051785            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于任务复制与冗余消除的多核调度算法</b></span>
 <span class="shoufa"></span>                                     </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E4%BB%BB%E8%89%AF%E8%82%B2&amp;code=40365865&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">任良育</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E8%B5%B5%E6%88%90%E8%90%8D&amp;code=09804487&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">赵成萍</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E4%B8%A5%E5%8D%8E&amp;code=08738360&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">严华</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E7%94%B5%E5%AD%90%E4%BF%A1%E6%81%AF%E5%AD%A6%E9%99%A2&amp;code=0054367&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">四川大学电子信息学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>在分布式计算中常把任务之间的协同和通信关系转换为任务图模型, 而任务调度是决定分布式计算性能的关键因素之一。为解决OSA、TDCS、RECS等传统经典算法处理器个数消耗多且存在大量冗余任务等问题, 提出一种改进的任务图调度算法。该算法基于贪心策略复制任务的前驱以及前驱的前驱, 减少调度长度和处理器空闲时间, 并在不增加调度长度的前提下, 通过合并簇及减少冗余任务降低处理器个数和处理器的负载。实验结果表明, 该算法在处理器个数、加速比以及冗余任务比率上都有一定程度的优化, 能提升分布式计算性能。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">分布式计算;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">任务调度;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E4%BB%BB%E5%8A%A1%E5%A4%8D%E5%88%B6&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">任务复制;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%86%97%E4%BD%99%E6%B6%88%E9%99%A4&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">冗余消除;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">贪心策略;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    任良育 (1992—) , 男, 硕士研究生, 主研方向为并行计算;;
                                </span>
                                <span>
                                    赵成萍, 副教授;;
                                </span>
                                <span>
                                    严华, 教授。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-06-11</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家重点基础研究发展计划 (2013CB328903-2);</span>
                    </p>
            </div>
                    <h1><b>Multi-core Scheduling Algorithm Based on Task Duplication and Redundancy Elimination</b></h1>
                    <h2>
                    <span>REN Liangyu</span>
                    <span>ZHAO Chengping</span>
                    <span>YAN Hua</span>
            </h2>
                    <h2>
                    <span>College of Electronics and Information Engineering, Sichuan University</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>In distributed computing, the coordination and communication relationships between tasks are often converted to a task graph model.Task scheduling is a critical factor in determining the performance of distributed computing.Traditional classical algorithms such as OSA, TDCS, RECS, can lead to a large amount of processor resource consumption and many redundant tasks.To address the problems, this paper proposes an improved task graph scheduling algorithm.The algorithm reduce the scheduling length and idle time of processors by using the greedy strategy to replicate the precursors of tasks and precursors.Without increasing the scheduling length, it merges clusters and reduces redundant tasks to decrease the number and the load of processors.Experimental results show that the algorithm has a certain degree of optimization in the number of processors, the speedup ratio and the redundancy task ratio, and improves the distributed computing performance.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=distributed%20computing&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">distributed computing;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=task%20scheduling&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">task scheduling;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=task%20duplication&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">task duplication;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=redundancy%20elimination&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">redundancy elimination;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=greedy%20strategy&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">greedy strategy;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-06-11</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="33" name="33" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="34">在分布式计算中, 常把一个大的任务划分为一个个子任务, 而任务调度根据一定的调度规则和调度策略, 将这些子任务按照任务之间的依赖关系和执行时序分配到各个处理器节点上<citation id="145" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>, 其目的是减少任务之间的通信开销和等待时间, 从而提高实时任务的响应速度, 优化整个系统的运行效率。多任务调度问题已被证明是一个NP难题, 较难在多项式时间内寻求最优解<citation id="146" type="reference"><link href="5" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>。在任务调度算法中最为常见的是基于启发式的调度算法。启发式的调度算法主要包括基于关键路径的表调度算法<citation id="150" type="reference"><link href="7" rel="bibliography" /><link href="9" rel="bibliography" /><link href="11" rel="bibliography" /><sup>[<a class="sup">3</a>,<a class="sup">4</a>,<a class="sup">5</a>]</sup></citation>、任务复制算法<citation id="151" type="reference"><link href="13" rel="bibliography" /><link href="15" rel="bibliography" /><link href="17" rel="bibliography" /><sup>[<a class="sup">6</a>,<a class="sup">7</a>,<a class="sup">8</a>]</sup></citation>、基于任务复制的处理器预分配算法<citation id="147" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>、改进的基于任务复制的多核调度算法<citation id="148" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>、聚簇算法<citation id="152" type="reference"><link href="23" rel="bibliography" /><link href="25" rel="bibliography" /><link href="27" rel="bibliography" /><sup>[<a class="sup">11</a>,<a class="sup">12</a>,<a class="sup">13</a>]</sup></citation>等。由于在同一个处理器上任务之间的通信开销可以忽略, 因此在减少通信开销上, 基于任务复制的调度是一个有效的策略。任务复制法的特点是通过复制有通信关系的前驱任务, 来减少处理器之间的通信时间, 从而在总体上降低系统的执行时间。当采用合理有效的复制规则与策略时, 基于任务复制的调度算法已被证明比其他调度算法具有更好的调度效果<citation id="149" type="reference"><link href="29" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="35">经典的任务调度算法主要有OSA算法<citation id="153" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>、TDCS算法<citation id="154" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>和RECS算法<citation id="155" type="reference"><link href="13" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>。OSA算法基于贪心策略, 通过复制任务的最佳前驱和进一步复制其他前驱节点来减少通信时间, 从而优化调度长度。但该算法未考虑任务图中可能出现复制的前驱与其前驱的前驱, 由于任务通信会造成节点的开始时间被推迟的情况, 因此存在进一步优化的可能。基于任务复制的算法虽然在调度长度上比其他算法更优, 但随之带来的是处理器数目的增多。基于此, TDCS算法在OSA算法的基础上通过合并有通信关系的簇来减少处理器的个数, 同时通过考虑复制任务的次前驱来缩短空闲时间从而降低处理器消耗, 但同样未考虑到复制的前驱与其前驱的前驱存在通信的情况。同时TDCS算法在OSA算法的基础上考虑消除有包含关系的冗余簇来进一步减少处理器的个数, 但简单地通过簇包含关系来消除冗余簇, 可能会造成有通信关系的后继节点的开始时间被推迟, 从而使调度长度增大。RECS算法提出通过将不影响后继任务开始时间的冗余任务删除来减少冗余任务, 但未考虑到在不增加总调度长度前提下的冗余任务都可以删除。针对上述算法的不足, 本文提出一种改进的基于任务复制和冗余任务消除的分簇调度算法TDRECS (Clustering Scheduling Algorithm Based on Task Duplication and Redundant Elimination) 。</p>
                </div>
                <h3 id="36" name="36" class="anchor-tag">1 调度算法模型</h3>
                <div class="p1">
                    <p id="37">一组有序并行任务可以用一个有向无环图 (Directed Acyclic Graph, DAG) 来表示, 将任务的调度问题转换为调度DAG任务图的问题。DAG任务图可以用数学描述为<i>G</i>= (<i>V</i>, <i>E</i>, <i>w</i>, <i>C</i>) 。其中:</p>
                </div>
                <div class="p1">
                    <p id="38"><i>V</i>={<i>n</i><sub><i>i</i></sub>|<i>n</i><sub><i>i</i></sub>是有序任务, <i>i</i>=1, 2, …, <i>v</i>}是有序任务集, <i>v</i>=|<i>V</i>|表示任务集的数目。</p>
                </div>
                <div class="p1">
                    <p id="39"><i>E</i>={<i>e</i><sub><i>ij</i></sub>|<i>e</i><sub><i>ij</i></sub>表示任务<i>n</i><sub><i>i</i></sub>到任务<i>n</i><sub><i>j</i></sub>的边}是任务集<i>V</i>边的集合, <i>e</i>=|<i>E</i>|表示边的数目。</p>
                </div>
                <div class="p1">
                    <p id="40"><i>w</i>={<i>w</i><sub><i>i</i></sub>|<i>w</i><sub><i>i</i></sub>表示任务<i>n</i><sub><i>i</i></sub>的计算时间开销或权值, <i>i</i>=1, 2, …, <i>v</i>}是计算时间开销集合。</p>
                </div>
                <div class="p1">
                    <p id="41"><i>C</i>={<i>c</i><sub><i>ij</i></sub>|表示任务<i>n</i><sub><i>i</i></sub>到<i>n</i><sub><i>j</i></sub>的通信时间开销}, 称任务<i>n</i><sub><i>i</i></sub>为任务<i>n</i><sub><i>j</i></sub>的父任务或直接前驱任务。若任务<i>n</i><sub><i>i</i></sub>和任务<i>n</i><sub><i>j</i></sub>在同一个处理器上, 则<i>c</i><sub><i>ij</i></sub>=0。</p>
                </div>
                <div class="p1">
                    <p id="42"><i>pred</i> (<i>n</i><sub><i>i</i></sub>) ={<i>n</i><sub><i>j</i></sub>|<i>e</i><sub><i>ij</i></sub>∈<i>E</i>}表示任务<i>n</i><sub><i>i</i></sub>的前驱任务集, |<i>pred</i> (<i>n</i><sub><i>i</i></sub>) |表示任务<i>n</i><sub><i>i</i></sub>的前驱任务的数目。</p>
                </div>
                <div class="p1">
                    <p id="43"><i>succ</i> (<i>n</i><sub><i>i</i></sub>) ={<i>n</i><sub><i>j</i></sub>|<i>e</i><sub><i>ij</i></sub>∈<i>E</i>}表示任务<i>n</i><sub><i>i</i></sub>的后继任务集合, <i>succ</i> (<i>n</i><sub><i>i</i></sub>, <i>p</i>) 为任务<i>n</i><sub><i>i</i></sub>在处理器<i>p</i>上的后继集合, |<i>succ</i> (<i>n</i><sub><i>i</i></sub>) |表示任务<i>n</i><sub><i>i</i></sub>的后继任务的数目。</p>
                </div>
                <div class="p1">
                    <p id="44">最早开始时间<i>est</i> (<i>n</i><sub><i>i</i></sub>) , 若|<i>pred</i> (<i>n</i><sub><i>i</i></sub>) |=0, 则<i>est</i> (<i>n</i><sub><i>i</i></sub>) =0, 即<i>est</i> (<i>n</i><sub>start</sub>) =0。</p>
                </div>
                <div class="p1">
                    <p id="45">最早完成时间<i>ect</i> (<i>n</i><sub><i>i</i></sub>) , 并且<i>ect</i> (<i>n</i><sub><i>i</i></sub>) =<i>est</i> (<i>n</i><sub><i>i</i></sub>) +<i>w</i> (<i>n</i><sub><i>i</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="46">最佳前驱<i>fpred</i> (<i>n</i><sub><i>i</i></sub>) =<i>n</i><sub><i>j</i></sub>|<i>ect</i> (<i>n</i><sub><i>j</i></sub>) +<i>c</i> (<i>n</i><sub><i>j</i></sub>, <i>n</i><sub><i>i</i></sub>) &gt;<i>ect</i> (<i>n</i><sub><i>k</i></sub>) +<i>c</i> (<i>n</i><sub><i>k</i></sub>, <i>n</i><sub><i>i</i></sub>) , ∀<i>j</i>, <i>k</i>∈<i>pred</i> (<i>n</i><sub><i>i</i></sub>) 且<i>j</i>≠<i>k</i>。</p>
                </div>
                <div class="p1">
                    <p id="47"><i>makespan</i>:任务图的调度长度, <i>makespan</i>=<i>ect</i> (<i>n</i><sub><i>exit</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="48"><i>r</i> (<i>C</i><sub><i>i</i></sub>) :簇<i>C</i><sub><i>i</i></sub>上的所有任务执行完所需的时间。</p>
                </div>
                <div class="p1">
                    <p id="49"><i>core</i> (<i>n</i><sub><i>i</i></sub>) :包含任务<i>n</i><sub><i>i</i></sub>的处理器集合。</p>
                </div>
                <div class="p1">
                    <p id="50"><i>ncore</i> (<i>n</i><sub><i>i</i></sub>) :包含任务<i>n</i><sub><i>i</i></sub>的处理器个数。</p>
                </div>
                <div class="p1">
                    <p id="51">分配到同一个处理器上的任务成为cluster的一个簇, 记为<i>C</i><sub><i>i</i></sub>。对于簇<i>C</i><sub><i>i</i></sub>中每个任务<i>n</i><sub><i>k</i></sub>, 存在2个值:即<i>stc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) 和<i>ctc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) , 分别表示簇<i>C</i><sub><i>i</i></sub>中任务<i>n</i><sub><i>k</i></sub>的开始执行时间和结束时间, <i>ct</i> (<i>C</i><sub><i>i</i></sub>) 表示簇<i>C</i><sub><i>i</i></sub>的完成时间, 即簇中出口任务的完成时间。簇中满足的条件如下:</p>
                </div>
                <div class="p1">
                    <p id="52">1) <i>ctc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) =<i>stc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) +<i>w</i> (<i>n</i><sub><i>k</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="53">2) 若对于任务<i>n</i><sub><i>k</i></sub>, <i>n</i><sub><i>j</i></sub>∈<i>C</i><sub><i>i</i></sub>, 则<i>ctc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) ≤<i>stc</i><sub><i>i</i></sub> (<i>n</i><sub><i>j</i></sub>) 或<i>ctc</i><sub><i>i</i></sub> (<i>n</i><sub><i>j</i></sub>) ≤<i>stc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="54">3) 若<i>n</i><sub><i>k</i></sub>, <i>n</i><sub><i>j</i></sub>∈<i>C</i><sub><i>i</i></sub>且<i>e</i><sub><i>kj</i></sub>∈<i>E</i>, 则<i>ctc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) ≤<i>stc</i><sub><i>i</i></sub> (<i>n</i><sub><i>j</i></sub>) 。</p>
                </div>
                <div class="p1">
                    <p id="55">4) 若<i>n</i><sub><i>k</i></sub>∈<i>C</i><sub><i>i</i></sub>-<i>C</i><sub><i>j</i></sub>, <i>n</i><sub><i>j</i></sub>∈<i>C</i><sub><i>j</i></sub>且<i>e</i><sub><i>kj</i></sub>∈<i>E</i>, 则<i>ctc</i><sub><i>i</i></sub> (<i>n</i><sub><i>k</i></sub>) ≤<i>stc</i><sub><i>j</i></sub> (<i>n</i><sub><i>j</i></sub>) 。</p>
                </div>
                <h3 id="56" name="56" class="anchor-tag">2 TDRECS算法</h3>
                <div class="p1">
                    <p id="57">在OSA算法、TDCS算法以及RECS算法的基础上, 本文TDRECS算法主要进行了以下改进:</p>
                </div>
                <div class="p1">
                    <p id="58">1) 在优化任务最早开始时间和减少簇上空闲时间时, 除了考虑复制任务的前驱, 还要进一步考虑复制任务前驱的前驱。</p>
                </div>
                <div class="p1">
                    <p id="59">2) 在删除冗余簇和合并簇以减少处理器个数时, 增加删除冗余簇的前提条件, 当删除冗余簇会使调度长度增加时, 需调整任务顺序或取消删除。放宽合并簇的条件, 只要不是调度长度增加的2个簇都可以考虑合并。</p>
                </div>
                <div class="p1">
                    <p id="60">3) 在RECS算法基础上, 放宽删除冗余任务的条件, 若删除冗余任务后调度长度不增加即可删除。</p>
                </div>
                <div class="p1">
                    <p id="61">改进后的TDRECS算法主要分为4个阶段:1) 使任务具有最早开始时间的首次复制阶段;2) 减少簇上空闲时间的再次复制阶段;3) 优化处理器数目阶段;4) 减少处理器负载的冗余任务消除阶段。</p>
                </div>
                <h4 class="anchor-tag" id="62" name="62">2.1 调度次序</h4>
                <div class="p1">
                    <p id="63">在DAG任务图中需满足父任务先执行、子任务后执行的原则, 以满足任务图中各任务间的执行先后关系。一般采取任务深度小者优先构建调度队列的原则来划分任务层次, 改进的TDRECS算法采取表调度算法中的向上排序值 (<i>rank</i>) 来确定任务调度优先级。向上排序值越大的任务优先被调度, 向上排序值相同时任务序号小者优先被调度。排序值定义如下:</p>
                </div>
                <div class="p1">
                    <p id="64" class="code-formula">
                        <mathml id="64"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mo stretchy="false"> (</mo><mi>n</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo>=</mo><mrow><mo>{</mo><mtable columnalign="left"><mtr><mtd><mn>0</mn><mo>, </mo><mi>n</mi><msub><mrow></mrow><mi>i</mi></msub><mo>=</mo><mi>n</mi><msub><mrow></mrow><mrow><mtext>e</mtext><mtext>x</mtext><mtext>i</mtext><mtext>t</mtext></mrow></msub></mtd></mtr><mtr><mtd><munder><mstyle mathsize="140%" displaystyle="true"><mrow><mi>max</mi><mo stretchy="false"> (</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mo stretchy="false"> (</mo><mi>n</mi><msub><mrow></mrow><mi>j</mi></msub><mo stretchy="false">) </mo><mo stretchy="false">) </mo></mrow></mstyle><mrow><mi>n</mi><msub><mrow></mrow><mi>j</mi></msub><mo>∈</mo><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mo stretchy="false"> (</mo><mi>n</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo></mrow></munder><mo>+</mo><mn>1</mn><mo>, </mo><mi>n</mi><msub><mrow></mrow><mi>i</mi></msub><mo>≠</mo><mi>n</mi><msub><mrow></mrow><mrow><mtext>e</mtext><mtext>x</mtext><mtext>i</mtext><mtext>t</mtext></mrow></msub></mtd></mtr></mtable></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <h4 class="anchor-tag" id="65" name="65">2.2 首次复制阶段</h4>
                <div class="p1">
                    <p id="66">对于任务<i>n</i><sub><i>a</i></sub>, 如果<i>pred</i> (<i>n</i><sub><i>a</i></sub>) ={<i>n</i><sub><i>k</i>1</sub>, <i>n</i><sub><i>k</i>2</sub>, …, <i>n</i><sub><i>kn</i></sub>}, 前驱节点所在的簇记为<i>C</i><sub>1</sub>, <i>C</i><sub>2</sub>, …, <i>C</i><sub><i>k</i></sub>, 记<i>rdy</i> (<i>n</i><sub><i>i</i></sub>, <i>n</i><sub><i>a</i></sub>) =<i>ctc</i><sub><i>i</i></sub> (<i>n</i><sub><i>i</i></sub>) +<i>c</i> (<i>n</i><sub><i>i</i></sub>, <i>n</i><sub><i>a</i></sub>) 。对前驱节点按照<i>rdy</i> (<i>n</i><sub><i>i</i></sub>, <i>n</i><sub><i>a</i></sub>) 进行降序排列, 得到:</p>
                </div>
                <div class="p1">
                    <p id="67"><i>rdy</i> (<i>n</i><sub>1</sub>, <i>n</i><sub><i>a</i></sub>) ≥<i>rdy</i> (<i>n</i><sub>2</sub>, <i>n</i><sub><i>a</i></sub>) ≥…≥<i>rdy</i> (<i>n</i><sub><i>n</i></sub>, <i>n</i><sub><i>a</i></sub>)      (2) </p>
                </div>
                <div class="p1">
                    <p id="68">任务<i>n</i><sub>1</sub>是任务<i>n</i><sub><i>a</i></sub>的最佳前驱, 称任务<i>n</i><sub>1</sub>, <i>n</i><sub>2</sub>, …, <i>n</i><sub><i>n</i></sub>中的任务<i>n</i><sub><i>s</i></sub> (1≤<i>s</i>≤<i>n</i>) 为<i>n</i><sub><i>a</i></sub>的前驱任务集的关键任务, <i>n</i><sub>1</sub>～<i>n</i><sub><i>s</i></sub>为关键前驱, 下标<i>s</i>为满足式 (3) 、式 (4) 的下标值:</p>
                </div>
                <div class="p1">
                    <p id="69" class="code-formula">
                        <mathml id="69"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>s</mi></munderover><mi>c</mi></mstyle><mi>t</mi><mi>c</mi><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>n</mi><msub><mrow></mrow><mi>i</mi></msub><mo stretchy="false">) </mo><mo>+</mo><mi>w</mi><msub><mrow></mrow><mi>i</mi></msub><mo>≤</mo><mi>r</mi><mi>d</mi><mi>y</mi><mo stretchy="false"> (</mo><mi>n</mi><msub><mrow></mrow><mi>s</mi></msub><mo>, </mo><mi>n</mi><msub><mrow></mrow><mi>a</mi></msub><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mtd></mtr><mtr><mtd><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></munderover><mi>c</mi></mstyle><mi>t</mi><mi>c</mi><msub><mrow></mrow><mi>m</mi></msub><mo stretchy="false"> (</mo><mi>n</mi><msub><mrow></mrow><mn>1</mn></msub><mo stretchy="false">) </mo><mo>+</mo><mi>w</mi><msub><mrow></mrow><mi>i</mi></msub><mo>&gt;</mo><mi>r</mi><mi>d</mi><mi>y</mi><mo stretchy="false"> (</mo><mi>n</mi><msub><mrow></mrow><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>, </mo><mi>n</mi><msub><mrow></mrow><mi>a</mi></msub><mo stretchy="false">) </mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="70">TDCS算法以及RECS算法的首次复制阶段采取和OSA算法同样的复制策略, 主要是将下标为2～<i>s</i>的任务依次复制到最佳前驱<i>n</i><sub>1</sub>所在簇<i>C</i><sub>1</sub>, 最后将当前任务<i>n</i><sub><i>a</i></sub>也放置到簇<i>C</i><sub>1</sub>上。这种通过复制关键前驱的策略, 可保证任务的最早开始时间最优<citation id="156" type="reference"><link href="23" rel="bibliography" /><sup>[<a class="sup">11</a>]</sup></citation>。但未考虑到在复制过程中将前驱复制到簇<i>C</i><sub>1</sub>上后, 可能前驱还需要与其前驱的前驱进行通信。若前驱与其前驱的前驱通信开销较大, 就有可能造成任务<i>n</i><sub><i>a</i></sub>的开始时间增大, 任务复制过程被终止, 从而失去了进一步优化任务<i>n</i><sub><i>a</i></sub>最早开始时间的机会。改进的TDRECS算法通过考虑复制任务<i>n</i><sub><i>a</i></sub>前驱的前驱, 以消除前驱与其前驱的前驱的通信开销, 最终在一定条件下可进一步减少任务图的调度长度。</p>
                </div>
                <div class="p1">
                    <p id="71">如图1所示, 设当前待复制的前驱任务为<i>n</i><sub><i>k</i></sub>, 假设任务<i>n</i><sub><i>a</i></sub>在簇中不需要等待其他簇内前驱执行完时的临时最早开始时间为<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) , 则有<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) =<i>ctc</i><sub>1</sub> (<i>n</i><sub><i>k</i>-1</sub>) , 即为任务<i>n</i><sub><i>a</i></sub>在当前簇上前一个任务的完成时间。</p>
                </div>
                <div class="area_img" id="72">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 na前驱任务的复制示意图" src="Detail/GetImg?filename=images/JSJC201905009_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 <i>n</i></b><sub><b><i>a</i></b></sub><b>前驱任务的复制示意图</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_072.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="73">任务<i>n</i><sub><i>a</i></sub>需要等待其他簇内前驱的临时最早开始时间为<i>est</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) , 则<i>est</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) 与<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) 的关系为:</p>
                </div>
                <div class="p1">
                    <p id="74"><i>est</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) =max (<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) , <i>rdy</i> (<i>n</i><sub><i>k</i></sub>, <i>n</i><sub><i>a</i></sub>) )      (5) </p>
                </div>
                <div class="p1">
                    <p id="75">若<i>est</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) =<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) , 说明任务<i>n</i><sub><i>a</i></sub>已无法再通过任务复制来优化任务的开始时间, 终止复制过程;否则考虑复制任务<i>n</i><sub><i>k</i></sub>, 设复制到簇<i>C</i><sub>1</sub>上的任务总执行时间为<i>W</i><sub>total</sub>, 此时<i>W</i><sub>total</sub>=<i>w</i> (<i>n</i><sub><i>k</i></sub>) , 并得到簇<i>C</i><sub>1</sub>上的临时空闲块大小为:</p>
                </div>
                <div class="p1">
                    <p id="76"><i>Inter</i>=<i>rdy</i> (<i>n</i><sub><i>k</i></sub>, <i>n</i><sub><i>a</i></sub>) -<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>)      (6) </p>
                </div>
                <div class="p1">
                    <p id="77">设簇<i>C</i><sub><i>k</i>+1</sub>上的任务<i>m</i><sub><i>j</i></sub>为任务<i>n</i><sub><i>k</i></sub>的前驱, 且<i>rdy</i> (<i>m</i><sub><i>j</i></sub>, <i>n</i><sub><i>k</i></sub>) 为<i>n</i><sub><i>k</i></sub>不在簇<i>C</i><sub>1</sub>上的前驱中最大的。更新此时的<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) , 有<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) =<i>rdy</i> (<i>m</i><sub><i>j</i></sub>, <i>n</i><sub><i>k</i></sub>) +<i>w</i> (<i>n</i><sub><i>k</i></sub>) , 则任务<i>n</i><sub><i>k</i></sub>可被复制到簇<i>C</i><sub>1</sub>上需同时满足以下2个条件:</p>
                </div>
                <div class="p1">
                    <p id="78"><i>W</i><sub>total</sub>&lt;<i>Inter</i>      (7) </p>
                </div>
                <div class="p1">
                    <p id="79"><i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) &lt;<i>est</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>)      (8) </p>
                </div>
                <div class="p1">
                    <p id="80">若式 (7) 不满足, 说明复制的任务总执行时间已超过临时空闲簇所能容纳的限度。任务<i>n</i><sub><i>a</i></sub>的开始时间已无法再通过任务复制进行优化, 结束整个复制过程, 并更新<i>n</i><sub><i>a</i></sub>的最早开始时间<i>est</i> (<i>n</i><sub><i>a</i></sub>) 。若式 (8) 不满足, 说明任务<i>n</i><sub><i>k</i></sub>由于与其前驱<i>m</i><sub><i>j</i></sub>通信造成<i>n</i><sub><i>a</i></sub>的开始时间增大。考虑复制<i>n</i><sub><i>a</i></sub>的前驱的前驱, 即<i>m</i><sub><i>j</i></sub>, 并更新条件式 (7) 和式 (8) 。若2个条件都满足, 则<i>k</i>++, 采取同样的复制策略, 考虑复制下一个任务, 直到<i>k</i>&gt;<i>s</i>, 或者式 (7) 不满足。</p>
                </div>
                <h4 class="anchor-tag" id="81" name="81">2.3 再次复制阶段</h4>
                <div class="p1">
                    <p id="82">经过第1阶段的复制, 任务<i>n</i><sub><i>a</i></sub>有了最早开始时间<i>est</i> (<i>n</i><sub><i>a</i></sub>) 。但簇中可能存在空闲时间段, 造成处理器空转消耗系统资源。此阶段通过考虑复制第1阶段的未复制前驱来减少处理器上的空闲时间段。TDCS算法以及RECS算法在此阶段同样未考虑复制的前驱与其前驱的前驱通信造成任务<i>n</i><sub><i>a</i></sub>的开始时间增大, 改进的TDRECS算法继续考虑复制任务前驱的前驱。</p>
                </div>
                <div class="p1">
                    <p id="83">如图2所示, 若首次复制阶段复制到了前驱任务<i>n</i><sub><i>s</i></sub>, 此时<i>rdy</i> (<i>n</i><sub><i>s</i></sub>, <i>n</i><sub><i>a</i></sub>) 大于<i>ctc</i><sub>1</sub> (<i>n</i><sub><i>s</i>-1</sub>) , 令式 (6) 中的<i>k</i>=<i>s</i>-1, 得到空闲时间段<i>Inter</i>。令<i>l</i>=<i>s</i>+1, 簇<i>C</i><sub><i>s</i>+1</sub>上任务<i>m</i><sub><i>i</i></sub>又为<i>n</i><sub><i>l</i></sub>的前驱, 且<i>rdy</i> (<i>m</i><sub><i>i</i></sub>, <i>n</i><sub><i>l</i></sub>) 为<i>n</i><sub><i>l</i></sub>不在簇<i>C</i><sub>1</sub>上的前驱中最大的, 则此阶段复制到空闲时间段的总执行时间为<i>W</i><sub>total</sub>=<i>w</i> (<i>n</i><sub><i>l</i></sub>) , 并更新此时的<i>SC</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) 以及<i>est</i><sub>tmp</sub> (<i>n</i><sub><i>a</i></sub>) 。任务<i>n</i><sub><i>l</i></sub>可被复制到空闲时间段同样需同时满足式 (7) 、式 (8) 。</p>
                </div>
                <div class="area_img" id="84">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_084.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 簇上空闲时间的减少示意图" src="Detail/GetImg?filename=images/JSJC201905009_084.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 簇上空闲时间的减少示意图</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_084.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="85">与首次复制阶段不同的是当式 (7) 不满足时, 由于此阶段只是为了减少空闲时间簇的大小, 当前前驱无法复制时, 可撤销当前前驱的复制, <i>l</i>++, 继续考虑复制下一个前驱。当式 (8) 不满足时与首次复制阶段一样继续考虑复制前驱的前驱。当2个条件都满足时, 则更新此时空闲簇的大小, 执行式 (9) , 继续考虑复制下一个任务。</p>
                </div>
                <div class="p1">
                    <p id="86"><i>Inter</i>=min (<i>Inter</i>, <i>est</i> (<i>n</i><sub><i>a</i></sub>) -<i>c</i> (<i>m</i><sub><i>i</i></sub>, <i>n</i><sub><i>l</i></sub>) ) -<i>w</i> (<i>n</i><sub><i>l</i></sub>)      (9) </p>
                </div>
                <h4 class="anchor-tag" id="87" name="87">2.4 优化处理器个数阶段</h4>
                <div class="p1">
                    <p id="88">此阶段主要采取减少冗余簇和合并簇相结合的方式进行, 以减少处理器的个数, 从而降低对资源的消耗, 前面2个阶段结束后, 可能会存在冗余簇, 即一个簇上的任务集合包含于另一个簇上的任务集合。如图3所示, 簇<i>C</i><sub>2</sub>上的任务包含于簇<i>C</i><sub><i>m</i></sub>上的任务集合。</p>
                </div>
                <div class="area_img" id="89">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_089.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 冗余簇实例" src="Detail/GetImg?filename=images/JSJC201905009_089.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 冗余簇实例</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_089.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="90">对于TDCS算法, 是直接将簇<i>C</i><sub>2</sub>进行删除, 这种做法未考虑到任务的最早开始时间可能会被推迟, 从而造成调度长度增大。对于RECS算法在删除冗余簇时只考虑不影响后继任务, 未考虑到不影响总调度长度的冗余簇都可删除。此阶段, 以图3为例, 说明TDRECS算法的改进措施, 步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="91"><b>步骤1</b> 记<i>n</i><sub><i>i</i></sub>=<i>n</i><sub>1</sub>, 找到使<i>n</i><sub><i>i</i></sub>具有最早开始时间的簇集合。若簇集合中不包含簇<i>C</i><sub>2</sub>, 或者包含簇<i>C</i><sub>2</sub>但簇集合中的簇个数不止一个, 则考虑簇<i>C</i><sub>2</sub>的下一个任务;否则, 转步骤2。</p>
                </div>
                <div class="p1">
                    <p id="92"><b>步骤2</b> 在除簇<i>C</i><sub>2</sub>的剩余簇中找到使任务<i>n</i><sub><i>i</i></sub>具有最早开始时间的簇<i>C</i><sub><i>x</i></sub>, 并更新<i>n</i><sub><i>i</i></sub>的最早开始时间。</p>
                </div>
                <div class="p1">
                    <p id="93"><b>步骤3</b> 更新任务<i>n</i><sub><i>i</i></sub>的所有后继以及后继的后继的开始时间, 如图3中任务<i>n</i><sub>1</sub>的后继<i>n</i><sub><i>i</i></sub>以及任务图调度长度。</p>
                </div>
                <div class="p1">
                    <p id="94"><b>步骤4</b> 若新的调度长度相比之前没有增加, 则考虑下一个任务, 转步骤1;否则, 取消对簇<i>C</i><sub>2</sub>的删除, 终止过程。</p>
                </div>
                <div class="p1">
                    <p id="95"><b>步骤5</b> 当遍历冗余簇上的任务, 并执行步骤1～步骤4后, 调度长度都不增加, 则删除冗余簇。</p>
                </div>
                <div class="p1">
                    <p id="96">除了消除冗余簇外, 还可以进行簇之间的合并以进一步减少处理器的个数。TDCS算法只考虑将有通信关联的2个簇合并, 改进的TDRECS算法放宽了合并条件, 对不影响调度长度的任意2个簇进行合并。记总执行时间最长所在的主簇为<i>C</i><sub>max</sub>, 对除主簇外的其他簇进行两两合并。合并时按照任务在各个簇上的完成时间从小到大安排, 对于有多份重复的任务, 保留开始时间较小的。更新其他簇上与当前合并的2个簇中的任务有通信关系的后继任务开始时间, 以及任务调度长度, 若新的调度长度不增加则可以合并, 否则取消合并。</p>
                </div>
                <h4 class="anchor-tag" id="97" name="97">2.5 冗余任务消除阶段</h4>
                <div class="p1">
                    <p id="98">第1阶段和第2阶段的任务复制过程为保证调度过程中节点的最早开始时间局部最优, 而带来大量的任务复制, 造成最终调度结果中有很多冗余任务。RECS算法只考虑将不影响后继任务开始时间的冗余任务删除, 具有一定的局限性。因此, 本文对其进行改进, 改进的冗余任务消除算法描述如下:</p>
                </div>
                <div class="p1">
                    <p id="99"><b>算法</b> Reduce_Redundant_Task (CL_set) </p>
                </div>
                <div class="area_img" id="158">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201905009_15800.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="158">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201905009_15801.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="119">找出有多份拷贝的任务列表<i>TL</i>={<i>n</i><sub>1</sub>, <i>n</i><sub>2</sub>, …, <i>n</i><sub><i>k</i></sub>}, 设<i>n</i><sub><i>i</i>, <i>p</i></sub>为处理器<i>p</i>上的任务。取任务列表中的任务<i>n</i><sub><i>i</i></sub>, 假设<i>n</i><sub><i>i</i></sub>在处理器<i>p</i><sub>least</sub>上具有最早开始时间。考虑删除其他处理器上的冗余任务<i>n</i><sub><i>i</i></sub>, 若在当前处理器上没有任务<i>n</i><sub><i>i</i></sub>的后继, 则直接删除<i>n</i><sub><i>i</i></sub>;否则, 更新这些后继的开始时间、有关联的后继的后继开始时间以及任务图的调度长度。若新的调度长度相比原调度长度不增加, 则删除当前处理器上的任务<i>n</i><sub><i>i</i></sub>。</p>
                </div>
                <h3 id="120" name="120" class="anchor-tag">3 实验结果与分析</h3>
                <div class="p1">
                    <p id="121">假定任务系统在运行前已经过划分并可以用DAG任务图表示, 处理器具有一个或多个I/O单元并且各个资源间的通信和任务计算可同时进行<citation id="157" type="reference"><link href="31" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>。基于以上假设, 通过对一个具体的任务图实例和TGFF随机生成任务图工具生成的任务图, 分别调用由C++语言编写的OSA算法、TDCS算法以及改进的TDRECS算法进行调度, 并根据3.1节提出的性能评估参数来评估各个算法的性能。</p>
                </div>
                <h4 class="anchor-tag" id="122" name="122">3.1 性能评估参数</h4>
                <div class="p1">
                    <p id="123">任务调度算法的性能可以用以下3种性能评估参数评价:</p>
                </div>
                <div class="p1">
                    <p id="124">1) 所用处理器个数<i>procnum</i>。将任务图中的所有任务调度完毕, 所用的处理器个数越少, 越能节省资源。</p>
                </div>
                <div class="p1">
                    <p id="125">2) 加速比<i>Speedup</i>。加速比是指一个资源上串行执行所有任务的最小时间与调度长度<i>makespan</i>的比值。<i>Speedup</i>用来衡量系统的加速程度和算法的并行程度, 加速比越高, 算法性能越好。</p>
                </div>
                <div class="p1">
                    <p id="126" class="code-formula">
                        <mathml id="126"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><mi>p</mi><mi>e</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>p</mi><mo>=</mo><mfrac><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mrow><mo>|</mo><mi>V</mi><mo>|</mo></mrow></mrow></munderover><mi>w</mi></mstyle><msub><mrow></mrow><mrow><mi>n</mi><msub><mrow></mrow><mi>i</mi></msub></mrow></msub></mrow><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi>s</mi><mi>p</mi><mi>a</mi><mi>n</mi></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>1</mn><mn>0</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="127">3) 调度前后总计算量比值<i>CalRate</i>。<i>CalRate</i>为调度后所有处理器上的任务计算量总和与调度前所有任务计算量总和的比值。因为4种算法都采用基于任务复制的思想, 调度后存在冗余任务, 这个指标可以用来评价调度算法的冗余计算量情况。<i>CalRate</i>越小, 冗余计算量也越小, 同时意味着完成同样的任务需要的处理器功耗越低, 而且对于其他任务也有更大的调度空间。</p>
                </div>
                <h4 class="anchor-tag" id="128" name="128">3.2 任务图实例分析</h4>
                <div class="p1">
                    <p id="129">对一个具体的任务图实例分别调用3种算法, 画出调度甘特图, 并比较3种算法的各个性能指标。任务图实例如图4所示。</p>
                </div>
                <div class="area_img" id="130">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 DAG任务图实例" src="Detail/GetImg?filename=images/JSJC201905009_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 DAG任务图实例</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_130.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="131">图4所示的任务图包含9个任务, 共有4层。其中, 每个圆圈代表一个任务, 圆圈旁边的数字代表任务执行所需时间, 图中的直线代表任务之间的通信依赖关系, 直线上的数字代表通信时间。用4种算法分别对其调度可得4种算法的任务调度分配甘特图如图5所示, 4种算法下各个性能评估参数的对比情况如表1所示。</p>
                </div>
                <div class="area_img" id="132">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 不同算法任务调度分配" src="Detail/GetImg?filename=images/JSJC201905009_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 不同算法任务调度分配</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_132.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="133">
                    <p class="img_tit"><b>表1 不同算法调度结果对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="133" border="1"><tr><td>算法</td><td>调度长度</td><td>处理器数</td><td><i>Speedup</i></td><td><i>CalRate</i></td></tr><tr><td>OSA</td><td>26</td><td>5</td><td>1.19</td><td>1.71</td></tr><tr><td><br />TDCS</td><td>26</td><td>4</td><td>1.19</td><td>1.52</td></tr><tr><td><br />RECS</td><td>26</td><td>4</td><td>1.19</td><td>1.52</td></tr><tr><td><br />TDRECS</td><td>23</td><td>2</td><td>1.35</td><td>1.16</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="134">从图5和表1可以看出, 由于TDCS算法以及RECS算法、OSA算法在优化调度长度的首次复制阶段相同, 因此调度长度一样。在OSA调度算法结果中, <i>P</i><sub>5</sub>和<i>P</i><sub>4</sub>是冗余簇, 由于<i>n</i><sub>3</sub>与<i>P</i><sub>3</sub>簇上的<i>n</i><sub>8</sub>通信, 若删除会造成<i>n</i><sub>8</sub>以及与<i>n</i><sub>8</sub>有通信关联的<i>n</i><sub>9</sub>开始时间增大, 从而导致调度长度增大, 故在TDCS算法以及RECS算法的消除冗余簇阶段只去除了冗余簇<i>P</i><sub>5</sub>。簇<i>P</i><sub>4</sub>和<i>P</i><sub>3</sub>有通信关系, 但合并后会造成<i>n</i><sub>8</sub>的完成时间由12变为13, 导致终止节点<i>n</i><sub>9</sub>的开始时间增大, 故在TDCS算法合并簇阶段没有合并簇。改进的TDRECS算法在OSA算法第一次复制阶段的基础上, 通过复制任务<i>n</i><sub>9</sub>的前驱任务<i>n</i><sub>8</sub>以及前驱的前驱任务<i>n</i><sub>4</sub>, 将调度长度由26缩短到了23, 相应地, 加速比相对比OSA算法和TDCS算法由1.19提升到了1.35。</p>
                </div>
                <div class="p1">
                    <p id="135">同时在TDCS算法基础上, 除了考虑合并有通信关系的簇, 还考虑合并其他没有通信关系的簇, 将处理器个数由4个减少到了2个。通过冗余任务消除算法减少冗余任务个数, 冗余计算比率由OSA算法的1.71和TDCS算法以及RECS算法的1.52下降到了1.16。通过以上对比分析, 可以看出TDRECS算法具有更好的调度性能。</p>
                </div>
                <h4 class="anchor-tag" id="136" name="136">3.3 随机任务图集测试</h4>
                <div class="p1">
                    <p id="137">通过TGFF随机生成任务图工具生成不同规格的任务图, 调用4种算法对比它们的各项性能参数。DAG的参数设置为:任务个数<i>n</i>={20, 30, 40, 50, 60, 70, 80, 90}, 节点的最大入度和出度分别设置为20、15, 任务执行时间和任务间的通信时间设置为10～40。将任务集分为8组, 每组随机生成5个任务图, 对4种算法的调度结果取平均值。图6为不同任务规模下4种算法所用处理器个数情况。TDCS算法在经典的OSA算法的基础上通过合并有通信关系的簇来减少处理器个数, 因此, 相对于OSA算法处理器个数大幅减少。RECS算法只考虑将不影响后继任务开始时间的冗余簇删除, 具有一定的局限性。而改进的TDRECS算法在此基础上通过继续合并其他没有通信关系的簇, 以及在不增加调度长度的前提下删除冗余簇, 将处理器个数进一步减少, 并且随着任务规模的提升, 相对于其他2种算法, 处理器个数增长率也相对较小。</p>
                </div>
                <div class="area_img" id="138">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_138.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 不同任务规模下处理器个数比较" src="Detail/GetImg?filename=images/JSJC201905009_138.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图6 不同任务规模下处理器个数比较</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_138.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="139">图7为不同任务规模下4种算法的加速比情况, TDCS算法、RECS算法和OSA算法在调度长度优化阶段是一样的, 因此加速比基本一致。改进的TDRECS算法是在当出现任务的前驱, 需要的与前驱的前驱通信导致任务开始时间增大而无法继续复制前驱时, 才通过继续复制前驱的前驱以进一步减少调度长度, 从而提升加速比。但对于随机生成的任务图, 这种情况出现较少, 因此从实验效果上看加速比略有提升。</p>
                </div>
                <div class="area_img" id="140">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_140.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 不同任务规模下加速比比较" src="Detail/GetImg?filename=images/JSJC201905009_140.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图7 不同任务规模下加速比比较</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_140.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="141">图8为不同任务规模下4种算法的冗余计算比率情况, RECS算法虽考虑了删除冗余任务, 但只考虑了不影响后继的冗余任务, 改进的TDRECS算法在通过在不增加调度长度的前提下继续减少各个处理器上的冗余任务, 因此, 冗余计算比率有较大程度的降低。</p>
                </div>
                <div class="area_img" id="142">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201905009_142.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 不同任务规模下冗余计算比率比较" src="Detail/GetImg?filename=images/JSJC201905009_142.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图8 不同任务规模下冗余计算比率比较</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201905009_142.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="143" name="143" class="anchor-tag">4 结束语</h3>
                <div class="p1">
                    <p id="144">本文提出一种改进的分布式多核任务调度算法。该算法通过不断递归复制任务前驱的前驱来减少调度长度和处理器中空闲块大小, 通过消除冗余簇和合并簇进一步减少处理器个数, 并在不增加调度长度的前提下减少冗余任务比率。实验结果表明, 改进TDRECS算法与OSA算法、TDCS算法以及RECS算法相比, 具有较高的计算性能。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSYJ201208035&amp;v=MjA0NDNVUkxPZVplUm9GeTNsVnJ2Tkx6N1NaTEc0SDlQTXA0OUdZWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckM=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 徐成, 赵林祥, 杨志邦.一种基于多处理器任务复制的分簇调度算法[J].计算机应用研究, 2012, 29 (8) :2931-2934.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=High performance cluster computing:architectures and systems">

                                <b>[2]</b> BUYYA R.High performance cluster computing:architectures and systems[M].[S.1.]:Prentice-Hall, 2002.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX200109014&amp;v=MjQ4MjdlWmVSb0Z5M2xWcnZOTHo3QmRyRzRIdERNcG85RVlJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE8=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> 石威, 郑纬民.相关任务图的均衡动态关键路径调度算法[J].计算机学报, 2001, 24 (9) :991-997.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Scheduling precedence graphs in systems with interprocessor communication times">

                                <b>[4]</b> HWANG J J, CHOW Y C, ANGER F D, et al.Scheduling precedence graphs in systems with interprocessor communication times[J].SIAM Journal on Computing, 1989, 18 (2) :244-257.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Hypertool: A programming aid for message-passing systems">

                                <b>[5]</b> WU Minyou, GAJSKI D D.Hypertool:a programming aid for message-passing systems[J].IEEE Transactions on Parallel and Distributed Systems, 1990, 1 (3) :330-343.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient scheduling of DAG tasks on multi-core processor based parallel systems">

                                <b>[6]</b> LIU Yuan, JIA Pingui, YANG Yiping.Efficient scheduling of DAG tasks on multi-core processor based parallel systems[C]//Proceedings of TENCON’16.Washington D.C., USA:IEEE Press, 2016:1-6.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Optimal scheduling algorithm for distributed-memory machines">

                                <b>[7]</b> DARBHA S, AGRAWAL D P.Optimal scheduling algorithm for distributed-memory machines[J].IEEE Transactions on Parallel and Distributed Systems, 1998, 9 (1) :87-95.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=An optimal scheduling algorithm based on task duplication">

                                <b>[8]</b> PARK C I, CHOE T Y.An optimal scheduling algorithm based on task duplication[C]//Proceedings of the 8th International Conference on Parallel and Distributed Systems.Washington D.C., USA:IEEE Press, 2001:9-14.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJX200402009&amp;v=MTgxOTdZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5M2xWcnZOTHo3QmRyRzRIdFhNclk5RmI=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[9]</b> 周双娥, 袁由光, 熊兵周, 等.基于任务复制的处理器预分配算法[J].计算机学报, 2004, 27 (2) :216-223.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSGG201512007&amp;v=MTYzOTFOclk5Rlk0UUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5M2xWcnZOTHo3TWFiRzRIOVQ=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b> 叶佳, 周鸣争.一种改进的基于任务复制的多核调度算法[J].计算机工程与应用, 2015, 51 (12) :31-37.
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A cluster-based strategy for scheduling task on heterogeneous processors">

                                <b>[11]</b> BOERES C, FILHO J V, REBELLO V E F.A cluster-based strategy for scheduling task on heterogeneous processors[C]//Proceedings of Symposium on Computer Architecture and High Performance Computing.Washington D.C., USA:IEEE Press, 2004:214-226.
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Task clustering and scheduling for distributed memory parallel architectures">

                                <b>[12]</b> PALIS M A, LIOU J C, WEI D S L.Task clustering and scheduling for distributed memory parallel architectures[J].IEEE Transactions on Parallel and Distributed Systems, 1996, 7 (1) :46-55.
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=2009160095.nh&amp;v=MTEzNTdJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5M2xWcnZOVjEyN0Y3SytIdEhGcXBFYlA=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[13]</b> 兰舟.分布式系统中的调度算法研究[D].成都:电子科技大学, 2009.
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Computers and intractability: a guide to the theory of NP-completeness">

                                <b>[14]</b> GAREY M R, JOHNSON D S.Computers and intractability:a guide to the theory of NP-completeness[M].[S.1.]:W.H.Freeman, 1979.
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A high-performance DAG task scheduling algorithm for heterogeneous networked embedded systems">

                                <b>[15]</b> XIE Guoqi, LI Renfa, XIAO Xiongren, et al.A high-performance DAG task scheduling algorithm for heterogeneous networked embedded systems[C]//Proceedings of the 28th International Conference on Advanced Information Networking and Applications.Washington D.C., USA:IEEE Press, 2014:1011-1016.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJC201905009" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201905009&amp;v=MDk2OTh0R0ZyQ1VSTE9lWmVSb0Z5M2xWcnZLTHo3QmJiRzRIOWpNcW85RmJZUUtESDg0dlI0VDZqNTRPM3pxcUI=&amp;uid=WEEvREcwSlJHSldRa1FhcEE0QVN2K0VNZjJWbHVQbXRmcGxDWVVPcjBMVT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
