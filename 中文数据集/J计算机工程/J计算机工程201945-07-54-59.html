<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637129918179520000%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201907009%26RESULT%3d1%26SIGN%3dD5tRWfspfuADOGr8%252bZ2IYuqHW9Y%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201907009&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201907009&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201907009&amp;v=MTE2Njg2ajU0TzN6cXFCdEdGckNVUkxPZVplUnBGQ2puVTdyUEx6N0JiYkc0SDlqTXFJOUZiWVFLREg4NHZSNFQ=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#45" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#49" data-title="1 基于虚拟冲突阵列的路由单元 ">1 基于虚拟冲突阵列的路由单元</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#50" data-title="1.1 传统虚拟通道路由单元传递途径">1.1 传统虚拟通道路由单元传递途径</a></li>
                                                <li><a href="#58" data-title="1.2 冲突阵列结构">1.2 冲突阵列结构</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#62" data-title="2 NoC路由单元设计 ">2 NoC路由单元设计</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#63" data-title="2.1 虚拟通道路由单元的虚拟冲突阵列">2.1 虚拟通道路由单元的虚拟冲突阵列</a></li>
                                                <li><a href="#76" data-title="2.2 消除率">2.2 消除率</a></li>
                                                <li><a href="#84" data-title="2.3 路由单元延迟">2.3 路由单元延迟</a></li>
                                                <li><a href="#97" data-title="2.4 硬件开销分析">2.4 硬件开销分析</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#102" data-title="3 实验结果与分析 ">3 实验结果与分析</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#113" data-title="4 结束语 ">4 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#52" data-title="&lt;b&gt;图1 4&#215;4环面拓扑NoC&lt;/b&gt;"><b>图1 4×4环面拓扑NoC</b></a></li>
                                                <li><a href="#54" data-title="&lt;b&gt;图2 传统基于虚拟通道的路由单元架构&lt;/b&gt;"><b>图2 传统基于虚拟通道的路由单元架构</b></a></li>
                                                <li><a href="#60" data-title="&lt;b&gt;图3 公共堆栈的冲突阵列结构&lt;/b&gt;"><b>图3 公共堆栈的冲突阵列结构</b></a></li>
                                                <li><a href="#68" data-title="&lt;b&gt;图4 虚拟冲突阵列中的请求消除流程&lt;/b&gt;"><b>图4 虚拟冲突阵列中的请求消除流程</b></a></li>
                                                <li><a href="#74" data-title="&lt;b&gt;图5 基于虚拟冲突阵列的路由单元体系结构&lt;/b&gt;"><b>图5 基于虚拟冲突阵列的路由单元体系结构</b></a></li>
                                                <li><a href="#105" data-title="&lt;b&gt;图6 消除率与&lt;i&gt;th&lt;/i&gt;/&lt;i&gt;tb&lt;/i&gt;值、&lt;i&gt;L&lt;/i&gt;值的关系&lt;/b&gt;"><b>图6 消除率与<i>th</i>/<i>tb</i>值、<i>L</i>值的关系</b></a></li>
                                                <li><a href="#107" data-title="&lt;b&gt;图7 虚拟冲突阵列延迟与&lt;i&gt;th&lt;/i&gt;/&lt;i&gt;tb&lt;/i&gt;值、&lt;i&gt;L&lt;/i&gt;值的关系&lt;/b&gt;"><b>图7 虚拟冲突阵列延迟与<i>th</i>/<i>tb</i>值、<i>L</i>值的关系</b></a></li>
                                                <li><a href="#109" data-title="&lt;b&gt;图8 2种延迟与&lt;i&gt;th&lt;/i&gt;/&lt;i&gt;tb&lt;/i&gt;值的关系&lt;/b&gt;"><b>图8 2种延迟与<i>th</i>/<i>tb</i>值的关系</b></a></li>
                                                <li><a href="#111" data-title="&lt;b&gt;图9 2种路由单元的路由延迟比较结果&lt;/b&gt;"><b>图9 2种路由单元的路由延迟比较结果</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="128">


                                    <a id="bibliography_1" title=" CHANG Y C, CHIU C T, LIN S Y, et al.On the design and analysis of fault tolerant NoC architecture using spare routers[C]//Proceedings of the 16th Asia and South Pacific Design Automation Conference.Washington D.C., USA:IEEE Press, 2011:431-436." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On the design and analysis of fault tolerant No C architecture using spare routers">
                                        <b>[1]</b>
                                         CHANG Y C, CHIU C T, LIN S Y, et al.On the design and analysis of fault tolerant NoC architecture using spare routers[C]//Proceedings of the 16th Asia and South Pacific Design Automation Conference.Washington D.C., USA:IEEE Press, 2011:431-436.
                                    </a>
                                </li>
                                <li id="130">


                                    <a id="bibliography_2" title=" CHOUDHARY N.Network-on-chip:a new SoC commu-nication infrastructure paradigm[J].International Journal of Soft Computing and Engineering, 2012, 1 (6) :70-78." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Network-on-chip:a new SoC commu-nication infrastructure paradigm">
                                        <b>[2]</b>
                                         CHOUDHARY N.Network-on-chip:a new SoC commu-nication infrastructure paradigm[J].International Journal of Soft Computing and Engineering, 2012, 1 (6) :70-78.
                                    </a>
                                </li>
                                <li id="132">


                                    <a id="bibliography_3" title=" 李璐璐, 裘雪红, 周端, 等.片上网络容错技术研究[J].计算机科学, 2018, 45 (3) :305-310." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201803050&amp;v=MDkzODVSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnBGQ2puVTdyUEx6N0JiN0c0SDluTXJJOUFaSVFLREg4NHY=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         李璐璐, 裘雪红, 周端, 等.片上网络容错技术研究[J].计算机科学, 2018, 45 (3) :305-310.
                                    </a>
                                </li>
                                <li id="134">


                                    <a id="bibliography_4" title=" KARPAGA S A, MURALIDHARAN D.High throughput pipelining NoC using clumsy flow control[EB/OL].[2018-07-02].http://www.indjst.org/index.php/indjst/article/view/91236/72140." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=High throughput pipelining NoC using clumsy flow control">
                                        <b>[4]</b>
                                         KARPAGA S A, MURALIDHARAN D.High throughput pipelining NoC using clumsy flow control[EB/OL].[2018-07-02].http://www.indjst.org/index.php/indjst/article/view/91236/72140.
                                    </a>
                                </li>
                                <li id="136">


                                    <a id="bibliography_5" title=" 刘炎华, 石世领, 孙海燕, 等.基于拥塞和热点感知的低延时片上网络路由器设计[J].微电子学与计算机, 2018, 35 (6) :128-133." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201806026&amp;v=MjM4NTE0TzN6cXFCdEdGckNVUkxPZVplUnBGQ2puVTdyUE1qWFNaTEc0SDluTXFZOUhZb1FLREg4NHZSNFQ2ajU=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         刘炎华, 石世领, 孙海燕, 等.基于拥塞和热点感知的低延时片上网络路由器设计[J].微电子学与计算机, 2018, 35 (6) :128-133.
                                    </a>
                                </li>
                                <li id="138">


                                    <a id="bibliography_6" title=" KUMAR R, ZYUBAN V, TULLSEN D M.Interconnections in multi-core architectures:understanding mechanisms, overheads and scaling[C]//Proceedings of International Symposium on Computer Architecture.Washington D.C., USA:IEEE Press, 2015:408-419." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Interconnections in multi-core architectures:understanding mechanisms,overheads and scaling">
                                        <b>[6]</b>
                                         KUMAR R, ZYUBAN V, TULLSEN D M.Interconnections in multi-core architectures:understanding mechanisms, overheads and scaling[C]//Proceedings of International Symposium on Computer Architecture.Washington D.C., USA:IEEE Press, 2015:408-419.
                                    </a>
                                </li>
                                <li id="140">


                                    <a id="bibliography_7" title=" PALESI M, DANESHTALAB M.Routing algorithms in networks-on-chip[M].Berlin, Germany:Springer, 2013." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Routing algorithms in networks-on-chip">
                                        <b>[7]</b>
                                         PALESI M, DANESHTALAB M.Routing algorithms in networks-on-chip[M].Berlin, Germany:Springer, 2013.
                                    </a>
                                </li>
                                <li id="142">


                                    <a id="bibliography_8" title=" 杭彦希.基于2D-Mesh互连的片上网络容错技术研究与设计[D].郑州:解放军信息工程大学, 2017." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CMFD&amp;filename=1018702458.nh&amp;v=MTMxMzc3clBWRjI2RnJTNEhOWEpwNUViUElRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJwRkNqblU=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[8]</b>
                                         杭彦希.基于2D-Mesh互连的片上网络容错技术研究与设计[D].郑州:解放军信息工程大学, 2017.
                                    </a>
                                </li>
                                <li id="144">


                                    <a id="bibliography_9" title=" BALFOUR J, DALLY W J.Design tradeoffs for tiled CMP on-chip networks[C]//Proceedings of ACM International Conference on Supercomputing, Anniversary Volume.New York, USA:ACM Press, 2014:390-401." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Design tradeoffs for tiled CMP on-chip networks">
                                        <b>[9]</b>
                                         BALFOUR J, DALLY W J.Design tradeoffs for tiled CMP on-chip networks[C]//Proceedings of ACM International Conference on Supercomputing, Anniversary Volume.New York, USA:ACM Press, 2014:390-401.
                                    </a>
                                </li>
                                <li id="146">


                                    <a id="bibliography_10" title=" AMDAHL G M.Validity of the single processor approach to achieving large scale computing capabilities[J].IEEE Solid-State Circuits Society News Letter, 2007, 12 (3) :19-20." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Validity of the Single Processor Approach to Achieving Large Scale Computing Capabilities">
                                        <b>[10]</b>
                                         AMDAHL G M.Validity of the single processor approach to achieving large scale computing capabilities[J].IEEE Solid-State Circuits Society News Letter, 2007, 12 (3) :19-20.
                                    </a>
                                </li>
                                <li id="148">


                                    <a id="bibliography_11" title=" KHAN A U, ISSHIKI T, LI D.A unified performance estimation method for hardware and software components in multiprocessor system-on-chips[J].IPSJ Transactions on System LSI Design Methodology, 2010, 3:194-206." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A unified performance estimation method for hardware and software components in multiprocessor system-on-chips">
                                        <b>[11]</b>
                                         KHAN A U, ISSHIKI T, LI D.A unified performance estimation method for hardware and software components in multiprocessor system-on-chips[J].IPSJ Transactions on System LSI Design Methodology, 2010, 3:194-206.
                                    </a>
                                </li>
                                <li id="150">


                                    <a id="bibliography_12" title=" KECKLER S W, OLUKOTUN K, HOFSTEE H P.Multicore processors and systems[M].Berlin, Germany:Springer, 2009." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Multicore processors and systems">
                                        <b>[12]</b>
                                         KECKLER S W, OLUKOTUN K, HOFSTEE H P.Multicore processors and systems[M].Berlin, Germany:Springer, 2009.
                                    </a>
                                </li>
                                <li id="152">


                                    <a id="bibliography_13" title=" JIM&#201;NEZ J, RUIZ D M J.Three-dimensional thinning algorithms on graphics processing units and multicore CPUs[J].Concurrency and Computation Practice and Experience, 2012, 24 (14) :1551-1571." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Three-dimensional thinning algorithms on graphics processing units and multicore CPUs">
                                        <b>[13]</b>
                                         JIM&#201;NEZ J, RUIZ D M J.Three-dimensional thinning algorithms on graphics processing units and multicore CPUs[J].Concurrency and Computation Practice and Experience, 2012, 24 (14) :1551-1571.
                                    </a>
                                </li>
                                <li id="154">


                                    <a id="bibliography_14" title=" LIDOW A.GaN transistors—giving new life to Moore’s law[C]//Proceedings of IEEE International Symposium on Power Semiconductor Devices and IC’s.Washington D.C., USA:IEEE Press, 2015:1-6." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=GaN transistors—giving new life to Moore&amp;#39;&amp;#39;s law">
                                        <b>[14]</b>
                                         LIDOW A.GaN transistors—giving new life to Moore’s law[C]//Proceedings of IEEE International Symposium on Power Semiconductor Devices and IC’s.Washington D.C., USA:IEEE Press, 2015:1-6.
                                    </a>
                                </li>
                                <li id="156">


                                    <a id="bibliography_15" title=" GIUSTO P, LAKSHMANAN K, RAJKUMAR R.Method and apparatus for improving processing performance of a multi-core processor:US9063796[P].2015-06-23." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Method and apparatus for improving processing performance of a multi-core processor">
                                        <b>[15]</b>
                                         GIUSTO P, LAKSHMANAN K, RAJKUMAR R.Method and apparatus for improving processing performance of a multi-core processor:US9063796[P].2015-06-23.
                                    </a>
                                </li>
                                <li id="158">


                                    <a id="bibliography_16" title=" 杨鹏飞, 王泉.片上网络异构多核系统任务调度与映射[J].西安交通大学学报, 2015, 49 (6) :72-76." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XAJT201506012&amp;v=MjYzODFyQ1VSTE9lWmVScEZDam5VN3JQUFN6QmVyRzRIOVRNcVk5RVpvUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0Y=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                         杨鹏飞, 王泉.片上网络异构多核系统任务调度与映射[J].西安交通大学学报, 2015, 49 (6) :72-76.
                                    </a>
                                </li>
                                <li id="160">


                                    <a id="bibliography_17" title=" MCKENNEY P E.Is parallel programming hard, and, if so, what can you do about it?[EB/OL].[2018-07-03].https://arxiv.org/pdf/1701.00854.pdf." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Is parallel programming hard,and,if so,what can you do about it?">
                                        <b>[17]</b>
                                         MCKENNEY P E.Is parallel programming hard, and, if so, what can you do about it?[EB/OL].[2018-07-03].https://arxiv.org/pdf/1701.00854.pdf.
                                    </a>
                                </li>
                                <li id="162">


                                    <a id="bibliography_18" title=" FULLER S H, MILLETT L I.The future of computing performance:game over or next level?[M].[S.l.]:National Academy Press, 2011." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=The future of computing performance:game over or next level?">
                                        <b>[18]</b>
                                         FULLER S H, MILLETT L I.The future of computing performance:game over or next level?[M].[S.l.]:National Academy Press, 2011.
                                    </a>
                                </li>
                                <li id="164">


                                    <a id="bibliography_19" title=" TURON A J, THAMSBORG J, AHMED A, et al.Logical relations for fine-grained concurrency[C]//Proceedings of ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages.New York, USA:ACM Press, 2013:343-356." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Logical relations for fine-grained concurrency">
                                        <b>[19]</b>
                                         TURON A J, THAMSBORG J, AHMED A, et al.Logical relations for fine-grained concurrency[C]//Proceedings of ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages.New York, USA:ACM Press, 2013:343-356.
                                    </a>
                                </li>
                                <li id="166">


                                    <a id="bibliography_20" title=" SHAVIT N.Data structures in the multicore age[M].New York, USA:ACM Press, 2011." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000001295&amp;v=MTg4NzlRVE1ud1plWnVIeWptVUxqTElGd1VieFU9TmlmSVk3SzdIdGpOcjQ5RlpPc09EblU4b0JNVDZUNFBRSC9pclJkR2VycQ==&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[20]</b>
                                         SHAVIT N.Data structures in the multicore age[M].New York, USA:ACM Press, 2011.
                                    </a>
                                </li>
                                <li id="168">


                                    <a id="bibliography_21" title=" KODI A K, SARATHY A, LOURI A.Adaptive channel buffers in on-chip interconnection networks—a power and performance analysis[J].IEEE Transactions on Computers, 2008, 57 (9) :1169-1181." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Adaptive channel buffers in on-chip interconnection networks - A power and performance analysis">
                                        <b>[21]</b>
                                         KODI A K, SARATHY A, LOURI A.Adaptive channel buffers in on-chip interconnection networks—a power and performance analysis[J].IEEE Transactions on Computers, 2008, 57 (9) :1169-1181.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(07),54-59 DOI:10.19678/j.issn.1000-3428.0052204            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于虚拟冲突阵列的片上网络路由单元设计</b></span>
                                    </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9D%A8%E5%A4%A9%E6%B5%A9&amp;code=42228679&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">杨天浩</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%AD%99%E6%99%8B&amp;code=08739947&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">孙晋</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E5%8D%97%E4%BA%AC%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2&amp;code=0077991&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">南京理工大学计算机科学与工程学院</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>片上网络 (NoC) 路由单元共享输入缓存区, 只允许顺序访问数据, 使片上通信的速度和效率受到限制。为提高NoC的并行性, 提出一种基于虚拟冲突阵列的路由单元体系结构。在数据进入路由单元流水线之前, 在虚拟冲突阵列中对串行的数据请求进行部分消除, 以降低路由单元流水线的传输数据量, 提高系统的并行性。实验结果表明, 与传统虚拟通道路由单元相比, 引入虚拟冲突阵列的路由单元能够有效缩短路由延迟。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%89%87%E4%B8%8A%E7%BD%91%E7%BB%9C&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">片上网络;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B7%AF%E7%94%B1%E5%8D%95%E5%85%83%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">路由单元体系结构;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%99%9A%E6%8B%9F%E5%86%B2%E7%AA%81%E9%98%B5%E5%88%97&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">虚拟冲突阵列;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E8%B7%AF%E7%94%B1%E5%BB%B6%E8%BF%9F&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">路由延迟;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%B6%88%E9%99%A4%E7%8E%87&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">消除率;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    杨天浩 (1994—) , 男, 硕士研究生, 主研方向为片上网络微体系结构, E-mail:nlgyth@163.com;
                                </span>
                                <span>
                                    孙晋, 副教授。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-07-25</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家自然科学基金 (61502234);</span>
                                <span>江苏省自然科学基金 (BK20150785);</span>
                    </p>
            </div>
                    <h1><b>Design of Network on Chip Routing Units Based on Virtual Conflict Array</b></h1>
                    <h2>
                    <span>YANG Tianhao</span>
                    <span>SUN Jin</span>
            </h2>
                    <h2>
                    <span>School of Computer Science and Engineering, Nanjing University of Science and Technology</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Network on Chip (NoC) routing units share the input buffers and only allow sequential access to data, which limits the speed and efficiency of communication on chip.To improve the parallelism of NoC, a routing units architecture based on virtual conflict array is proposed.Before data enters the pipeline of routing units, serial data requests are partially eliminated in the virtual conflict array to reduce the amount of data transmitted by pipeline of routing units and improve the parallelism of the system.Experimental results show that compared with the traditional virtual channel routing units, the routing units with virtual conflict array can effectively shorten the routing delay.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Network%20on%20Chip%20(NoC)%20&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Network on Chip (NoC) ;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=routing%20unit%20architecture&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">routing unit architecture;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=virtual%20conflict%20array&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">virtual conflict array;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=routing%20delay&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">routing delay;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=elimination%20rate&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">elimination rate;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-07-25</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="45" name="45" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="46">随着纳米技术的快速发展, 在单芯片上增加晶体管密度的多核架构得到广泛应用。然而, 日益增长的全局互联线延迟<citation id="170" type="reference"><link href="128" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>限制了多核架构潜在的性能改进, 导致片上网络 (Network on Chip, NoC) 向模块化<citation id="171" type="reference"><link href="130" rel="bibliography" /><link href="132" rel="bibliography" /><link href="134" rel="bibliography" /><sup>[<a class="sup">2</a>,<a class="sup">3</a>,<a class="sup">4</a>]</sup></citation>和可扩展<citation id="172" type="reference"><link href="136" rel="bibliography" /><link href="138" rel="bibliography" /><sup>[<a class="sup">5</a>,<a class="sup">6</a>]</sup></citation>的分组交换方向发展<citation id="173" type="reference"><link href="140" rel="bibliography" /><link href="142" rel="bibliography" /><link href="144" rel="bibliography" /><sup>[<a class="sup">7</a>,<a class="sup">8</a>,<a class="sup">9</a>]</sup></citation>。在单芯片上增加内核数量较难实现, 即使使用多个内核, 片上系统 (System on Chip, SoC) 架构通常也无法提供与内核数量相等的加速倍数。Amdahl定律表明, 并行计算所实现的加速效果取决于需要计算的串行运算量<citation id="174" type="reference"><link href="146" rel="bibliography" /><link href="148" rel="bibliography" /><sup>[<a class="sup">10</a>,<a class="sup">11</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="47">多数多核系统的运算速度受到片上网络I/O数量的影响。在单芯片上集成数十个甚至数百个内核, 需要复杂的NoC来提供高效可靠的片上通信。但是, NoC路由单元不是并发结构, 传统路由单元共享输入缓冲器, 如虚拟通道和交叉开关, 只允许连续的串行访问<citation id="175" type="reference"><link href="150" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>。这种设计导致片上通信的速度与效率较低。NoC路由单元将队列中的传输数据写入路由单元输入缓冲区, 或从路由单元输出缓冲区读出。每个数据块的每次写或读操作都会以串行方式更新路由单元缓冲区, 而同一个数据包中的其他数据则处于等待状态<citation id="178" type="reference"><link href="152" rel="bibliography" /><link href="154" rel="bibliography" /><link href="156" rel="bibliography" /><sup>[<a class="sup">13</a>,<a class="sup">14</a>,<a class="sup">15</a>]</sup></citation>。交叉开关中也存在相同的串行操作。交换分配器协调输入通道和输出通道的使用, 每次只有一个输入通道可以将数据传输到一个输出通道, 来自其他输入通道的数据包必须等待并尝试在未来的周期中竞争交换机和输出通道<citation id="176" type="reference"><link href="158" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>。核心之间的大量通信使系统吞吐量大辐下降。有研究表明, 性能良好的并行策略能够更有效地利用多核系统<citation id="179" type="reference"><link href="160" rel="bibliography" /><link href="162" rel="bibliography" /><sup>[<a class="sup">17</a>,<a class="sup">18</a>]</sup></citation>。传统的路由单元遵循“推模式”规律<citation id="177" type="reference"><link href="134" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>, 其中, 数据包从路由单元输入通道进入输出通道而不调查数据内容。因此, 路由速度受到限制。</p>
                </div>
                <div class="p1">
                    <p id="48">本文提出一种基于虚拟冲突阵列<citation id="180" type="reference"><link href="164" rel="bibliography" /><link href="166" rel="bibliography" /><sup>[<a class="sup">19</a>,<a class="sup">20</a>]</sup></citation>的NoC路由单元架构。在路由单元缓冲区的输入处集成虚拟冲突阵列结构, 以消除对路由单元流水线的连续数据访问。数据请求不对路由单元输入缓冲区进行直接访问, 而在虚拟冲突阵列中被接收, 并与其相反请求实现中和。</p>
                </div>
                <h3 id="49" name="49" class="anchor-tag">1 基于虚拟冲突阵列的路由单元</h3>
                <h4 class="anchor-tag" id="50" name="50">1.1 传统虚拟通道路由单元传递途径</h4>
                <div class="p1">
                    <p id="51">NoC通过多核系统在每个核心间传输数据。图1所示为一个4×4环面拓扑的多核平台, 每个路由单元通过短暂的本地互连连接到核心和4个邻居路由单元。因此, 对于环形拓扑NoC, 每个路由单元具有5个输入/输出通道, 用于向东、南、西、北方向节点以及中心节点传输数据。</p>
                </div>
                <div class="area_img" id="52">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 4&#215;4环面拓扑NoC" src="Detail/GetImg?filename=images/JSJC201907009_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 4×4环面拓扑NoC</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_052.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="53">不同类型的路由单元有其独特的数据流控制机制。例如, 虚拟通道路由单元实现了高效的物理链路利用率和高吞吐量。如图2所示, 每个输入端口的输入缓冲区由多个虚拟通道组成, 这些虚拟通道共享一个输入通道的相同物理链路。当一个虚拟通道的数据包由于某些未知原因而被阻塞时, 其余数据包可以通过其他虚拟通道的物理链路进行传输。</p>
                </div>
                <div class="area_img" id="54">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 传统基于虚拟通道的路由单元架构" src="Detail/GetImg?filename=images/JSJC201907009_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 传统基于虚拟通道的路由单元架构</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_054.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="55">虚拟通道路由单元遵循“推模式”规律<citation id="181" type="reference"><link href="132" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>, 其中, 数据包通过一跳或多跳从源端推送到目的端。在每一跳, 只要数据包的报头在路由单元输入通道可用, 如果虚拟通道有空间存储输入数据包, 则确认信号设置为“高”。在接收到该确认信号后, 输入缓冲器将接收写入请求以启动写入操作。当所有虚拟通道被占用并且没有更多空间来存储新的数据包时, 确认信号被设置为“低”, 写入操作停止。路由单元计算模块使用确定性逻辑来分析数据包的报头, 计算数据包的目的地并选择输出通道。如果输出通道可用, 并且授权信号被虚拟通道分配器和交换分配器设置为“高”, 则输入缓冲器将接收读请求并启动读操作, 直到授权信号被设置为“低”或虚拟通道变空。典型的路由单元流水线包含缓冲区写入和路由计算阶段、虚拟通道分配和交换分配阶段, 以及交换遍历阶段, 每个数据传递阶段都连续。假设<i>T</i><sub><i>p</i></sub>是数据包经过路由单元流水线的持续时间 (数据包的延迟时间) , 路由单元平均延迟<i>T</i><sub><i>r</i></sub>可以表示为:</p>
                </div>
                <div class="p1">
                    <p id="56"><i>T</i><sub><i>r</i></sub>=<i>H</i>·<i>N</i>·<i>T</i><sub><i>p</i></sub>      (1) </p>
                </div>
                <div class="p1">
                    <p id="57">其中, <i>H</i>是跳数, <i>N</i>是数据包的总数。</p>
                </div>
                <h4 class="anchor-tag" id="58" name="58">1.2 冲突阵列结构</h4>
                <div class="p1">
                    <p id="59">图3所示为一个公共堆栈的冲突阵列结构, 其中, 有pop、push 2个操作与堆栈相关。在单核心多线程体系结构中, 每个线程都可能尝试访问此公共堆栈, 这种尝试被视为一个请求。如果有来自其他线程的请求争用堆栈导致该请求不能执行, 则其会退回到一个冲突阵列结构中, 并随机挑选阵列中的位置。如果有另一个请求已经存储在该位置, 且他们具有相反的操作, 则2个请求可能都被消除。例如, 一个请求想要弹出数据, 另一个请求想要推送数据。推送操作将其数据与弹出操作交换, 该过程称为请求消除。在这种情况下, 堆栈未被访问。如果一个请求不能与存储在所选位置中的请求交换数据 (例如, pop不能与pop冲突, push不能与push冲突) , 或者在所选位置找不到另一个请求, 则该请求会重新访问堆栈。</p>
                </div>
                <div class="area_img" id="60">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_060.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 公共堆栈的冲突阵列结构" src="Detail/GetImg?filename=images/JSJC201907009_060.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 公共堆栈的冲突阵列结构</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_060.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="61">单核多线程架构可以大幅提高吞吐量。基于NoC的多核系统也具有共享结构, 例如路由单元中的输入缓冲区和交叉开关, Amdahl定律同样适用于这些情况。冲突阵列的概念不仅限于单核多线程架构, 本文将其扩展到片上路由单元, 以降低路由单元流水线的传输数据量。</p>
                </div>
                <h3 id="62" name="62" class="anchor-tag">2 NoC路由单元设计</h3>
                <h4 class="anchor-tag" id="63" name="63">2.1 虚拟通道路由单元的虚拟冲突阵列</h4>
                <div class="p1">
                    <p id="64">本文提出一种新的NoC路由单元体系结构。在传统虚拟通道路由单元的每个输入端口, 设置虚拟冲突阵列, 以消除对路由单元流水线的连续数据访问, 提高路由单元资源利用率与并行性。 为说明数据不是直接访问输入缓冲区, 而是首先访问虚拟冲突阵列, 以潜在地与其他请求相冲突, 本文作如下定义:</p>
                </div>
                <div class="p1">
                    <p id="65"><b>定义1</b> 虚拟冲突阵列是一种虚拟数据阵列 (也称为消除阵列) , 在访问共享结构之前可以消除数据请求。</p>
                </div>
                <div class="p1">
                    <p id="66"><b>定义2</b> 冲突阵列的大小<i>L</i>为其长度, 表示可以同时存储在冲突阵列中的最大写请求数。</p>
                </div>
                <div class="p1">
                    <p id="67">给定一个应用程序, 其包括任务流和相关任务。如图4所示, 当在多核平台上处理任务流时, 任务<i>T</i><sub>1</sub>和<i>T</i><sub>2</sub>分配给内核<i>A</i>, 任务<i>T</i><sub>3</sub>和<i>T</i><sub>4</sub>分配给内核<i>B</i>。然后, 数据在<i>T</i><sub>1</sub>和<i>T</i><sub>3</sub>之间切换, 通过片上路由单元从核心<i>A</i>传输到核心<i>B</i>。任务流分区在路由过程之前被执行。通过任务流分割, 可以获取核心间通信数据包的源和目的信息。虚拟冲突阵列放置在每个路由单元输入端口中的路由单元虚拟通道之前。本文NoC路由单元体系结构包括随机地址生成器、计数器、状态分析器和<i>L</i>大小的虚拟冲突阵列。在任务流分区和任务调度阶段, 将任务分配给不同的核心并生成核心间的通信。</p>
                </div>
                <div class="area_img" id="68">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_068.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 虚拟冲突阵列中的请求消除流程" src="Detail/GetImg?filename=images/JSJC201907009_068.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 虚拟冲突阵列中的请求消除流程</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_068.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="69">图4所示为虚拟冲突阵列中的请求消除过程。当写入请求到达路由单元输入端口时, 随机地址生成器为其提供一个随机地址。如果此随机地址的关联阵列位置可用, 则数据请求将存储在此位置。如果这个位置被另一个数据请求占用, 随机地址生成器将为这个新的数据请求提供一个不同的地址。例如, 图4中的写请求<i>i</i>首先被分配给虚拟冲突阵列中的一个位置。然而, 该位置已经被写请求<i>b</i>占用。因此, 写请求<i>i</i>从随机地址生成器获取新地址并进行存储。当读请求到达时, 随机地址生成器也在同一个虚拟冲突阵列中提供一个随机地址。状态分析器记录虚拟冲突阵列状态。如果存在与相同数据关联的写入请求, 则这2个相反的请求将发生冲突, 两者都被消除, 相关数据包将绕过路由单元管道, 直接到达目的地的输出通道。例如, 图4中的读请求<i>c</i>在虚拟冲突阵列中的一个位置遇到写请求<i>c</i>, 这2个请求被消除, 数据包<i>c</i>将不再遍历路由单元流水线, 而直接从输入通道发送到输出通道。如果读请求不能满足其对应的相反请求, 则其退出并等待<i>tb</i>周期 (定义将在下文给出) , 以对下一个可用的虚拟冲突阵列进行访问, 而对应的数据分组仍存储在前一个路由单元的核心或缓冲区的存储器中 (如图4中的读请求<i>d</i>) 。在上述过程中, 每个数据请求都可以独立访问虚拟冲突阵列。</p>
                </div>
                <div class="p1">
                    <p id="70">通过上述分析可以看出, 提高访问次数可以增加数据冲突的可能性并缩短路由单元的延迟。本文路由单元结构允许回退并重新访问虚拟冲突阵列, 每个写请求存储在虚拟冲突阵列的随机位置。当计数器记录周期时, 如果数据请求仍未消除, 则它将离开虚拟冲突阵列并返回到输入缓冲区, 相关的数据包将在没有旁路的情况下穿过路由单元管道。例如, 图4中的写请求<i>a</i>在虚拟冲突阵列中进行第<i>n</i>个循环后未被消除, 其将被发送到路由单元输入缓冲区。</p>
                </div>
                <div class="p1">
                    <p id="71"><b>定义3</b> 写请求保持时间<i>th</i>表示虚拟冲突阵列可以存储每个写请求的最长时间。一旦持有时间到期, 未被消除的写请求必须离开虚拟冲突阵列, 而关联的数据包将在没有旁路的情况下穿过路由单元管道。</p>
                </div>
                <div class="p1">
                    <p id="72"><b>定义4</b> 读请求回退持续时间<i>tb</i>表示读请求在重新访问虚拟冲突阵列之前必须等待的时间间隔。</p>
                </div>
                <div class="p1">
                    <p id="73">图5所示为本文基于虚拟冲突阵列的路由单元体系结构。</p>
                </div>
                <div class="area_img" id="74">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 基于虚拟冲突阵列的路由单元体系结构" src="Detail/GetImg?filename=images/JSJC201907009_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 基于虚拟冲突阵列的路由单元体系结构</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_074.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="75">当需要通过路由单元进行核心间的通信时, 将数据包从前一个路由单元的核心或缓冲区的存储器注入路由单元输入端口之一。如果此输入端口中的虚拟冲突阵列具有存储数据请求的空间, 则状态分析器将确认信号设置为“高”, 并将其发送到输入通道。对于每个数据包, 发出写请求并将其发送到虚拟冲突阵列。同时, 路由计算模块在报头中提取数据包的目标地址, 并决定每个数据包的输出通道。如果输出通道可接收数据, 则它会发送一个确认信号回到输入端口, 并发出读请求, 该读请求将访问虚拟冲突阵列, 并尝试与已经在此处等待的写请求发生冲突。如果发生请求消除, 数据包将绕过路由单元管道到达输出通道。如果此输入端口中的虚拟冲突阵列存储空间已满, 则状态分析器将确认信号设置为“低”, 数据流将正常发送到路由单元流水线进行数据请求。在上述过程中, 新的虚拟冲突阵列消除了发送到路由单元流水线的数据请求。因此, 数据包可以绕过路由单元管道以节省路由时间和能量。消除速率、路由单元延迟可作为虚拟冲突阵列的关键性能评价指标。</p>
                </div>
                <h4 class="anchor-tag" id="76" name="76">2.2 消除率</h4>
                <div class="p1">
                    <p id="77">为NoC路由单元引入虚拟冲突阵列, 可以在进入传统路由单元流水线之前消除数据请求。因此, 虚拟冲突阵列的消除率成为其性能评估的关键参数。对于<i>L</i>尺寸的虚拟冲突阵列, 为不失一般性, 假设一些写请求已经在其中。每个读请求可以访问任何位置的可能性为1/<i>L</i>。因此, 消除成功的概率是1/<i>L</i>, 消除失败的概率是1-1/<i>L</i>。<i>th</i>/<i>tb</i>的值表示一个读请求可能访问冲突阵列的上限。则消除率定义为:</p>
                </div>
                <div class="p1">
                    <p id="78" class="code-formula">
                        <mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>E</mi><mi>R</mi><mo>=</mo><mn>1</mn><mo>-</mo><mrow><mo> (</mo><mrow><mfrac><mrow><mi>L</mi><mo>-</mo><mn>1</mn></mrow><mi>L</mi></mfrac></mrow><mo>) </mo></mrow><msup><mrow></mrow><mrow><mi>t</mi><mi>h</mi><mo>/</mo><mi>t</mi><mi>b</mi></mrow></msup><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="79">与冲突阵列中失败的消除尝试相关联的数据包数量为:</p>
                </div>
                <div class="p1">
                    <p id="80" class="code-formula">
                        <mathml id="80"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ν</mi><msub><mrow></mrow><mrow><mtext>f</mtext><mtext>a</mtext><mtext>i</mtext><mtext>l</mtext></mrow></msub><mo>=</mo><mi>Ν</mi><mo>⋅</mo><mrow><mo> (</mo><mrow><mfrac><mrow><mi>L</mi><mo>-</mo><mn>1</mn></mrow><mi>L</mi></mfrac></mrow><mo>) </mo></mrow><msup><mrow></mrow><mrow><mi>t</mi><mi>h</mi><mo>/</mo><mi>t</mi><mi>b</mi></mrow></msup><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>3</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="81">绕过路由单元管道的数据包数量为:</p>
                </div>
                <div class="p1">
                    <p id="82" class="code-formula">
                        <mathml id="82"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Ν</mi><msub><mrow></mrow><mrow><mtext>s</mtext><mtext>u</mtext><mtext>c</mtext><mtext>c</mtext></mrow></msub><mo>=</mo><mi>Ν</mi><mo>⋅</mo><mrow><mo> (</mo><mrow><mn>1</mn><mo>-</mo><mrow><mo> (</mo><mrow><mfrac><mrow><mi>L</mi><mo>-</mo><mn>1</mn></mrow><mi>L</mi></mfrac></mrow><mo>) </mo></mrow><msup><mrow></mrow><mrow><mi>t</mi><mi>h</mi><mo>/</mo><mi>t</mi><mi>b</mi></mrow></msup></mrow><mo>) </mo></mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>4</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="83">高消除率不一定缩短路由单元延迟。下文将进一步讨论如何设计虚拟冲突阵列以优化路由单元延迟。</p>
                </div>
                <h4 class="anchor-tag" id="84" name="84">2.3 路由单元延迟</h4>
                <div class="p1">
                    <p id="85">式 (1) 定义<i>N</i>个数据包通过<i>H</i>跳传播的路由单元延迟, 式 (3) 给出使用路由单元流水线传输的数据包数量。因此, 核心间通信的总路由单元流水线延迟, 可以表示为使用路由单元流水线传输的数据包数量和路由单元流水线延迟的乘积:</p>
                </div>
                <div class="p1">
                    <p id="86"><i>T</i><sub>pipeline</sub>=<i>N</i><sub>fail</sub>·<i>T</i><sub><i>p</i></sub>      (5) </p>
                </div>
                <div class="p1">
                    <p id="87">令<i>k</i><sub><i>i</i></sub>为第<i>i</i>个读请求的访问次数, 且1≤<i>k</i><sub><i>i</i></sub>≤<i>th</i>/<i>tb</i>。因此, 在虚拟冲突阵列中消除该读请求及其相应写请求的延迟是<i>k</i><sub><i>i</i></sub>·<i>tb</i>。成功消除虚拟冲突阵列中的请求所需的总延迟如下:</p>
                </div>
                <div class="p1">
                    <p id="88" class="code-formula">
                        <mathml id="88"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Τ</mi><msub><mrow></mrow><mrow><mtext>s</mtext><mtext>u</mtext><mtext>c</mtext><mtext>c</mtext><mo>-</mo><mtext>e</mtext></mrow></msub><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>Ν</mi><msub><mrow></mrow><mrow><mtext>s</mtext><mtext>u</mtext><mtext>c</mtext><mtext>c</mtext></mrow></msub></mrow></munderover><mi>k</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo>⋅</mo><mi>t</mi><mi>b</mi><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>6</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="89">虚拟冲突阵列中失败的请求消除花费的总延迟如下:</p>
                </div>
                <div class="p1">
                    <p id="90"><i>T</i><sub>fail-e</sub>=<i>N</i><sub>fail</sub>·<i>th</i>      (7) </p>
                </div>
                <div class="p1">
                    <p id="91">综上, 虚拟冲突阵列的总延迟可以表示为:</p>
                </div>
                <div class="p1">
                    <p id="92" class="code-formula">
                        <mathml id="92"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Τ</mi><msub><mrow></mrow><mrow><mtext>a</mtext><mtext>r</mtext><mtext>r</mtext><mtext>a</mtext><mtext>y</mtext></mrow></msub><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>Ν</mi><msub><mrow></mrow><mrow><mtext>s</mtext><mtext>u</mtext><mtext>c</mtext><mtext>c</mtext></mrow></msub></mrow></munderover><mi>k</mi></mstyle><msub><mrow></mrow><mi>i</mi></msub><mo>⋅</mo><mi>t</mi><mi>b</mi><mo>+</mo><mi>Ν</mi><msub><mrow></mrow><mrow><mtext>f</mtext><mtext>a</mtext><mtext>i</mtext><mtext>l</mtext></mrow></msub><mo>⋅</mo><mi>t</mi><mi>h</mi><mo>+</mo><mi>Ν</mi><msub><mrow></mrow><mrow><mtext>s</mtext><mtext>u</mtext><mtext>c</mtext><mtext>c</mtext></mrow></msub><mo>⋅</mo><mi>t</mi><mi>w</mi><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mrow><mtext> </mtext><mtext> </mtext><mtext> </mtext></mrow><mo stretchy="false"> (</mo><mn>8</mn><mo stretchy="false">) </mo></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="93">其中, <i>tw</i>是一个数据包从路由单元输入通道传输到输出通道的线路延迟。</p>
                </div>
                <div class="p1">
                    <p id="94">本文路由单元体系架构的总路由延迟可以计算为:</p>
                </div>
                <div class="p1">
                    <p id="95"><i>T</i><sub>router</sub>=<i>H</i>· (<i>T</i><sub>pipeline</sub>+<i>T</i><sub>array</sub>+<i>T</i><sub>overlap</sub>)      (9) </p>
                </div>
                <div class="p1">
                    <p id="96">其中, <i>T</i><sub>overlap</sub>是路由器流水线延迟和虚拟冲突阵列延迟的重叠。</p>
                </div>
                <h4 class="anchor-tag" id="97" name="97">2.4 硬件开销分析</h4>
                <div class="p1">
                    <p id="98">在路由单元结构中引入虚拟冲突阵列, 可以提高路由单元的资源利用率, 但也会带来额外的硬件开销, 该开销表示如下:</p>
                </div>
                <div class="p1">
                    <p id="99"><i>Z</i>=<i>L</i>/ (<i>V</i>·<i>R</i>)      (10) </p>
                </div>
                <div class="p1">
                    <p id="100">其中, <i>V</i>是每个输入端口拥有的虚拟通道数, <i>R</i>是每个虚拟通道所含的缓存区个数。</p>
                </div>
                <div class="p1">
                    <p id="101">参考文献<citation id="182" type="reference">[<a class="sup">21</a>]</citation>对NoC的性能分析数据, 对于一个使用90 nm制程、含有16个缓存区的路由单元结构, 其硬件面积开销为81 407 μm<sup>2</sup>。以<i>V</i>=8、<i>R</i>=8、<i>L</i>=8为例, 根据式 (10) 的分析结果, 引入虚拟冲突阵列导致的新增面积约为10 176 μm<sup>2</sup>, 开销比为12.5%。然而, 该虚拟冲突阵列配置能够消除55%的数据请求, 从而有效缩短了路由延迟。</p>
                </div>
                <h3 id="102" name="102" class="anchor-tag">3 实验结果与分析</h3>
                <div class="p1">
                    <p id="103">本节在HNOCS平台上模拟4×4环形拓扑的NoC, 将基于虚拟冲突阵列的路由单元结构与现有虚拟通道路由单元结构在路由延迟方面进行比较。HNOCS是一个基于Omnet++平台的开源NoC模拟器, 其提供了一个开源、模块化、可扩展且完全可参数化的框架, 用于对NoC进行建模。所有计算机采用英特尔酷睿i7-6700 CPU, 频率为3.4 GHz, 配有16 GB内存和Microsoft Windows 10操作系统。</p>
                </div>
                <div class="p1">
                    <p id="104">图6所示为消除率与<i>th</i>/<i>tb</i>值、<i>L</i>值之间的关系。由图6可以看出, 使用更大的<i>th</i>/<i>tb</i>值和更小的<i>L</i>值, 可以实现更高的消除率。</p>
                </div>
                <div class="area_img" id="105">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_105.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 消除率与th/tb值、L值的关系" src="Detail/GetImg?filename=images/JSJC201907009_105.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图6 消除率与<i>th</i>/<i>tb</i>值、<i>L</i>值的关系</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_105.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="106">图7所示为虚拟冲突阵列延迟与<i>th</i>/<i>tb</i>值、<i>L</i>值之间的关系。其中, 核心间的通信具有5 000个数据包。由图7可以看出, 在<i>L</i>达到8之前, 随着<i>L</i>的增加, 虚拟冲突阵列延迟急剧下降。当<i>L</i>达到8后, 该下降趋势变慢, 且当<i>L</i>超过10时开始平稳。当<i>th</i>/<i>tb</i>值达到6后, 在<i>L</i>=2时虚拟冲突阵列延迟为32 000个循环。而在<i>L</i>=16时, 虚拟冲突阵列延迟变为11 000个循环。对于不同的应用, 这些结论会有所不同, 但它们遵循相同的规律:如果一个写请求长时间存储在虚拟冲突阵列中, 则会剥夺其他请求的冲突机会。另外, 较高的<i>th</i>/<i>tb</i>值意味着每个写请求可以存储在虚拟冲突阵列中较长时间, 虚拟冲突阵列的延迟因此增加。另一方面, 更大的<i>L</i>值将在虚拟冲突阵列中提供更多的空间, 由于可以在虚拟冲突阵列中处理更多的请求, 因此延迟将缩短。</p>
                </div>
                <div class="area_img" id="107">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_107.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 虚拟冲突阵列延迟与th/tb值、L值的关系" src="Detail/GetImg?filename=images/JSJC201907009_107.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图7 虚拟冲突阵列延迟与<i>th</i>/<i>tb</i>值、<i>L</i>值的关系</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_107.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="108">图8所示为路由器流水线延迟、虚拟冲突阵列延迟与<i>th</i>/<i>tb</i>值的关系。其中, 核心间的通信具有5 000个数据包。由图8可以看出, 随着<i>th</i>/<i>tb</i>值的增加, 路由单元流水线延迟减少, 虚拟冲突阵列延迟增加。原因是虚拟冲突阵列放置在路由单元虚拟通道之前, 当数据包由虚拟冲突阵列处理时, 先前的数据包被现有的路由单元流水线同时处理, 因此, 虚拟冲突阵列延迟和路由单元流水线延迟高度重叠。</p>
                </div>
                <div class="area_img" id="109">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_109.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 2种延迟与th/tb值的关系" src="Detail/GetImg?filename=images/JSJC201907009_109.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图8 2种延迟与<i>th</i>/<i>tb</i>值的关系</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_109.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="110">为比较基于虚拟冲突阵列的路由单元与现有虚拟通道路由单元在路由延迟方面的性能, 模拟均匀数据业务模式, 在不同负载下得到的路由延迟对比结果如图9所示。其中, <i>L</i>值设置为8。由图9可以看出, 随着负载的增加, 与传统虚拟通道路由单元相比, 基于虚拟冲突阵列的路由单元具有较低的路由延迟, 且延迟增加较缓慢, 即其具有较好的路由延迟性能。</p>
                </div>
                <div class="area_img" id="111">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201907009_111.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 2种路由单元的路由延迟比较结果" src="Detail/GetImg?filename=images/JSJC201907009_111.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图9 2种路由单元的路由延迟比较结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201907009_111.jpg&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="112">当<i>L</i>为8、负载为0.3时, 相比传统虚拟通道路由单元, 基于虚拟冲突阵列的路由单元延迟缩短了约70%, 代价仅为增加25%的硬件面积。当<i>L</i>值小于8时, 虽然消除率会减小, 延迟改进会降低, 但相应的硬件面积开销也会降低。</p>
                </div>
                <h3 id="113" name="113" class="anchor-tag">4 结束语</h3>
                <div class="p1">
                    <p id="114">本文提出一种基于虚拟冲突阵列的路由单元结构, 以在数据进入路由单元流水线之前在虚拟冲突阵列中对其进行部分消除, 提高NoC的并行性。实验结果表明, 与传统虚拟通道路由单元相比, 该路由单元具有较短的路由延迟。本文路由单元结构目前只针对路由时延进行了优化, 下一步将研究并解决路由单元的能效优化问题。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="128">
                            <a id="bibliography_1" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On the design and analysis of fault tolerant No C architecture using spare routers">

                                <b>[1]</b> CHANG Y C, CHIU C T, LIN S Y, et al.On the design and analysis of fault tolerant NoC architecture using spare routers[C]//Proceedings of the 16th Asia and South Pacific Design Automation Conference.Washington D.C., USA:IEEE Press, 2011:431-436.
                            </a>
                        </p>
                        <p id="130">
                            <a id="bibliography_2" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Network-on-chip:a new SoC commu-nication infrastructure paradigm">

                                <b>[2]</b> CHOUDHARY N.Network-on-chip:a new SoC commu-nication infrastructure paradigm[J].International Journal of Soft Computing and Engineering, 2012, 1 (6) :70-78.
                            </a>
                        </p>
                        <p id="132">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJA201803050&amp;v=MDE2OThRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJwRkNqblU3clBMejdCYjdHNEg5bk1ySTlBWkk=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> 李璐璐, 裘雪红, 周端, 等.片上网络容错技术研究[J].计算机科学, 2018, 45 (3) :305-310.
                            </a>
                        </p>
                        <p id="134">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=High throughput pipelining NoC using clumsy flow control">

                                <b>[4]</b> KARPAGA S A, MURALIDHARAN D.High throughput pipelining NoC using clumsy flow control[EB/OL].[2018-07-02].http://www.indjst.org/index.php/indjst/article/view/91236/72140.
                            </a>
                        </p>
                        <p id="136">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=WXYJ201806026&amp;v=MTc2NjdUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJwRkNqblU3clBNalhTWkxHNEg5bk1xWTlIWW9RS0RIODR2UjQ=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> 刘炎华, 石世领, 孙海燕, 等.基于拥塞和热点感知的低延时片上网络路由器设计[J].微电子学与计算机, 2018, 35 (6) :128-133.
                            </a>
                        </p>
                        <p id="138">
                            <a id="bibliography_6" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Interconnections in multi-core architectures:understanding mechanisms,overheads and scaling">

                                <b>[6]</b> KUMAR R, ZYUBAN V, TULLSEN D M.Interconnections in multi-core architectures:understanding mechanisms, overheads and scaling[C]//Proceedings of International Symposium on Computer Architecture.Washington D.C., USA:IEEE Press, 2015:408-419.
                            </a>
                        </p>
                        <p id="140">
                            <a id="bibliography_7" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Routing algorithms in networks-on-chip">

                                <b>[7]</b> PALESI M, DANESHTALAB M.Routing algorithms in networks-on-chip[M].Berlin, Germany:Springer, 2013.
                            </a>
                        </p>
                        <p id="142">
                            <a id="bibliography_8" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CMFD&amp;filename=1018702458.nh&amp;v=MzI1MDZPZVplUnBGQ2puVTdyUFZGMjZGclM0SE5YSnA1RWJQSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkw=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[8]</b> 杭彦希.基于2D-Mesh互连的片上网络容错技术研究与设计[D].郑州:解放军信息工程大学, 2017.
                            </a>
                        </p>
                        <p id="144">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Design tradeoffs for tiled CMP on-chip networks">

                                <b>[9]</b> BALFOUR J, DALLY W J.Design tradeoffs for tiled CMP on-chip networks[C]//Proceedings of ACM International Conference on Supercomputing, Anniversary Volume.New York, USA:ACM Press, 2014:390-401.
                            </a>
                        </p>
                        <p id="146">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Validity of the Single Processor Approach to Achieving Large Scale Computing Capabilities">

                                <b>[10]</b> AMDAHL G M.Validity of the single processor approach to achieving large scale computing capabilities[J].IEEE Solid-State Circuits Society News Letter, 2007, 12 (3) :19-20.
                            </a>
                        </p>
                        <p id="148">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A unified performance estimation method for hardware and software components in multiprocessor system-on-chips">

                                <b>[11]</b> KHAN A U, ISSHIKI T, LI D.A unified performance estimation method for hardware and software components in multiprocessor system-on-chips[J].IPSJ Transactions on System LSI Design Methodology, 2010, 3:194-206.
                            </a>
                        </p>
                        <p id="150">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Multicore processors and systems">

                                <b>[12]</b> KECKLER S W, OLUKOTUN K, HOFSTEE H P.Multicore processors and systems[M].Berlin, Germany:Springer, 2009.
                            </a>
                        </p>
                        <p id="152">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Three-dimensional thinning algorithms on graphics processing units and multicore CPUs">

                                <b>[13]</b> JIMÉNEZ J, RUIZ D M J.Three-dimensional thinning algorithms on graphics processing units and multicore CPUs[J].Concurrency and Computation Practice and Experience, 2012, 24 (14) :1551-1571.
                            </a>
                        </p>
                        <p id="154">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=GaN transistors—giving new life to Moore&amp;#39;&amp;#39;s law">

                                <b>[14]</b> LIDOW A.GaN transistors—giving new life to Moore’s law[C]//Proceedings of IEEE International Symposium on Power Semiconductor Devices and IC’s.Washington D.C., USA:IEEE Press, 2015:1-6.
                            </a>
                        </p>
                        <p id="156">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Method and apparatus for improving processing performance of a multi-core processor">

                                <b>[15]</b> GIUSTO P, LAKSHMANAN K, RAJKUMAR R.Method and apparatus for improving processing performance of a multi-core processor:US9063796[P].2015-06-23.
                            </a>
                        </p>
                        <p id="158">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XAJT201506012&amp;v=MTM2MjFTekJlckc0SDlUTXFZOUVab1FLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUnBGQ2puVTdyUFA=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b> 杨鹏飞, 王泉.片上网络异构多核系统任务调度与映射[J].西安交通大学学报, 2015, 49 (6) :72-76.
                            </a>
                        </p>
                        <p id="160">
                            <a id="bibliography_17" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Is parallel programming hard,and,if so,what can you do about it?">

                                <b>[17]</b> MCKENNEY P E.Is parallel programming hard, and, if so, what can you do about it?[EB/OL].[2018-07-03].https://arxiv.org/pdf/1701.00854.pdf.
                            </a>
                        </p>
                        <p id="162">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=The future of computing performance:game over or next level?">

                                <b>[18]</b> FULLER S H, MILLETT L I.The future of computing performance:game over or next level?[M].[S.l.]:National Academy Press, 2011.
                            </a>
                        </p>
                        <p id="164">
                            <a id="bibliography_19" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Logical relations for fine-grained concurrency">

                                <b>[19]</b> TURON A J, THAMSBORG J, AHMED A, et al.Logical relations for fine-grained concurrency[C]//Proceedings of ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages.New York, USA:ACM Press, 2013:343-356.
                            </a>
                        </p>
                        <p id="166">
                            <a id="bibliography_20" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000001295&amp;v=MjM1MDJxUVRNbndaZVp1SHlqbVVMakxJRndVYnhVPU5pZklZN0s3SHRqTnI0OUZaT3NPRG5VOG9CTVQ2VDRQUUgvaXJSZEdlcg==&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[20]</b> SHAVIT N.Data structures in the multicore age[M].New York, USA:ACM Press, 2011.
                            </a>
                        </p>
                        <p id="168">
                            <a id="bibliography_21" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Adaptive channel buffers in on-chip interconnection networks - A power and performance analysis">

                                <b>[21]</b> KODI A K, SARATHY A, LOURI A.Adaptive channel buffers in on-chip interconnection networks—a power and performance analysis[J].IEEE Transactions on Computers, 2008, 57 (9) :1169-1181.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJC201907009" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201907009&amp;v=MTE2Njg2ajU0TzN6cXFCdEdGckNVUkxPZVplUnBGQ2puVTdyUEx6N0JiYkc0SDlqTXFJOUZiWVFLREg4NHZSNFQ=&amp;uid=WEEvREcwSlJHSldRa1FhdXNXaEhoRFQwam9BWm83cU5adCswdFNtUXRBUT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
