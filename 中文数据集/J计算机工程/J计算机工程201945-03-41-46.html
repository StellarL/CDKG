<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637130630490118750%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201903008%26RESULT%3d1%26SIGN%3dkacVWiEP1ih42yT2e2c%252bcbwjMuY%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201903008&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201903008&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201903008&amp;v=MDQ4OTJPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5N2tWcjdOTHo3QmJiRzRIOWpNckk5RmJJUUtESDg0dlI0VDZqNTQ=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#41" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#46" data-title="1 张量相关的基本概念 ">1 张量相关的基本概念</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#47" data-title="1.1 张量">1.1 张量</a></li>
                                                <li><a href="#63" data-title="1.2 张量相关计算">1.2 张量相关计算</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#90" data-title="2 张量Tucker分解算法 ">2 张量Tucker分解算法</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#91" data-title="2.1 相关概念">2.1 相关概念</a></li>
                                                <li><a href="#99" data-title="2.2 &lt;i&gt;Tucker&lt;/i&gt;分解定义">2.2 <i>Tucker</i>分解定义</a></li>
                                                <li><a href="#113" data-title="2.3 高阶正交迭代法">2.3 高阶正交迭代法</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#143" data-title="3 张量Tucker分解算法的改进 ">3 张量Tucker分解算法的改进</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#144" data-title="3.1 计算过程矩阵化原理">3.1 计算过程矩阵化原理</a></li>
                                                <li><a href="#188" data-title="3.2 改进算法的实现">3.2 改进算法的实现</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#237" data-title="4 张量Tucker分解算法模块性能测试 ">4 张量Tucker分解算法模块性能测试</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#239" data-title="4.1 &lt;i&gt;CUBLAS&lt;/i&gt;与&lt;i&gt;C&lt;/i&gt;语言性能比对">4.1 <i>CUBLAS</i>与<i>C</i>语言性能比对</a></li>
                                                <li><a href="#250" data-title="4.2 模块对比测试结果">4.2 模块对比测试结果</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#258" data-title="5 结束语 ">5 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#219" data-title="&lt;b&gt;表1 相关算法对应使用的函数&lt;/b&gt;"><b>表1 相关算法对应使用的函数</b></a></li>
                                                <li><a href="#248" data-title="&lt;b&gt;表2 CUBLAS与C语言所用时间对比&lt;/b&gt;"><b>表2 CUBLAS与C语言所用时间对比</b></a></li>
                                                <li><a href="#253" data-title="&lt;b&gt;表3 CUBLAS、CUDA与C语言所用时间对比&lt;/b&gt;"><b>表3 CUBLAS、CUDA与C语言所用时间对比</b></a></li>
                                                <li><a href="#254" data-title="&lt;b&gt;表4 CUBLAS、CUDA与C语言性能对比&lt;/b&gt;"><b>表4 CUBLAS、CUDA与C语言性能对比</b></a></li>
                                                <li><a href="#255" data-title="&lt;b&gt;表5 使用CUBLAS情况下所用时间对比&lt;/b&gt;"><b>表5 使用CUBLAS情况下所用时间对比</b></a></li>
                                                <li><a href="#256" data-title="&lt;b&gt;表6 使用CUBLAS情况下性能对比&lt;/b&gt;"><b>表6 使用CUBLAS情况下性能对比</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" 张若京.张量分析简明教程[M].上海:同济大学出版社, 2010." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787560842400001&amp;v=Mjk4ODY4UlhGcXpHYmErSHRuSXJZdEZaT3NQRFJNOHp4VVNtRGQ5U0g3bjN4RTlmYnZuS3JpZlp1OXVGQ3ZqVTduSkpW&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         张若京.张量分析简明教程[M].上海:同济大学出版社, 2010.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title=" 王明月.基于张量分解的统计模型及其应用[D].苏州:苏州科技大学, 2016." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CMFD&amp;filename=1016181986.nh&amp;v=MTQ5MTlHRnJDVVJMT2VaZVJvRnk3a1ZyN05WRjI2R0xLd0g5akVxWkViUElRS0RIODR2UjRUNmo1NE8zenFxQnQ=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         王明月.基于张量分解的统计模型及其应用[D].苏州:苏州科技大学, 2016.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" 徐联微, 杨晓梅.基于迭代张量高阶奇异值分解的运动目标提取[J].计算机应用研究, 2016, 33 (9) :2856-2861." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSYJ201609069&amp;v=MTc4NjdlWmVSb0Z5N2tWcjdOTHo3U1pMRzRIOWZNcG85RGJZUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE8=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[3]</b>
                                         徐联微, 杨晓梅.基于迭代张量高阶奇异值分解的运动目标提取[J].计算机应用研究, 2016, 33 (9) :2856-2861.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" title=" KOLDA T G, BADER B W.Tensor decomposition and applications[J].Slam, 2009, 51 (3) :455-500." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Tensor decompositions and applications">
                                        <b>[4]</b>
                                         KOLDA T G, BADER B W.Tensor decomposition and applications[J].Slam, 2009, 51 (3) :455-500.
                                    </a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" 张梦元.基于CUDA的矩阵乘法的并行实现[J].信息通信, 2012, 2 (2) :20-21." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=HBYD201202010&amp;v=MzE4ODlqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5N2tWcjdOTFMvU2FyRzRIOVBNclk5RVpJUUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[5]</b>
                                         张梦元.基于CUDA的矩阵乘法的并行实现[J].信息通信, 2012, 2 (2) :20-21.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" 张雄军.图像恢复和低秩张量逼近的模型及算法研究[D].长沙:湖南大学, 2017." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1018067359.nh&amp;v=MTcyMTN5N2tWcjdOVkYyNkZyTytHZExKcHBFYlBJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Y=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         张雄军.图像恢复和低秩张量逼近的模型及算法研究[D].长沙:湖南大学, 2017.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title=" 杨洪礼.非负矩阵与张量分解及其应用[D].青岛:山东科技大学, 2011." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1012277442.nh&amp;v=MDI0MTdJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5N2tWcjdOVkYyNkhMRy9HZFhJclpFYlA=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                         杨洪礼.非负矩阵与张量分解及其应用[D].青岛:山东科技大学, 2011.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" >
                                        <b>[8]</b>
                                     张雄军.图像恢复和低秩张量逼近的模型及算法研究[D].长沙:湖南大学, 2017.</a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title=" 王丽琪.张量的低秩逼近与梯度流方法[D].大连:大连理工大学, 2015." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1015355434.nh&amp;v=MDU3ODVSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeTdrVnI3TlZGMjZHN0M5RzlYUHE1RWJQSVFLREg4NHY=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[9]</b>
                                         王丽琪.张量的低秩逼近与梯度流方法[D].大连:大连理工大学, 2015.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title=" 王磊, 王斌, 张立明.基于张量分析和小波包变换的高光谱图像压缩[J].复旦学报 (自然科学版) , 2013, 52 (3) :371-379." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=FDXB201303013&amp;v=MDExNTNJOUVaNFFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeTdrVnI3Tkl5blRiTEc0SDlMTXI=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[10]</b>
                                         王磊, 王斌, 张立明.基于张量分析和小波包变换的高光谱图像压缩[J].复旦学报 (自然科学版) , 2013, 52 (3) :371-379.
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title=" TUCKER L R.Some mathematical notes on three-mode factor analysis[J].Psychometrika, 1966, 31 (3) :279-311." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00001068384&amp;v=MDczMjNoNGo5OVNYcVJyeG94Y01IN1I3cWVidWR0RkM3bFZiN05JVnM9Tmo3QmFyTzRIdEhOcjRsTlorTUxZM2s1ekJk&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[11]</b>
                                         TUCKER L R.Some mathematical notes on three-mode factor analysis[J].Psychometrika, 1966, 31 (3) :279-311.
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" title=" LATHAUWER L D, MOOR B D, VANDWEALLE J.A multilinear singular value decomposition[J].SIAM Journal on Matrix Analysis and Applications, 2000, 21 (4) :1253-1278." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A Multilinear Singular Value Decomposition">
                                        <b>[12]</b>
                                         LATHAUWER L D, MOOR B D, VANDWEALLE J.A multilinear singular value decomposition[J].SIAM Journal on Matrix Analysis and Applications, 2000, 21 (4) :1253-1278.
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title=" LATHAUWER L D, MOOR B D, VANDWEALLE J.On the best rank-1 and rank- (&lt;i&gt;R&lt;/i&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;i&gt;R&lt;/i&gt;&lt;sub&gt;2&lt;/sub&gt;, …, &lt;i&gt;R&lt;/i&gt;&lt;sub&gt;&lt;i&gt;N&lt;/i&gt;&lt;/sub&gt;) approximation of higherorder tensors[J].SIAM Journal on Matrix Analysis and Applications, 2000, 21 (4) :123-149." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On the Best Rank-1 and Rank-(R1,R2,. . .,RN) Approximation of Higher-Order Tensors">
                                        <b>[13]</b>
                                         LATHAUWER L D, MOOR B D, VANDWEALLE J.On the best rank-1 and rank- (&lt;i&gt;R&lt;/i&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;i&gt;R&lt;/i&gt;&lt;sub&gt;2&lt;/sub&gt;, …, &lt;i&gt;R&lt;/i&gt;&lt;sub&gt;&lt;i&gt;N&lt;/i&gt;&lt;/sub&gt;) approximation of higherorder tensors[J].SIAM Journal on Matrix Analysis and Applications, 2000, 21 (4) :123-149.
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_14" title=" ANDERSSON C A, BRO R.Improving the speed of multiway algorithms:Part II:compression[J].Chemometrics and Intelligent Laboratory Systems, 1998, 42 (1/2) :105-113." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300186513&amp;v=MDIzMTZmYks3SHRET3JJOUZaZU1KQ1gwNm9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUxuSUpsOFJheGM9TmlmTw==&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[14]</b>
                                         ANDERSSON C A, BRO R.Improving the speed of multiway algorithms:Part II:compression[J].Chemometrics and Intelligent Laboratory Systems, 1998, 42 (1/2) :105-113.
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_15" title=" BARRACHINA S, CASTILLO M, IGUAL F D, et al.Evaluation and tuning of the Level 3 CUBLAS for graphics processors[C]//Proceedings of IEEE International Symposium on Parallel and Distributed Processing.Washington D.C., USA:IEEE Press, 2008:1-8." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Evaluation and tuning of the Level 3 CUBLAS for graphics processors">
                                        <b>[15]</b>
                                         BARRACHINA S, CASTILLO M, IGUAL F D, et al.Evaluation and tuning of the Level 3 CUBLAS for graphics processors[C]//Proceedings of IEEE International Symposium on Parallel and Distributed Processing.Washington D.C., USA:IEEE Press, 2008:1-8.
                                    </a>
                                </li>
                                <li id="33">


                                    <a id="bibliography_16" title=" 周海芳, 高畅, 方民权.基于CUBLAS和CUDA 的MNF并行算法设计与优化[J].湖南大学学报 (自然科学版) , 2017, 44 (4) :147-156." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=HNDX201704020&amp;v=MjIyNTZWcjdOTFNQUGRyRzRIOWJNcTQ5SFpJUUtESDg0dlI0VDZqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5N2s=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                         周海芳, 高畅, 方民权.基于CUBLAS和CUDA 的MNF并行算法设计与优化[J].湖南大学学报 (自然科学版) , 2017, 44 (4) :147-156.
                                    </a>
                                </li>
                                <li id="35">


                                    <a id="bibliography_17" title=" 张韵华.数值计算方法和算法[M].北京:科学出版社, 2000." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=0007030073770999&amp;v=MjQzOTlDWk9JR0JSTTh6eFVTbURkOVNIN24zeEU5ZmJ2bktyaWZadTl1RkN2alU3bkpKVjhSVlYyN0diTzdIdEhMcklo&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                         张韵华.数值计算方法和算法[M].北京:科学出版社, 2000.
                                    </a>
                                </li>
                                <li id="37">


                                    <a id="bibliography_18" title=" CHAKARAVARTHY V T, CHOI J W, JOSEPH D J, et al.On optimizing distributed tucker decomposition for dense tensors[C]//Proceedings of IEEE Parallel and Distributed Processing Symposium.Washington D.C., USA:IEEE Press, 2017:1038-1047." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=On optimizing distributed tucker decomposition for dense tensors">
                                        <b>[18]</b>
                                         CHAKARAVARTHY V T, CHOI J W, JOSEPH D J, et al.On optimizing distributed tucker decomposition for dense tensors[C]//Proceedings of IEEE Parallel and Distributed Processing Symposium.Washington D.C., USA:IEEE Press, 2017:1038-1047.
                                    </a>
                                </li>
                                <li id="39">


                                    <a id="bibliography_19" title=" KROOONENBERG P M, LEEUW J D, CASTILLO M.Principal component analysis of three-mode data by means of alternating least squares algorithms[J].Psychometrika, 1980, 45 (1) :69-97." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00001071651&amp;v=MTE1MjFqN0Jhck80SHRITnI0aEVZdTRPWTNrNXpCZGg0ajk5U1hxUnJ4b3hjTUg3UjdxZWJ1ZHRGQzdsVmI3TklWcz1O&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[19]</b>
                                         KROOONENBERG P M, LEEUW J D, CASTILLO M.Principal component analysis of three-mode data by means of alternating least squares algorithms[J].Psychometrika, 1980, 45 (1) :69-97.
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(03),41-46 DOI:10.19678/j.issn.1000-3428.0052189            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>基于CUDA与CUBLAS的Tucker分解模块设计与实现</b></span>
 <span class="shoufa"></span>                                     </h1>

            </div>
                        <h2>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E5%91%A8%E7%90%A6&amp;code=39200656&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">周琦</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E6%9F%B4%E5%B0%8F%E4%B8%BD&amp;code=26546184&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">柴小丽</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E9%A9%AC%E5%85%8B%E6%9D%B0&amp;code=29209767&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">马克杰</a>
                                <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=au&amp;skey=%E4%BF%9E%E5%88%99%E4%BA%BA&amp;code=34764000&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">俞则人</a>
                </h2>
                    <h2>
                    <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=in&amp;skey=%E4%B8%AD%E5%9B%BD%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E9%9B%86%E5%9B%A2%E5%85%AC%E5%8F%B8%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E7%A0%94%E7%A9%B6%E6%89%80&amp;code=0131038&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">中国电子科技集团公司第三十二研究所</a>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>由于张量Tucker分解在图像处理、人脸识别与信号处理等领域中的大量应用, 使得Tucker分解算法成为目前重点研究对象。但是当前流行的Tucker分解算法需要对张量进行多次展开, 导致算法加速效率降低。针对上述问题, 提出一种应用于统一计算设备架构 (CUDA) 平台上的改进Tucker分解模块, 通过对Tucker分解算法与CUDA平台进行优化, 在省略张量展开过程的同时, 提高加速效率, 从而降低对加速系统的要求。实验结果表明, 改进Tucker分解算法在CUDA平台上的加速性能具有明显提高。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Tucker%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Tucker分解算法;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%BC%A0%E9%87%8F%E5%88%86%E8%A7%A3&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张量分解;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%BB%9F%E4%B8%80%E8%AE%A1%E7%AE%97%E8%AE%BE%E5%A4%87%E6%9E%B6%E6%9E%84&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">统一计算设备架构;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">图形处理单元;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%BC%A0%E9%87%8F%E8%8C%83%E6%95%B0&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">张量范数;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    周琦 (1990—) , 男, 硕士研究生, 主研方向为异构计算、FPGA技术;;
                                </span>
                                <span>
                                    柴小丽, 研究员;;
                                </span>
                                <span>
                                    马克杰, 工程师。;
                                </span>
                                <span>
                                    俞则人, 工程师。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-07-23</p>

                    <p>

                            <b>基金：</b>
                                                        <span>中国电子科技集团安可系统自由硬件新技术研发项目 (170225);</span>
                    </p>
            </div>
                    <h1><b>Design and Implementation of Tucker Decomposition Module Based on CUDA and CUBLAS</b></h1>
                    <h2>
                    <span>ZHOU Qi</span>
                    <span>CHAI Xiaoli</span>
                    <span>MA Kejie</span>
                    <span>YU Zeren</span>
            </h2>
                    <h2>
                    <span>The 32th Research Institution of the China Electronics Technology Group Corporation</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Because tensor Tucker decomposition is widely used in image processing, face recognition, signal processing and other fields, Tucker decomposition algorithm becomes a key research object.However, the current popular Tucker decomposition algorithm needs to expand tensors many times, which results in that the acceleration efficiency of the algorithm is mostly consumed in tensor multiple expansion.In order to solve the above problems, a modified Tucker decomposition module applied to CUDA platform is proposed.By optimizing the Tucker decomposition algorithm and CUDA platform, the tensor expansion process is omitted, and the requirements of acceleration system are reduced and the acceleration efficiency is improved.Experimental results show that the modified Tucker decomposition algorithm has better acceleration performance on CUDA platform.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Tucker%20decomposition%20algorithm&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Tucker decomposition algorithm;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=tensor%20decomposition&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">tensor decomposition;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Compute%20Unified%20Device%20Architecture%20(CUDA)%20&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Compute Unified Device Architecture (CUDA) ;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Graphics%20Processing%20Unit%20(GPU)%20&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Graphics Processing Unit (GPU) ;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=tensor%20norm&amp;code=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">tensor norm;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-07-23</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="41" name="41" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="42">张量是一个力学系统的概念, 用来表现非线性连续介质中的应力与应变状态<citation id="260" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。在计算机科学领域中, 张量是体现数据之间线性关系的集合<citation id="261" type="reference"><link href="5" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>。由于张量能够在二维以上的维度拓展, 因此在图像处理、人脸识别、信号处理等领域中用来描述原先需要进行降维处理后才能处理的数据, 从而保证数据的完整性<citation id="262" type="reference"><link href="7" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="43">张量分解是张量主要的分析工具, 其中, CANDECOMP/PARAFAC (CP) 分解与Tucker分解最常使用, 它们分别是矩阵秩-1分解和矩阵奇异值分解高阶下的推广<citation id="263" type="reference"><link href="9" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>。由于Tucker分解包含的计算种类比较少, 对矩阵数据要求比CP分解低。同时, CP分解在算法上为Tucker分解的特殊情况<citation id="264" type="reference"><link href="9" rel="bibliography" /><sup>[<a class="sup">4</a>]</sup></citation>。因此, 在张量分解算法的相关研究中, Tucker分解算法一直是被重点研究的对象。</p>
                </div>
                <div class="p1">
                    <p id="44">因为Tucker分解的重要性, 算法相关的计算加速研究成为热点。Jee Choi提出利用图形处理单元 (GPU) 异构系统, 把分解任务分给各个计算节点进行运算, 从而获得了较好的加速效果。但是, 该加速方案有2个方面的不足:Tucker分解需要多块GPU卡才能完成加速效果 (GPU数量与维度有关, 维度越高GPU需要的就越多) ;加速方案中的算法没有进行优化, 每次相乘都需要进行张量展开, 浪费计算资源与时间。</p>
                </div>
                <div class="p1">
                    <p id="45">针对上述问题, 本文通过使用CUBLAS和优化算法步骤的方式, 对Tucker分解算法进行优化改进。CUBLAS是基础线性代数子程序库 (Basic Linear Algebra Subprograms, BLAS) 在统一设备计算架构 (Compute Unified Device Architecture, CUDA) 上的应用, CUDA是运用GPU进行通用运算的应用程序平台<citation id="265" type="reference"><link href="11" rel="bibliography" /><sup>[<a class="sup">5</a>]</sup></citation>。用户通过CUBLAS程序库, 配合GPU与计算密集型和高度并行计算的特性, 获得线性计算加速效果。同时, 本文将Tucker算法中的张量乘法全部转化为矩阵算法, 避免因为张量展开所产生的资源和时间的浪费, 以达到加速的目的。</p>
                </div>
                <h3 id="46" name="46" class="anchor-tag">1 张量相关的基本概念</h3>
                <h4 class="anchor-tag" id="47" name="47">1.1 张量</h4>
                <div class="p1">
                    <p id="48">张量是一个多阶数列, 是由多个向量组成的多阶空间。本文张量的概念与力学系统中的张量不同, 这里的张量是借鉴了数学概念中的张量。标量被称为零阶张量, 向量称为一阶张量, 矩阵称为二阶张量, 三阶或更高阶度的张量称为高阶张量。本文中提到的张量, 都默认为三阶张量。</p>
                </div>
                <div class="p1">
                    <p id="49">张量表达式:本文中张量的表达符号为<b><i>X</i></b>, 张量中的元素表达符号为<i>x</i>, 元素位置通过下标来表示, 假设三维张量<b><i>X</i></b>∈<image href="images/JSJC201903008_050.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i>×<i>J</i>×<i>K</i></sup>, 则张量中的元素表达式为<i>x</i><sub><i>ijk</i></sub>。</p>
                </div>
                <div class="p1">
                    <p id="51">张量矩阵化:高阶张量由于需要和矩阵进行计算, 因此这些高阶张量需要在某一个维度上进行变换, 转变为矩阵, 这个过程称为张量的矩阵化, 或者张量的矩阵展开<citation id="266" type="reference"><link href="13" rel="bibliography" /><sup>[<a class="sup">6</a>]</sup></citation>。假设一个<i>N</i>维张量<b><i>X</i></b>∈<image href="images/JSJC201903008_052.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i><sub>1</sub>×<i>I</i><sub>2</sub>×…×<i>I</i><sub><i>N</i></sub></sup>在<i>n</i>模展开, 则记为<b><i>X</i></b><sub> (<i>n</i>) </sub>, 将<i>n</i>维矢量排列为大小为<b><i>I</i></b><sub><i>n</i></sub>× (<i>I</i><sub>1</sub>, <i>I</i><sub>2</sub>, …, <i>I</i><sub><i>N</i></sub>) 的矩阵。张量中 (<i>i</i><sub>1</sub>, <i>i</i><sub>2</sub>, …, <i>i</i><sub><i>N</i></sub>) 元素在<i>n</i>模矩阵<b><i>X</i></b><sub> (<i>n</i>) </sub>中的位置为 (<i>i</i><sub><i>n</i></sub>, <i>j</i>) , 同时:</p>
                </div>
                <div class="p1">
                    <p id="53" class="code-formula">
                        <mathml id="53"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi>j</mi><mo>=</mo><mn>1</mn><mo>+</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>, </mo><mi>k</mi><mo>≠</mo><mi>n</mi></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></munderover><mrow><mrow><mo> (</mo><mrow><mi>i</mi><msub><mrow></mrow><mi>k</mi></msub><mo>-</mo><mn>1</mn></mrow><mo>) </mo></mrow></mrow></mstyle><mi>J</mi><msub><mrow></mrow><mi>k</mi></msub></mtd></mtr><mtr><mtd><mi>J</mi><msub><mrow></mrow><mi>k</mi></msub><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∏</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn><mo>, </mo><mi>m</mi><mo>≠</mo><mi>n</mi></mrow><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow></munderover><mi>Ι</mi></mstyle><msub><mrow></mrow><mi>m</mi></msub></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="54">内乘与张量范数:张量之间内积是2个相同的张量<b><i>X</i>, <i>Y</i></b>∈<image href="images/JSJC201903008_055.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i><sub>1</sub>×<i>I</i><sub>2</sub>×…×<i>I</i><sub><i>N</i></sub></sup>的每个元素乘积的和<citation id="267" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>, 其阶段表达式为:</p>
                </div>
                <div class="p1">
                    <p id="56" class="code-formula">
                        <mathml id="56"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>〈</mo><mi mathvariant="bold-italic">X</mi><mo>, </mo><mi mathvariant="bold-italic">Y</mi><mo>〉</mo><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mn>2</mn></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></munderover><mo>⋯</mo></mstyle></mrow></mstyle><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mi>Ν</mi></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow></munderover><mi>x</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>i</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow></msub><mi>y</mi><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>i</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow></msub></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="57">而张量范数是张量<b><i>X</i></b>∈<image href="images/JSJC201903008_058.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i><sub>1</sub>×<i>I</i><sub>2</sub>×<i>I</i><sub>3</sub>…<i>I</i><sub><i>N</i></sub></sup>对其本身进行内积的二次根<citation id="268" type="reference"><link href="15" rel="bibliography" /><sup>[<a class="sup">7</a>]</sup></citation>, 其表达式为:</p>
                </div>
                <div class="p1">
                    <p id="59" class="code-formula">
                        <mathml id="59"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><mo stretchy="false">∥</mo><mo>=</mo><msqrt><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mn>1</mn></msub></mrow></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mn>2</mn></msub></mrow></munderover><mo>⋯</mo></mstyle></mrow></mstyle><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow></munderover><mi>x</mi></mstyle><msubsup><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>i</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow><mn>2</mn></msubsup></mrow></msqrt></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="60">表达式可简化为:</p>
                </div>
                <div class="p1">
                    <p id="61" class="code-formula">
                        <mathml id="61"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><mo stretchy="false">∥</mo><mo>=</mo><msqrt><mrow><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">X</mi><mo>, </mo><mi mathvariant="bold-italic">X</mi><mo stretchy="false">) </mo></mrow></msqrt></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="62">从定义可以得知, 张量范数和矩阵的Frobenius范数定义一致。</p>
                </div>
                <h4 class="anchor-tag" id="63" name="63">1.2 张量相关计算</h4>
                <h4 class="anchor-tag" id="64" name="64">1.2.1 张量乘法</h4>
                <div class="p1">
                    <p id="65">张量乘法又被称为n模乘积, 是一种不同于矩阵乘法的乘法, 一般被定义为张量与矩阵在模n中的乘积<citation id="269" type="reference"><link href="17" rel="bibliography" /><sup>[<a class="sup">8</a>]</sup></citation>。假设一个N阶张量<b><i>X</i></b>∈<image href="images/JSJC201903008_066.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i><sub>1</sub>×<i>I</i><sub>2</sub>×…×<i>I</i><sub><i>N</i></sub></sup>, 以及一个矩阵<b><i>U</i></b>∈<image href="images/JSJC201903008_067.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>J</i>×<i>I</i><sub><i>n</i></sub></sup>, 则<i>n</i>模乘积的计算公式为<b><i>X</i></b>×<sub><i>n</i></sub><b><i>U</i></b>, 同时张量<b><i>X</i></b>的大小变为<i>I</i><sub>1</sub>×<i>I</i><sub>2</sub>×…×<i>I</i><sub><i>n</i>-1</sub>×<i>J</i>×<i>I</i><sub><i>n</i>+1</sub>×…×<i>I</i><sub><i>N</i></sub>, 公式表达为:</p>
                </div>
                <div class="p1">
                    <p id="68" class="code-formula">
                        <mathml id="68"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><mo>×</mo><msub><mrow></mrow><mi>n</mi></msub><mi mathvariant="bold-italic">U</mi></mrow><mo>) </mo></mrow></mrow><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><mi>j</mi><mi>i</mi><msub><mrow></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn><mo>, </mo><mn>2</mn></mrow></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>i</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow></msub><mo>=</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>i</mi><msub><mrow></mrow><mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow><mrow><mi>Ι</mi><msub><mrow></mrow><mi>n</mi></msub></mrow></munderover><mi>x</mi></mstyle><msub><mrow></mrow><mrow><mi>i</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>i</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>i</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow></msub><mi>u</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>i</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow></msub></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="69">同时, <i>n</i>模乘积的表达式也可进行如下变化:</p>
                </div>
                <div class="p1">
                    <p id="70"><b><i>Y</i></b>=<b><i>X</i></b>×<sub><i>n</i></sub><b><i>U</i></b>⇔<b><i>Y</i></b><sub> (<i>n</i>) </sub>=<b><i>UX</i></b><sub> (<i>n</i>) </sub></p>
                </div>
                <div class="p1">
                    <p id="71">这样张量乘法可以通过矩阵乘法进行计算, 假设存在一个张量<b><i>X</i></b>∈<image href="images/JSJC201903008_072.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup>3×4×2</sup>, 表达式为:</p>
                </div>
                <div class="p1">
                    <p id="73" class="code-formula">
                        <mathml id="73"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>7</mn></mtd><mtd><mn>1</mn><mn>0</mn></mtd></mtr><mtr><mtd><mn>2</mn></mtd><mtd><mn>5</mn></mtd><mtd><mn>8</mn></mtd><mtd><mn>1</mn><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>9</mn></mtd><mtd><mn>1</mn><mn>2</mn></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mo>, </mo><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mn>1</mn><mn>3</mn></mtd><mtd><mn>1</mn><mn>6</mn></mtd><mtd><mn>1</mn><mn>9</mn></mtd><mtd><mn>2</mn><mn>2</mn></mtd></mtr><mtr><mtd><mn>1</mn><mn>4</mn></mtd><mtd><mn>1</mn><mn>7</mn></mtd><mtd><mn>2</mn><mn>0</mn></mtd><mtd><mn>2</mn><mn>3</mn></mtd></mtr><mtr><mtd><mn>1</mn><mn>5</mn></mtd><mtd><mn>1</mn><mn>8</mn></mtd><mtd><mn>2</mn><mn>1</mn></mtd><mtd><mn>2</mn><mn>4</mn></mtd></mtr></mtable></mrow><mo>]</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="74">同时存在一个矩阵<b><i>U</i></b>∈<image href="images/JSJC201903008_075.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup>2×3</sup>, 其表达式为:</p>
                </div>
                <div class="p1">
                    <p id="76" class="code-formula">
                        <mathml id="76"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">U</mi><mo>=</mo><mrow><mo>[</mo><mtable columnalign="left"><mtr><mtd><mn>1</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mn>5</mn></mtd></mtr><mtr><mtd><mn>2</mn><mtext> </mtext><mn>4</mn><mtext> </mtext><mn>6</mn></mtd></mtr></mtable><mo>]</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="77">则<b><i>Y</i></b>=<b><i>X</i></b>×<sub>1</sub><b><i>U</i></b>运算结果为:</p>
                </div>
                <div class="p1">
                    <p id="78" class="code-formula">
                        <mathml id="78"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi mathvariant="bold-italic">Y</mi><msub><mrow></mrow><mn>1</mn></msub><mo>=</mo><mrow><mo>[</mo><mtable columnalign="left"><mtr><mtd><mn>2</mn><mn>2</mn><mtext> </mtext><mn>4</mn><mn>9</mn><mtext> </mtext><mn>7</mn><mn>6</mn><mtext> </mtext><mn>1</mn><mn>0</mn><mn>3</mn></mtd></mtr><mtr><mtd><mn>2</mn><mn>8</mn><mtext> </mtext><mn>6</mn><mn>4</mn><mtext> </mtext><mn>1</mn><mn>0</mn><mn>0</mn><mtext> </mtext><mn>1</mn><mn>3</mn><mn>6</mn></mtd></mtr></mtable><mo>]</mo></mrow></mtd></mtr><mtr><mtd><mi mathvariant="bold-italic">Y</mi><msub><mrow></mrow><mn>2</mn></msub><mo>=</mo><mrow><mo>[</mo><mtable columnalign="left"><mtr><mtd><mn>1</mn><mn>3</mn><mn>0</mn><mtext> </mtext><mn>1</mn><mn>5</mn><mn>7</mn><mtext> </mtext><mn>1</mn><mn>8</mn><mn>4</mn><mtext> </mtext><mn>2</mn><mn>1</mn><mn>1</mn></mtd></mtr><mtr><mtd><mn>1</mn><mn>7</mn><mn>2</mn><mtext> </mtext><mn>2</mn><mn>0</mn><mn>8</mn><mtext> </mtext><mn>2</mn><mn>4</mn><mn>4</mn><mtext> </mtext><mn>2</mn><mn>8</mn><mn>0</mn></mtd></mtr></mtable><mo>]</mo></mrow></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <h4 class="anchor-tag" id="79" name="79">1.2.2 矩阵积</h4>
                <div class="p1">
                    <p id="80">虽然矩阵积的计算原本都属于矩阵计算, 但是在张量分解的核型仍然是矩阵乘法以及矩阵积计算。因此, 本节主要研究<i>Tucker</i>分解算法中的<i>Kronecker</i>积。</p>
                </div>
                <div class="p1">
                    <p id="81">若存在<b><i>A</i></b>∈<image href="images/JSJC201903008_082.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i>×<i>J</i></sup>、<b><i>B</i></b>∈<image href="images/JSJC201903008_083.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>K</i>×<i>L</i></sup>, 则Kronecker积表达为<b><i>A</i></b>⨂<b><i>B</i></b>、结果为<i>IK</i>×<i>JL</i>的矩阵。</p>
                </div>
                <div class="p1">
                    <p id="84" class="code-formula">
                        <mathml id="84"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">X</mi><mo>⊗</mo><mi mathvariant="bold-italic">B</mi><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mi>a</mi><msub><mrow></mrow><mrow><mn>1</mn><mn>1</mn></mrow></msub><mi>B</mi></mtd><mtd><mi>a</mi><msub><mrow></mrow><mrow><mn>1</mn><mn>2</mn></mrow></msub><mi>B</mi></mtd><mtd><mo>⋯</mo></mtd><mtd><mi>a</mi><msub><mrow></mrow><mrow><mn>1</mn><mi>J</mi></mrow></msub><mi>B</mi></mtd></mtr><mtr><mtd><mi>a</mi><msub><mrow></mrow><mrow><mn>2</mn><mn>1</mn></mrow></msub><mi>B</mi></mtd><mtd><mi>a</mi><msub><mrow></mrow><mrow><mn>2</mn><mn>2</mn></mrow></msub><mi>B</mi></mtd><mtd><mo>⋯</mo></mtd><mtd><mi>a</mi><msub><mrow></mrow><mrow><mn>2</mn><mi>J</mi></mrow></msub><mi>B</mi></mtd></mtr><mtr><mtd><mo>⋮</mo></mtd><mtd><mo>⋮</mo></mtd><mtd></mtd><mtd><mo>⋮</mo></mtd></mtr><mtr><mtd><mi>a</mi><msub><mrow></mrow><mrow><mi>Ι</mi><mn>1</mn></mrow></msub></mtd><mtd><mi>a</mi><msub><mrow></mrow><mrow><mi>Ι</mi><mn>2</mn></mrow></msub><mi>B</mi></mtd><mtd><mo>⋯</mo></mtd><mtd><mi>a</mi><msub><mrow></mrow><mrow><mi>Ι</mi><mi>J</mi></mrow></msub><mi>B</mi></mtd></mtr></mtable></mrow><mo>]</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="85">另外有一个和张量乘法有关的公式:假设<b><i>X</i></b>∈<image href="images/JSJC201903008_086.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i><sub>1</sub>×<i>I</i><sub>2</sub>×…×<i>I</i><sub><i>N</i></sub></sup>, 同时<b><i>A</i></b><sub> (<i>n</i>) </sub>∈<image href="images/JSJC201903008_087.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>J</i><sub><i>n</i></sub>×<i>I</i><sub><i>n</i></sub></sup>, 那么对于任意<i>n</i>∈{1, 2, …, <i>N</i>}, 存在以下的公式对等关系:</p>
                </div>
                <div class="p1">
                    <p id="88"><b><i>Y</i></b>=<b><i>X</i></b>×<sub>1</sub><b><i>A</i></b><sup> (1) </sup>×<sub>2</sub><b><i>A</i></b><sup> (2) </sup>×…×<sub><i>N</i></sub><b><i>A</i></b><sup> (<i>N</i>) </sup>⇔<b><i>Y</i></b><sub> (<i>n</i>) </sub>=<b><i>A</i></b><sup> (<i>n</i>) </sup><b><i>X</i></b><sub> (<i>n</i>) </sub> (<b><i>A</i></b><sup> (<i>N</i>) </sup>⨂…⨂<i>A</i><sup> (<i>n</i>-1) </sup>⨂…⨂<i>A</i><sup> (1) </sup>) <sup>T</sup></p>
                </div>
                <h3 id="90" name="90" class="anchor-tag">2 张量Tucker分解算法</h3>
                <h4 class="anchor-tag" id="91" name="91">2.1 相关概念</h4>
                <div class="p1">
                    <p id="92">在张量分解之前, 需要了解和<i>Tucker</i>分解有关的2个概念:张量的秩, 张量分解的非唯一性。</p>
                </div>
                <div class="p1">
                    <p id="93">张量的秩:一个N维张量<b><i>X</i></b>, 它在第<i>n</i>阶张量的秩 (表达式为<mathml id="94"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><msub><mrow></mrow><mi>n</mi></msub><mrow><mo> (</mo><mi>X</mi><mo>) </mo></mrow><mo stretchy="false">) </mo></mrow></math></mathml>为其<b><i>X</i></b><sub> (<i>n</i>) </sub>的列秩。若<mathml id="95"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><msub><mrow></mrow><mi>n</mi></msub><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><msub><mrow></mrow><mi>n</mi></msub><mrow><mo> (</mo><mi mathvariant="bold-italic">X</mi><mo>) </mo></mrow></mrow></math></mathml>且n=1, 2, …, N, 则这个N阶张量<b><i>X</i></b>是一个<mathml id="96"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mo>-</mo><mrow><mo> (</mo><mrow><mi>R</mi><msub><mrow></mrow><mn>1</mn></msub><mo>, </mo><mi>R</mi><msub><mrow></mrow><mn>2</mn></msub><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>R</mi><msub><mrow></mrow><mi>Ν</mi></msub></mrow><mo>) </mo></mrow></mrow></math></mathml>的张量, 而其第n阶对应的秩则为<mathml id="97"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><msub><mrow></mrow><mi>n</mi></msub><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><msub><mrow></mrow><mi>n</mi></msub><mrow><mo> (</mo><mi mathvariant="bold-italic">X</mi><mo>) </mo></mrow></mrow></math></mathml>。</p>
                </div>
                <div class="p1">
                    <p id="98">张量分解的非唯一性:<i>Tucker</i>分解没有唯一解, 这意味着在不破坏拟合的条件下, 可以通过调整因子矩阵而对核心张量进行修改。这说明核心张量可以被调整成对角张量或者超低秩张量 (几乎所有的元素都为0) 。在一般情况下, <i>Tucker</i>的分解条件就是因子矩阵为正交矩阵, 本文也使用这个约束条件<citation id="270" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>。</p>
                </div>
                <h4 class="anchor-tag" id="99" name="99">2.2 <i>Tucker</i>分解定义</h4>
                <div class="p1">
                    <p id="100">Tucker分解是一种高阶的主成分分析, 是将一个高阶张量分解为一个核心张量与张量维度相同数量的矩阵<citation id="271" type="reference"><link href="21" rel="bibliography" /><sup>[<a class="sup">10</a>]</sup></citation>。假设一个三阶张量<b><i>X</i></b>∈<image href="images/JSJC201903008_101.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i>×<i>J</i>×<i>K</i></sup>, 则Tucker分解的表达式为:</p>
                </div>
                <div class="p1">
                    <p id="102" class="code-formula">
                        <mathml id="102"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mi mathvariant="bold-italic">X</mi><mo>≈</mo><mi mathvariant="bold-italic">G</mi><mo>×</mo><msub><mrow></mrow><mn>1</mn></msub><mi mathvariant="bold-italic">A</mi><mo>×</mo><msub><mrow></mrow><mn>2</mn></msub><mi mathvariant="bold-italic">B</mi><mo>×</mo><msub><mrow></mrow><mn>3</mn></msub><mi mathvariant="bold-italic">C</mi><mo>=</mo></mtd></mtr><mtr><mtd><mrow><mtext> </mtext><mtext> </mtext></mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><mi>Ρ</mi></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>q</mi><mo>=</mo><mn>1</mn></mrow><mi>Q</mi></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><mi>g</mi></mstyle></mrow></mstyle></mrow></mstyle><msub><mrow></mrow><mrow><mi>p</mi><mi>q</mi><mi>r</mi></mrow></msub><mi>a</mi><msub><mrow></mrow><mi>p</mi></msub><mo>˚</mo><mi>b</mi><msub><mrow></mrow><mi>q</mi></msub><mo>˚</mo><mi>c</mi><msub><mrow></mrow><mi>r</mi></msub><mo>=</mo><mrow><mo>[</mo><mrow><mrow><mo>[</mo><mrow><mi mathvariant="bold-italic">G</mi><mo>;</mo><mi mathvariant="bold-italic">A</mi><mo>, </mo><mi mathvariant="bold-italic">B</mi><mo>, </mo><mi mathvariant="bold-italic">C</mi></mrow><mo>]</mo></mrow></mrow><mo>]</mo></mrow></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="103">其中, <b><i>A</i></b>∈<image href="images/JSJC201903008_104.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i>×<i>P</i></sup>, <b><i>B</i></b>∈<image href="images/JSJC201903008_105.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>J</i>×<i>Q</i></sup>, <b><i>C</i></b>∈<image href="images/JSJC201903008_106.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>K</i>×<i>R</i></sup>, 这些矩阵被称为因子矩阵, 也可认为是张量在对应模的主成分。张量<b><i>G</i></b>∈<image href="images/JSJC201903008_107.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>P</i>×<i>Q</i>×<i>R</i></sup> 被称为核心张量, 它的元素是不同成分相互作用的结。</p>
                </div>
                <div class="p1">
                    <p id="108">由此可知, Tucker分解元素计算公式为:</p>
                </div>
                <div class="p1">
                    <p id="109" class="code-formula">
                        <mathml id="109"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mi>x</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>j</mi><mi>k</mi></mrow></msub><mo>≈</mo><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>p</mi><mo>=</mo><mn>1</mn></mrow><mi>Ρ</mi></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>q</mi><mo>=</mo><mn>1</mn></mrow><mi>Q</mi></munderover><mrow><mstyle displaystyle="true"><munderover><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mn>1</mn></mrow><mi>R</mi></munderover><mi>g</mi></mstyle></mrow></mstyle></mrow></mstyle><msub><mrow></mrow><mrow><mi>p</mi><mi>q</mi><mi>r</mi></mrow></msub><mi>a</mi><msub><mrow></mrow><mrow><mi>i</mi><mi>p</mi></mrow></msub><mo>˚</mo><mi>b</mi><msub><mrow></mrow><mrow><mi>j</mi><mi>q</mi></mrow></msub><mo>˚</mo><mi>c</mi><msub><mrow></mrow><mrow><mi>k</mi><mi>r</mi></mrow></msub><mo>, </mo></mtd></mtr><mtr><mtd columnalign="left"><mi>i</mi><mo>=</mo><mn>1</mn><mo>, </mo><mn>2</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>Ι</mi><mo>, </mo><mi>j</mi><mo>=</mo><mn>1</mn><mo>, </mo><mn>2</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>J</mi><mo>, </mo><mi>k</mi><mo>=</mo><mn>1</mn><mo>, </mo><mn>2</mn><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>Κ</mi></mtd></mtr></mtable></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="110">其中, <i>P</i>、<i>Q</i>、<i>R</i>是因子矩阵<b><i>A</i>、<i>B</i>、<i>C</i></b>成分数 (此处指列数) , 如果<i>P</i>、<i>Q</i>、<i>R</i>比<i>I</i>、<i>J</i>、<i>K</i>小, 核心张量<b><i>G</i></b>则是压缩版的张量<b><i>X</i></b>。</p>
                </div>
                <div class="p1">
                    <p id="111">三维张量的Tucker分解公式可以拓展到<i>N</i>维, 公式为:</p>
                </div>
                <div class="p1">
                    <p id="112" class="code-formula">
                        <mathml id="112"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mi mathvariant="bold-italic">X</mi><mo>≈</mo><mi mathvariant="bold-italic">G</mi><mo>×</mo><msub><mrow></mrow><mn>1</mn></msub><mi>A</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>×</mo><msub><mrow></mrow><mn>2</mn></msub><mi>A</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></msup><mo>⋯</mo><mo>×</mo><msub><mrow></mrow><mi>Ν</mi></msub><mi>A</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>Ν</mi><mo stretchy="false">) </mo></mrow></msup><mo>=</mo></mtd></mtr><mtr><mtd><mrow><mo>[</mo><mrow><mi mathvariant="bold-italic">G</mi><mo>;</mo><mi>A</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mi>A</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></msup><mo>, </mo><mo>⋯</mo><mo>, </mo><mi>A</mi><msup><mrow></mrow><mrow><mo stretchy="false"> (</mo><mi>Ν</mi><mo stretchy="false">) </mo></mrow></msup></mrow><mo>]</mo></mrow></mtd></mtr></mtable></mrow></math></mathml>
                    </p>
                </div>
                <h4 class="anchor-tag" id="113" name="113">2.3 高阶正交迭代法</h4>
                <div class="p1">
                    <p id="114"><i>Tucker</i>分解算法是文献<citation id="272" type="reference">[<a class="sup">11</a>]</citation>给出的<i>Tucker</i>分解方法, <i>Tucker</i>分解算法如下。</p>
                </div>
                <div class="p1">
                    <p id="115"><b>算法1</b> Tucker分解算法</p>
                </div>
                <div class="area_img" id="281">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903008_28100.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="area_img" id="281">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903008_28101.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="122">算法的基本思想是找到<i>n</i>模对应的矩阵因子, 但是对其方法没有详细阐述。</p>
                </div>
                <div class="p1">
                    <p id="123">这种分解算法被称为高阶奇异值分解 (Higher-order Singular Value Decomposition, HOSVD) , 其来源于De Lathauwer、De Moor和Vandewalle, 文献<citation id="273" type="reference">[<a class="sup">12</a>]</citation>证明HOSVD是矩阵奇异值分解 (Singular Value Decomposition, SVD) , 当满足<i>R</i><sub><i>n</i></sub>&lt;<i>rank</i><sub><i>n</i></sub> (<i>X</i>) 时, HOSVD被称为缩减版HOSVD。基于上述研究, 文献<citation id="274" type="reference">[<a class="sup">13</a>]</citation>提出高阶正交迭代法 (Higher-order Orthogonal Iteration, HOOI) 。</p>
                </div>
                <div class="p1">
                    <p id="124">HOOI算法的关键是求得逼近条件<mathml id="125"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><mo stretchy="false">∥</mo></mrow></math></mathml>最小化 (一般默认是逼近于0) , 其中, <mathml id="126"><math xmlns="http://www.w3.org/1998/Math/MathML"><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover></math></mathml>为Tucker分解获得的矩阵和核心张量所求得的张量。HOOI的算法过程如下。</p>
                </div>
                <div class="p1">
                    <p id="127"><b>算法2</b> 高阶正交迭代法算法</p>
                </div>
                <div class="area_img" id="282">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903008_28200.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="138">在算法2中, 核心张量<b><i>G</i></b>的计算公式为:</p>
                </div>
                <div class="p1">
                    <p id="139"><b><i>G</i></b>≈<b><i>X</i></b>×<sub>1</sub><b><i>A</i></b><sup> (1) </sup><sup>T</sup>×<sub>2</sub><b><i>A</i></b><sup> (2) </sup><sup>T</sup>×…×<sub><i>N</i></sub><b><i>A</i></b><sup> (<i>N</i>) </sup><sup>T</sup></p>
                </div>
                <div class="p1">
                    <p id="140">在通过一系列变化后<citation id="275" type="reference"><link href="29" rel="bibliography" /><sup>[<a class="sup">14</a>]</sup></citation>, 逼近条件<mathml id="141"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><mo stretchy="false">∥</mo></mrow></math></mathml>最小化可以转化为:</p>
                </div>
                <div class="p1">
                    <p id="142"><i>max</i>‖<b><i>X</i></b>×<sub>1</sub><b><i>A</i></b><sup> (1) </sup><sup>T</sup>×<sub>2</sub><b><i>A</i></b><sup> (2) </sup><sup>T</sup>×…×<sub><i>N</i></sub><b><i>A</i></b><sup> (<i>N</i>) </sup><sup>T</sup>‖</p>
                </div>
                <h3 id="143" name="143" class="anchor-tag">3 张量Tucker分解算法的改进</h3>
                <h4 class="anchor-tag" id="144" name="144">3.1 计算过程矩阵化原理</h4>
                <div class="p1">
                    <p id="145">从第1.2.2节可知, 张量乘法可以转化为矩阵运算。根据转换公式, <i>Tucker</i>分解的公式为:</p>
                </div>
                <div class="p1">
                    <p id="146"><b><i>X</i></b><sub> (1) </sub>≈<b><i>AG</i></b><sub> (1) </sub> (<b><i>C</i></b>⨂<b><i>B</i></b>) <sup>T</sup></p>
                </div>
                <div class="p1">
                    <p id="147"><b><i>X</i></b><sub> (2) </sub>≈<b><i>BG</i></b><sub> (2) </sub> (<b><i>C</i></b>⨂<b><i>A</i></b>) <sup>T</sup></p>
                </div>
                <div class="p1">
                    <p id="148"><b><i>X</i></b><sub> (3) </sub>≈<b><i>CG</i></b><sub> (3) </sub> (<b><i>B</i></b>⨂<b><i>A</i></b>) <sup>T</sup></p>
                </div>
                <div class="p1">
                    <p id="149"><i>N</i>维张量的Tucker分解公式矩阵化后为:</p>
                </div>
                <div class="p1">
                    <p id="150"><b><i>X</i></b><sub> (<i>n</i>) </sub>=<b><i>A</i></b><sup> (<i>n</i>) </sup><b><i>G</i></b><sub> (<i>n</i>) </sub> (<b><i>A</i></b><sup> (<i>N</i>) </sup>⨂… ⨂<b><i>A</i></b><sup> (<i>n</i>+1) </sup>⨂<b><i>A</i></b><sup> (<i>n</i>-1) </sup>⨂…⨂<b><i>A</i></b><sup> (1) </sup>) <sup>T</sup></p>
                </div>
                <div class="p1">
                    <p id="151">此处以求因子矩阵<b><i>A</i></b>为例, 根据文献<citation id="276" type="reference">[<a class="sup">14</a>,<a class="sup">19</a>]</citation>的相关内容, 推导三维张量的Tucker分解算法。</p>
                </div>
                <div class="p1">
                    <p id="152">首先, 已知一维展开张量<b><i>X</i></b> (以下简称<b><i>X</i></b><sub> (1) </sub>) 的计算公式为:</p>
                </div>
                <div class="p1">
                    <p id="153"><b><i>X</i></b><sub> (1) </sub>≈<b><i>AG</i></b><sub> (1) </sub> (<b><i>C</i></b>⨂<b><i>B</i></b>) <sup>T</sup></p>
                </div>
                <div class="p1">
                    <p id="154">因为因子矩阵为正交矩阵, 从而得知一维展开核心张量<b><i>G</i></b> (以下简称<b><i>G</i></b><sub> (1) </sub>) 公式为:</p>
                </div>
                <div class="p1">
                    <p id="155"><b><i>G</i></b><sub> (1) </sub>≈<b><i>A</i></b><sup>T</sup><b><i>X</i></b><sub> (1) </sub> (<b><i>C</i></b>⨂<b><i>B</i></b>) </p>
                </div>
                <div class="p1">
                    <p id="156"><b><i>X</i></b><sub> (1) </sub>计算公式中核心张量<b><i>T</i></b>用计算公式替换:</p>
                </div>
                <div class="p1">
                    <p id="157"><b><i>AG</i></b><sub> (1) </sub> (<b><i>C</i></b>⨂<b><i>B</i></b>) <sup>T</sup>=<b><i>AA</i></b><sup>T</sup><b><i>X</i></b><sub> (1) </sub> (<b><i>C</i></b>⨂<b><i>B</i></b>) (<b><i>C</i></b>⨂<b><i>B</i></b>) <sup>T</sup>=<b><i>AA</i></b><sup>T</sup><b><i>X</i></b><sub> (1) </sub> (<b><i>CC</i></b><sup>T</sup>⨂<b><i>BB</i></b><sup>T</sup>) </p>
                </div>
                <div class="p1">
                    <p id="159">为了表达方便, 用<b><i>M</i></b>表示<b><i>X</i></b><sub> (1) </sub> (<b><i>CC</i></b><sup>T</sup>⨂<b><i>BB</i></b><sup>T</sup>) , 则<b><i>X</i></b><sub> (1) </sub>相关表达式为 (此处用<mathml id="160"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub></mrow></math></mathml>表达) :</p>
                </div>
                <div class="p1">
                    <p id="161" class="code-formula">
                        <mathml id="161"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>=</mo><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">A</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mi mathvariant="bold-italic">Μ</mi></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="162">由<i>HOOI</i>算法可知, 迭代算法满足迭代条件为<mathml id="163"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><mo stretchy="false">∥</mo></mrow></math></mathml>最小化。由于张量范数与矩阵的<i>F</i>-范数定义类似, 因此可变化为:</p>
                </div>
                <div class="p1">
                    <p id="164" class="code-formula">
                        <mathml id="164"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign="left"><mtr><mtd><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><mo stretchy="false">∥</mo><mo>=</mo><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false">∥</mo><mo>=</mo></mtd></mtr><mtr><mtd><mrow><mtext> </mtext><mtext> </mtext></mrow><msqrt><mrow><mtext>t</mtext><mtext>r</mtext><mrow><mo> (</mo><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub></mrow><mo>) </mo></mrow><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub></mrow><mo>) </mo></mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow><mo>) </mo></mrow></mrow></msqrt></mtd></mtr></mtable></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="165">因此, 只需计算<i>tr</i><mathml id="166"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false"> (</mo><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false">) </mo><mrow><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false">) </mo></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup><mo stretchy="false">) </mo></mrow></math></mathml>的最小值即可, 该公式可变化为:</p>
                </div>
                <div class="area_img" id="170">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJC201903008_17000.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="171">由于tr<mathml id="172"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow><mo>) </mo></mrow></mrow></math></mathml>是固定值, 因此公式变换时不需要考虑<i>tr</i><mathml id="173"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow><mo>) </mo></mrow></mrow></math></mathml>。</p>
                </div>
                <div class="p1">
                    <p id="174">则公式变化可继续变为:</p>
                </div>
                <div class="area_img" id="175">
                            <div class="imgformula">
                                <img class="pFormula" alt="" src="Detail/GetImg?filename=images/JSJC201903008_17500.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                <p class="formula_seq"></p>
                            </div>

                </div>
                <div class="p1">
                    <p id="179">由于是求<mathml id="180"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">∥</mo><mi mathvariant="bold-italic">X</mi><mo>-</mo><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><mo stretchy="false">∥</mo></mrow></math></mathml>最小值, 同时<i>tr</i><mathml id="181"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mover accent="true"><mi mathvariant="bold-italic">X</mi><mo>^</mo></mover><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow><mo>) </mo></mrow></mrow></math></mathml>数值固定, 则只需要求<i>tr</i><mathml id="182"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">Μ</mi><mi mathvariant="bold-italic">Μ</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mi mathvariant="bold-italic">A</mi><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow><mo>) </mo></mrow></mrow></math></mathml>的最大值即可。而求<i>tr</i><mathml id="183"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">A</mi><mi mathvariant="bold-italic">Μ</mi><mi mathvariant="bold-italic">Μ</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mi mathvariant="bold-italic">A</mi><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow><mo>) </mo></mrow></mrow></math></mathml>的最大值则要求因子矩阵<b><i>A</i></b>为<b><i>MM</i></b><sup>T</sup>最大特征值所对应的特征向量。</p>
                </div>
                <div class="p1">
                    <p id="184">同时, <b><i>MM</i></b><sup>T</sup>本身可简化为:</p>
                </div>
                <div class="p1">
                    <p id="185" class="code-formula">
                        <mathml id="185"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><mi mathvariant="bold-italic">C</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mo>⊗</mo><mspace width="0.25em" /><mi mathvariant="bold-italic">B</mi><mi mathvariant="bold-italic">B</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mo stretchy="false">) </mo></mrow><mo>) </mo></mrow><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><mi mathvariant="bold-italic">C</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mo>⊗</mo><mspace width="0.25em" /><mi mathvariant="bold-italic">B</mi><mi mathvariant="bold-italic">B</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mo stretchy="false">) </mo></mrow><mo>) </mo></mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup><mo>=</mo></mtd></mtr><mtr><mtd columnalign="left"><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><mi mathvariant="bold-italic">C</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mo>⊗</mo><mspace width="0.25em" /><mi mathvariant="bold-italic">B</mi><mi mathvariant="bold-italic">B</mi><msup><mrow></mrow><mtext>Τ</mtext></msup><mo stretchy="false">) </mo><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup><mo>=</mo></mtd></mtr><mtr><mtd columnalign="left"><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><mo>⊗</mo><mspace width="0.25em" /><mi mathvariant="bold-italic">B</mi><mo stretchy="false">) </mo></mrow><mo>) </mo></mrow><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><mo>⊗</mo><mspace width="0.25em" /><mi mathvariant="bold-italic">B</mi><mo stretchy="false">) </mo></mrow><mo>) </mo></mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup></mtd></mtr></mtable></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="186">由上式可知, 因子矩阵<b><i>A</i></b>的求法为<mathml id="187"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo stretchy="false"> (</mo><mi mathvariant="bold-italic">C</mi><mo>⊗</mo><mspace width="0.25em" /><mi mathvariant="bold-italic">B</mi><mo stretchy="false">) </mo></mrow><mo>) </mo></mrow><mrow><mrow><mo> (</mo><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mi mathvariant="bold-italic">C</mi><mo>⊗</mo><mspace width="0.25em" /><mi mathvariant="bold-italic">B</mi><mo stretchy="false">) </mo></mrow><mo>) </mo></mrow></mrow><msup><mrow></mrow><mtext>Τ</mtext></msup></mrow></math></mathml>最大特征值所对应的特征向量。</p>
                </div>
                <h4 class="anchor-tag" id="188" name="188">3.2 改进算法的实现</h4>
                <div class="p1">
                    <p id="189">上文推导出因子公式的求法, 将原本需要进行张量乘法的运算转化为矩阵计算, 本节首先介绍<i>CUDA</i>平台上的<i>CUBLAS</i>的编程库, 然后再说明算法实现的细节, 以便<i>Tucker</i>分解改进算法能够更好地转化为代码。</p>
                </div>
                <h4 class="anchor-tag" id="190" name="190">3.2.1 <i>CUDA</i>与<i>CUBLAS</i></h4>
                <div class="p1">
                    <p id="191"><i>CUDA</i>是一个基于显卡厂商<i>NVIDIA</i>推出的并行运算平台。支持通用运算处理的<i>GPU</i>可以通过<i>CUDA</i>进行通用计算<citation id="277" type="reference"><link href="31" rel="bibliography" /><sup>[<a class="sup">15</a>]</sup></citation>。由于<i>GPU</i>架构是一个<i>SIMD</i>数据并行执行结构, 因此<i>CUDA</i>平台在图像处理、3<i>D</i>建模、高性能运算等方面具有广泛应用。</p>
                </div>
                <div class="p1">
                    <p id="192"><i>BLAS</i>是一个用于向量与矩阵计算的标准程序库。<i>CUBLAS</i>为<i>BLAS</i>在<i>CUDA</i>平台的应用程序编程接口 (<i>API</i>) 。通过<i>CUBLAS</i>的<i>API</i>, 用户可以使用单个<i>GPU</i>来加速应用程序, 或者高效地跨多<i>GPU</i>配置扩展和分发程序<citation id="278" type="reference"><link href="33" rel="bibliography" /><sup>[<a class="sup">16</a>]</sup></citation>。</p>
                </div>
                <h4 class="anchor-tag" id="193" name="193">3.2.2 矩阵与张量的排列存储方式</h4>
                <div class="p1">
                    <p id="194">由于张量在内存存储方式上没有研究先例, 因此需要描述在代码实现中模块所约定的存储方式。本文采用<i>C</i>/<i>C</i>++中矩阵排列方式的行排列方式, 例如, 假设张量<b><i>X</i></b>数据为:</p>
                </div>
                <div class="p1">
                    <p id="195" class="code-formula">
                        <mathml id="195"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mo>;</mo><mo>;</mo><mn>1</mn><mo stretchy="false">) </mo></mrow></msub><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mn>1</mn></mtd><mtd><mn>4</mn></mtd><mtd><mn>7</mn></mtd><mtd><mn>1</mn><mn>0</mn></mtd></mtr><mtr><mtd><mn>2</mn></mtd><mtd><mn>5</mn></mtd><mtd><mn>8</mn></mtd><mtd><mn>1</mn><mn>1</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>9</mn></mtd><mtd><mn>1</mn><mn>2</mn></mtd></mtr></mtable></mrow><mo>]</mo></mrow><mo>, </mo><mi mathvariant="bold-italic">X</mi><msub><mrow></mrow><mrow><mo stretchy="false"> (</mo><mo>;</mo><mo>;</mo><mn>2</mn><mo stretchy="false">) </mo></mrow></msub><mo>=</mo><mrow><mo>[</mo><mrow><mtable><mtr><mtd><mn>1</mn><mn>3</mn></mtd><mtd><mn>1</mn><mn>6</mn></mtd><mtd><mn>1</mn><mn>9</mn></mtd><mtd><mn>2</mn><mn>2</mn></mtd></mtr><mtr><mtd><mn>1</mn><mn>4</mn></mtd><mtd><mn>1</mn><mn>7</mn></mtd><mtd><mn>2</mn><mn>0</mn></mtd><mtd><mn>2</mn><mn>3</mn></mtd></mtr><mtr><mtd><mn>1</mn><mn>5</mn></mtd><mtd><mn>1</mn><mn>8</mn></mtd><mtd><mn>2</mn><mn>1</mn></mtd><mtd><mn>2</mn><mn>4</mn></mtd></mtr></mtable></mrow><mo>]</mo></mrow></mrow></math></mathml>
                    </p>
                </div>
                <div class="p1">
                    <p id="196">那么张量<b><i>X</i></b><sub> (;;1) </sub>在内存中的存储结构为:</p>
                </div>
                <div class="p1">
                    <p id="197"><b><i>X</i></b><sub> (;;1) </sub>=[1 4 7 10 2 5 8 11 3 6 9 12]</p>
                </div>
                <div class="p1">
                    <p id="198">则<b><i>X</i></b><sub> (;;2) </sub>直接排在<b><i>X</i></b><sub> (;;1) </sub>后面。</p>
                </div>
                <h4 class="anchor-tag" id="199" name="199">3.2.3 改进算法的代码实现</h4>
                <div class="p1">
                    <p id="200">根据上文的描述, 可以得到<i>Tucker</i>算法。</p>
                </div>
                <div class="p1">
                    <p id="201"><b>算法3</b> 改进高阶正交迭代法算法</p>
                </div>
                <div class="area_img" id="283">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903008_28300.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="216">为了减少转换所需要的资源和时钟周期, 计算核心张量<b><i>G</i></b>的范数可以转化为计算3-模展开的核心张量<mathml id="217"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="bold-italic">G</mi><msub><mrow></mrow><mrow><mrow><mo> (</mo><mn>3</mn><mo>) </mo></mrow></mrow></msub></mrow></math></mathml>。因此, <i>Tucker</i>分解在计算层面上完全转化为矩阵计算, 仅在最后输出时会进行一次张量转换获得核心张量。</p>
                </div>
                <div class="p1">
                    <p id="218">相关算法对应使用的函数如表1所示。</p>
                </div>
                <div class="area_img" id="219">
                    <p class="img_tit"><b>表1 相关算法对应使用的函数</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="219" border="1"><tr><td><br />计算步骤</td><td>对应计算函数</td></tr><tr><td><br /> (<b><i>C</i></b>⨂ <b><i>B</i></b>) </td><td>Kronecker</td></tr><tr><td><br /><b><i>X</i></b><sub> (1) </sub> (<b><i>C</i></b>⨂ <b><i>B</i></b>) </td><td>cublasSgemm</td></tr><tr><td><br /><b><i>A</i></b>←<b><i>Y</i></b><sub><i>p</i></sub><b><i>Y</i></b><sup>T</sup><sub><i>p</i></sub></td><td>Eigvector</td></tr><tr><td><br />‖<b><i>G</i></b><sub> (3) </sub>‖</td><td>cublasSnrm2</td></tr><tr><td><br /><b><i>G</i></b>←<b><i>G</i></b><sub> (3) </sub></td><td>Tensor_folding</td></tr><tr><td><br /><b><i>X</i></b><sub> (1) </sub>←<b><i>X</i></b></td><td>Tensor_unfolding</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="220">在表1中, Kronecker、Eigvector、Tensor_folding、Tensor_unfolding函数是自编函数。</p>
                </div>
                <h4 class="anchor-tag" id="221" name="221">3.2.4 改进算法的自编函数实现</h4>
                <div class="p1">
                    <p id="222">改进算法的自编函数有以下3种:</p>
                </div>
                <h4 class="anchor-tag" id="223" name="223">1) <i>Kronecker</i>函数</h4>
                <div class="p1">
                    <p id="224">根据第1.2.2节中<i>Kronecker</i>积的定义可知, 在乘积结果 (设乘积结果为<b><i>C</i></b>∈<image href="images/JSJC201903008_225.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>IK</i>×<i>JL</i></sup>) 中, <b><i>A</i></b>∈<image href="images/JSJC201903008_226.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>I</i>×<i>J</i></sup>与<b><i>B</i></b>∈<image href="images/JSJC201903008_227.jpg" type="" display="inline" placement="inline"><alt></alt></image><sup><i>K</i>×<i>L</i></sup>的下标对应关系为:</p>
                </div>
                <div class="p1">
                    <p id="228"><b><i>C</i></b>[<i>i</i>×<i>I</i>×<i>K</i>+<i>j</i>]=<b><i>A</i></b>[ (<i>i</i>/<i>K</i>) ×<i>I</i>+ (<i>j</i>/<i>L</i>) ]×<b><i>B</i></b>[ (<i>i</i>%<i>K</i>) ×<i>K</i>+ (<i>j</i>%<i>L</i>) ]</p>
                </div>
                <div class="p1">
                    <p id="230">其中, <i>i</i>与<i>j</i>为乘积结果的横向下标和纵向下标。</p>
                </div>
                <div class="p1">
                    <p id="231">通过上述方式即可计算Kronecker积。</p>
                </div>
                <h4 class="anchor-tag" id="232" name="232">2) Eigvector函数</h4>
                <div class="p1">
                    <p id="233">由于所求对象是对称函数, 因此此处求特征向量的方法是:首先使用圆盘原理求得特征值<citation id="280" type="reference"><link href="35" rel="bibliography" /><sup>[<a class="sup">17</a>]</sup></citation>, 然后使用对应的特征值依照定义求特征向量。</p>
                </div>
                <h4 class="anchor-tag" id="234" name="234">3) Tensor_folding与Tensor_unfolding函数</h4>
                <div class="p1">
                    <p id="235">从第3.2.2节可知, 张量表达式是一个个依照<b><i>X</i></b><sub> (;;1) </sub>, <b><i>X</i></b><sub> (;;2) </sub>, …, <b><i>X</i></b><sub> (;;<i>K</i>) </sub>衔接排列, 只要对<b><i>X</i></b><sub> (;;<i>k</i>) </sub>进行转置即可获得3-模展开的张量。由此可以获得Tensor_folding函数是依靠这个方式获得核心函数<i>G</i>, Tucker分解模块中使用3-模展开的核心张量<b><i>G</i></b><sub> (3) </sub>。</p>
                </div>
                <div class="p1">
                    <p id="236">1-模展开和2-模展开在内存中则是和<b><i>X</i></b>、<b><i>X</i></b><sub> (3) </sub>互相对应。1-模展开张量<b><i>X</i></b><sub> (1) </sub>是把依照<b><i>X</i></b><sub> (;;<i>k</i>) </sub>的行接到<b><i>X</i></b><sub> (;;<i>k</i>+1) </sub>前面, 依此类推, 2-模展开张量<b><i>X</i></b><sub> (2) </sub>则是对<b><i>X</i></b><sub> (3) </sub>进行相同操作获得。</p>
                </div>
                <h3 id="237" name="237" class="anchor-tag">4 张量Tucker分解算法模块性能测试</h3>
                <div class="p1">
                    <p id="238">本节主要是对比<i>Tucker</i>算法在<i>C</i>语言、<i>CUDA</i>平台和<i>CUBLAS</i>下的表现。由于<i>CUBLAS</i>是一个比较新的工具, 因此首先比对<i>CUBLAS</i>和<i>C</i>语言的性能。</p>
                </div>
                <h4 class="anchor-tag" id="239" name="239">4.1 <i>CUBLAS</i>与<i>C</i>语言性能比对</h4>
                <div class="p1">
                    <p id="240">为了显示<i>CUBLAS</i>在计算矩阵乘法上的性能, 本文使用<i>CUBLAS</i>与<i>C</i>语言各编写一个矩阵乘法模块, 对比不同平台进行矩阵计算所需的时间。本文测试环境为:</p>
                </div>
                <div class="area_img" id="284">
                                <img alt="" src="Detail/GetImg?filename=images/JSJC201903008_28400.jpg&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="247">表2为<i>CUBLAS</i>与<i>C</i>语言在计算相同规模矩阵所用的时间对比。</p>
                </div>
                <div class="area_img" id="248">
                    <p class="img_tit"><b>表2 CUBLAS与C语言所用时间对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="248" border="1"><tr><td rowspan="2"><br />矩阵阶数</td><td colspan="2"><br />用时/s</td></tr><tr><td><br />CUBLAS</td><td>C语言</td></tr><tr><td><br />480</td><td>0.138</td><td> 125</td></tr><tr><td><br />512</td><td>1.137</td><td>1 927</td></tr><tr><td><br />768</td><td>2.833</td><td>5 401</td></tr><tr><td><br />1 024</td><td>6.265</td><td>29 728</td></tr><tr><td><br />1 280</td><td>12.741</td><td>32 536</td></tr><tr><td><br />1 536</td><td>21.277</td><td>76 114</td></tr><tr><td><br />1 792</td><td>35.096</td><td>63 075</td></tr><tr><td><br />2 048</td><td>47.776</td><td>186 042</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="249">通过表2可以明显看出, 使用C语言进行矩阵乘法计算所使用的时间不仅远远高于使用CUBLAS所消耗的时间, 而且在矩阵规模超过1 000以后, C语言所消耗的时间开始突然增加, 而CUBLAS所消耗的时间则增长有限。</p>
                </div>
                <h4 class="anchor-tag" id="250" name="250">4.2 模块对比测试结果</h4>
                <div class="p1">
                    <p id="251">本文模块性能对比测试的目的是为了显示出Tucker分解优化算法以及使用CUBLAS后的性能对比。</p>
                </div>
                <div class="p1">
                    <p id="252">表3、表4为使用CUBLAS、CUDA、C语言的Tucker分解优化算法所用时间对比及性能对比。表5、表6是在相同情况下使用优化算法和不使用优化算法所用时间对比以及性能对比。</p>
                </div>
                <div class="area_img" id="253">
                    <p class="img_tit"><b>表3 CUBLAS、CUDA与C语言所用时间对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="253" border="1"><tr><td rowspan="2"><br />三阶张量规模</td><td colspan="3"><br />用时/s</td></tr><tr><td><br />CUBLAS</td><td>CUDA</td><td>C语言</td></tr><tr><td>512×512×512</td><td>0.011</td><td>0.308</td><td>9.638</td></tr><tr><td><br />768×768×768</td><td>0.027</td><td>1.043</td><td>34.800</td></tr><tr><td><br />1 024×1 024×1 024</td><td>0.058</td><td>2.468</td><td>212.496</td></tr><tr><td><br />1 280×1 280×1 280</td><td>0.117</td><td>4.832</td><td>175.933</td></tr><tr><td><br />1 536×1 536×1 536</td><td>0.199</td><td>8.347</td><td>702.639</td></tr><tr><td><br />1 792×1 792×1 792</td><td>0.322</td><td>13.227</td><td>582.358</td></tr><tr><td><br />2 048×2 048×2 048</td><td>0.440</td><td>19.725</td><td>1 838.819</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="254">
                    <p class="img_tit"><b>表4 CUBLAS、CUDA与C语言性能对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="254" border="1"><tr><td rowspan="2"><br />三阶张量规模</td><td colspan="3"><br />性能/ (Gflop·s<sup>-1</sup>) </td></tr><tr><td><br />CUBLAS</td><td>CUDA</td><td>C语言</td></tr><tr><td>512×512×512</td><td>170.13</td><td>7.82</td><td>0.26</td></tr><tr><td><br />768×768×768</td><td>219.97</td><td>7.82</td><td>0.13</td></tr><tr><td><br />1 024×1 024×1 024</td><td>305.71</td><td>7.88</td><td>0.09</td></tr><tr><td><br />1 280×1 280×1 280</td><td>320.66</td><td>7.83</td><td>0.22</td></tr><tr><td><br />1 536×1 536×1 536</td><td>327.50</td><td>7.81</td><td>0.09</td></tr><tr><td><br />1 792×1 792×1 792</td><td>321.17</td><td>7.83</td><td>0.18</td></tr><tr><td><br />2 048×2 048×2 048</td><td>350.83</td><td>7.84</td><td>0.08</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="255">
                    <p class="img_tit"><b>表5 使用CUBLAS情况下所用时间对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="255" border="1"><tr><td rowspan="2"><br />三阶张量规模</td><td colspan="2"><br />用时/s</td></tr><tr><td><br />优化算法</td><td>非优化算法</td></tr><tr><td><br />512×512×512</td><td>0.011</td><td>0.101</td></tr><tr><td><br />768×768×768</td><td>0.027</td><td>0.187</td></tr><tr><td><br />1 024×1 024×1 024</td><td>0.058</td><td>0.698</td></tr><tr><td><br />1 280×1 280×1 280</td><td>0.117</td><td>1.646</td></tr><tr><td><br />1 536×1 536×1 536</td><td>0.199</td><td>4.984</td></tr><tr><td><br />1 792×1 792×1 792</td><td>0.322</td><td>5.821</td></tr><tr><td><br />2 048×2 048×2 048</td><td>0.440</td><td>8.796</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="area_img" id="256">
                    <p class="img_tit"><b>表6 使用CUBLAS情况下性能对比</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="256" border="1"><tr><td rowspan="2"><br />三阶张量规模</td><td colspan="2"><br />性能/ (Gflop·s<sup>-1</sup>) </td></tr><tr><td><br />优化算法</td><td>非优化算法</td></tr><tr><td><br />512×512×512</td><td>170.13</td><td>23.25</td></tr><tr><td><br />768×768×768</td><td>219.97</td><td>44.63</td></tr><tr><td><br />1 024×1 024×1 024</td><td>305.71</td><td>27.69</td></tr><tr><td><br />1 280×1 280×1 280</td><td>320.66</td><td>23.07</td></tr><tr><td><br />1 536×1 536×1 536</td><td>327.50</td><td>13.09</td></tr><tr><td><br />1 792×1 792×1 792</td><td>321.17</td><td>18.80</td></tr><tr><td><br />2 048×2 048×2 048</td><td>350.83</td><td>18.57</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <div class="p1">
                    <p id="257">从表3～表6可以看出, 使用了CUBLAS并加上Tucker优化算法的模块, 性能远超使用非优化算法CUBLAS的模块、使用CUDA平台的模块以及使用C语言所编写的模块。</p>
                </div>
                <h3 id="258" name="258" class="anchor-tag">5 结束语</h3>
                <div class="p1">
                    <p id="259">本文设计一种基于CUBLAS以及优化分解算法的张量Tucker分解模块。利用优化后的Tucker分解算法, 省去了张量展开环节, 节约了计算资源时间, 同时运用CUBLAS实现了在单个GPU上获得远超多GPU的加速效果, 提高了张量Tucker分解计算效率。但是, 本文模块具有一定的局限性, 如本文模块面向分解的张量是一般张量, 对稀疏度很大的张量的Tucker分解未进行相应加速, 也没有对有特殊要求的张量分解进行讨论 (例如在非负约束情况下) 。上述问题将是后续研究的重点。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=9787560842400001&amp;v=MDYzMTNidm5LcmlmWnU5dUZDdmpVN25KSlY4UlhGcXpHYmErSHRuSXJZdEZaT3NQRFJNOHp4VVNtRGQ5U0g3bjN4RTlm&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 张若京.张量分析简明教程[M].上海:同济大学出版社, 2010.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CMFD&amp;filename=1016181986.nh&amp;v=MzE3MTdCdEdGckNVUkxPZVplUm9GeTdrVnI3TlZGMjZHTEt3SDlqRXFaRWJQSVFLREg4NHZSNFQ2ajU0TzN6cXE=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 王明月.基于张量分解的统计模型及其应用[D].苏州:苏州科技大学, 2016.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSYJ201609069&amp;v=MTI4NjdUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnk3a1ZyN05MejdTWkxHNEg5Zk1wbzlEYllRS0RIODR2UjQ=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[3]</b> 徐联微, 杨晓梅.基于迭代张量高阶奇异值分解的运动目标提取[J].计算机应用研究, 2016, 33 (9) :2856-2861.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Tensor decompositions and applications">

                                <b>[4]</b> KOLDA T G, BADER B W.Tensor decomposition and applications[J].Slam, 2009, 51 (3) :455-500.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=HBYD201202010&amp;v=MTQwNTVFWklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnk3a1ZyN05MUy9TYXJHNEg5UE1yWTk=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[5]</b> 张梦元.基于CUDA的矩阵乘法的并行实现[J].信息通信, 2012, 2 (2) :20-21.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1018067359.nh&amp;v=MDY2NDVMT2VaZVJvRnk3a1ZyN05WRjI2RnJPK0dkTEpwcEViUElRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVI=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> 张雄军.图像恢复和低秩张量逼近的模型及算法研究[D].长沙:湖南大学, 2017.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1012277442.nh&amp;v=MDk1NDZHL0dkWElyWkViUElRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnk3a1ZyN05WRjI2SEw=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b> 杨洪礼.非负矩阵与张量分解及其应用[D].青岛:山东科技大学, 2011.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" >
                                    <b>[8]</b>
                                 张雄军.图像恢复和低秩张量逼近的模型及算法研究[D].长沙:湖南大学, 2017.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CDFD&amp;filename=1015355434.nh&amp;v=MDM5Njc5RzlYUHE1RWJQSVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeTdrVnI3TlZGMjZHN0M=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[9]</b> 王丽琪.张量的低秩逼近与梯度流方法[D].大连:大连理工大学, 2015.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=FDXB201303013&amp;v=Mjg0NjlqNTRPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5N2tWcjdOSXluVGJMRzRIOUxNckk5RVo0UUtESDg0dlI0VDY=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[10]</b> 王磊, 王斌, 张立明.基于张量分析和小波包变换的高光谱图像压缩[J].复旦学报 (自然科学版) , 2013, 52 (3) :371-379.
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00001068384&amp;v=Mjc3MThPNEh0SE5yNGxOWitNTFkzazV6QmRoNGo5OVNYcVJyeG94Y01IN1I3cWVidWR0RkM3bFZiN05JVnM9Tmo3QmFy&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[11]</b> TUCKER L R.Some mathematical notes on three-mode factor analysis[J].Psychometrika, 1966, 31 (3) :279-311.
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A Multilinear Singular Value Decomposition">

                                <b>[12]</b> LATHAUWER L D, MOOR B D, VANDWEALLE J.A multilinear singular value decomposition[J].SIAM Journal on Matrix Analysis and Applications, 2000, 21 (4) :1253-1278.
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On the Best Rank-1 and Rank-(R1,R2,. . .,RN) Approximation of Higher-Order Tensors">

                                <b>[13]</b> LATHAUWER L D, MOOR B D, VANDWEALLE J.On the best rank-1 and rank- (<i>R</i><sub>1</sub>, <i>R</i><sub>2</sub>, …, <i>R</i><sub><i>N</i></sub>) approximation of higherorder tensors[J].SIAM Journal on Matrix Analysis and Applications, 2000, 21 (4) :123-149.
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_14" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012300186513&amp;v=MzE0NjRaZVp1SHlqbVVMbklKbDhSYXhjPU5pZk9mYks3SHRET3JJOUZaZU1KQ1gwNm9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1udw==&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[14]</b> ANDERSSON C A, BRO R.Improving the speed of multiway algorithms:Part II:compression[J].Chemometrics and Intelligent Laboratory Systems, 1998, 42 (1/2) :105-113.
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_15" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Evaluation and tuning of the Level 3 CUBLAS for graphics processors">

                                <b>[15]</b> BARRACHINA S, CASTILLO M, IGUAL F D, et al.Evaluation and tuning of the Level 3 CUBLAS for graphics processors[C]//Proceedings of IEEE International Symposium on Parallel and Distributed Processing.Washington D.C., USA:IEEE Press, 2008:1-8.
                            </a>
                        </p>
                        <p id="33">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=HNDX201704020&amp;v=MjgyMTJxNDlIWklRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnk3a1ZyN05MU1BQZHJHNEg5Yk0=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b> 周海芳, 高畅, 方民权.基于CUBLAS和CUDA 的MNF并行算法设计与优化[J].湖南大学学报 (自然科学版) , 2017, 44 (4) :147-156.
                            </a>
                        </p>
                        <p id="35">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CBBD&amp;filename=0007030073770999&amp;v=MjU3NjhmYnZuS3JpZlp1OXVGQ3ZqVTduSkpWOFJWVjI3R2JPN0h0SExySWhDWk9JR0JSTTh6eFVTbURkOVNIN24zeEU5&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b> 张韵华.数值计算方法和算法[M].北京:科学出版社, 2000.
                            </a>
                        </p>
                        <p id="37">
                            <a id="bibliography_18" target="_blank" href="http://scholar.cnki.net/result.aspx?q=On optimizing distributed tucker decomposition for dense tensors">

                                <b>[18]</b> CHAKARAVARTHY V T, CHOI J W, JOSEPH D J, et al.On optimizing distributed tucker decomposition for dense tensors[C]//Proceedings of IEEE Parallel and Distributed Processing Symposium.Washington D.C., USA:IEEE Press, 2017:1038-1047.
                            </a>
                        </p>
                        <p id="39">
                            <a id="bibliography_19" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SSJD&amp;filename=SSJD00001071651&amp;v=MTgwMzV0RkM3bFZiN05JVnM9Tmo3QmFyTzRIdEhOcjRoRVl1NE9ZM2s1ekJkaDRqOTlTWHFScnhveGNNSDdSN3FlYnVk&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[19]</b> KROOONENBERG P M, LEEUW J D, CASTILLO M.Principal component analysis of three-mode data by means of alternating least squares algorithms[J].Psychometrika, 1980, 45 (1) :69-97.
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJC201903008" />
        <input id="dpi" type="hidden" value="300" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201903008&amp;v=MDQ4OTJPM3pxcUJ0R0ZyQ1VSTE9lWmVSb0Z5N2tWcjdOTHo3QmJiRzRIOWpNckk5RmJJUUtESDg0dlI0VDZqNTQ=&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0lPUU45dm52MzRMT3pvcFZMMjlLRVVpST0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="1" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
