<!DOCTYPE html>
<html>
<head>
    <title>全文阅读--XML全文阅读--中国知网</title>
    <link rel="icon" href="/kxreader/favicon.ico" />
    <link rel="shortcut Icon" href="/kxreader/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="文献 XML KBASE CNKI 中国知网" />
    <meta name="description" content="XML文献检索" />
    <link href="/kxreader/Content/css/detail?v=qX2z2KjRAEyQiNfAbKtl7dLnsqFoQ5Jdw3TZfDf0n1k1" rel="stylesheet"/>

    <script type="text/javascript">
        var APPPATH = '/kxreader';
    </script>
</head>

<body>
    
<script type="text/javascript" src="//login.cnki.net/TopLogin/api/loginapi/get?type=top&amp;localCSS=&amp;returnurl=%2f%2fkns.cnki.net%2f%2fKXReader%2fDetail%3fTIMESTAMP%3d637130603516681250%26DBCODE%3dCJFD%26TABLEName%3dCJFDLAST2019%26FileName%3dJSJC201904026%26RESULT%3d1%26SIGN%3dDjJ2h4KNllAU02ExLpt6mQEkO4Q%253d"></script>

<div id="headerBox" class="header">
    <div class="topbar">
        <div class="textalign">
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201904026&amp;align=md">
                <i class="icon-cen active" title="居中对齐"></i>
            </a>
            <a href="/kxreader/Detail?dbcode=CJFD&amp;filename=JSJC201904026&amp;align=lt">
                <i class="icon-left " title="左对齐"></i>
            </a>
        </div>
        <h6 class="free-tip"><i class="icon"></i>HTML阅读开放试用阶段，欢迎体验！</h6>
    </div>
</div>

    



<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201904026&amp;v=MjY4NDVSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeS9uVXIzUEx6N0JiYkc0SDlqTXE0OUhZb1FLREg4NHY=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>

    <div class="main">

        

    <div class="sidebar-a">
        <!--sidebar start-->
        <div class="sidenav">
            <div class="arrow"><span></span></div>
            <!--sidebar_list start-->
            <dl class="sidenav-list">
                    <dt class="tit">目录结构</dt>
                            <dd class="guide">
                                    <p><a href="#37" data-title="0 概述 ">0 概述</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#42" data-title="1 相关工作 ">1 相关工作</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#53" data-title="2 子串抽取技术和匹配引擎 ">2 子串抽取技术和匹配引擎</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#55" data-title="2.1 解析树构造">2.1 解析树构造</a></li>
                                                <li><a href="#97" data-title="2.2 最长子串抽取">2.2 最长子串抽取</a></li>
                                                <li><a href="#174" data-title="2.3 逻辑关系子串抽取">2.3 逻辑关系子串抽取</a></li>
                                                <li><a href="#179" data-title="2.4 正则表达式匹配引擎">2.4 正则表达式匹配引擎</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#205" data-title="3 实验结果与分析 ">3 实验结果与分析</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#208" data-title="3.1 抽取算法性能">3.1 抽取算法性能</a></li>
                                                <li><a href="#214" data-title="3.2 预过滤系统性能">3.2 预过滤系统性能</a></li>
                                                <li><a href="#226" data-title="3.3 与开源匹配引擎对比测试">3.3 与开源匹配引擎对比测试</a></li>
                                    </ul>
                            </dd>
                            <dd class="guide">
                                    <p><a href="#229" data-title="4 结束语 ">4 结束语</a><i></i></p>
                                                            </dd>
                            <dd class="guide">
                                    <p><a href="#" data-title="文内图表 ">文内图表</a><i></i></p>
                                                                    <ul class="contentbox">
                                                <li><a href="#59" data-title="&lt;b&gt;图1 正则表达式解析树&lt;/b&gt;"><b>图1 正则表达式解析树</b></a></li>
                                                <li><a href="#102" data-title="&lt;b&gt;图2 正则表达式最长子串抽取示例&lt;/b&gt;"><b>图2 正则表达式最长子串抽取示例</b></a></li>
                                                <li><a href="#108" data-title="&lt;b&gt;图3 最长子串抽取算法&lt;/b&gt;"><b>图3 最长子串抽取算法</b></a></li>
                                                <li><a href="#183" data-title="&lt;b&gt;图4 基于子串抽取的正则匹配引擎框架&lt;/b&gt;"><b>图4 基于子串抽取的正则匹配引擎框架</b></a></li>
                                                <li><a href="#207" data-title="&lt;b&gt;表1 规则集统计数据&lt;/b&gt;"><b>表1 规则集统计数据</b></a></li>
                                                <li><a href="#211" data-title="&lt;b&gt;图5 各规则集平均抽取时间结果&lt;/b&gt;"><b>图5 各规则集平均抽取时间结果</b></a></li>
                                                <li><a href="#213" data-title="&lt;b&gt;图6 各规则集抽取比例结果&lt;/b&gt;"><b>图6 各规则集抽取比例结果</b></a></li>
                                                <li><a href="#219" data-title="&lt;b&gt;图7 预处理时间分析&lt;/b&gt;"><b>图7 预处理时间分析</b></a></li>
                                                <li><a href="#221" data-title="&lt;b&gt;图8 匹配速度分析&lt;/b&gt;"><b>图8 匹配速度分析</b></a></li>
                                                <li><a href="#223" data-title="&lt;b&gt;图9 预过滤命中数量分析&lt;/b&gt;"><b>图9 预过滤命中数量分析</b></a></li>
                                                <li><a href="#225" data-title="&lt;b&gt;图10 http规则集匹配速度与预过滤命中数量分析&lt;/b&gt;"><b>图10 http规则集匹配速度与预过滤命中数量分析</b></a></li>
                                                <li><a href="#228" data-title="&lt;b&gt;图11 各匹配引擎的速度对比结果&lt;/b&gt;"><b>图11 各匹配引擎的速度对比结果</b></a></li>
                                    </ul>
                            </dd>
                                    <dd class="guide">
                                        <h6>
                                            <p><a href="#a_bibliography">参考文献</a> </p>
                                        </h6>
                                    </dd>

            </dl>
        </div>
        <!--sidebar end-->
        &nbsp;
        <!--此处有一空格符 勿删-->
    </div>

                <div class="sidebar-b three-collumn" style="width:0;">
            <div class="refer" style="width: 0;">
                <div class="arrow off" title="参考文献"><span></span></div>
                <div class="js-scrollbox" >
                    
                    <div class="subbox active">
                        <h4>
                            <span class="tit">参考文献</span>
                            <a class="close" href="javascript:void(0)">x</a>
                        </h4>
                        <div class="side-scroller">
                            <ul class="refer-list">
                                <li id="3">


                                    <a id="bibliography_1" title=" 褚衍杰, 李云照, 魏强.一种改进的多模式匹配算法[J].西安电子科技大学学报 (自然科学版) , 2014 (6) :174-180." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XDKD201406029&amp;v=MDg2MzJGeS9uVXIzUFBTbkFhckc0SDlYTXFZOUhiWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm8=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[1]</b>
                                         褚衍杰, 李云照, 魏强.一种改进的多模式匹配算法[J].西安电子科技大学学报 (自然科学版) , 2014 (6) :174-180.
                                    </a>
                                </li>
                                <li id="5">


                                    <a id="bibliography_2" title=" 赵毅, 朱鹏, 迟学斌, 等.浅析高性能计算应用的需求与发展[J].计算机研究与发展, 2007, 44 (10) :1640-1646." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200710001&amp;v=MzEwODl0Yk5yNDlGWllRS0RIODR2UjRUNmo1NE8zenFxQnRHRnJDVVJMT2VaZVJvRnkvblVyM1BMeXZTZExHNEg=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[2]</b>
                                         赵毅, 朱鹏, 迟学斌, 等.浅析高性能计算应用的需求与发展[J].计算机研究与发展, 2007, 44 (10) :1640-1646.
                                    </a>
                                </li>
                                <li id="7">


                                    <a id="bibliography_3" title=" XU C, CHEN S, SU J, et al.A survey on regular expression matching for deep packet inspection:applications, algorithms, and hardware platforms[J].IEEE Communications Surveys and Tutorials, 2016, 18 (4) :2991-3029." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=A survey on regular expression matching for deep packet inspection:applications,algorithms,and hardware platforms">
                                        <b>[3]</b>
                                         XU C, CHEN S, SU J, et al.A survey on regular expression matching for deep packet inspection:applications, algorithms, and hardware platforms[J].IEEE Communications Surveys and Tutorials, 2016, 18 (4) :2991-3029.
                                    </a>
                                </li>
                                <li id="9">


                                    <a id="bibliography_4" >
                                        <b>[4]</b>
                                     刘燕兵.高性能正则表达式匹配技术研究[D].北京:中国科学院大学, 2012.</a>
                                </li>
                                <li id="11">


                                    <a id="bibliography_5" title=" BECCHI M, CADAMBI S.Memory-efficient regular expression search using state merging[C]//Proceedings of the 26th IEEE International Conference on Computer Communications.Washington D.C., USA:IEEE Press, 2007:1064-1072." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Memory-efficient regular expression search using state merging">
                                        <b>[5]</b>
                                         BECCHI M, CADAMBI S.Memory-efficient regular expression search using state merging[C]//Proceedings of the 26th IEEE International Conference on Computer Communications.Washington D.C., USA:IEEE Press, 2007:1064-1072.
                                    </a>
                                </li>
                                <li id="13">


                                    <a id="bibliography_6" title=" FICARA D, GIORDANO S, PROCISSI G, et al.An improved DFA for fast regular expression matching[J].ACM SIGCOMM Computer Communication Review, 2008, 38 (5) :29-40." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000047086&amp;v=MDA5MjVycVFUTW53WmVadUh5am1VTG5JSjF3VmFCVT1OaWZJWTdLN0h0ak5yNDlGWk84SURIUS9vQk1UNlQ0UFFIL2lyUmRHZQ==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[6]</b>
                                         FICARA D, GIORDANO S, PROCISSI G, et al.An improved DFA for fast regular expression matching[J].ACM SIGCOMM Computer Communication Review, 2008, 38 (5) :29-40.
                                    </a>
                                </li>
                                <li id="15">


                                    <a id="bibliography_7" title=" FICARA D, PIETRO A D, GIORDANO S, et al.Differential encoding of DFAs for fast regular expression matching[J].IEEE/ACM Transactions on Networking, 2011, 19 (3) :683-694." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000009385&amp;v=MTAzNzAvaXJSZEdlcnFRVE1ud1plWnVIeWptVUxuSUoxd1ZhQlU9TmlmSVk3SzdIdGpOcjQ5RlpPc0dEM1E4b0JNVDZUNFBRSA==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[7]</b>
                                         FICARA D, PIETRO A D, GIORDANO S, et al.Differential encoding of DFAs for fast regular expression matching[J].IEEE/ACM Transactions on Networking, 2011, 19 (3) :683-694.
                                    </a>
                                </li>
                                <li id="17">


                                    <a id="bibliography_8" title=" KONG S, SMITH R, ESTAN C.Efficient signature matching with multiple alphabet compression tables[C]//Proceedings of the 4th International Conference on Security and Privacy in Communication Networks.New York, USA:ACM Press, 2008." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Efficient signature matching with multiple alphabet compression tables">
                                        <b>[8]</b>
                                         KONG S, SMITH R, ESTAN C.Efficient signature matching with multiple alphabet compression tables[C]//Proceedings of the 4th International Conference on Security and Privacy in Communication Networks.New York, USA:ACM Press, 2008.
                                    </a>
                                </li>
                                <li id="19">


                                    <a id="bibliography_9" title=" LIU Y, GUO L, LIU P, et al.Compressing regular expressions’ DFA table by matrix decomposition[C]//Proceedings of the 15th International Conference on Implementation and Application of Automata.Berlin, Germany:Springer, 2010:282-289." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Compressing regular expressions&amp;#39;&amp;#39; DFA table by matrix decomposition">
                                        <b>[9]</b>
                                         LIU Y, GUO L, LIU P, et al.Compressing regular expressions’ DFA table by matrix decomposition[C]//Proceedings of the 15th International Conference on Implementation and Application of Automata.Berlin, Germany:Springer, 2010:282-289.
                                    </a>
                                </li>
                                <li id="21">


                                    <a id="bibliography_10" title=" SMITH R, ESTAN C, JHA S.XFA:faster signature matching with extended automata[C]//Proceedings of IEEE Symposium on Security and Privacy.Washington D.C., USA:IEEE Computer Society, 2008:187-201." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=XFA: Faster Signature Matching with Extended Automata">
                                        <b>[10]</b>
                                         SMITH R, ESTAN C, JHA S.XFA:faster signature matching with extended automata[C]//Proceedings of IEEE Symposium on Security and Privacy.Washington D.C., USA:IEEE Computer Society, 2008:187-201.
                                    </a>
                                </li>
                                <li id="23">


                                    <a id="bibliography_11" title=" SMITH R D.Toward robust network payload inspection[D].Madison, USA:University of Wisconsin at Madison, 2009." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Toward robust network payload inspection">
                                        <b>[11]</b>
                                         SMITH R D.Toward robust network payload inspection[D].Madison, USA:University of Wisconsin at Madison, 2009.
                                    </a>
                                </li>
                                <li id="25">


                                    <a id="bibliography_12" title=" YANG Y E, PRASANNA V K.Space-time tradeoff in regular expression matching with semi-deterministic finite automata[C]//Proceedings of IEEE International Conference on Computer Communications.Washington D.C., USA:IEEE Press, 2011:1853-1861." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Space-time tradeoff in regular expression matching withsemi-deterministic finite automata">
                                        <b>[12]</b>
                                         YANG Y E, PRASANNA V K.Space-time tradeoff in regular expression matching with semi-deterministic finite automata[C]//Proceedings of IEEE International Conference on Computer Communications.Washington D.C., USA:IEEE Press, 2011:1853-1861.
                                    </a>
                                </li>
                                <li id="27">


                                    <a id="bibliography_13" title=" MAJUMDER A, RASTOGI R, VANAMA S.Scalable regular expression matching on data streams[C]//Proceedings of ACM SIGMOD International Conference on Management of Data.New York, USA:ACM Press, 2008:161-172." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Scalable regular expression matching on data streams">
                                        <b>[13]</b>
                                         MAJUMDER A, RASTOGI R, VANAMA S.Scalable regular expression matching on data streams[C]//Proceedings of ACM SIGMOD International Conference on Management of Data.New York, USA:ACM Press, 2008:161-172.
                                    </a>
                                </li>
                                <li id="29">


                                    <a id="bibliography_14" title=" ROHRER J, ATASU K, LUNTEREN J, et al.Memory-efficient distribution of regular expressions for fast deep packet inspection[C]//Proceedings of the 7th IEEE/ACM International Conference on Hardware/Software Codesign and System Synthesis.New York, USA:ACM Press, 2009:147-154." target="_blank"
                                       href="http://scholar.cnki.net/result.aspx?q=Memory-efficient distribution of regular expressions for fastdeep packet inspection">
                                        <b>[14]</b>
                                         ROHRER J, ATASU K, LUNTEREN J, et al.Memory-efficient distribution of regular expressions for fast deep packet inspection[C]//Proceedings of the 7th IEEE/ACM International Conference on Hardware/Software Codesign and System Synthesis.New York, USA:ACM Press, 2009:147-154.
                                    </a>
                                </li>
                                <li id="31">


                                    <a id="bibliography_15" title=" WATSON B W.A new regular grammar pattern matching algorithm[J].Theoretical Computer Science, 1996, 299 (1/2/3) :364-377." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012100983186&amp;v=MTg3NTZVTG5JSjF3VmFCVT1OaWZPZmJLN0h0RE9ybzlGYmVNTURYUS9vQk1UNlQ0UFFIL2lyUmRHZXJxUVRNbndaZVp1SHlqbQ==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[15]</b>
                                         WATSON B W.A new regular grammar pattern matching algorithm[J].Theoretical Computer Science, 1996, 299 (1/2/3) :364-377.
                                    </a>
                                </li>
                                <li id="33">


                                    <a id="bibliography_16" title=" NAVARRO G.NR-grep:a fast and flexible pattern-matching tool[J].Practice and Experience, 2001, 31 (13) :1265-1312." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJWD&amp;filename=SJWD00001284161&amp;v=Mjc1NTE5U1hxUnJ4b3hjTUg3UjdxZWJ1ZHRGQzdsVkwzSklsaz1OaWZjYXJPNEh0SE5yWWRCWmUwT1kzazV6QmRoNGo5&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[16]</b>
                                         NAVARRO G.NR-grep:a fast and flexible pattern-matching tool[J].Practice and Experience, 2001, 31 (13) :1265-1312.
                                    </a>
                                </li>
                                <li id="35">


                                    <a id="bibliography_17" title=" YANG X, QIU T, WANG B, et al.Negative factor:improving regular-expression matching in strings[J].ACM Transactions on Database Systems, 2016, 40 (4) ." target="_blank"
                                       href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMF658AA1A2C1919215A6CF3612661E64F&amp;v=MDc2NDZtOTNvNDBacGdPQlgwd3pSY1dtemtPUG56a3JSQXpmN1BoUTc3cENPTnZGU2lXV3I3SklGcG1hQnVIWWZPR1FsZkNwYlEzNU41aHc3cSt3cTg9TmlmSVk4VytHOQ==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                        <b>[17]</b>
                                         YANG X, QIU T, WANG B, et al.Negative factor:improving regular-expression matching in strings[J].ACM Transactions on Database Systems, 2016, 40 (4) .
                                    </a>
                                </li>
                            </ul>
                            <div style='display: none;' class="zqscroller" >
                                <h4 class="">附加材料</h4>
                                <ul></ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            &nbsp;
            <!--此处有一空格符 勿删-->
        </div>

        
    <div class="content">



        <!--tips start-->
                            <div class="tips">
                    <a href="http://navi.cnki.net/KNavi/JournalDetail?pcode=CJFD&amp;pykm=JSJC" target="_blank">计算机工程</a>
                2019,45(04),148-156 DOI:10.19678/j.issn.1000-3428.0049992            </div>
        <!--tips end-->
            <div class="top-title">
                <h1 class="title">
                    <span class="vm"><b>一种针对DFA状态爆炸的正则表达式匹配方法</b></span>
 <span class="shoufa"></span>                                     </h1>

            </div>
                        <h2>
                                <a href="javascript:;">王翔</a>
                                <a href="javascript:;">卢毓海</a>
                                <a href="javascript:;">马伟</a>
                                <a href="javascript:;">刘燕兵</a>
                </h2>
                    <h2>

                    <span>中国科学院大学网络空间安全学院</span>
                    <span>中国科学院信息工程研究所</span>
                    <span>信息内容安全技术国家工程实验室</span>
            </h2>

        
<div class="link">
    <a id="aexport" class="icon icon-output"  onclick="" href="javascript:void(0);"><i></i>导出/参考文献</a>
    
    <span class="shareBoard" onmouseover="$('#sharedet').show();$('#this').addClass('shareBoardCUR')" onmouseout="$('#sharedet').hide();$('#this').removeClass('shareBoardCUR')">
        <a class="icon icon-share" href="#"><i></i>分享<em></em></a>
        <ul class="shareHide" id="sharedet" style="display: none;">
            <li><a title="复制链接" class="copy" onclick="" href="#"><i></i>复制链接</a></li>
            <li><a title="分享到新浪微博" class="xl" onclick="" href="javascript:common.ShareAction('xl');"><i></i>新浪微博</a></li>
            <li>
                <a title="分享到微信" class="wx" onclick="" href="#"><i></i>微信扫一扫</a>
                <div class="qrcode"><img src='' alt='' /></div>
            </li>
        </ul>

    </span>
    
    <a id="RefTrack" title="创建引文跟踪" class="icon icon-track" onclick="" href="javascript:void(0);"> <i></i>创建引文跟踪 </a>
    <a id="ashoucang" title="收藏" class="icon icon-favor" onclick="" href="javascript:void(0);"><i></i>收藏</a>
    <a class="icon icon-print" onclick="window.print();" href="javascript:void(0);"><i></i>打印</a>
    
    <!--版本切换 end-->
</div>
                            <div class="data" id="a_abstract">
                <span class="keys">摘<span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;</span>要：</span>
                <p>针对基于确定有限状态自动机的匹配引擎在大规模、复杂规则下会出现状态爆炸的问题, 提出正则表达式子串抽取算法。通过将子串抽取算法应用于DFA状态爆炸场景, 设计基于子串抽取的正则匹配引擎。实验结果表明, 该算法在单个规则上运行时间可达10 ms量级, 抽取率高达99%, 同时匹配引擎具有较好的稳定性和可拓展性, 且匹配速度优于相关开源匹配引擎。</p>
            </div>
                    <div class="data" id="a_keywords">
                <span class="keys">关键词：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">正则表达式;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">确定有限自动机;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E7%8A%B6%E6%80%81%E7%88%86%E7%82%B8&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">状态爆炸;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%AD%90%E4%B8%B2%E6%8A%BD%E5%8F%96&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">子串抽取;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=%E5%8C%B9%E9%85%8D%E5%BC%95%E6%93%8E&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">匹配引擎;</a>
                </p>
            </div>
        
        <!--brief start-->
        
            <div class="brief">
                    <p>
                            <b>作者简介：</b>
                                                        <span>
                                    王翔 (1993—) , 男, 硕士研究生, 主研方向为模式匹配、内容过滤, E-mail:wangxiang@iie.ac.cn;;
                                </span>
                                <span>
                                    卢毓海, 博士研究生;;
                                </span>
                                <span>
                                    马伟, 副研究员。;
                                </span>
                                <span>
                                    刘燕兵, 副研究员。;
                                </span>
                    </p>
                                    <p><b>收稿日期：</b>2018-01-08</p>

                    <p>

                            <b>基金：</b>
                                                        <span>国家重点研发计划 (2016YFB0800303);</span>
                                <span>中国科学院信息工程研究所基础前沿项目 (Y7Z0351101);</span>
                    </p>
            </div>
                    <h1><b>A Regular Expression Matching Method for DFA State Explosion</b></h1>
                    <h2>
                    <span>WANG Xiang</span>
                    <span>LU Yuhai</span>
                    <span>MA Wei</span>
                    <span>LIU Yanbing</span>
            </h2>
                    <h2>
                    <span>School of Cyber Security, University of Chinese Academy of Sciences</span>
                    <span>Institute of Information Engineering, Chinese Academy of Sciences</span>
                    <span>National Engineering Laboratory for Information Security Technologies</span>
            </h2>
                            <div class="data" id="a_abstractEN">
                <span class="keys">Abstract：</span>
                <p>Aiming at the problem that the Deterministic Finite Automation (DFA) -based matching engine will explode under large-scale and complex rules, a regular expression substring extraction algorithm is proposed.A substring extraction based regular matching engine is designed by applying the substring extraction algorithm to the DFA state explosion scenario.Experimental results show that the algorithm can run on a single rule up to 10 ms, and the decimation rate is as high as 99%.At the same time, the matching engine has better stability and scalability, and the matching speed is better than the related open source matching engine.</p>
            </div>
                    <div class="data" id="a_keywordsEN">
                <span class="keys">Keyword：</span>
                <p>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=regular%20expression&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">regular expression;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=Deterministic%20Finite%20Automaton%20(DFA)%20&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">Deterministic Finite Automaton (DFA) ;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=state%20explosion&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">state explosion;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=substring%20extraction&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">substring extraction;</a>
                        <a href="/kcms/detail/knetsearch.aspx?dbcode=CJFD&amp;sfield=kw&amp;skey=matching%20engine&amp;code=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" target="_blank">matching engine;</a>
                </p>
            </div>
                    <div class="brief">
                
                    <p>
                                            </p>
                                    <p><b>Received：</b> 2018-01-08</p>
                                    <p>
                                            </p>
            </div>


        <!--brief start-->
                        <h3 id="37" name="37" class="anchor-tag">0 概述</h3>
                <div class="p1">
                    <p id="38">随着信息社会的到来, 数据量急速增长, 网络应用对海量信息下匹配引擎的性能提出了更高的要求<citation id="231" type="reference"><link href="3" rel="bibliography" /><sup>[<a class="sup">1</a>]</sup></citation>。在信息安全领域中, 深度包检测 (Deep Packet Inspection, DPI) <citation id="232" type="reference"><link href="5" rel="bibliography" /><sup>[<a class="sup">2</a>]</sup></citation>是一种先进的包过滤技术, 通过对数据包进行内容分析, 可以识别并阻止特定的数据包。其中, 正则表达式匹配可用来对网络信息进行深度识别与检测, 是网络内容安全分析的关键技术之一。</p>
                </div>
                <div class="p1">
                    <p id="39">正则表达式被广泛应用到计算机领域, 其中, 代表性的系统有google/re2、PCRE、intel/hyperscan等, 代表性的产品有华为、Cisco、3Com等公司的商用设备。传统的正则表达式查询方法是构造正则表达式对应的自动机, 然后对于待匹配字符串的每一个位置, 通过自动机判断从该位置开始的子串是否可以被该自动机所接受。现实中的实时系统多采用基于确定有限状态自动机 (Deterministic Finite Automation, DFA) 的正则表达式匹配技术, 但是待检测规则数量日益庞大, 导致基于DFA的匹配自动机状态爆炸。DFA状态爆炸产生的原因主要有单个正则表达式状态爆炸和多个正则表达式联合编译产生状态爆炸<citation id="233" type="reference"><link href="7" rel="bibliography" /><sup>[<a class="sup">3</a>]</sup></citation>。</p>
                </div>
                <div class="p1">
                    <p id="40">现有子串抽取的方法有抽取前缀因子、后缀因子和负因子。前缀因子和后缀因子考虑了匹配字符串的位置信息, 负因子考虑了正则表达式未描述语言的信息。同时, 一个正则规则中可能有多个精确子串, 并且每个子串间存在与或非的逻辑关系。</p>
                </div>
                <div class="p1">
                    <p id="41">本文提出基于子串抽取的正则匹配方法, 以期在联合编译的场景下, 降低DFA状态爆炸的可能性, 同时保持较好的在线匹配性能。</p>
                </div>
                <h3 id="42" name="42" class="anchor-tag">1 相关工作</h3>
                <div class="p1">
                    <p id="43">根据自动机和计算理论, 正则表达式具有与自动机等价的计算能力, 因此正则表达式匹配主要依靠有限状态的自动机完成。有限状态自动机包括非确定有限状态自动机 (Nondeterministic Finite Automata, NFA) 和DFA。NFA和DFA的区别是, 对于确定的状态和确定的输入, NFA有多个后继状态, 而DFA只有一个后继状态。2种自动机结构上的区别导致其性能间的差异, 基于NFA的匹配算法预处理时间短, 存储空间小, 但是线上匹配时间复杂度高。相反, 基于DFA的匹配算法只需要扫描一遍待检测文档, 具有较高的匹配速度, 但是预处理时间较长, 存储空间大, 甚至会出现状态爆炸。</p>
                </div>
                <div class="p1">
                    <p id="44">针对DFA状态爆炸问题, 一方面是消除状态转移表中的冗余边。所谓冗余边是指DFA中那些目的状态相同的转移边。DFA中存在着大量的冗余边, 尽管它们的起始状态和转移字符可能并不相同, 但是如果在能保证可恢复的前提下消除这些冗余边将极大地减少每个状态消耗的内存空间。国内外代表性的研究有消除同源异符的冗余边<citation id="235" type="reference"><link href="9" rel="bibliography" /><link href="11" rel="bibliography" /><sup>[<a class="sup">4</a>,<a class="sup">5</a>]</sup></citation>、消除异源同符的冗余边<citation id="236" type="reference"><link href="13" rel="bibliography" /><link href="15" rel="bibliography" /><link href="17" rel="bibliography" /><sup>[<a class="sup">6</a>,<a class="sup">7</a>,<a class="sup">8</a>]</sup></citation>和消除异源异符的冗余边<citation id="234" type="reference"><link href="19" rel="bibliography" /><sup>[<a class="sup">9</a>]</sup></citation>。这些方法存在以下2个方面的不足:</p>
                </div>
                <div class="p1">
                    <p id="45">1) 消除后每个状态仍至少剩余一条带有转移字符的边, 压缩后占用空间较大。</p>
                </div>
                <div class="p1">
                    <p id="46">2) 该类技术对已构造好的 DFA 进行压缩, 可能在现有的存储资源下无法完成构造。</p>
                </div>
                <div class="p1">
                    <p id="47">另一方面是减少自动机的状态。该类技术通过避免膨胀状态来生成状态数目较少的自动机, 因而能较大的减少内存消耗, 并可以和上述消除状态转移表中的冗余边叠加使用。相关研究主要有记录历史的拓展自动机技术<citation id="238" type="reference"><link href="21" rel="bibliography" /><link href="23" rel="bibliography" /><sup>[<a class="sup">10</a>,<a class="sup">11</a>]</sup></citation>、NFA部分确定化技术<citation id="237" type="reference"><link href="25" rel="bibliography" /><sup>[<a class="sup">12</a>]</sup></citation>以及分组技术<citation id="239" type="reference"><link href="27" rel="bibliography" /><link href="29" rel="bibliography" /><sup>[<a class="sup">13</a>,<a class="sup">14</a>]</sup></citation>。但是这些方法存在以下不足:</p>
                </div>
                <div class="p1">
                    <p id="48">1) 需要消耗大量的辅助空间。</p>
                </div>
                <div class="p1">
                    <p id="49">2) 辅助空间的更新时间消耗较大。</p>
                </div>
                <div class="p1">
                    <p id="50">3) 通常无法处理包含 [-]、{n, m} 等类型的复杂正则表达式。</p>
                </div>
                <div class="p1">
                    <p id="51">在预过滤技术方面, 经典的正则表达式匹配算法需要对文本逐个字符进行匹配检测, 会影响匹配效率, 一种有效的方法是先过滤再验证。该方法的思路是从正则表达式中得到其精确子串, 先进行精确串的匹配, 然后直接抛弃未有子串命中的规则, 减少进入正则匹配的规则数量, 进而加快匹配速度。文献<citation id="240" type="reference">[<a class="sup">15</a>]</citation>描述一种MultiStringRE算法。该算法设置一个ℓmin作为最短匹配长度, 然后求出超过该长度的前缀字符串集合<i>S</i>, 从<i>S</i>中获得前缀集合<i>pefix</i> (<i>R</i>) (<i>R</i>是正则表达式) 作为粗过滤条件。由于正则表达式每次成功的匹配需要从前缀字符串开始, 因此每次只需要从<i>pefix</i> (<i>R</i>) 命中的位置开始匹配即可, 有效地减少了匹配数据量, 具有较好的过滤效果, 但随着 ℓmin 增大, 通常前缀的规模集合呈指数增长, 降低匹配的效率。文献<citation id="241" type="reference">[<a class="sup">16</a>]</citation>提出一种RegularBNDM算法, 其核心思想是基于Glushkov构造的位并行DFA模拟, 通过反转箭头和初始化所有的状态对DFA进行改进, 使最终的自动机能够识别所有反转表达式<i>R</i>的前缀。该方法在文本中滑动大小为ℓmin的窗口, 并从后向前读取窗口中的字符。窗口中的反向搜索在下列2种情况下可以停止:DFA中没有活动的状态, 这时可以滑动窗口重新开始匹配过程; 匹配位置到达窗口的起始位置, 此时说明匹配了一个因子, 如果自动机的最终状态是位于停在窗口的起点位置, 那么就可以使用正常的无自循环DFA进行前向验证, 同前缀匹配方法类似, 该方法随着 ℓmin 增大, 通常前缀的规模集合呈指数增长, 降低了匹配的效率。文献<citation id="242" type="reference">[<a class="sup">17</a>]</citation>提出一种基于反向因子和必要因子组合的算法, 负因子是一定不会出现在匹配文本中的因子, 不仅能过滤掉很多无效的候选区间, 还能提前结束自动机的验证过程, 对比不使用反向因子的算法, 该算法有较大的性能提升。</p>
                </div>
                <div class="p1">
                    <p id="52">综上所述, 通过直接压缩状态机和减少自动机状态, 会有较大的内存开销, 子串的预过滤技术的研究结果表明, 其可以提高匹配的速率。因此将子串抽取的技术应用在DFA状体爆炸的场景中, 不仅降低联合编译产生DFA状态爆炸的概率, 也能够保持较优的在线匹配速度。</p>
                </div>
                <h3 id="53" name="53" class="anchor-tag">2 子串抽取技术和匹配引擎</h3>
                <div class="p1">
                    <p id="54">精确子串的抽取首先需要构造正则表达式解析树, 在解析树构建完毕后, 分别求得正则表达式的最长精确子串, 以及具有较好过滤效果的逻辑关系组合的精确子串。最后将子串抽取技术应用于正则表达式匹配引擎。</p>
                </div>
                <h4 class="anchor-tag" id="55" name="55">2.1 解析树构造</h4>
                <div class="p1">
                    <p id="56">解析树是正则表达式在内存中的表现形式, 像二叉树、数组等用来组织数据存储的结构一样, 正则表达式的解析树为正则表达式的处理和分析奠定了基础。一般来说, 解析树并不是唯一的, 在解析树中, 每个叶节点都使用∑∪{∈}中的一个字符来标识, 而每个中间节点是操作符, 如集合{·, |, *, +}中的元素可以对字符进行逻辑关系操作或数量描述操作。</p>
                </div>
                <div class="p1">
                    <p id="57">对于简单的语法, 使用类似Lex这样简单的词法分析器即可, 但是正则表达式的语法对于词法分析器来说过于复杂, 而对那些完整的自底向上的解析器来说又过于简单。因此, 根据需求, 构造一个语法解析器。</p>
                </div>
                <div class="p1">
                    <p id="58">图1给出了正则表达式AG+ (ACT) 和 (AG|AC) (AG|AT) 的解析树, 其中每个运算符节点有1个或2个子节点, {+}节点是一个子节点, 用来描述该子节点的数量, {·, |}有2个子节点, 用来描述2个子节点之间的关系。同时, 解析树表示法具有唯一可逆性, 即给出一个解析树和其根节点, 只能逆推得到一个正则表达式。</p>
                </div>
                <div class="area_img" id="59">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图1 正则表达式解析树" src="Detail/GetImg?filename=images/JSJC201904026_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图1 正则表达式解析树</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_059.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="60">正则表达式的解析树并不是唯一的, 由于构建方法不同, 解析树的形式也有所不同。算法1给出一个简单的正则表达式解析树构造算法, 该算法输入是一个正则表达式, 可以识别的运算符有{·, |, *, (, ) }, 并以符号$作为正则表达式的结尾。该算法的逻辑是通过对不同的运算符进行分类并构建相应的解析树, 然后按照运算符的优先级递归处理表达式逻辑。在伪代码中, 通过while循环从左向右处理正则表达式, 循环内对普通字符、并集操作符|、闭包操作符*、优先级限定符 () 几种字符情况分别处理。</p>
                </div>
                <div class="p1">
                    <p id="61"><b>算法1</b> 正则表达式解析树构造</p>
                </div>
                <div class="p1">
                    <p id="62"><b>输入</b><i>p</i>:正则表达式;<i>index</i>:当前下标</p>
                </div>
                <div class="p1">
                    <p id="63"><b>输出</b> 解析树</p>
                </div>
                <div class="p1">
                    <p id="64">1.Function Construct (p = p<sub>1</sub>p<sub>2</sub>…p<sub>m</sub>, index) </p>
                </div>
                <div class="p1">
                    <p id="65">2.v= θ //θ代表最后一次的迭代值</p>
                </div>
                <div class="p1">
                    <p id="66">3.while p<sub>index</sub> != $ do // 从左向右处理</p>
                </div>
                <div class="p1">
                    <p id="67">4.if p<sub>index</sub> ∈ Σ then //处理字符集</p>
                </div>
                <div class="p1">
                    <p id="68">5.v<sub>r </sub>= Create a new Node with p<sub>last</sub></p>
                </div>
                <div class="p1">
                    <p id="69">6.if v<sub>r</sub> != θ then //合并v和v<sub>r</sub></p>
                </div>
                <div class="p1">
                    <p id="70">7.v=Operation (CONCAT, v, v<sub>r</sub>) </p>
                </div>
                <div class="p1">
                    <p id="71">8.else</p>
                </div>
                <div class="p1">
                    <p id="72">9.v=v<sub>r</sub></p>
                </div>
                <div class="p1">
                    <p id="73">10.index = index + 1//处理下个字符</p>
                </div>
                <div class="p1">
                    <p id="74">11.end if</p>
                </div>
                <div class="p1">
                    <p id="75">12.else if p<sub>index</sub> == ‘|’ then //处理 |操作</p>
                </div>
                <div class="p1">
                    <p id="76">13. (v<sub>r</sub>, index) =Construct (p, index+1) </p>
                </div>
                <div class="p1">
                    <p id="77">14.v=Operation (OR, v, v<sub>r</sub>) </p>
                </div>
                <div class="p1">
                    <p id="78">15.else if p<sub>index</sub> == ‘*’ then//处理*操作</p>
                </div>
                <div class="p1">
                    <p id="79">16.v=Operation (ASTERISK, v) </p>
                </div>
                <div class="p1">
                    <p id="80">17.index = index +1</p>
                </div>
                <div class="p1">
                    <p id="81">18.else if p<sub>index</sub> == ‘ (’ then//处理括号</p>
                </div>
                <div class="p1">
                    <p id="82">19. (v<sub>r</sub>, index) =Construct (p, index+1) </p>
                </div>
                <div class="p1">
                    <p id="83">20.index = index + 1</p>
                </div>
                <div class="p1">
                    <p id="84">21.if v<sub>r </sub>!= θ then</p>
                </div>
                <div class="p1">
                    <p id="85">22.v=Operation (CONCAT, v, v<sub>r</sub>) </p>
                </div>
                <div class="p1">
                    <p id="86">23.else</p>
                </div>
                <div class="p1">
                    <p id="87">24.v=v<sub>r</sub></p>
                </div>
                <div class="p1">
                    <p id="88">25.end if</p>
                </div>
                <div class="p1">
                    <p id="89">26.else if p<sub>index</sub> == ‘) ’ then</p>
                </div>
                <div class="p1">
                    <p id="90">27.return (v, index) </p>
                </div>
                <div class="p1">
                    <p id="91">28.end if</p>
                </div>
                <div class="p1">
                    <p id="92">29.end while</p>
                </div>
                <div class="p1">
                    <p id="93">30.//返回结果</p>
                </div>
                <div class="p1">
                    <p id="94">31.return (v, index) </p>
                </div>
                <div class="p1">
                    <p id="95">32.end funtion</p>
                </div>
                <div class="p1">
                    <p id="96">这是一个简单的解析器逻辑实现算法, 现实中根据正则语义的复杂度要进行相关的修改。本文是兼容Perl语义的正则匹配系统, 解析器同时还支持量词、字符组、顺序环视等复杂语义。</p>
                </div>
                <h4 class="anchor-tag" id="97" name="97">2.2 最长子串抽取</h4>
                <div class="p1">
                    <p id="98"><b>定义1</b> (最长子串抽取技术) 输入正则表达式<i>R</i>, 令<i>L</i> (<i>R</i>) 为该正则表达式描述的语言集合, 令<i>P</i>为<i>L</i> (<i>R</i>) 中每个子串的公共子串集合, 则抽取集合<i>P</i>中最长的子串即为最长子串抽取技术。</p>
                </div>
                <div class="p1">
                    <p id="99"><b>定义2</b> (基本单元) 利用语法解析树, 将正则表达式<i>R</i>分解为基本的连接单元, <i>R</i>=<i>A</i><sub>1</sub><i>A</i><sub>2</sub>…<i>A</i><sub><i>k</i></sub>, 每个连接单元不可再分, 其中<i>A</i><sub><i>i</i></sub> (1≤<i>i</i>≤<i>k</i>) 称为基本单元。</p>
                </div>
                <div class="p1">
                    <p id="100"><b>定义3</b> (CONCAT路径) 在语法解析树上, 从根节点出发, 路径上的节点都是CONCAT操作符, 则该路径称为CONCAT路径。</p>
                </div>
                <div class="p1">
                    <p id="101">最长子串是正则表达式中必要因子的最长字符串, 必要因子是正则表达式所描述的语言中公共子串。以正则表达式<i>R</i>=ABC+ (D|E) F 为例, 该正则表达式描述的语言有<i>L</i> (<i>R</i>) ={ABCDF, ABCEF, ABCCDF, ABCCEF, …}, 这个正则表达式描述的语言是无限的, 但是必定会出现的因子是{ABC, F}, 因此最长子串<i>MaxStr</i>=ABC。图2所示列出了其他几种常见操作符组成正则表达式的最长字符串抽取示例。其中, <i>R</i>表示正则表达式, <i>L</i> (<i>R</i>) 表示正则表达式描述的语言集, <i>MaxStr</i>表示该正则表达式抽取的最长子串。</p>
                </div>
                <div class="area_img" id="102">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_102.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图2 正则表达式最长子串抽取示例" src="Detail/GetImg?filename=images/JSJC201904026_102.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图2 正则表达式最长子串抽取示例</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_102.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="103">最长子串抽取算法的主要思路如图3所示。以正则表达式 (A*G) + (TCA) (TA|TC?) 为例, 首先由正则表达式构造语法解析树, 然后将解析树分解成多个基本单元, 选中精确子串的基本单元作为锚点, 分别计算该锚点的前缀和后缀, 对每个锚点同样的处理得到多个精确子串。具体步骤如下:</p>
                </div>
                <div class="p1">
                    <p id="104"><b>步骤1</b> 构造正则表达式的解析树。采用算法1框架, 根据正则表达式的复杂性, 设计实现相应的解析树构造程序, 将解析得到的解析树存放在内存中, 并返回可以进行解析树遍历访问的根节点。</p>
                </div>
                <div class="p1">
                    <p id="105"><b>步骤2</b> CONCAT切分法。在图3中, 虚线分割的边即为CONCAT路径上的边, 将CONCAT路径上的CONCAT节点的边进行切分, 就可以把原解析树切分成多个子树, 每个子树即为一个基本单元。上述是从解析树的角度进行分析, 如果从正则表达式的角度来看, 即选择最外层的CONCAT符作为切分符, 将原正则表达式分解为多个小型的正则表达式的组合。</p>
                </div>
                <div class="p1">
                    <p id="106"><b>步骤3</b> 构造精确串锚点。只有单个字符的基本单元是精确串, 对于由连续CONCAT操作符切分的字符也可以拼接成为精确串。同时新建一个节点, 并存储精确串, 记录该精确串节点的左右邻居, 该节点即为精确串锚点。</p>
                </div>
                <div class="p1">
                    <p id="107"><b>步骤4</b> 计算精确串锚点的前缀和后缀子串。对精确串锚点的左邻居计算后缀, 对精确串锚点的右邻居计算前缀, 通过对后缀、精确串、前缀进行拼接, 可得到基于该精确串锚点抽取的精确子串。最后通过对所有精确串锚点的计算, 得到最长子串, 即为该正则表达式的最长子串。在分类抽取中, 有对{+, *, , {m, n}}等这些量词的处理, 也有{·, |}这些运算符的处理等。</p>
                </div>
                <div class="area_img" id="108">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图3 最长子串抽取算法" src="Detail/GetImg?filename=images/JSJC201904026_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图3 最长子串抽取算法</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_108.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="109">综合上述4个步骤, 即可得到正则表达式的最长子串, 形式化描述的抽取算法主逻辑伪代码如算法2所示。先通过CONCAT切分法得到精确串锚点, 在for循环中, 逐个计算锚点的前缀和后缀, 最后得到最长子串。其中, 前缀和后缀的处理是抽取算法的关键。前缀计算的伪代码如算法3所示。switch模块需要合理的设计来对不同的运算符分类并进行递归处理。该模块中描述了对选择限定符?、闭包操作符* 、贪婪限定符+ 、 字符集限定符[]、重复数限定符{}、串接操作符·、char等多种情况的处理。</p>
                </div>
                <div class="p1">
                    <p id="110"><b>算法2</b> Extract from <i>R</i></p>
                </div>
                <div class="p1">
                    <p id="111"><b>输入</b> 正则表达式</p>
                </div>
                <div class="p1">
                    <p id="112"><b>输出</b> 最长子串</p>
                </div>
                <div class="p1">
                    <p id="113">1.Function ExtractMaxSubstring (p) </p>
                </div>
                <div class="p1">
                    <p id="114">2.pt = Construct (p) //用算法1构造解析树</p>
                </div>
                <div class="p1">
                    <p id="115">3.root = pt.get_root () </p>
                </div>
                <div class="p1">
                    <p id="116">4.//CONCAT切分法</p>
                </div>
                <div class="p1">
                    <p id="117">5.tree_nodes = SplitByConcat (root) </p>
                </div>
                <div class="p1">
                    <p id="118">6.//获得精确串锚点</p>
                </div>
                <div class="p1">
                    <p id="119">7.exact_nodes = GetAnchor (tree_nodes) </p>
                </div>
                <div class="p1">
                    <p id="120">8.//迭代计算每个锚点</p>
                </div>
                <div class="p1">
                    <p id="121">9.for (i=0; i &lt; exact_nodes.size;++i) do</p>
                </div>
                <div class="p1">
                    <p id="122">10.node = exact_nodes[i]</p>
                </div>
                <div class="p1">
                    <p id="123">11.s=node.str</p>
                </div>
                <div class="p1">
                    <p id="124">12.//计算前缀和后缀</p>
                </div>
                <div class="p1">
                    <p id="125">13.prefix=GetPrefix (node) </p>
                </div>
                <div class="p1">
                    <p id="126">14.suffix=GetSuffix (node) </p>
                </div>
                <div class="p1">
                    <p id="127">15.//构造精确串</p>
                </div>
                <div class="p1">
                    <p id="128">16.str=prefix + s + suffix</p>
                </div>
                <div class="p1">
                    <p id="129">17.//计算最长子串</p>
                </div>
                <div class="p1">
                    <p id="130">18.If str.size &gt; max_str.size then</p>
                </div>
                <div class="p1">
                    <p id="131">19.max_str = str</p>
                </div>
                <div class="p1">
                    <p id="132">20.end if</p>
                </div>
                <div class="p1">
                    <p id="133">21.end for</p>
                </div>
                <div class="p1">
                    <p id="134">22.return max_str</p>
                </div>
                <div class="p1">
                    <p id="135">23.end function</p>
                </div>
                <div class="p1">
                    <p id="136"><b>算法3</b> 前缀计算</p>
                </div>
                <div class="p1">
                    <p id="137"><b>输入</b> 解析树结点</p>
                </div>
                <div class="p1">
                    <p id="138"><b>输出</b> 前缀</p>
                </div>
                <div class="p1">
                    <p id="139">1.Function GetPrefix (node) </p>
                </div>
                <div class="p1">
                    <p id="140">2.type = node.type</p>
                </div>
                <div class="p1">
                    <p id="141">3.//对不同的节点分情况处理</p>
                </div>
                <div class="p1">
                    <p id="142">4.switch (type) :</p>
                </div>
                <div class="p1">
                    <p id="143">5.// *  可能出现0次, 为null</p>
                </div>
                <div class="p1">
                    <p id="144">6.case ‘?’ :</p>
                </div>
                <div class="p1">
                    <p id="145">7.prefix = NULL;</p>
                </div>
                <div class="p1">
                    <p id="146">8.case ‘*’ :</p>
                </div>
                <div class="p1">
                    <p id="147">9.prefix = NULL;</p>
                </div>
                <div class="p1">
                    <p id="148">10.case ‘+’ :</p>
                </div>
                <div class="p1">
                    <p id="149">11.//+至少1次, 继续递归计算</p>
                </div>
                <div class="p1">
                    <p id="150">12.prefix = GetPrefix (node.left) ;</p>
                </div>
                <div class="p1">
                    <p id="151">13.case normal_char :</p>
                </div>
                <div class="p1">
                    <p id="152">14.//普通字符处理</p>
                </div>
                <div class="p1">
                    <p id="153">15.prefix = normal_char;</p>
                </div>
                <div class="p1">
                    <p id="154">16.case‘[]’ :</p>
                </div>
                <div class="p1">
                    <p id="155">17.//字符组单独处理, 仅表示一个字符时抽取</p>
                </div>
                <div class="p1">
                    <p id="156">18.prefix = GetFromBracket (node) ;</p>
                </div>
                <div class="p1">
                    <p id="157">19.case‘{m, n}’ :</p>
                </div>
                <div class="p1">
                    <p id="158">20.//{m, n}单独处理, 构造NFA识别</p>
                </div>
                <div class="p1">
                    <p id="159">21.prefix = GetFromBrace (node) ;</p>
                </div>
                <div class="p1">
                    <p id="160">22.case ‘|’ :</p>
                </div>
                <div class="p1">
                    <p id="161">23.//获取公共前缀</p>
                </div>
                <div class="p1">
                    <p id="162">24.prefix = CommonPrefix (node) ;</p>
                </div>
                <div class="p1">
                    <p id="163">25.case ‘·’ :</p>
                </div>
                <div class="p1">
                    <p id="164">26.//分情况拼接左右边字符串</p>
                </div>
                <div class="p1">
                    <p id="165">27.if node.left is exact then</p>
                </div>
                <div class="p1">
                    <p id="166">28.prefix=node.left+GetPrefix (node) </p>
                </div>
                <div class="p1">
                    <p id="167">29.else</p>
                </div>
                <div class="p1">
                    <p id="168">30.prefix = GetPrefix (node.right) </p>
                </div>
                <div class="p1">
                    <p id="169">31.end if</p>
                </div>
                <div class="p1">
                    <p id="170">32.end switch</p>
                </div>
                <div class="p1">
                    <p id="171">33.//返回结果</p>
                </div>
                <div class="p1">
                    <p id="172">34.return prefix</p>
                </div>
                <div class="p1">
                    <p id="173">35.end function</p>
                </div>
                <h4 class="anchor-tag" id="174" name="174">2.3 逻辑关系子串抽取</h4>
                <div class="p1">
                    <p id="175">抽取具有逻辑关系的子串可以增强预过滤效果, 增强匹配效率。逻辑关系分为与或非3种以及各种关系的组合。本文主要探讨具有逻辑与关系的匹配引擎。</p>
                </div>
                <div class="p1">
                    <p id="176"><b>定义4</b> (与或非逻辑关系子串抽取) 输入正则表达式R, 使用子串抽取技术得到该正则表达式描述的公共子串集合<i>P</i>={<i>p</i><sub>1</sub>, <i>p</i><sub>2</sub>, …, <i>p</i><sub><i>n</i></sub>}, <i>p</i><sub><i>i</i></sub>∈<i>L</i> (<i>R</i>) 。同时记录各个子串间的逻辑关系♁∈{&amp;, |, !}, 最后通过组合评估策略 (<i>Optimal</i>函数) 对得到的逻辑组合关系进行剪枝, 得到合适的与或非逻辑关系子串<i>M</i><sub>opt</sub>=<i>Optimal</i> (<i>p</i><sub><i>i</i></sub> ♁<i>p</i><sub><i>j</i></sub>) , <i>p</i><sub><i>i</i></sub>, <i>p</i><sub><i>j</i></sub>∈<i>L</i> (<i>R</i>) 。</p>
                </div>
                <div class="p1">
                    <p id="177">在子串抽取的过程中, 不仅抽取精确子串, 也抽取各个子串间的逻辑关系。以正则表达式<i>R</i>=ABC+ (D|E) F+G{3}为例, 该正则表达式描述的语言有<i>L</i> (<i>R</i>) ={ABCDFGGG, ABCEFGGG, ABCCDFGGG, ABCCEFGGG, …}, 显然, 会有必要因子{ABC, F, GGG}, 这3个精确子串是逻辑与关系, 即<i>P</i>=ABC&amp;F&amp;GGG, 同时设置子串的评价指标, 如设置子串长度至少为3, 则最后<i>M</i><sub>opt</sub>=ABC&amp;GGG。</p>
                </div>
                <div class="p1">
                    <p id="178">具有逻辑与关系子串的抽取是在最长子串抽取基础上进一步探索, 它不仅抽取到子串, 同时记录各个子串之间的逻辑关系, 本文研究关注逻辑与关系的抽取。逻辑与关系的抽取带来的额外工作一方面是需要对抽取的子串进行质量评估, 另一方面是基于子串抽取的正则匹配引擎需要构造相应的布尔匹配引擎来验证各个子串间的逻辑与关系是否成立。关于抽取子串的评估策略, 有多种指标, 如抽取子串的个数、抽取子串的长度、子串间的差异 (如编辑距离等) 。本文抽取最长子串的策略是选择长度大于3的子串, 抽取具有逻辑与关系的子串的策略是选择子串长度大于3同时子串个数不超过8个的子串组合。</p>
                </div>
                <h4 class="anchor-tag" id="179" name="179">2.4 正则表达式匹配引擎</h4>
                <div class="p1">
                    <p id="180">本节将从匹配引擎的框架、匹配引擎性能依赖因素2个方面进行说明。</p>
                </div>
                <h4 class="anchor-tag" id="181" name="181">2.4.1 匹配引擎框架</h4>
                <div class="p1">
                    <p id="182">本文将最长子串抽取技术和逻辑与关系的子串抽取技术相结合, 面向大规模复杂规则情况下的正则匹配的广泛应用需求, 设计实现一种基于子串抽取的正则匹配引擎。图4给出基于子串抽取的匹配引擎的总体架构。</p>
                </div>
                <div class="area_img" id="183">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_183.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图4 基于子串抽取的正则匹配引擎框架" src="Detail/GetImg?filename=images/JSJC201904026_183.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图4 基于子串抽取的正则匹配引擎框架</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_183.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="184">从图4可以看出, 该引擎由离线预处理和在线匹配两部分组成。预处理阶段将输入的正则表达式规则集利用子串抽取技术进行子串的抽取和分类, 对能够抽取出合适子串的规则集、不能抽取出合适子串的规则集分别构建正则匹配引擎。在线过滤阶段, 输入实时的待匹配数据包, 依次通过子串粗过滤引擎和正则匹配精细过滤引擎。对于最后命中的数据包进行阻断, 反之则进行放行。</p>
                </div>
                <div class="p1">
                    <p id="185">离线预处理流程主要包括4个步骤, 具体描述如下:</p>
                </div>
                <div class="p1">
                    <p id="186"><b>步骤1</b> 将正则规则集进行编号, 每个规则给定一个唯一的ID, 该ID是系统在线匹配阶段的唯一标识。</p>
                </div>
                <div class="p1">
                    <p id="187"><b>步骤2</b> 对每一个规则执行子串抽取算法, 得到规则和子串集合的对应关系。</p>
                </div>
                <div class="p1">
                    <p id="188"><b>步骤3</b> 对每个得到的规则进行再次处理, 选择合适的子串长度和个数, 并依据是否合适将规则集分为可以抽取合适子串的规则集<i>S</i><sub>has-str</sub>和不能抽取合适子串的规则集<i>S</i><sub>no-str</sub>, 对集合<i>S</i><sub>has-str</sub>中抽取的精确子串集合保存在集合<i>S</i><sub>exact</sub>。</p>
                </div>
                <div class="p1">
                    <p id="189"><b>步骤4</b> 分别构建精确串匹配引擎和正则匹配引擎, 对步骤3得到的精确子串集合<i>S</i><sub>exact</sub>使用多模式串匹配算法构建AC自动机, <i>S</i><sub>has-str</sub>中的每一个正则表达式构建小的正则引擎, 并将这些引擎串联得到引擎<i>E</i><sub>has-str</sub>, <i>S</i><sub>no-str</sub>正则表达式进行联合编译得到一个正则匹配引擎<i>E</i><sub>no-str</sub>。</p>
                </div>
                <div class="p1">
                    <p id="190">在线过滤阶段主要由子串粗过滤引擎和正则匹配精细过滤引擎2个部分串联而成, 其中子串粗过滤引擎包含精确串匹配引擎和布尔匹配引擎2个部分。只有被前面引擎命中的规则, 才会在接下来的引擎继续进行匹配。各引擎的工作原理具体分析如下:</p>
                </div>
                <div class="p1">
                    <p id="191">1) 精确串匹配引擎使用离线预处理阶段抽取的精确串集合作为输入, 使用经典的多模式匹配算法AC算法进行精确串匹配, 对于命中的正则规则送入布尔匹配引擎。</p>
                </div>
                <div class="p1">
                    <p id="192">2) 布尔匹配引擎采用基于位图的布尔表达式存储、匹配方法, 该方法对于逻辑与关系的布尔表达式匹配效率较高。</p>
                </div>
                <div class="p1">
                    <p id="193">3) 正则匹配引擎首先进行离线预处理阶段得到的<i>E</i><sub>has-str</sub>进行过滤, 如果数据包有命中, 则使用正则规则对应的小型DFA引擎进行匹配过滤验证, 最后使用<i>E</i><sub>no-str</sub>进行匹配验证。</p>
                </div>
                <div class="p1">
                    <p id="194">该匹配引擎可以应用于深度包检测等场景中。例如, 设正则表达式为ab+cde, 待检测的数据包有abcde、bcdef、cdefg这3个。当处于离线阶段时, 运用最长子串抽取算法2得到最长子串bcde, 同时ab+cde是可抽取合适子串的规则。当处于在线匹配阶段时, 在预过滤匹配模块中, 数据包abcde和bcdef可以命中精确串bcde, 因此为可疑数据包, 数据包cdefg不能命中, 为正常数据包, 予以放行。当进入正则匹配精细过滤阶段时, 数据包bcdef没有命中规则, 予以放行;而数据包abcde命中规则ab+cde, 该数据包为恶意数据包, 进行阻断。</p>
                </div>
                <h4 class="anchor-tag" id="195" name="195">2.4.2 匹配引擎性能影响因素</h4>
                <div class="p1">
                    <p id="196">本节包含离线预处理和在线检测2个阶段的性能分析。</p>
                </div>
                <div class="p1">
                    <p id="197"><b>定义5</b> (抽取率) 在一个数据集内, 可抽取的合适子串的规则数量比上总规则数量。</p>
                </div>
                <div class="p1">
                    <p id="198">在离线预处理阶段, 本文主要考虑子串抽取算法的速度以及子串抽取的比例, 抽取的速度反映抽取算法的时间复杂度以及实用性, 抽取比例的高低直接影响后期在线检测的效率以及引擎<i>E</i><sub>no-str</sub>的大小。离线处理的时间由子串的抽取时间和自动机 (包含精确串匹配自动机和正则匹配自动机) 的构造时间共同组成, 如式 (1) 所示。</p>
                </div>
                <div class="p1">
                    <p id="199"><i>T</i><sub>offline</sub> = <i>T</i><sub>exact</sub> + <i>T</i><sub>construct</sub>      (1) </p>
                </div>
                <div class="p1">
                    <p id="200">在线检测阶段包含子串粗过滤引擎的匹配时间和正则匹配精细过滤引擎的时间。定义规则集的数量是<i>C</i><sub>total</sub>, 抽取率是<i>R</i>, 子串粗过滤引擎中平均每个子串的处理时间为<i>T</i><sub>pre</sub>, 子串粗过滤引擎命中的个数是<i>C</i><sub>hit</sub>, 正则匹配精细过滤引擎平均每个正则表达式的匹配时间为<i>T</i><sub>hit</sub>, 不能抽取合适子串的匹配引擎总匹配时间为<i>T</i><sub>no-str</sub>。在线检测阶段的时间为:</p>
                </div>
                <div class="p1">
                    <p id="201"><i>T</i><sub>online</sub>= (<i>C</i><sub>total</sub> × <i>R</i>) ×<i>T</i><sub>pre</sub>+<i>C</i><sub>hit</sub>×<i>T</i><sub>hit</sub>+<i>T</i><sub>no-str</sub>      (2) </p>
                </div>
                <div class="p1">
                    <p id="202">现考虑在线匹配阶段DFA构造的内存占用, 定义规则集中的正则表达式数目为<i>m</i>, 平均每条正则表达式长度为<i>n</i>, 又单个规则构造DFA的空间消耗和规则的长度呈指数关系即<i>O</i> (2<sup><i>n</i></sup>) , 多个规则联合编译构造成大的DFA的空间消耗为<i>O</i> (2<sup><i>m</i>×<i>n</i></sup>) 。故自动机的空间消耗<i>S</i>如式 (3) 所示, 由式 (3) 可以看出, <i>S</i>同样依赖于抽取率<i>R</i>, <i>R</i>越大, 占用的空间<i>S</i>越小。</p>
                </div>
                <div class="p1">
                    <p id="203"><i>S</i>=<i>O</i> (<i>C</i><sub>total</sub> ×<i>R</i>×2<sup><i>n</i></sup>) +<i>O</i> (2<sup><i>n</i>×<i>C</i><sub>total</sub><sup>× (1-<i>R</i>) </sup></sup>)      (3) </p>
                </div>
                <div class="p1">
                    <p id="204">由上述2个部分可以得出该匹配引擎的依赖因素, 因此实验部分将会从抽取算法的抽取速度、抽取率, 预过滤阶段的命中个数、匹配速度以及和相关开源引擎对比等方面来评价该引擎的性能。</p>
                </div>
                <h3 id="205" name="205" class="anchor-tag">3 实验结果与分析</h3>
                <div class="p1">
                    <p id="206">为测试子串抽取方法和基于子串抽取的匹配技术, 本文在多个规则集上进行性能测试。实验使用C++作为编程语言, 实验环境是Intel 3.60 GHz Quad Core CPU i7, 12 GB RAM。实验规则集统计数据如表1所示。其中, random是随机生成的规则集, competition是来自于某个正则表达式匹配竞赛的规则集, bro、clamav、http、l7、snort是常用的病毒检测规则集。本文实验部分将从规则集的抽取性能、预过滤系统性能、匹配引擎性能3个方面进行对比测试。</p>
                </div>
                <div class="area_img" id="207">
                    <p class="img_tit"><b>表1 规则集统计数据</b> <a class="downexcel" onclick="DownLoadReportExcel(this)">导出到EXCEL</a></p>
                    <p class="img_tit"></p>
                    <p class="img_note"></p>
                    <table id="207" border="1"><tr><td><br />规则集</td><td>规则个数</td><td>平均长度</td></tr><tr><td><br />bro</td><td>508</td><td>45.300</td></tr><tr><td><br />clamav</td><td>9 302</td><td>317.915</td></tr><tr><td><br />competition</td><td>2 000</td><td>37.530</td></tr><tr><td><br />http</td><td>1 508</td><td>23.210</td></tr><tr><td><br />l7</td><td>112</td><td>118.670</td></tr><tr><td><br />random</td><td>5 000</td><td>30.000</td></tr><tr><td><br />snort</td><td>1 105</td><td>35.600</td></tr></table>
                    <form name="form" action="/kxreader/Detail/DownloadReportExcel" method="POST" style="display:inline">
                        <input type="hidden" name="hidTable" value="" />
                        <input type="hidden" name="hidFileName" value="" />
                    </form>
                    <p class="img_note"></p>
                    <p class="img_note"></p>
                </div>
                <h4 class="anchor-tag" id="208" name="208">3.1 抽取算法性能</h4>
                <div class="p1">
                    <p id="209">子串的抽取性能对整个预过滤系统性能有着直接的影响。抽取算法的性能包含复杂性和子串的抽取率2个方面。</p>
                </div>
                <div class="p1">
                    <p id="210">该实验共对7个规则集进行测试, 图5所示为平均每个规则抽取时间结果。从图5可以看出, 规则集中的单个正则表达式抽取时间在10 ms级别, 大部分的抽取时间小于10 ms。规则集clamav和l7由于复杂规则的存在, 导致算法进行多次迭代计算, 因此抽取时间较多, 但是依然小于90 ms, 即对于大规模的复杂规则集, 预处理时间在较优的范围内。</p>
                </div>
                <div class="area_img" id="211">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_211.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图5 各规则集平均抽取时间结果" src="Detail/GetImg?filename=images/JSJC201904026_211.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图5 各规则集平均抽取时间结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_211.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="212">对上述7个规则集进行抽取率测试, 图6所示为各规则抽取比例结果。从图6可以看出, 4/7的规则集抽取率高于99%, 高的子串抽取率为后期的匹配引擎设计实现提供支持。</p>
                </div>
                <div class="area_img" id="213">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_213.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图6 各规则集抽取比例结果" src="Detail/GetImg?filename=images/JSJC201904026_213.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图6 各规则集抽取比例结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_213.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="214" name="214">3.2 预过滤系统性能</h4>
                <div class="p1">
                    <p id="215">基于子串抽取的预过滤系统性能包括以下2个方面, 具体分析如下:</p>
                </div>
                <div class="p1">
                    <p id="216">1) 离线预处理性能。该段时间包含抽取到的子串进行AC自动机构建时间、对于能抽取出合适子串的规则集分别构建单个匹配引擎总时间、对于未能抽取到合适子串的规则集进行联合编译得到一个匹配引擎时间, 离线预处理时间是这3个时间的总和。</p>
                </div>
                <div class="p1">
                    <p id="217">2) 在线匹配性能。对该性能的测试包含2个方面, 一是性能的拓展性, 即规则集数量上的增加对匹配系统性能的影响, 二是和开源正则匹配引擎的匹配速率对比。本文实验选择上述规则集中的competition、http、random这3个代表性的规则集进行比较分析, 同时使用抓包得到的文本数据 (大小为1 GB) 作为待检测的数据集。</p>
                </div>
                <div class="p1">
                    <p id="218">图7给出规则集预处理时间和规则集规模的关系。从图7可以看出, 随着规则集数量的增加, 预处理的时间也逐渐增加, 且呈线性增长, 同时单个规则的预处理时间在100 ms级别。由此统计数据可以得出, 单条的平均处理时间较低, 同时预处理的时间同规则的增长是线性关系, 因而该子串抽取算法可以应用在正则规则集数量不断增大的场景, 即适用于大规模的正则规则集。</p>
                </div>
                <div class="area_img" id="219">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_219.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图7 预处理时间分析" src="Detail/GetImg?filename=images/JSJC201904026_219.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图7 预处理时间分析</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_219.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="220">图8给出3个规则集匹配速度和规则集规模的关系。随着规则集数量的增加, 匹配速度基本保持不变或者降低缓慢, 即该匹配引擎对这3个规则数据集的规模敏感性较低, 在规则集规模增长的情况下, 仍然能保持较好的匹配速度, 拓展性好。从图8可以看出, http规则集的匹配速度较另外2个规则集的速度低, 且速度下降的趋势较为明显。由第2.4.2节分析可知, 匹配速度和预过滤部分的命中规则集数量相关, 预过滤阶段命中的规则集数量越多, 后期在正则匹配精细过滤引擎消耗的时间就会相应增多。</p>
                </div>
                <div class="area_img" id="221">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_221.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图8 匹配速度分析" src="Detail/GetImg?filename=images/JSJC201904026_221.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图8 匹配速度分析</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_221.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="222">预过滤阶段子串命中数量和规则集规模大小的关系如图9所示。匹配速度较高的competition规则集、random规则集在预过滤阶段命中数量较少, 而http规则集随着规则集的数量增多, 预过滤阶段命中的规则数量也越多。</p>
                </div>
                <div class="area_img" id="223">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_223.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图9 预过滤命中数量分析" src="Detail/GetImg?filename=images/JSJC201904026_223.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图9 预过滤命中数量分析</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_223.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <div class="p1">
                    <p id="224">http规则集的匹配速度与预过滤命中数量关系如图10所示。随着预过滤阶段命中的规则数量增多, 匹配速度逐渐下降, 并呈现亚线性关系, 即预过滤阶段命中的数量增多会减缓在线阶段的匹配速度, 但是减缓的速率在下降。</p>
                </div>
                <div class="area_img" id="225">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_225.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图10 http规则集匹配速度与预过滤命中数量分析" src="Detail/GetImg?filename=images/JSJC201904026_225.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图10 http规则集匹配速度与预过滤命中数量分析</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_225.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h4 class="anchor-tag" id="226" name="226">3.3 与开源匹配引擎对比测试</h4>
                <div class="p1">
                    <p id="227">开源的正则表达式匹配引擎Boost regex、Boost Xpressive、GRETA、PCRE是基于NFA的正则匹配引擎, 是在DFA状态爆炸场景中的一种解决方案。选择这4个匹配引擎同本文匹配引擎PrefilterREGEX在性能上对比测试, 如图11所示。在数据集 (competition中选择300条规则集和选择1 GB的待匹配数据) 上, 对其匹配速度进行对比测试。从图11可以看出, 匹配引擎GRETA、Boost、regex、PCRE和Boost Xpressive速度接近, 本文基于子串抽取的匹配引擎PrefilterREGEX效率最高, 且在性能上提升一个数量级。</p>
                </div>
                <div class="area_img" id="228">
                                <a class="zoom-in" href="Detail/GetImg?filename=images/JSJC201904026_228.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">
                                    <img alt="图11 各匹配引擎的速度对比结果" src="Detail/GetImg?filename=images/JSJC201904026_228.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
                                </a>
                                <p class="img_tit"><b>图11 各匹配引擎的速度对比结果</b>  <a class="btn-zoomin" href="Detail/GetImg?filename=images/JSJC201904026_228.jpg&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!"></a><a class="downimg">&nbsp;&nbsp;下载原图</a></p>
                            <p class="img_tit"></p>

                </div>
                <h3 id="229" name="229" class="anchor-tag">4 结束语</h3>
                <div class="p1">
                    <p id="230">本文通过抽取正则表达式的最长子串和具有逻辑与关系的子串, 设计并实现基于子串抽取的正则匹配引擎算法。将子串抽取在大规模复杂规则DFA状态爆炸的场景中进行实验, 结果表明, 子串抽取算法具有较高的效率和抽取率, 与开源NFA正则表达式匹配引擎相比, 预过滤引擎性能有一个数量级的提升。下一步将研究抽取逻辑或和逻辑非的子串, 并将其应用到匹配系统的场景中。</p>
                </div>

        <!--brief end-->
        
        <!--conten left  end-->
        <!--增强附件-->
        

        <!--reference start-->
            <div class="reference anchor-tag" id="a_bibliography">
                    <h3>参考文献</h3>
                                        <p id="3">
                            <a id="bibliography_1" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=XDKD201406029&amp;v=MDE0NDFTbkFhckc0SDlYTXFZOUhiWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeS9uVXIzUFA=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[1]</b> 褚衍杰, 李云照, 魏强.一种改进的多模式匹配算法[J].西安电子科技大学学报 (自然科学版) , 2014 (6) :174-180.
                            </a>
                        </p>
                        <p id="5">
                            <a id="bibliography_2" target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JFYZ200710001&amp;v=MTMxODllUm9GeS9uVXIzUEx5dlNkTEc0SHRiTnI0OUZaWVFLREg4NHZSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVo=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[2]</b> 赵毅, 朱鹏, 迟学斌, 等.浅析高性能计算应用的需求与发展[J].计算机研究与发展, 2007, 44 (10) :1640-1646.
                            </a>
                        </p>
                        <p id="7">
                            <a id="bibliography_3" target="_blank" href="http://scholar.cnki.net/result.aspx?q=A survey on regular expression matching for deep packet inspection:applications,algorithms,and hardware platforms">

                                <b>[3]</b> XU C, CHEN S, SU J, et al.A survey on regular expression matching for deep packet inspection:applications, algorithms, and hardware platforms[J].IEEE Communications Surveys and Tutorials, 2016, 18 (4) :2991-3029.
                            </a>
                        </p>
                        <p id="9">
                            <a id="bibliography_4" >
                                    <b>[4]</b>
                                 刘燕兵.高性能正则表达式匹配技术研究[D].北京:中国科学院大学, 2012.
                            </a>
                        </p>
                        <p id="11">
                            <a id="bibliography_5" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Memory-efficient regular expression search using state merging">

                                <b>[5]</b> BECCHI M, CADAMBI S.Memory-efficient regular expression search using state merging[C]//Proceedings of the 26th IEEE International Conference on Computer Communications.Washington D.C., USA:IEEE Press, 2007:1064-1072.
                            </a>
                        </p>
                        <p id="13">
                            <a id="bibliography_6" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000047086&amp;v=MDYyMDVPOElESFEvb0JNVDZUNFBRSC9pclJkR2VycVFUTW53WmVadUh5am1VTG5JSjF3VmFCVT1OaWZJWTdLN0h0ak5yNDlGWg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[6]</b> FICARA D, GIORDANO S, PROCISSI G, et al.An improved DFA for fast regular expression matching[J].ACM SIGCOMM Computer Communication Review, 2008, 38 (5) :29-40.
                            </a>
                        </p>
                        <p id="15">
                            <a id="bibliography_7" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCM13091000009385&amp;v=MDEzMDU0OUZaT3NHRDNROG9CTVQ2VDRQUUgvaXJSZEdlcnFRVE1ud1plWnVIeWptVUxuSUoxd1ZhQlU9TmlmSVk3SzdIdGpOcg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[7]</b> FICARA D, PIETRO A D, GIORDANO S, et al.Differential encoding of DFAs for fast regular expression matching[J].IEEE/ACM Transactions on Networking, 2011, 19 (3) :683-694.
                            </a>
                        </p>
                        <p id="17">
                            <a id="bibliography_8" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Efficient signature matching with multiple alphabet compression tables">

                                <b>[8]</b> KONG S, SMITH R, ESTAN C.Efficient signature matching with multiple alphabet compression tables[C]//Proceedings of the 4th International Conference on Security and Privacy in Communication Networks.New York, USA:ACM Press, 2008.
                            </a>
                        </p>
                        <p id="19">
                            <a id="bibliography_9" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Compressing regular expressions&amp;#39;&amp;#39; DFA table by matrix decomposition">

                                <b>[9]</b> LIU Y, GUO L, LIU P, et al.Compressing regular expressions’ DFA table by matrix decomposition[C]//Proceedings of the 15th International Conference on Implementation and Application of Automata.Berlin, Germany:Springer, 2010:282-289.
                            </a>
                        </p>
                        <p id="21">
                            <a id="bibliography_10" target="_blank" href="http://scholar.cnki.net/result.aspx?q=XFA: Faster Signature Matching with Extended Automata">

                                <b>[10]</b> SMITH R, ESTAN C, JHA S.XFA:faster signature matching with extended automata[C]//Proceedings of IEEE Symposium on Security and Privacy.Washington D.C., USA:IEEE Computer Society, 2008:187-201.
                            </a>
                        </p>
                        <p id="23">
                            <a id="bibliography_11" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Toward robust network payload inspection">

                                <b>[11]</b> SMITH R D.Toward robust network payload inspection[D].Madison, USA:University of Wisconsin at Madison, 2009.
                            </a>
                        </p>
                        <p id="25">
                            <a id="bibliography_12" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Space-time tradeoff in regular expression matching withsemi-deterministic finite automata">

                                <b>[12]</b> YANG Y E, PRASANNA V K.Space-time tradeoff in regular expression matching with semi-deterministic finite automata[C]//Proceedings of IEEE International Conference on Computer Communications.Washington D.C., USA:IEEE Press, 2011:1853-1861.
                            </a>
                        </p>
                        <p id="27">
                            <a id="bibliography_13" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Scalable regular expression matching on data streams">

                                <b>[13]</b> MAJUMDER A, RASTOGI R, VANAMA S.Scalable regular expression matching on data streams[C]//Proceedings of ACM SIGMOD International Conference on Management of Data.New York, USA:ACM Press, 2008:161-172.
                            </a>
                        </p>
                        <p id="29">
                            <a id="bibliography_14" target="_blank" href="http://scholar.cnki.net/result.aspx?q=Memory-efficient distribution of regular expressions for fastdeep packet inspection">

                                <b>[14]</b> ROHRER J, ATASU K, LUNTEREN J, et al.Memory-efficient distribution of regular expressions for fast deep packet inspection[C]//Proceedings of the 7th IEEE/ACM International Conference on Hardware/Software Codesign and System Synthesis.New York, USA:ACM Press, 2009:147-154.
                            </a>
                        </p>
                        <p id="31">
                            <a id="bibliography_15" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJES&amp;filename=SJES13012100983186&amp;v=MzE0NjVlWnVIeWptVUxuSUoxd1ZhQlU9TmlmT2ZiSzdIdERPcm85RmJlTU1EWFEvb0JNVDZUNFBRSC9pclJkR2VycVFUTW53Wg==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[15]</b> WATSON B W.A new regular grammar pattern matching algorithm[J].Theoretical Computer Science, 1996, 299 (1/2/3) :364-377.
                            </a>
                        </p>
                        <p id="33">
                            <a id="bibliography_16" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJWD&amp;filename=SJWD00001284161&amp;v=MzE3NDdjYXJPNEh0SE5yWWRCWmUwT1kzazV6QmRoNGo5OVNYcVJyeG94Y01IN1I3cWVidWR0RkM3bFZMM0pJbGs9Tmlm&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[16]</b> NAVARRO G.NR-grep:a fast and flexible pattern-matching tool[J].Practice and Experience, 2001, 31 (13) :1265-1312.
                            </a>
                        </p>
                        <p id="35">
                            <a id="bibliography_17" target="_blank" href="/kcms/detail/detail.aspx?dbcode=SJCM&amp;filename=SJCMF658AA1A2C1919215A6CF3612661E64F&amp;v=MTg5NTJOaWZJWThXK0c5bTkzbzQwWnBnT0JYMHd6UmNXbXprT1BuemtyUkF6ZjdQaFE3N3BDT052RlNpV1dyN0pJRnBtYUJ1SFlmT0dRbGZDcGJRMzVONWh3N3Erd3E4PQ==&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">

                                <b>[17]</b> YANG X, QIU T, WANG B, et al.Negative factor:improving regular-expression matching in strings[J].ACM Transactions on Database Systems, 2016, 40 (4) .
                            </a>
                        </p>
            </div>
        <!--reference end-->
        <!--footnote start-->
        <!--footnote end-->



    </div>

        <input id="fileid" type="hidden" value="JSJC201904026" />
        <input id="dpi" type="hidden" value="600" />
    </div>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6e967eb120601ea41b9d312166416aa6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

    


<input id="hid_uid" name="hid_uid" type="hidden" value="WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!" />
<input id="hid_kLogin_headerUrl" name="hid_kLogin_headerUrl" type="hidden" value="/KLogin/Request/GetKHeader.ashx%3Fcallback%3D%3F" />
<input id="hid_kLogin_footerUrl" name="hid_kLogin_footerUrl" type="hidden" value="/KLogin/Request/GetKFooter.ashx%3Fcallback%3D%3F" />
<div class="btn-link" style="display: none"><a target="_blank" href="/kcms/detail/detail.aspx?dbcode=CJFD&amp;filename=JSJC201904026&amp;v=MjY4NDVSNFQ2ajU0TzN6cXFCdEdGckNVUkxPZVplUm9GeS9uVXIzUEx6N0JiYkc0SDlqTXE0OUhZb1FLREg4NHY=&amp;uid=WEEvREcwSlJHSldRa1FhcTdWa2FjcW9vRlJTQ2JLUmN2amRwVFpsWThsTT0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!">知网节</a></div>
<div class="popflow" id="popupTips" style="display: none;">
    <div class="popflowArr"></div>
    <div class="popflowCot">
        <div class="hd"><a href="javascript:void(0);" onclick="$('#popupTips').hide();$('#popupmsg').html('')" class="close">X</a></div>
        <div class="bd">
            <p class="mes" id="popupmsg" name="popupmsg"></p>
          
        </div>
    </div>
</div>
<input type="hidden" id="myexport" value="//kns.cnki.net" />

<input type="hidden" id="KPCAPIPATH" value="//ishufang.cnki.net" />
<input type="hidden" id="CitedTimes" value="" />
<div class="link" id="GLSearch" style="display: none;">
    <i class="icon-trangle"></i>
    <div class="inner">
        <a class="icon" id="copytext">复制</a>
        <a class="icon" target="_blank" onclick="searchCRFD(this)">工具书搜索</a>
    </div>
</div>




<input id="hidVirtualPath" name="hidVirtualPath" type="hidden" value="/kxreader" />
<script src="/kxreader/bundles/detail?v=-ULdk-c6FkZHtJA2KAXPgHnyA8mtgyPnBde_C2VZ2BY1"></script>

<script src="/kxreader/Scripts/layer.min.js" type="text/javascript"></script>

<div id="footerBox" class="rootw footer">
</div>
<script>
    if (typeof FlushLogin == 'function') {
        FlushLogin();
    }
    modifyEcpHeader(true);
</script>

<!--图片放大功能 start-->
<script src="/kxreader/bundles/imagebox?v=W4phPu9SNkGcuPeJclikuVE3PpRyIW_gnfjm_19nynI1"></script>

<script type="text/javascript">
    $(function () {
        var j = $.noConflict();
        j(function () {
            j(".zoom-in,.btn-zoomin").imgbox({
                'alignment': 'center',
                'allowMultiple': false,
                'overlayShow': true
            });
        })
    });
</script>
<!--图片放大功能 end-->
<div class="fixedbar">
    <div class="backtop hiddenV" id="backtop">
        <a id="backTopSide" href="javascript:scroll(0,0);" title=""></a>
    </div>
</div>
<script type="text/javascript" src="/kxreader/Scripts/MathJax-2.6-latest/MathJax.js?config=MML_HTMLorMML-full"></script>

</body>
</html>
